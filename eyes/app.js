(self.webpackChunksolar_system = self.webpackChunksolar_system || []).push([[0], [function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        SolarSystemApp: function() {
            return SolarSystemApp
        }
    });
    var s = i(1)
      , n = (i(723),
    i(735))
      , o = i(737)
      , a = i(738)
      , r = i(739)
      , l = i(740)
      , c = i(1047)
      , h = i(1053)
      , d = i.n(h)
      , u = i(890)
      , p = i(542)
      , m = i(743);
    class SolarSystemApp extends s.BaseApp {
        constructor() {
            super(u.Types),
            this._timeInfo = o,
            this._sceneInfo = a,
            this._viewClasses = {
                ...l.default
            },
            this._viewInfo = r,
            this._componentInfo = n.default
        }
        async init() {
            await super.init(),
            p.Entity._entities.get("101955_bennu").radius = .2207,
            m.default.hideLoadingScreen(),
            m.default.updateEmbedLoadPercent(50),
            this.getComponent("menu")?.updateMenuContent()
        }
        setUpRoutes() {
            this.getManager("router").addRoutes([{
                route: this.getManager("router").homeRoute,
                view: "home"
            }, {
                route: "/story/:id",
                view: "story"
            }, {
                route: "/:spaceObject",
                view: "object"
            }, {
                route: "/:spaceObject/compare",
                view: "compare"
            }, {
                route: "/:spaceObject/telescope",
                view: "telescope"
            }, {
                route: "/:spaceObject/distance",
                view: "distance"
            }, {
                route: "/:spaceObject/:feature",
                view: "feature"
            }, {
                route: "/:spaceObject/events/:child",
                view: "event"
            }, {
                route: "/:spaceObject/:feature/:child",
                view: "object"
            }])
        }
        async setUpScene() {
            await super.setUpScene(),
            await this.scene.getLoadedPromise()
        }
        async setUpManagers() {
            await super.setUpManagers(),
            this.addManager("link", u.LinkManager),
            this.addManager("cameraFollow", s.CameraFollowManager);
            const t = this.getManager("content");
            t.setStoryList(c.STORY_LIST),
            t.setStories(c.STORIES);
            const e = t.getEntityList();
            this.getManager("search").setDatabase(e);
            const i = {
                prefix: "Eyes on the Solar System",
                suffix: "NASA/JPL",
                parseFn: ({url: t, params: e, query: i}={}) => {
                    const {spaceObject: s, spacecraft: n, planet: o, star: a, moon: r} = e
                      , l = s || n || o || a || r
                      , c = this.getManager("content")
                      , {altName: h, displayName: d, iauName: u} = c.getEntityInfo(l) || {}
                      , p = h || d || u
                      , m = i ? this.getManager("router").parseQuery(i) : {}
                      , _ = t.includes("/story");
                    if (_) {
                        const t = _ ? e.id : null
                          , {stories: i} = c.getStoryList()
                          , s = i[t]
                          , n = m.slide ? m.slide.replace("slide_", "") : 1;
                        return s?.title && n ? `${s.title} - Slide ${n}` : "Story"
                    }
                    if (!p)
                        return "Home";
                    if ("feature"in e) {
                        if ("child"in e) {
                            const {iauName: t, displayName: i} = c.getEntityInfo(e.child) || {}
                              , s = t || i;
                            if (s)
                                return s
                        }
                        const t = e.feature.charAt(0).toUpperCase() + e.feature.slice(1);
                        return `${p}'${p.endsWith("s") ? "" : "s"} ${t}`
                    }
                    if (t.includes("/telescope"))
                        return `${p} Telescope Mode`;
                    if (t.includes("/events")) {
                        const t = "child"in e
                          , i = t ? this.getView("event")._eventInfo?.title : null;
                        return t && i ? `${p} - ${i}` : `${p}'${p.endsWith("s") ? "" : "s"} Events`
                    }
                    if (t?.includes("/compare") && "id"in m) {
                        const {iauName: t, displayName: e} = c.getEntityInfo(m.id) || {}
                          , i = t || e;
                        if (i)
                            return `${p} compared to ${i}`
                    }
                    return p
                }
            }
              , n = u.Types.get("TitleManager");
            this.addManager("title", n, i);
            const o = this.addManager("autoplay", u.Types.get("AutoplayManager"), "autoplay.json");
            await o.init()
        }
        async setUpComponents() {
            await super.setUpComponents();
            const t = this.getManager("layer");
            t.getLayer("starfield").toggleCallback[0](!0);
            const e = this.getComponent("layerPanel")
              , i = ["ui", "planets", "spacecraft", "trails", "labels", "icons"]
              , s = ["asteroids", "comets", "dwarfPlanets", "constellations"];
            for (let s = 0; s < i.length; s++) {
                const n = i[s];
                t.getLayer(n).visible || e.toggleLayer(n)
            }
            for (let i = 0; i < s.length; i++) {
                const n = s[i];
                t.getLayer(n).visible && e.toggleLayer(n)
            }
            this.getComponent("breadcrumb")?.setCrumbClickHandler((t => {
                const e = {
                    keepTime: !0,
                    __remove: "all"
                };
                this.getManager("router").navigate({}, t, e)
            }
            ));
            const n = this.pioneer?.getViewport("main-viewport")?.getDiv();
            n && (n.style.top = "",
            n.style.left = "")
        }
        getVersion() {
            return u.AppVersion
        }
        getVersions() {
            return {
                pioneer: this.getPioneerVersion(),
                eyes: this.getEyesVersion(),
                app: this.getVersion()
            }
        }
    }
    SolarSystemApp.html = d(),
    SolarSystemApp.setAppClass()
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        AnimationUtils: function() {
            return s.AnimationUtils
        },
        AppUtils: function() {
            return s.AppUtils
        },
        AutoplayManager: function() {
            return s.AutoplayManager
        },
        BaseApp: function() {
            return s.BaseApp
        },
        BaseComponent: function() {
            return s.BaseComponent
        },
        BaseManager: function() {
            return s.BaseManager
        },
        BaseView: function() {
            return s.BaseView
        },
        Breadcrumb: function() {
            return s.Breadcrumb
        },
        ButtonsBlock: function() {
            return s.ButtonsBlock
        },
        CameraFollowManager: function() {
            return s.CameraFollowManager
        },
        CameraManager: function() {
            return s.CameraManager
        },
        CameraScripts: function() {
            return s.CameraScripts
        },
        CancelToken: function() {
            return s.CancelToken
        },
        Carousel: function() {
            return s.Carousel
        },
        CarouselPanel: function() {
            return s.CarouselPanel
        },
        Checkbox: function() {
            return s.Checkbox
        },
        CheckboxBlock: function() {
            return s.CheckboxBlock
        },
        CheckboxMultistate: function() {
            return s.CheckboxMultistate
        },
        Clock: function() {
            return s.Clock
        },
        ClockShortcut: function() {
            return s.ClockShortcut
        },
        ComparisonManager: function() {
            return s.ComparisonManager
        },
        ContentManager: function() {
            return s.ContentManager
        },
        DescriptionBlock: function() {
            return s.DescriptionBlock
        },
        DistanceLineComponent: function() {
            return s.DistanceLineComponent
        },
        ERTManager: function() {
            return s.ERTManager
        },
        EyesVersion: function() {
            return s.EyesVersion
        },
        HintBlock: function() {
            return s.HintBlock
        },
        ImageBlock: function() {
            return s.ImageBlock
        },
        KioskBase: function() {
            return s.KioskBase
        },
        LabelManager: function() {
            return s.LabelManager
        },
        LayerManager: function() {
            return s.LayerManager
        },
        LayerPanel: function() {
            return s.LayerPanel
        },
        LoadIcon: function() {
            return s.LoadIcon
        },
        OrbiterLineOfSightComponent: function() {
            return s.OrbiterLineOfSightComponent
        },
        Overlay: function() {
            return s.Overlay
        },
        ReplayButtonBlock: function() {
            return s.ReplayButtonBlock
        },
        RouteManager: function() {
            return s.RouteManager
        },
        SceneManager: function() {
            return s.SceneManager
        },
        Search: function() {
            return s.Search
        },
        SearchManager: function() {
            return s.SearchManager
        },
        SelectionManager: function() {
            return s.SelectionManager
        },
        Settings: function() {
            return s.Settings
        },
        ShareModal: function() {
            return s.ShareModal
        },
        SpoutManager: function() {
            return s.SpoutManager
        },
        Story: function() {
            return s.Story
        },
        StoryBaseContentBlock: function() {
            return s.StoryBaseContentBlock
        },
        TimeController: function() {
            return s.TimeController
        },
        TimeManager: function() {
            return s.TimeManager
        },
        TitleBlock: function() {
            return s.TitleBlock
        },
        TitleManager: function() {
            return s.TitleManager
        },
        Toast: function() {
            return s.Toast
        },
        ToggleBlock: function() {
            return s.ToggleBlock
        },
        TrailManager: function() {
            return s.TrailManager
        },
        TutorialOverlay: function() {
            return s.TutorialOverlay
        },
        Types: function() {
            return s.Types
        },
        WMTSManager: function() {
            return s.WMTSManager
        }
    });
    var s = i(2)
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        EyesVersion: function() {
            return s.version
        },
        OrbiterLineOfSightComponent: function() {
            return n.OrbiterLineOfSightComponent
        },
        DistanceLineComponent: function() {
            return o.DistanceLineComponent
        },
        CancelToken: function() {
            return a.CancelToken
        },
        AppUtils: function() {
            return r.AppUtils
        },
        AnimationUtils: function() {
            return l.AnimationUtils
        },
        BaseComponent: function() {
            return c.BaseComponent
        },
        Settings: function() {
            return h.default
        },
        LoadIcon: function() {
            return d.default
        },
        Overlay: function() {
            return u.default
        },
        Search: function() {
            return p.default
        },
        Clock: function() {
            return m.default
        },
        ClockShortcut: function() {
            return _.default
        },
        Carousel: function() {
            return g.default
        },
        TutorialOverlay: function() {
            return y.default
        },
        CarouselPanel: function() {
            return f.default
        },
        ShareModal: function() {
            return b.default
        },
        TimeController: function() {
            return T.default
        },
        Checkbox: function() {
            return v.default
        },
        CheckboxMultistate: function() {
            return v.CheckboxMultistate
        },
        LayerPanel: function() {
            return S.LayerPanel
        },
        Breadcrumb: function() {
            return E.Breadcrumb
        },
        StoryBaseContentBlock: function() {
            return C.StoryBaseContentBlock
        },
        HintBlock: function() {
            return x.HintBlock
        },
        ToggleBlock: function() {
            return w.ToggleBlock
        },
        TitleBlock: function() {
            return I.TitleBlock
        },
        ImageBlock: function() {
            return M.ImageBlock
        },
        DescriptionBlock: function() {
            return A.DescriptionBlock
        },
        ReplayButtonBlock: function() {
            return N.ReplayButtonBlock
        },
        ButtonsBlock: function() {
            return L.ButtonsBlock
        },
        CheckboxBlock: function() {
            return k.CheckboxBlock
        },
        Story: function() {
            return V.Story
        },
        KioskBase: function() {
            return R.KioskBase
        },
        Toast: function() {
            return P.Toast
        },
        BaseManager: function() {
            return O.BaseManager
        },
        SelectionManager: function() {
            return F.SelectionManager
        },
        LabelManager: function() {
            return U.LabelManager
        },
        RouteManager: function() {
            return D.RouteManager
        },
        ContentManager: function() {
            return z.ContentManager
        },
        SceneManager: function() {
            return j.SceneManager
        },
        WMTSManager: function() {
            return B.WMTSManager
        },
        LayerManager: function() {
            return H.LayerManager
        },
        TrailManager: function() {
            return $.TrailManager
        },
        CameraManager: function() {
            return G.CameraManager
        },
        CameraScripts: function() {
            return J.CameraScripts
        },
        ERTManager: function() {
            return Y.ERTManager
        },
        TimeManager: function() {
            return Q.TimeManager
        },
        ComparisonManager: function() {
            return Z.ComparisonManager
        },
        SearchManager: function() {
            return W.SearchManager
        },
        TitleManager: function() {
            return q.TitleManager
        },
        SpoutManager: function() {
            return X.SpoutManager
        },
        CameraFollowManager: function() {
            return K.CameraFollowManager
        },
        AutoplayManager: function() {
            return tt.AutoplayManager
        },
        BaseView: function() {
            return et.BaseView
        },
        BaseApp: function() {
            return it.BaseApp
        },
        Types: function() {
            return st.Types
        }
    });
    var s = i(3)
      , n = i(4)
      , o = i(132)
      , a = i(133)
      , r = i(134)
      , l = i(141)
      , c = i(142)
      , h = i(143)
      , d = i(206)
      , u = i(210)
      , p = i(214)
      , m = i(218)
      , _ = i(362)
      , g = i(366)
      , y = i(371)
      , f = i(481)
      , b = i(486)
      , T = i(491)
      , v = i(495)
      , S = i(500)
      , E = i(503)
      , C = i(506)
      , x = i(508)
      , w = i(511)
      , I = i(514)
      , M = i(516)
      , A = i(519)
      , N = i(522)
      , L = i(525)
      , k = i(528)
      , V = i(531)
      , R = i(533)
      , P = i(536)
      , O = i(539)
      , F = i(540)
      , U = i(541)
      , D = i(685)
      , z = i(687)
      , j = i(688)
      , B = i(689)
      , H = i(690)
      , $ = i(691)
      , G = i(692)
      , J = i(693)
      , Y = i(694)
      , Q = i(695)
      , Z = i(696)
      , W = i(697)
      , q = i(699)
      , X = i(700)
      , K = i(701)
      , tt = i(702)
      , et = i(703)
      , it = i(704)
      , st = i(722)
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        version: function() {
            return s
        }
    });
    const s = "2.5.2"
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        OrbiterLineOfSightComponent: function() {
            return OrbiterLineOfSightComponent
        }
    });
    var s = i(5);
    class OrbiterLineOfSightComponent extends s.BaseComponent {
        constructor(t, e) {
            super(t, e),
            this._targetA = null,
            this._targetB = null,
            this._ignoreDistance = !1,
            this._distanceThreshold = {
                min: 2,
                max: 20
            },
            this._positions = [],
            this._colors = [],
            this._widths = [],
            this._color = new s.Color(1,1,0),
            this._width = 2,
            this._threeJsScene = e.getScene().getThreeJsScene(),
            this._lineMesh = null,
            this.__setRadius(Number.POSITIVE_INFINITY)
        }
        setTargets(t, e) {
            "string" == typeof t && (t = this.getEntity().getScene().getEntity(t)),
            "string" == typeof e && (e = this.getEntity().getScene().getEntity(e)),
            this._targetA = t,
            this._targetB = e
        }
        setColor(t) {
            this._color = t
        }
        setWidth(t) {
            this._width = t
        }
        __loadResources() {
            return this._lineMesh = new s.LineMesh(this),
            Promise.resolve()
        }
        __unloadResources() {
            s.ThreeJsHelper.destroyAllObjectsAndMaterials(this),
            this._lineMesh = null
        }
        __prepareForRender(t) {
            if (null === this._targetA || null === this._targetB)
                return void (this.getThreeJsObjects().length > 0 && (this.getThreeJsObjects()[0].visible = !1));
            this._updatePoints(t);
            let e = 1;
            if (!this._ignoreDistance) {
                e *= (t.getEntity().getPosition().magnitude() - this._distanceThreshold.min) / (this._distanceThreshold.max - this._distanceThreshold.min)
            }
            s.ThreeJsHelper.setPositionToEntity(this.getThreeJsObjects()[0], this.getEntity(), t),
            this._lineMesh.setAlphaMultiplier(e),
            this._lineMesh.prepareForRender(t)
        }
        _updatePoints() {
            const t = s.Vector3.pool.get()
              , e = s.Vector3.pool.get();
            this._targetA.getPositionRelativeToEntity(t, s.Vector3.Zero, this.getEntity()),
            this._targetB.getPositionRelativeToEntity(e, s.Vector3.Zero, this.getEntity()),
            this._positions = [],
            this._positions.push(t),
            this._positions.push(e),
            this._lineMesh.setPositions(this._positions);
            const i = this._color;
            this._colors = [],
            this._colors.push(i),
            this._colors.push(i),
            this._lineMesh.setColors(this._colors),
            this._widths = [],
            this._widths.push(this._width),
            this._widths.push(this._width),
            this._lineMesh.setWidths(this._widths),
            s.Vector3.pool.release(t),
            s.Vector3.pool.release(e)
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        AER: function() {
            return s.AER
        },
        AlignController: function() {
            return s.AlignController
        },
        AnimdataController: function() {
            return s.AnimdataController
        },
        AtmosphereComponent: function() {
            return s.AtmosphereComponent
        },
        BaseComponent: function() {
            return s.BaseComponent
        },
        BaseController: function() {
            return s.BaseController
        },
        BaseRef: function() {
            return s.BaseRef
        },
        CMTSComponent: function() {
            return s.CMTSComponent
        },
        Cache: function() {
            return s.Cache
        },
        CameraComponent: function() {
            return s.CameraComponent
        },
        Capabilities: function() {
            return s.Capabilities
        },
        Collection: function() {
            return s.Collection
        },
        CollectionItem: function() {
            return s.CollectionItem
        },
        Color: function() {
            return s.Color
        },
        CometTailComponent: function() {
            return s.CometTailComponent
        },
        ComponentRef: function() {
            return s.ComponentRef
        },
        Config: function() {
            return s.Config
        },
        ConnectedSpriteComponent: function() {
            return s.ConnectedSpriteComponent
        },
        ControllerRef: function() {
            return s.ControllerRef
        },
        CoverageController: function() {
            return s.CoverageController
        },
        CubeMap: function() {
            return s.CubeMap
        },
        DependencyGraph: function() {
            return s.DependencyGraph
        },
        DivComponent: function() {
            return s.DivComponent
        },
        Download: function() {
            return s.Download
        },
        Downloader: function() {
            return s.Downloader
        },
        DynamicEnvironmentMapComponent: function() {
            return s.DynamicEnvironmentMapComponent
        },
        DynamoController: function() {
            return s.DynamoController
        },
        Engine: function() {
            return s.Engine
        },
        Entity: function() {
            return s.Entity
        },
        EntityItem: function() {
            return s.EntityItem
        },
        EntityRef: function() {
            return s.EntityRef
        },
        FPS: function() {
            return s.FPS
        },
        FastIterable: function() {
            return s.FastIterable
        },
        FastMap: function() {
            return s.FastMap
        },
        FastMapEntry: function() {
            return s.FastMapEntry
        },
        FastSet: function() {
            return s.FastSet
        },
        FixedController: function() {
            return s.FixedController
        },
        FixedToParentController: function() {
            return s.FixedToParentController
        },
        FreeFlyController: function() {
            return s.FreeFlyController
        },
        Freezable: function() {
            return s.Freezable
        },
        Geometry: function() {
            return s.Geometry
        },
        GizmoComponent: function() {
            return s.GizmoComponent
        },
        GroundClampController: function() {
            return s.GroundClampController
        },
        Input: function() {
            return s.Input
        },
        Interval: function() {
            return s.Interval
        },
        KeyframeController: function() {
            return s.KeyframeController
        },
        LabelComponent: function() {
            return s.LabelComponent
        },
        LatLonAlt: function() {
            return s.LatLonAlt
        },
        LightSourceComponent: function() {
            return s.LightSourceComponent
        },
        LineMesh: function() {
            return s.LineMesh
        },
        LookController: function() {
            return s.LookController
        },
        MaterialManager: function() {
            return s.MaterialManager
        },
        MaterialUtils: function() {
            return s.MaterialUtils
        },
        MaterialUtilsPhong: function() {
            return s.MaterialUtilsPhong
        },
        MaterialUtilsStandard: function() {
            return s.MaterialUtilsStandard
        },
        MathUtils: function() {
            return s.MathUtils
        },
        ModelAnimateController: function() {
            return s.ModelAnimateController
        },
        ModelComponent: function() {
            return s.ModelComponent
        },
        OrbitController: function() {
            return s.OrbitController
        },
        OrbitKeyframeController: function() {
            return s.OrbitKeyframeController
        },
        OrbitalElements: function() {
            return s.OrbitalElements
        },
        OrbitalElementsController: function() {
            return s.OrbitalElementsController
        },
        OrbitalElementsKeyFrame: function() {
            return s.OrbitalElementsKeyFrame
        },
        OrbitalParticlesComponent: function() {
            return s.OrbitalParticlesComponent
        },
        ParticleSprayComponent: function() {
            return s.ParticleSprayComponent
        },
        PickController: function() {
            return s.PickController
        },
        Pool: function() {
            return s.Pool
        },
        Quaternion: function() {
            return s.Quaternion
        },
        RandomString: function() {
            return s.RandomString
        },
        Reader: function() {
            return s.Reader
        },
        Rect: function() {
            return s.Rect
        },
        RingsComponent: function() {
            return s.RingsComponent
        },
        RollController: function() {
            return s.RollController
        },
        RotateByEntityOrientationController: function() {
            return s.RotateByEntityOrientationController
        },
        RotateController: function() {
            return s.RotateController
        },
        ScaleController: function() {
            return s.ScaleController
        },
        Scene: function() {
            return s.Scene
        },
        SelectController: function() {
            return s.SelectController
        },
        SetParentController: function() {
            return s.SetParentController
        },
        ShaderChunkLogDepth: function() {
            return s.ShaderChunkLogDepth
        },
        SkyboxComponent: function() {
            return s.SkyboxComponent
        },
        Sort: function() {
            return s.Sort
        },
        SpheroidComponent: function() {
            return s.SpheroidComponent
        },
        SpheroidLODComponent: function() {
            return s.SpheroidLODComponent
        },
        SpinController: function() {
            return s.SpinController
        },
        SpoutComponent: function() {
            return s.SpoutComponent
        },
        SpriteComponent: function() {
            return s.SpriteComponent
        },
        SpriteParticles: function() {
            return s.SpriteParticles
        },
        StarfieldComponent: function() {
            return s.StarfieldComponent
        },
        THREE: function() {
            return s.THREE
        },
        TapController: function() {
            return s.TapController
        },
        TextureLOD: function() {
            return s.TextureLOD
        },
        TextureLoader: function() {
            return s.TextureLoader
        },
        ThreeJsHelper: function() {
            return s.ThreeJsHelper
        },
        Tile: function() {
            return s.Tile
        },
        TimeUtils: function() {
            return s.TimeUtils
        },
        TrailComponent: function() {
            return s.TrailComponent
        },
        TransitionController: function() {
            return s.TransitionController
        },
        TranslateController: function() {
            return s.TranslateController
        },
        Vector2: function() {
            return s.Vector2
        },
        Vector3: function() {
            return s.Vector3
        },
        Version: function() {
            return s.Version
        },
        Viewport: function() {
            return s.Viewport
        },
        ZoomController: function() {
            return s.ZoomController
        },
        credits: function() {
            return s.credits
        },
        waitUntil: function() {
            return s.waitUntil
        }
    });
    var s = i(6)
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        THREE: function() {
            return s
        },
        ShaderChunkLogDepth: function() {
            return n.ShaderChunkLogDepth
        },
        BaseRef: function() {
            return o.BaseRef
        },
        Collection: function() {
            return a.Collection
        },
        CollectionItem: function() {
            return a.CollectionItem
        },
        DependencyGraph: function() {
            return r.DependencyGraph
        },
        FastIterable: function() {
            return l.FastIterable
        },
        FPS: function() {
            return c.FPS
        },
        Freezable: function() {
            return h.Freezable
        },
        MathUtils: function() {
            return d.MathUtils
        },
        Pool: function() {
            return u.Pool
        },
        RandomString: function() {
            return p.RandomString
        },
        Reader: function() {
            return m.Reader
        },
        Sort: function() {
            return _.Sort
        },
        Tile: function() {
            return g.Tile
        },
        TimeUtils: function() {
            return y.TimeUtils
        },
        waitUntil: function() {
            return f.waitUntil
        },
        AER: function() {
            return b.AER
        },
        Color: function() {
            return T.Color
        },
        FastMap: function() {
            return v.FastMap
        },
        FastMapEntry: function() {
            return v.FastMapEntry
        },
        FastSet: function() {
            return S.FastSet
        },
        Geometry: function() {
            return E.Geometry
        },
        Interval: function() {
            return C.Interval
        },
        OrbitalElements: function() {
            return x.OrbitalElements
        },
        Rect: function() {
            return w.Rect
        },
        Quaternion: function() {
            return I.Quaternion
        },
        Vector2: function() {
            return M.Vector2
        },
        Vector3: function() {
            return A.Vector3
        },
        Cache: function() {
            return N.Cache
        },
        ComponentRef: function() {
            return L.ComponentRef
        },
        ControllerRef: function() {
            return k.ControllerRef
        },
        CubeMap: function() {
            return V.CubeMap
        },
        EntityRef: function() {
            return R.EntityRef
        },
        LatLonAlt: function() {
            return P.LatLonAlt
        },
        LineMesh: function() {
            return O.LineMesh
        },
        MaterialUtilsPhong: function() {
            return F.MaterialUtilsPhong
        },
        MaterialUtilsStandard: function() {
            return U.MaterialUtilsStandard
        },
        MaterialUtils: function() {
            return D.MaterialUtils
        },
        SpriteParticles: function() {
            return z.SpriteParticles
        },
        TextureLOD: function() {
            return j.TextureLOD
        },
        ThreeJsHelper: function() {
            return B.ThreeJsHelper
        },
        Capabilities: function() {
            return H.Capabilities
        },
        Config: function() {
            return $.Config
        },
        Download: function() {
            return G.Download
        },
        Downloader: function() {
            return G.Downloader
        },
        Engine: function() {
            return J.Engine
        },
        Entity: function() {
            return Y.Entity
        },
        EntityItem: function() {
            return Q.EntityItem
        },
        Input: function() {
            return Z.Input
        },
        MaterialManager: function() {
            return W.MaterialManager
        },
        Scene: function() {
            return q.Scene
        },
        TextureLoader: function() {
            return X.TextureLoader
        },
        Version: function() {
            return K.Version
        },
        Viewport: function() {
            return tt.Viewport
        },
        BaseComponent: function() {
            return et.BaseComponent
        },
        AtmosphereComponent: function() {
            return it.AtmosphereComponent
        },
        CameraComponent: function() {
            return st.CameraComponent
        },
        CMTSComponent: function() {
            return nt.CMTSComponent
        },
        CometTailComponent: function() {
            return ot.CometTailComponent
        },
        ConnectedSpriteComponent: function() {
            return at.ConnectedSpriteComponent
        },
        DivComponent: function() {
            return rt.DivComponent
        },
        DynamicEnvironmentMapComponent: function() {
            return lt.DynamicEnvironmentMapComponent
        },
        GizmoComponent: function() {
            return ct.GizmoComponent
        },
        LabelComponent: function() {
            return ht.LabelComponent
        },
        LightSourceComponent: function() {
            return dt.LightSourceComponent
        },
        ModelComponent: function() {
            return ut.ModelComponent
        },
        OrbitalParticlesComponent: function() {
            return pt.OrbitalParticlesComponent
        },
        ParticleSprayComponent: function() {
            return mt.ParticleSprayComponent
        },
        RingsComponent: function() {
            return _t.RingsComponent
        },
        SkyboxComponent: function() {
            return gt.SkyboxComponent
        },
        SpheroidComponent: function() {
            return yt.SpheroidComponent
        },
        SpheroidLODComponent: function() {
            return ft.SpheroidLODComponent
        },
        SpoutComponent: function() {
            return bt.SpoutComponent
        },
        SpriteComponent: function() {
            return Tt.SpriteComponent
        },
        StarfieldComponent: function() {
            return vt.StarfieldComponent
        },
        TrailComponent: function() {
            return St.TrailComponent
        },
        BaseController: function() {
            return Et.BaseController
        },
        AlignController: function() {
            return Ct.AlignController
        },
        AnimdataController: function() {
            return xt.AnimdataController
        },
        CoverageController: function() {
            return wt.CoverageController
        },
        DynamoController: function() {
            return It.DynamoController
        },
        FixedController: function() {
            return Mt.FixedController
        },
        FixedToParentController: function() {
            return At.FixedToParentController
        },
        FreeFlyController: function() {
            return Nt.FreeFlyController
        },
        GroundClampController: function() {
            return Lt.GroundClampController
        },
        KeyframeController: function() {
            return kt.KeyframeController
        },
        LookController: function() {
            return Vt.LookController
        },
        ModelAnimateController: function() {
            return Rt.ModelAnimateController
        },
        OrbitController: function() {
            return Pt.OrbitController
        },
        OrbitKeyframeController: function() {
            return Ot.OrbitKeyframeController
        },
        OrbitalElementsController: function() {
            return Ft.OrbitalElementsController
        },
        OrbitalElementsKeyFrame: function() {
            return Ft.OrbitalElementsKeyFrame
        },
        PickController: function() {
            return Ut.PickController
        },
        RollController: function() {
            return Dt.RollController
        },
        RotateController: function() {
            return zt.RotateController
        },
        RotateByEntityOrientationController: function() {
            return jt.RotateByEntityOrientationController
        },
        ScaleController: function() {
            return Bt.ScaleController
        },
        SelectController: function() {
            return Ht.SelectController
        },
        SetParentController: function() {
            return $t.SetParentController
        },
        SpinController: function() {
            return Gt.SpinController
        },
        TapController: function() {
            return Jt.TapController
        },
        TransitionController: function() {
            return Yt.TransitionController
        },
        TranslateController: function() {
            return Qt.TranslateController
        },
        ZoomController: function() {
            return Zt.ZoomController
        },
        credits: function() {
            return Wt
        }
    });
    var s = i(7)
      , n = i(8)
      , o = i(9)
      , a = i(10)
      , r = i(11)
      , l = i(12)
      , c = i(13)
      , h = i(14)
      , d = i(15)
      , u = i(16)
      , p = i(17)
      , m = i(18)
      , _ = i(19)
      , g = i(20)
      , y = i(21)
      , f = i(22)
      , b = i(23)
      , T = i(24)
      , v = i(25)
      , S = i(26)
      , E = i(27)
      , C = i(28)
      , x = i(29)
      , w = i(30)
      , I = i(31)
      , M = i(32)
      , A = i(33)
      , N = i(34)
      , L = i(35)
      , k = i(36)
      , V = i(37)
      , R = i(38)
      , P = i(39)
      , O = i(40)
      , F = i(41)
      , U = i(42)
      , D = i(43)
      , z = i(44)
      , j = i(45)
      , B = i(46)
      , H = i(47)
      , $ = i(48)
      , G = i(49)
      , J = i(50)
      , Y = i(51)
      , Q = i(52)
      , Z = i(53)
      , W = i(54)
      , q = i(63)
      , X = i(64)
      , K = i(69)
      , tt = i(70)
      , et = i(71)
      , it = i(72)
      , st = i(73)
      , nt = i(83)
      , ot = i(84)
      , at = i(85)
      , rt = i(86)
      , lt = i(87)
      , ct = i(88)
      , ht = i(89)
      , dt = i(90)
      , ut = i(91)
      , pt = i(95)
      , mt = i(96)
      , _t = i(97)
      , gt = i(98)
      , yt = i(99)
      , ft = i(100)
      , bt = i(101)
      , Tt = i(102)
      , vt = i(103)
      , St = i(104)
      , Et = i(105)
      , Ct = i(106)
      , xt = i(107)
      , wt = i(108)
      , It = i(109)
      , Mt = i(110)
      , At = i(111)
      , Nt = i(112)
      , Lt = i(113)
      , kt = i(114)
      , Vt = i(115)
      , Rt = i(116)
      , Pt = i(117)
      , Ot = i(118)
      , Ft = i(119)
      , Ut = i(120)
      , Dt = i(121)
      , zt = i(122)
      , jt = i(123)
      , Bt = i(124)
      , Ht = i(125)
      , $t = i(126)
      , Gt = i(127)
      , Jt = i(128)
      , Yt = i(129)
      , Qt = i(130)
      , Zt = i(131);
    const Wt = '\nNASA\'s Eyes Team Credits\n\nManagers\n* Alicia Cermak\n* Kevin Hussey\n* Jon Nelson\n\nProducers\n* Doug Ellison\n* Jason Craig\n\n3D Artists\n* Brian Kumanchik\n* Christian Lopez\n* Matthew Garcia\n\nSoftware Developers\n* Anton Kulikov\n* Charles Mattei\n* Daniel Sedlacko\n* Davit Stepanyan\n* Ibrahim Ahmed\n* Jack Simpson\n* James Ray\n* Jasmine Nelson\n* Kenny Wu\n* Christopher "Kit" Petrie\n* Kristine Nguyen\n* Mi Nguyen\n* Stephen O\'Rourley\n* Steven "Russ" King\n* Tariq Soliman\n* Ximena Jaramillo\n\nIT Support\n* Alexander "Sasha" Mednikov\n* Dennis Ramirez\n* Jan Santos\n\nData Pipeline Support\n* Bach Bui\n* Charles Thompson\n* Jeff Hall\n* Natalie Gallegos\n* Shan Malhotra\n* Shigeru Suzuki\n'
}
, , function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        ShaderChunkLogDepth: function() {
            return ShaderChunkLogDepth
        }
    });
    var s = i(7);
    class ShaderChunkLogDepth {
        static Uniforms = {
            invertDepth: "float",
            nearDistance: "float",
            midDistance: "float"
        };
        static VertexHead = "\n\t\tout float depth;\n\t";
        static Vertex = "\n\t\tdepth = gl_Position.w;\n\t";
        static FragmentHead = "\n\t\tuniform float invertDepth;\n\t\tuniform float nearDistance;\n\t\tuniform float midDistance;\n\t\tin float depth;\n\t";
        static Fragment = "\n\t\tfloat logFactor = 0.01254291648; // 1 / log2(1 + 1e24)\n\t\tfloat nearFactor = 0.5 * (depth - nearDistance) / (midDistance - nearDistance);\n\t\tfloat farFactor = 0.5 * (1.0 + log2(1.0 + depth - midDistance) * logFactor);\n\t\tgl_FragDepth = (1.0 - 2.0 * invertDepth) * (depth >= midDistance ? farFactor : nearFactor) + invertDepth;\n\t";
        static ThreeUniforms = {
            invertDepth: new s.Uniform(0),
            nearDistance: new s.Uniform(0),
            midDistance: new s.Uniform(0)
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        BaseRef: function() {
            return BaseRef
        }
    });
    i(6);
    class BaseRef {
        constructor(t) {
            this._scene = t,
            this._ref = null,
            this._refChangedCallback = null
        }
        get() {
            return this.update(),
            this._ref
        }
        setRefChangedCallback(t) {
            this._refChangedCallback = t
        }
        update() {}
        _setRef(t) {
            if (null === t || t.isEnabled() || (t = null),
            this._ref !== t) {
                const e = this._ref;
                this._ref = t,
                null !== this._refChangedCallback && this._refChangedCallback(e, this._ref)
            }
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        CollectionItem: function() {
            return CollectionItem
        },
        Collection: function() {
            return Collection
        }
    });
    class CollectionItem {
        constructor(t, e) {
            this._index = 0,
            this._classIndex = 0,
            this._name = t,
            this._collectionParent = e
        }
        getIndex() {
            return this._index
        }
        __setIndex(t) {
            this._index = t
        }
        getClassIndex() {
            return this._classIndex
        }
        __setClassIndex(t) {
            this._classIndex = t
        }
        getName() {
            return this._name
        }
        __getCollectionParent() {
            return this._collectionParent
        }
        __setCollectionParent(t) {
            this._collectionParent = t
        }
        __destroy() {}
    }
    class Collection {
        constructor(t) {
            this._parent = t,
            this._items = [],
            this._itemsByName = new Map,
            this._itemsByClass = new Map
        }
        get(t, e=0) {
            if ("number" == typeof e) {
                const i = this._itemsByClass.get(t);
                return i ? i[e] ?? null : null
            }
            {
                const i = this._itemsByName.get(e);
                return i instanceof t ? i : null
            }
        }
        getAt(t) {
            return this._items[t]
        }
        getSize() {
            return this._items.length
        }
        getAny(t, e) {
            const i = this._itemsByName.get(t);
            if (i)
                return i;
            for (const [i,s] of this._itemsByClass)
                if (i.name === t)
                    return s[e ?? 0] ?? null;
            return null
        }
        add(t, e="", i) {
            if ("" !== e && e[0].match("/A-Z/"))
                throw new Error(`The name "${e}" must start with lowercase to differentiate it from class names.`);
            if ("" !== e && this._itemsByName.has(e))
                throw new Error(`Already added "${e}".`);
            if (i && this._items[i.getIndex()] !== i)
                throw new Error(`While adding ${t.name}${"" !== e ? ` named ${e}` : ""}: The beforeItem ${i} does not exist in the same class list.`);
            try {
                const s = new t(e,this._parent);
                return this._addToLists(s, i),
                s
            } catch (i) {
                throw i instanceof Error && (i.message = `While adding ${t.name}${"" !== e ? ` named ${e}` : ""}: ${i.message}`),
                i
            }
        }
        move(t, e, i) {
            let s;
            if ("string" == typeof t) {
                if (s = this._itemsByName.get(t),
                !s)
                    throw new Error(`There is no item with name ${t}.`)
            } else
                s = t;
            const n = s.getIndex();
            if (s !== this._items[n])
                throw new Error(`While moving ${s}, it is not in the source collection.`);
            const o = s.getName();
            if ("" !== o && e._itemsByName.has(o))
                throw new Error(`While moving ${s}, an item with the same name "${o}" already exists in the destination collection.`);
            this._removeFromLists(s.getIndex(), s),
            e._addToLists(s, i),
            s.__setCollectionParent(e._parent)
        }
        remove(t) {
            let e;
            if ("string" == typeof t) {
                if (e = this._itemsByName.get(t),
                !e)
                    throw new Error(`There is no item with name "${t}".`)
            } else
                e = t;
            const i = e.getIndex();
            if (e !== this._items[i])
                throw new Error(`While removing ${e}, it is not in the collection.`);
            this._removeFromLists(i, e),
            e.__destroy()
        }
        clear() {
            for (let t = 0, e = this._items.length; t < e; t++)
                this._items[t].__destroy();
            this._items = [],
            this._itemsByClass.clear(),
            this._itemsByName.clear()
        }
        _addToLists(t, e) {
            const i = void 0 !== e ? e.getIndex() : this._items.length;
            this._items.splice(i, 0, t),
            "" !== t.getName() && this._itemsByName.set(t.getName(), t),
            this._updateIndices(i, t)
        }
        _removeFromLists(t, e) {
            this._items.splice(t, 1),
            "" !== e.getName() && this._itemsByName.delete(e.getName()),
            this._updateIndices(t, e)
        }
        _updateIndices(t, e) {
            for (let e = t, i = this._items.length; e < i; e++)
                this._items[e].__setIndex(e);
            const i = e.constructor
              , s = [];
            for (let t = 0, e = this._items.length; t < e; t++) {
                const e = this._items[t];
                e.constructor === i && (e.__setClassIndex(s.length),
                s.push(e))
            }
            s.length > 0 ? this._itemsByClass.set(i, s) : this._itemsByClass.delete(i)
        }
        __destroy() {
            for (let t = this._items.length - 1; t >= 0; t--)
                this._items[t].__destroy()
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        DependencyGraph: function() {
            return DependencyGraph
        }
    });
    class DependencyGraph {
        constructor(t, e) {
            this._updateItemCallback = t,
            this._compareItemCallback = e,
            this._nodes = new Map,
            this._sortedNodes = [],
            this._needsSorting = !1
        }
        addItem(t) {
            const e = new Node(t);
            this._nodes.set(t, e),
            this._needsSorting = !0
        }
        removeItem(t) {
            this._nodes.delete(t) && (this._needsSorting = !0)
        }
        needsSorting() {
            this._needsSorting = !0
        }
        update() {
            if (this._needsSorting) {
                for (const t of this._nodes.values())
                    t.permanentMark = !1,
                    t.temporaryMark = !1;
                this._sortedNodes = [];
                const t = this._nodes.values();
                for (; ; ) {
                    const e = t.next();
                    if (!0 === e.done)
                        break;
                    if (!this._visit(e.value))
                        break
                }
                this._needsSorting = !1
            }
            for (let t = 0, e = this._sortedNodes.length; t < e; t++)
                this._updateItemCallback(this._sortedNodes[t].item)
        }
        _visit(t) {
            if (t.permanentMark)
                return !0;
            if (t.temporaryMark)
                throw new Error(`Dependency cycle in graph: ${t.item}`);
            t.temporaryMark = !0;
            for (const e of this._nodes.values()) {
                if (this._compareItemCallback(t.item, e.item))
                    try {
                        this._visit(e)
                    } catch (e) {
                        throw e instanceof Error && (e.message = `${e.message} â† ${t.item}`),
                        e
                    }
            }
            return t.temporaryMark = !1,
            t.permanentMark = !0,
            this._sortedNodes.push(t),
            !0
        }
    }
    class Node {
        constructor(t) {
            this.item = t,
            this.permanentMark = !1,
            this.temporaryMark = !1
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        FastIterable: function() {
            return FastIterable
        }
    });
    class FastIterable {
        getAt(t) {
            throw new Error
        }
        getSize() {
            throw new Error
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        FPS: function() {
            return FPS
        }
    });
    class FPS {
        constructor() {
            this._numberOfSamples = 100,
            this._samples = new Array(this._numberOfSamples),
            this._index = 0
        }
        getNumberOfSamples() {
            return this._numberOfSamples
        }
        setNumberOfSamples(t) {
            this._numberOfSamples = t,
            this._samples = new Array(this._numberOfSamples)
        }
        getFPS() {
            let t = 0;
            for (let e = 0; e < this._samples.length; e++)
                t += this._samples[e];
            return this._samples.length / t
        }
        update(t) {
            this._samples[this._index] = t,
            this._index = (this._index + 1) % this._samples.length
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        Freezable: function() {
            return Freezable
        }
    });
    class Freezable {
        constructor(t) {
            this._frozen = t
        }
        throwIfFrozen() {
            if (this._frozen)
                throw new TypeError("The object is frozen.")
        }
        isFrozen() {
            return this._frozen
        }
        freeze() {
            this._frozen = !0
        }
        thaw() {
            this._frozen = !1
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        MathUtils: function() {
            return MathUtils
        }
    });
    class MathUtils {
        static get pi() {
            return 3.141592653589793
        }
        static get twoPi() {
            return 6.283185307179586
        }
        static get halfPi() {
            return 1.5707963267948966
        }
        static angle(t, e) {
            return t = this.wrap(t, 0, 2 * Math.PI),
            (e = this.wrap(e, 0, 2 * Math.PI)) - t > Math.PI ? t - e + 2 * Math.PI : t - e > Math.PI ? e - t + 2 * Math.PI : Math.abs(e - t)
        }
        static clamp(t, e, i) {
            return Math.min(Math.max(e, t), i)
        }
        static clamp01(t) {
            return Math.min(Math.max(0, t), 1)
        }
        static wrap(t, e, i) {
            let s = (t - e) % (i - e) + e;
            return s < e && (s += i - e),
            s
        }
        static lerp(t, e, i) {
            return (1 - i) * t + i * e
        }
        static lerpAngle(t, e, i) {
            return t = this.wrap(t, -Math.PI, +Math.PI),
            (e = this.wrap(e, -Math.PI, +Math.PI)) - t > Math.PI && (t += 2 * Math.PI),
            t - e > Math.PI && (e += 2 * Math.PI),
            this.wrap(this.lerp(t, e, i), -Math.PI, +Math.PI)
        }
        static radToDeg(t) {
            return 57.29577951308232 * t
        }
        static degToRad(t) {
            return .01745329251994329 * t
        }
        static ceilPow2(t) {
            return 2 ** Math.ceil(Math.log(t) / Math.log(2))
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        Pool: function() {
            return Pool
        }
    });
    var s = i(6);
    class Pool extends s.FastIterable {
        constructor(t) {
            super(),
            this._type = t,
            this._objects = [],
            this._free = [],
            this._freeLength = 0,
            this._constructorFunction = () => new this._type,
            this._destructorFunction = () => {}
        }
        setConstructorFunction(t) {
            this._constructorFunction = t
        }
        setDestructorFunction(t) {
            this._destructorFunction = t
        }
        get() {
            let t;
            if (this._freeLength > 0)
                t = this._objects[this._free[this._freeLength - 1]],
                this._freeLength -= 1;
            else {
                t = this._constructorFunction();
                const e = this._objects.push(t) - 1;
                this._objects[e]._poolIndex = e
            }
            return t._poolUsed = !0,
            t
        }
        release(t) {
            const e = t;
            void 0 !== e._poolIndex && (this._freeLength >= this._free.length ? this._free.push(e._poolIndex) : this._free[this._freeLength] = e._poolIndex,
            this._freeLength += 1,
            e._poolUsed = !1)
        }
        clean(t) {
            if (void 0 === t || t >= (this._objects.length - this._freeLength) / this._objects.length) {
                for (let t = 0; t < this._freeLength; t++) {
                    const e = this._free[t];
                    this._destructorFunction(this._objects[e]),
                    this._objects.splice(e, 1);
                    for (let t = e, i = this._objects.length; t < i; t++)
                        this._objects[t]._poolIndex -= 1;
                    for (let i = t + 1, s = this._freeLength; i < s; i++)
                        this._free[i] > e && (this._free[i] -= 1)
                }
                this._free = [],
                this._freeLength = 0
            }
        }
        getAsArray() {
            return this._objects
        }
        isUsed(t) {
            return t._poolUsed
        }
        areAnyUsed() {
            return this._freeLength < this._objects.length
        }
        getAt(t) {
            return this._objects[t]
        }
        getSize() {
            return this._objects.length
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        RandomString: function() {
            return RandomString
        }
    });
    class RandomString {
        static generate(t) {
            const e = new Uint8Array(Math.ceil(t / 2));
            return crypto.getRandomValues(e),
            Array.from(e, (t => `0${(255 & t).toString(16)}`.slice(-2))).join("").slice(0, t)
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        Reader: function() {
            return Reader
        }
    });
    class Reader {
        constructor(t) {
            this._dataView = new DataView(t),
            this._offset = 0
        }
        isAtEnd() {
            return this._offset >= this._dataView.byteLength
        }
        readByte() {
            const t = this._dataView.getUint8(this._offset);
            return this._offset += 1,
            t
        }
        readFloat32() {
            const t = this._dataView.getFloat32(this._offset, !0);
            return this._offset += 4,
            t
        }
        readFloat64() {
            const t = this._dataView.getFloat64(this._offset, !0);
            return this._offset += 8,
            t
        }
        readUInt8() {
            const t = this._dataView.getUint8(this._offset);
            return this._offset += 1,
            t
        }
        readUInt16() {
            const t = this._dataView.getUint16(this._offset, !0);
            return this._offset += 2,
            t
        }
        readUInt32() {
            const t = this._dataView.getUint32(this._offset, !0);
            return this._offset += 4,
            t
        }
        readUInt64() {
            const t = Number(this._dataView.getBigUint64(this._offset, !0));
            return this._offset += 8,
            Number.isSafeInteger(t) ? t : NaN
        }
        readInt8() {
            const t = this._dataView.getInt8(this._offset);
            return this._offset += 1,
            t
        }
        readInt16() {
            const t = this._dataView.getInt16(this._offset, !0);
            return this._offset += 2,
            t
        }
        readInt32() {
            const t = this._dataView.getInt32(this._offset, !0);
            return this._offset += 4,
            t
        }
        readInt64() {
            const t = Number(this._dataView.getBigInt64(this._offset, !0));
            return this._offset += 8,
            Number.isSafeInteger(t) ? t : NaN
        }
        readLine() {
            const t = [];
            for (; ; ) {
                const e = this.readByte()
                  , i = String.fromCharCode(e);
                if ("\r" !== i) {
                    if ("\n" === i)
                        break;
                    t.push(e)
                }
            }
            if ("undefined" != typeof TextEncoder) {
                const e = new TextDecoder
                  , i = new Uint8Array(t);
                return e.decode(i)
            }
            return this._utf8ArrayToStr(t)
        }
        readString(t) {
            const e = [];
            for (; ; ) {
                const i = this.readByte();
                if (void 0 === t && 0 === i)
                    break;
                if (e.push(i),
                void 0 !== t && e.length === t)
                    break
            }
            if ("undefined" != typeof TextEncoder) {
                const t = new TextDecoder
                  , i = new Uint8Array(e);
                return t.decode(i)
            }
            return this._utf8ArrayToStr(e)
        }
        _utf8ArrayToStr(t) {
            let e, i, s, n, o = "", a = 0;
            const r = t.length;
            for (; a < r; )
                switch (e = t[a],
                a += 1,
                e >> 4) {
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                    o += String.fromCharCode(e);
                    break;
                case 12:
                case 13:
                    i = 0 | t[a],
                    a += 1,
                    o += String.fromCharCode((31 & e) << 6 | 63 & i);
                    break;
                case 14:
                    i = 0 | t[a],
                    a += 1,
                    s = 0 | t[a],
                    a += 1,
                    o += String.fromCharCode((15 & e) << 12 | (63 & i) << 6 | (63 & s) << 0);
                    break;
                case 15:
                    i = 0 | t[a],
                    a += 1,
                    s = 0 | t[a],
                    a += 1,
                    n = 0 | t[a],
                    a += 1,
                    o += String.fromCharCode((7 & e) << 18 | (63 & i) << 12 | (63 & s) << 6 | (63 & n) << 0)
                }
            return o
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        Sort: function() {
            return Sort
        }
    });
    class Sort {
        static getIndex(t, e, i) {
            let s = 0
              , n = e.length;
            if (void 0 === i)
                for (; s < n; ) {
                    const i = s + n >>> 1;
                    e[i] < t ? s = i + 1 : n = i
                }
            else
                for (; s < n; ) {
                    const o = s + n >>> 1;
                    i(e[o], t) ? s = o + 1 : n = o
                }
            return s
        }
        static add(t, e, i, s) {
            let n = this.getIndex(t, e, i);
            if (void 0 === s)
                for (; n < e.length && e[n] === t; )
                    n += 1;
            else
                for (; n < e.length && s(e[n], t); )
                    n += 1;
            e.splice(n, 0, t)
        }
        static remove(t, e, i, s) {
            const n = this.getIndex(t, e, i);
            let o = !1;
            return n < e.length && (void 0 === s && e[n] === t || void 0 !== s && s(e[n], t)) && (o = !0),
            o && e.splice(n, 1),
            o
        }
        static sort(t, e, i) {
            if (0 === t.length)
                return;
            let s = 1;
            for (; s < t.length; ) {
                let n = s - 1;
                if (e)
                    for (; n >= 0 && e(t[n + 1], t[n]); ) {
                        const e = t[n];
                        t[n] = t[n + 1],
                        t[n + 1] = e,
                        i && i(n + 1, n),
                        n--
                    }
                else
                    for (; n >= 0 && t[n + 1] < t[n]; ) {
                        const e = t[n];
                        t[n] = t[n + 1],
                        t[n + 1] = e,
                        i && i(n + 1, n),
                        n--
                    }
                s++
            }
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        Tile: function() {
            return Tile
        }
    });
    class Tile {
        constructor(t) {
            this._parent = t,
            this._children = [],
            this._activated = !1,
            this._shouldBeVisible = !1,
            this._splitFailed = !1,
            this._loaded = !1,
            this._destroyed = !1,
            this._transitioning = !1
        }
        shouldBeVisible() {
            return this._shouldBeVisible
        }
        getParent() {
            return this._parent
        }
        async forceLoad() {
            this._transitioning = !0,
            this._destroyed || await this.load(),
            this._loaded = !0,
            this._destroyed || await this.activate(),
            this._activated = !0,
            this._shouldBeVisible = !0,
            this._transitioning = !1
        }
        check() {
            return this._destroyed || this._transitioning || (0 === this._children.length && !this._splitFailed && this.checkSplit() ? this._split() : this._children.length > 0 && this.checkJoin() && this._join()),
            this._transitioning
        }
        getChildren() {
            return this._children
        }
        createNewTile(t, e, i) {
            return null
        }
        checkSplit() {
            return !1
        }
        checkJoin() {
            return !1
        }
        async load() {}
        unload() {}
        async activate() {}
        deactivate() {}
        destroy() {
            this._destroyed = !0;
            for (let t = 0; t < this._children.length; t++)
                this._children[t].destroy();
            this._transitioning || (this._shouldBeVisible = !1,
            this._activated && this.deactivate(),
            this._loaded && this.unload())
        }
        isDestroyed() {
            return this._destroyed
        }
        async _split() {
            const t = []
              , e = [];
            this._splitAndGetNeedingLoad(t, e);
            for (let e = 0; e < t.length; e++)
                t[e]._transitioning = !0;
            this._transitioning = !0;
            const i = [];
            for (let t = 0; t < e.length; t++) {
                const s = e[t];
                i.push(s.load().then(( () => {
                    s._loaded = !0
                }
                )).catch((async t => {
                    throw t instanceof Error && console.log(t.message),
                    t
                }
                )))
            }
            if (!(await Promise.allSettled(i)).map((t => "fulfilled" === t.status)).reduce(( (t, e) => t && e), !0) || this._destroyed) {
                for (let t = 0; t < e.length; t++) {
                    const i = e[t];
                    i._loaded && (i.unload(),
                    i._loaded = !1)
                }
                return this._destroyed && (this._shouldBeVisible = !1,
                this.deactivate(),
                this.unload()),
                this._splitFailed = !0,
                this._children = [],
                void (this._transitioning = !1)
            }
            const s = [];
            for (let t = 0; t < e.length; t++) {
                const i = e[t];
                s.push(i.activate().then(( () => {
                    i._activated = !0
                }
                )).catch((async t => {
                    throw t instanceof Error && console.log(t.message),
                    t
                }
                )))
            }
            if (!(await Promise.allSettled(s)).map((t => "fulfilled" === t.status)).reduce(( (t, e) => t && e), !0) || this._destroyed) {
                for (let t = 0; t < e.length; t++) {
                    const i = e[t];
                    i._activated && (i._shouldBeVisible = !1,
                    i.deactivate(),
                    i._activated = !1),
                    i._loaded && (i.unload(),
                    i._loaded = !1)
                }
                return this._destroyed && (this._shouldBeVisible = !1,
                this.deactivate(),
                this.unload()),
                this._splitFailed = !0,
                this._children = [],
                void (this._transitioning = !1)
            }
            for (let t = 0; t < e.length; t++) {
                e[t]._shouldBeVisible = !0
            }
            this._activated && (this._shouldBeVisible = !1,
            this.deactivate(),
            this._activated = !1),
            this._loaded && (this.unload(),
            this._loaded = !1);
            for (let e = 0; e < t.length; e++)
                t[e]._transitioning = !1;
            this._transitioning = !1
        }
        async _join() {
            const t = [];
            this._getDescendentTiles(t);
            for (let e = 0; e < t.length; e++)
                if (t[e]._transitioning)
                    return;
            const e = [];
            for (let i = 0; i < t.length; i++) {
                const s = t[i];
                s._activated && e.push(s),
                s._transitioning = !0
            }
            this._transitioning = !0;
            try {
                await this.load(),
                this._loaded = !0,
                await this.activate(),
                this._activated = !0,
                this._shouldBeVisible = !0
            } catch (i) {
                if (i instanceof Error && console.log(i.message),
                this._destroyed)
                    for (let t = 0; t < e.length; t++) {
                        const i = e[t];
                        i._shouldBeVisible = !1,
                        i.deactivate(),
                        i.unload()
                    }
                else {
                    for (let e = 0; e < t.length; e++) {
                        t[e]._transitioning = !1
                    }
                    this._transitioning = !1
                }
                return this._activated && this.deactivate(),
                void (this._loaded && this.unload())
            }
            for (let t = 0; t < e.length; t++) {
                const i = e[t];
                i._shouldBeVisible = !1,
                i.deactivate(),
                i.unload()
            }
            if (this._destroyed)
                return this._shouldBeVisible = !1,
                this.deactivate(),
                void this.unload();
            this._children = [],
            this._transitioning = !1
        }
        _splitAndGetNeedingLoad(t, e, i=0) {
            for (let s = 0; s < 2; s++)
                for (let n = 0; n < 2; n++) {
                    const o = this.createNewTile(this, s, n);
                    null !== o && (this._children.push(o),
                    i < 3 && o.checkSplit() ? o._splitAndGetNeedingLoad(t, e, i + 1) : e.push(o),
                    t.push(o))
                }
        }
        _getDescendentTiles(t) {
            for (let e = 0; e < this._children.length; e++) {
                const i = this._children[e];
                t.push(i),
                i._getDescendentTiles(t)
            }
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        TimeUtils: function() {
            return TimeUtils
        }
    });
    class TimeUtils {
        static now() {
            return TimeUtils.unixToEt(Date.now() / 1e3)
        }
        static etToUnix(t) {
            let e = 0;
            for (let i = 0; i < TimeUtils.leapSeconds.length; i++)
                t + 946727957.816 + e >= TimeUtils.leapSeconds[i] + 1 && (e -= 1);
            return t + 946727957.816 + e
        }
        static unixToEt(t) {
            let e = 0;
            for (let i = 0; i < TimeUtils.leapSeconds.length; i++)
                t >= TimeUtils.leapSeconds[i] + 1 && (e += 1);
            return t - 946727957.816 + e
        }
        static leapSeconds = [Date.UTC(1972, 5, 30, 23, 59, 59) / 1e3, Date.UTC(1972, 11, 31, 23, 59, 59) / 1e3, Date.UTC(1973, 11, 31, 23, 59, 59) / 1e3, Date.UTC(1974, 11, 31, 23, 59, 59) / 1e3, Date.UTC(1975, 11, 31, 23, 59, 59) / 1e3, Date.UTC(1976, 11, 31, 23, 59, 59) / 1e3, Date.UTC(1977, 11, 31, 23, 59, 59) / 1e3, Date.UTC(1978, 11, 31, 23, 59, 59) / 1e3, Date.UTC(1979, 11, 31, 23, 59, 59) / 1e3, Date.UTC(1981, 5, 30, 23, 59, 59) / 1e3, Date.UTC(1982, 5, 30, 23, 59, 59) / 1e3, Date.UTC(1983, 5, 30, 23, 59, 59) / 1e3, Date.UTC(1985, 5, 30, 23, 59, 59) / 1e3, Date.UTC(1987, 11, 31, 23, 59, 59) / 1e3, Date.UTC(1989, 11, 31, 23, 59, 59) / 1e3, Date.UTC(1990, 11, 31, 23, 59, 59) / 1e3, Date.UTC(1992, 5, 30, 23, 59, 59) / 1e3, Date.UTC(1993, 5, 30, 23, 59, 59) / 1e3, Date.UTC(1994, 5, 30, 23, 59, 59) / 1e3, Date.UTC(1995, 11, 31, 23, 59, 59) / 1e3, Date.UTC(1997, 5, 30, 23, 59, 59) / 1e3, Date.UTC(1998, 11, 31, 23, 59, 59) / 1e3, Date.UTC(2005, 11, 31, 23, 59, 59) / 1e3, Date.UTC(2008, 11, 31, 23, 59, 59) / 1e3, Date.UTC(2012, 5, 30, 23, 59, 59) / 1e3, Date.UTC(2015, 5, 30, 23, 59, 59) / 1e3, Date.UTC(2016, 11, 31, 23, 59, 59) / 1e3]
    }
}
, function(t, e, i) {
    "use strict";
    function s(t, e, i) {
        return new Promise(( (s, n) => {
            let o = 0;
            const a = setInterval(( () => {
                try {
                    t() && (clearInterval(a),
                    s(void 0))
                } catch (t) {
                    return clearInterval(a),
                    void n(t)
                }
                o += e,
                o >= i && (clearInterval(a),
                n(new Error(`Timed out after ${i} seconds.`)))
            }
            ), 1e3 * e)
        }
        ))
    }
    i.r(e),
    i.d(e, {
        waitUntil: function() {
            return s
        }
    })
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        AER: function() {
            return AER
        }
    });
    var s = i(6);
    class AER extends s.Freezable {
        static get pool() {
            return AER._pool
        }
        constructor(t=0, e=0, i=0, s=!1) {
            super(s),
            this._azimuth = t,
            this._elevation = e,
            this._range = i
        }
        get azimuth() {
            return this._azimuth
        }
        set azimuth(t) {
            this.throwIfFrozen(),
            this._azimuth = t
        }
        get elevation() {
            return this._elevation
        }
        set elevation(t) {
            this.throwIfFrozen(),
            this._elevation = t
        }
        get range() {
            return this._range
        }
        set range(t) {
            this.throwIfFrozen(),
            this._range = t
        }
        toString(t=!1) {
            return t ? `[${s.MathUtils.radToDeg(this._azimuth)}, ${s.MathUtils.radToDeg(this._elevation)}, ${this._range}]` : `[${this._azimuth}, ${this._elevation}, ${this._range}]`
        }
        copy(t) {
            this.throwIfFrozen(),
            this._azimuth = t._azimuth,
            this._elevation = t._elevation,
            this._range = t._range
        }
        set(t, e, i) {
            this.throwIfFrozen(),
            this._azimuth = t,
            this._elevation = e,
            this._range = i
        }
        setFromVector(t) {
            this.throwIfFrozen(),
            this._range = t.magnitude(),
            this._elevation = Math.asin(t.z / this._range),
            this._azimuth = Math.atan2(t.y, t.x)
        }
        static _pool = new s.Pool(AER)
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        Color: function() {
            return Color
        }
    });
    var s = i(6);
    class Color extends s.Freezable {
        static get pool() {
            return Color._pool
        }
        static get Black() {
            return Color._black
        }
        static get Clear() {
            return Color._clear
        }
        constructor(t=1, e=1, i=1, s=1, n=!1) {
            super(n),
            this._r = t,
            this._g = e,
            this._b = i,
            this._a = s
        }
        get r() {
            return this._r
        }
        set r(t) {
            this.throwIfFrozen(),
            this._r = t
        }
        get g() {
            return this._g
        }
        set g(t) {
            this.throwIfFrozen(),
            this._g = t
        }
        get b() {
            return this._b
        }
        set b(t) {
            this.throwIfFrozen(),
            this._b = t
        }
        get a() {
            return this._a
        }
        set a(t) {
            this.throwIfFrozen(),
            this._a = t
        }
        toString() {
            return `[${this._r}, ${this._g}, ${this._b}, ${this._a}]`
        }
        copy(t) {
            this.throwIfFrozen(),
            this._r = t._r,
            this._g = t._g,
            this._b = t._b,
            this._a = t._a
        }
        set(t, e, i, s=1) {
            this.throwIfFrozen(),
            this._r = t,
            this._g = e,
            this._b = i,
            this._a = s
        }
        add(t, e) {
            this.throwIfFrozen(),
            this._r = t._r + e._r,
            this._g = t._g + e._g,
            this._b = t._b + e._b,
            this._a = t._a + e._a
        }
        sub(t, e) {
            this.throwIfFrozen(),
            this._r = t._r - e._r,
            this._g = t._g - e._g,
            this._b = t._b - e._b,
            this._a = t._a - e._a
        }
        mult(t, e) {
            this.throwIfFrozen(),
            this._r = t._r * e,
            this._g = t._g * e,
            this._b = t._b * e,
            this._a = t._a * e
        }
        addMult(t, e, i) {
            this.throwIfFrozen(),
            this._r = t._r + e._r * i,
            this._g = t._g + e._g * i,
            this._b = t._b + e._b * i,
            this._a = t._a + e._a * i
        }
        div(t, e) {
            this.throwIfFrozen(),
            this._r = t._r / e,
            this._g = t._g / e,
            this._b = t._b / e,
            this._a = t._a / e
        }
        scale(t, e) {
            this.throwIfFrozen(),
            this._r = t._r * e._r,
            this._g = t._g * e._g,
            this._b = t._b * e._b,
            this._a = t._a * e._a
        }
        value() {
            return (this._r + this._g + this._b) / 3
        }
        min() {
            return Math.min(this._r, this._g, this._b)
        }
        max() {
            return Math.max(this._r, this._g, this._b)
        }
        lerp(t, e, i) {
            this.throwIfFrozen(),
            this._r = s.MathUtils.lerp(t._r, e._r, i),
            this._g = s.MathUtils.lerp(t._g, e._g, i),
            this._b = s.MathUtils.lerp(t._b, e._b, i),
            this._a = s.MathUtils.lerp(t._a, e._a, i)
        }
        static _pool = new s.Pool(Color);
        static _black = new Color(0,0,0,1,!0);
        static _clear = new Color(0,0,0,1,!0)
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        FastMapEntry: function() {
            return FastMapEntry
        },
        FastMap: function() {
            return FastMap
        }
    });
    var s = i(6);
    class FastMapEntry {
        constructor(t, e) {
            this.key = t,
            this.value = e
        }
    }
    class FastMap extends s.FastIterable {
        constructor(t) {
            if (super(),
            this._entries = [],
            this._keyMap = new Map,
            void 0 !== t)
                for (const e of t)
                    this._entries.push(new FastMapEntry(e.key,e.value)),
                    this._keyMap.set(e.key, this._entries.length - 1)
        }
        has(t) {
            return this._keyMap.has(t)
        }
        get(t) {
            const e = this._keyMap.get(t);
            if (void 0 !== e)
                return this._entries[e].value
        }
        set(t, e) {
            const i = this._keyMap.get(t);
            void 0 !== i ? this._entries[i].value = e : (this._entries.push(new FastMapEntry(t,e)),
            this._keyMap.set(t, this._entries.length - 1))
        }
        delete(t) {
            const e = this._keyMap.get(t);
            if (void 0 !== e) {
                this._entries.splice(e, 1),
                this._keyMap.delete(t);
                for (const t of this._keyMap)
                    t[1] > e && this._keyMap.set(t[0], t[1] - 1);
                return !0
            }
            return !1
        }
        clear() {
            this._entries = [],
            this._keyMap.clear()
        }
        getAt(t) {
            return this._entries[t]
        }
        getSize() {
            return this._entries.length
        }
        sort(t) {
            s.Sort.sort(this._entries, ( (e, i) => t(e.value, i.value)), ( (t, e) => {
                this._keyMap.set(this._entries[t].key, t),
                this._keyMap.set(this._entries[e].key, e)
            }
            ))
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        FastSet: function() {
            return FastSet
        }
    });
    var s = i(6);
    class FastSet extends s.FastIterable {
        constructor(t) {
            if (super(),
            this._values = [],
            this._valueMap = new Map,
            void 0 !== t)
                for (const e of t)
                    this._values.push(e),
                    this._valueMap.set(e, this._values.length - 1)
        }
        has(t) {
            return this._valueMap.has(t)
        }
        add(t) {
            return void 0 === this._valueMap.get(t) && (this._values.push(t),
            this._valueMap.set(t, this._values.length - 1)),
            this
        }
        delete(t) {
            const e = this._valueMap.get(t);
            if (void 0 !== e) {
                this._values.splice(e, 1),
                this._valueMap.delete(t);
                for (const t of this._valueMap)
                    t[1] > e && this._valueMap.set(t[0], t[1] - 1);
                return !0
            }
            return !1
        }
        clear() {
            this._values = [],
            this._valueMap.clear()
        }
        getAt(t) {
            return this._values[t]
        }
        getSize() {
            return this._values.length
        }
        sort(t) {
            s.Sort.sort(this._values, ( (e, i) => t(e, i)), ( (t, e) => {
                this._valueMap.set(this._values[t], t),
                this._valueMap.set(this._values[e], e)
            }
            ))
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        Geometry: function() {
            return Geometry
        }
    });
    i(6);
    class Geometry {
        static getLineSphereIntersectionWithSphereAtOrigin(t, e, i) {
            const s = t.dot(t)
              , n = t.dot(e)
              , o = e.dot(e)
              , a = n * n + (i * i - s) * o;
            return a < 0 ? Number.NaN : (-n - Math.sqrt(a)) / o
        }
        static getLineSphereIntersectionWithLineStartAtOrigin(t, e, i, s) {
            const n = e.dot(e)
              , o = e.dot(i)
              , a = o * o + (s * s - i.dot(i)) * n;
            if (a < 0)
                t.min = Number.NaN,
                t.max = Number.NaN;
            else {
                const e = Math.sqrt(a);
                t.min = (o - e) / n,
                t.max = (o + e) / n
            }
        }
        static getLLAFromXYZOnSphere(t, e, i) {
            const s = e.magnitudeXY();
            t.lon = Math.atan2(e.y, e.x),
            t.lat = Math.atan(e.z / s),
            t.alt = e.magnitude() - i
        }
        static getXYZFromLLAOnSphere(t, e, i) {
            t.x = (i + e.alt) * Math.cos(e.lat) * Math.cos(e.lon),
            t.y = (i + e.alt) * Math.cos(e.lat) * Math.sin(e.lon),
            t.z = (i + e.alt) * Math.sin(e.lat)
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        Interval: function() {
            return Interval
        }
    });
    var s = i(6);
    class Interval extends s.Freezable {
        static get pool() {
            return Interval._pool
        }
        static get Infinite() {
            return Interval._infinite
        }
        constructor(t=0, e=0, i=!1) {
            super(i),
            this._min = t,
            this._max = e
        }
        get min() {
            return this._min
        }
        set min(t) {
            this.throwIfFrozen(),
            this._min = t
        }
        get max() {
            return this._max
        }
        set max(t) {
            this.throwIfFrozen(),
            this._max = t
        }
        toString() {
            return `[${this._min}, ${this._max}]`
        }
        isNaN() {
            return this._min != this._min || this._max != this._max
        }
        copy(t) {
            this.throwIfFrozen(),
            this._min = t._min,
            this._max = t._max
        }
        set(t, e) {
            this.throwIfFrozen(),
            this._min = t,
            this._max = e
        }
        length() {
            return this._max - this._min
        }
        clamp(t) {
            return Math.min(Math.max(this._min, t), this._max)
        }
        expandTo(t) {
            this.throwIfFrozen(),
            this._min = Math.min(this._min, t),
            this._max = Math.max(this._max, t)
        }
        contains(t) {
            return this._min <= t && t < this._max
        }
        intersects(t) {
            return this._min < t._max && t._min < this._max
        }
        intersection(t, e) {
            this.throwIfFrozen(),
            this._min = Math.max(t._min, e._min),
            this._max = Math.min(t._max, e._max),
            this._max < this._min && (this._max = this._min)
        }
        union(t, e) {
            this.throwIfFrozen(),
            this._min = Math.min(t._min, e._min),
            this._max = Math.max(t._max, e._max)
        }
        static _pool = new s.Pool(Interval);
        static _infinite = new Interval(Number.NEGATIVE_INFINITY,Number.POSITIVE_INFINITY,!0)
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        OrbitalElements: function() {
            return OrbitalElements
        }
    });
    var s = i(6);
    class OrbitalElements {
        constructor() {
            this.epoch = 0,
            this.eccentricity = 0,
            this.semiMajorAxis = 0,
            this.meanAngularMotion = 0,
            this.meanAnomalyAtEpoch = 0,
            this.orbitOrientation = new s.Quaternion
        }
        copy(t) {
            this.epoch = t.epoch,
            this.eccentricity = t.eccentricity,
            this.semiMajorAxis = t.semiMajorAxis,
            this.meanAnomalyAtEpoch = t.meanAnomalyAtEpoch,
            this.meanAngularMotion = t.meanAngularMotion,
            this.orbitOrientation.copy(t.orbitOrientation)
        }
        projectFromMeanAnomaly(t, e, i) {
            if (this.eccentricity < 1) {
                const s = this.getEccentricAnomalyFromMeanAnomaly(i)
                  , n = this.semiMajorAxis * (1 - this.eccentricity * Math.cos(s))
                  , o = this.meanAngularMotion * this.semiMajorAxis * this.semiMajorAxis / n;
                t.x = this.semiMajorAxis * (Math.cos(s) - this.eccentricity),
                t.y = this.semiMajorAxis * Math.sqrt(1 - this.eccentricity * this.eccentricity) * Math.sin(s),
                e.x = -o * Math.sin(s),
                e.y = o * Math.sqrt(1 - this.eccentricity * this.eccentricity) * Math.cos(s)
            } else {
                const s = this.getEccentricAnomalyFromMeanAnomaly(i)
                  , n = -this.semiMajorAxis * (1 - this.eccentricity * Math.cosh(s))
                  , o = this.meanAngularMotion * this.semiMajorAxis * this.semiMajorAxis / n;
                t.x = this.semiMajorAxis * (this.eccentricity - Math.cosh(s)),
                t.y = this.semiMajorAxis * Math.sqrt(this.eccentricity * this.eccentricity - 1) * Math.sinh(s),
                e.x = -o * Math.sinh(s),
                e.y = o * Math.sqrt(this.eccentricity * this.eccentricity - 1) * Math.cosh(s)
            }
            t.z = 0,
            e.z = 0,
            t.rotate(this.orbitOrientation, t),
            e.rotate(this.orbitOrientation, e)
        }
        project(t, e, i) {
            let n = this.meanAnomalyAtEpoch + this.meanAngularMotion * (i - this.epoch);
            this.eccentricity < 1 && (n = s.MathUtils.wrap(n, -s.MathUtils.pi, +s.MathUtils.pi)),
            this.projectFromMeanAnomaly(t, e, n)
        }
        getTrueAnomalyFromPosition(t) {
            const e = s.Vector3.pool.get();
            e.rotateInverse(this.orbitOrientation, t);
            const i = Math.atan2(e.y, e.x);
            return s.Vector3.pool.release(e),
            i
        }
        getMeanAnomalyFromTrueAnomaly(t) {
            let e;
            if (this.eccentricity < 1) {
                const i = 2 * Math.atan(Math.tan(t / 2) * Math.sqrt((1 - this.eccentricity) / (1 + this.eccentricity)));
                e = i - this.eccentricity * Math.sin(i)
            } else {
                const i = 2 * Math.atanh(Math.tan(t / 2) * Math.sqrt((this.eccentricity - 1) / (1 + this.eccentricity)));
                e = this.eccentricity * Math.sinh(i) - i
            }
            return e
        }
        getEccentricAnomalyFromMeanAnomaly(t) {
            if (this.eccentricity < 1) {
                let e = t;
                this.eccentricity >= .8 && (e = Math.sign(t) * s.MathUtils.pi);
                for (let i = 0; i < 20; i++) {
                    const i = (e - this.eccentricity * Math.sin(e) - t) / (this.eccentricity * Math.cos(e) - 1);
                    if (e += i,
                    Math.abs(i) < .00174532925)
                        break
                }
                return e
            }
            let e = Math.log(2 * Math.abs(t) / Math.E + 1.8);
            this.eccentricity <= 1.2 && (e = Math.log(2 * Math.abs(t) / Math.E + 1.8)),
            t < 0 && (e *= -1);
            for (let i = 0; i < 20; i++) {
                const i = (e - this.eccentricity * Math.sinh(e) + t) / (this.eccentricity * Math.cosh(e) - 1);
                if (e += i,
                Math.abs(i) < .00174532925)
                    break
            }
            return e
        }
        getMeanAnomalyFromEccentricAnomaly(t) {
            if (this.eccentricity < 1) {
                const e = t - this.eccentricity * Math.sin(t);
                return s.MathUtils.wrap(e, -Math.PI, +Math.PI)
            }
            return this.eccentricity * Math.sinh(t) - t
        }
        getTrueAnomalyFromEccentricAnomaly(t) {
            return this.eccentricity < 1 ? 2 * Math.atan(Math.sqrt((1 + this.eccentricity) / (1 - this.eccentricity)) * Math.tan(t / 2)) : 2 * Math.atan(Math.sqrt((1 + this.eccentricity) / (this.eccentricity - 1)) * Math.tanh(t / 2))
        }
        getEccentricAnomalyFromTrueAnomaly(t) {
            if (this.eccentricity < 1) {
                const e = 2 * Math.atan2(Math.tan(t / 2), Math.sqrt((1 + this.eccentricity) / (1 - this.eccentricity)));
                return s.MathUtils.wrap(e, -Math.PI, +Math.PI)
            }
            return 2 * Math.atanh(Math.sqrt((this.eccentricity - 1) / (this.eccentricity + 1)) * Math.tan(t / 2))
        }
        getInclination() {
            const t = s.Vector3.pool.get();
            this.orbitOrientation.getAxis(t, 2);
            const e = t.angle(s.Vector3.ZAxis);
            return s.Vector3.pool.release(t),
            e
        }
        getLongitudeOfAscendingNode() {
            const t = s.Vector3.pool.get();
            this.orbitOrientation.getAxis(t, 2);
            const e = Math.atan2(t.x, -t.y);
            return s.Vector3.pool.release(t),
            s.MathUtils.wrap(e, 0, s.MathUtils.twoPi)
        }
        getArgumentOfPeriapsis() {
            const t = s.Vector3.pool.get()
              , e = s.Vector3.pool.get();
            this.orbitOrientation.getAxis(t, 2),
            t.set(-t.y, t.x, 0),
            this.orbitOrientation.getAxis(e, 0);
            const i = t.angle(e);
            return s.Vector3.pool.release(e),
            s.Vector3.pool.release(t),
            s.MathUtils.wrap(i, 0, s.MathUtils.twoPi)
        }
        getPeriod() {
            return s.MathUtils.twoPi / this.meanAngularMotion
        }
        getPeriapsis() {
            return this.semiMajorAxis * (1 - this.eccentricity)
        }
        getApoapsis() {
            return this.semiMajorAxis * (1 + this.eccentricity)
        }
        setOrbitOrientationFromElements(t, e, i) {
            const n = s.Vector3.pool.get()
              , o = s.Vector3.pool.get()
              , a = s.Quaternion.pool.get();
            n.set(Math.cos(e), Math.sin(e), 0),
            o.set(Math.sin(e) * Math.sin(t), -Math.cos(e) * Math.sin(t), Math.cos(t)),
            this.orbitOrientation.setFromAxes(n, void 0, o),
            a.setFromAxisAngle(o, i),
            this.orbitOrientation.mult(a, this.orbitOrientation),
            s.Quaternion.pool.release(a),
            s.Vector3.pool.release(o),
            s.Vector3.pool.release(n)
        }
        setFromPositionAndVelocity(t, e, i, n) {
            const o = 1 / n;
            this.epoch = i;
            const a = s.Vector3.pool.get();
            a.cross(t, e);
            const r = s.Vector3.pool.get()
              , l = s.Vector3.pool.get();
            l.normalize(t),
            r.cross(e, a),
            r.mult(r, o),
            r.sub(r, l),
            this.eccentricity = r.magnitude();
            const c = a.dot(a) * o;
            this.semiMajorAxis = c / (1 - this.eccentricity * this.eccentricity),
            this.eccentricity > 1 && (this.semiMajorAxis *= -1);
            let h = Math.acos(s.MathUtils.clamp(r.dot(l) / this.eccentricity, -1, 1));
            t.dot(e) < 0 && (h *= -1),
            h < -Math.PI && (h += s.MathUtils.twoPi),
            h >= Math.PI && (h -= s.MathUtils.twoPi),
            r.normalize(r),
            a.normalize(a),
            this.orbitOrientation.setFromAxes(r, void 0, a),
            s.Vector3.pool.release(l),
            s.Vector3.pool.release(a),
            s.Vector3.pool.release(r);
            const d = this.getEccentricAnomalyFromTrueAnomaly(h);
            this.meanAnomalyAtEpoch = this.getMeanAnomalyFromEccentricAnomaly(d),
            this.meanAngularMotion = Math.sqrt(n / (this.semiMajorAxis * this.semiMajorAxis * this.semiMajorAxis))
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        Rect: function() {
            return Rect
        }
    });
    var s = i(6);
    class Rect extends s.Freezable {
        static get pool() {
            return Rect._pool
        }
        constructor(t=0, e=0, i=0, n=0, o=!1) {
            super(o),
            this._origin = new s.Vector2(t,e),
            this._size = new s.Vector2(i,n)
        }
        freeze() {
            this._origin.freeze(),
            this._size.freeze()
        }
        thaw() {
            this._origin.thaw(),
            this._size.thaw()
        }
        get origin() {
            return this._origin
        }
        get size() {
            return this._size
        }
        toString() {
            return `[Origin: (${this._origin.x}, ${this._origin.y}), Size: (${this._size.x}, ${this._size.y})]`
        }
        copy(t) {
            this._origin.copy(t._origin),
            this._size.copy(t._size)
        }
        set(t, e, i, s) {
            this._origin.set(t, e),
            this._size.set(i, s)
        }
        contains(t) {
            return this._origin.x <= t.x && t.x < this._origin.x + this._size.x && this._origin.y <= t.y && t.y < this._origin.y + this._size.y
        }
        intersects(t) {
            return this._origin.x + this._size.x > t._origin.x && t._origin.x + t._size.x > this._origin.x && this._origin.y + this._size.y > t._origin.y && t._origin.y + t._size.y > this._origin.y
        }
        surrounds(t) {
            return this._origin.x <= t._origin.x && this._origin.x + this._size.x >= t.origin.x + t.size.x && this._origin.y <= t._origin.y && this._origin.y + this._size.y >= t.origin.y + t.size.y
        }
        static _pool = new s.Pool(Rect)
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        Quaternion: function() {
            return Quaternion
        }
    });
    var s = i(6);
    class Quaternion extends s.Freezable {
        static get pool() {
            return Quaternion._pool
        }
        static get threeJsPool() {
            return Quaternion._threeJsPool
        }
        static get NaN() {
            return Quaternion._nan
        }
        static get Identity() {
            return Quaternion._identity
        }
        static fromAxisAngle(t, e) {
            const i = new Quaternion;
            return i.setFromAxisAngle(t, e),
            i
        }
        static fromAxes(t, e, i) {
            const s = new Quaternion;
            return s.setFromAxes(t, e, i),
            s
        }
        static fromEuler(t, e, i) {
            const s = new Quaternion;
            return s.setFromEuler(t, e, i),
            s
        }
        static fromVectorFromTo(t, e) {
            const i = new Quaternion;
            return i.setFromVectorFromTo(t, e),
            i
        }
        static fromFromAxis(t, e) {
            const i = new Quaternion;
            return i.setFromAxis(t, e),
            i
        }
        constructor(t=1, e=0, i=0, s=0, n=!1) {
            super(n),
            this._w = t,
            this._x = e,
            this._y = i,
            this._z = s
        }
        get w() {
            return this._w
        }
        set w(t) {
            this.throwIfFrozen(),
            this._w = t
        }
        get x() {
            return this._x
        }
        set x(t) {
            this.throwIfFrozen(),
            this._x = t
        }
        get y() {
            return this._y
        }
        set y(t) {
            this.throwIfFrozen(),
            this._y = t
        }
        get z() {
            return this._z
        }
        set z(t) {
            this.throwIfFrozen(),
            this._z = t
        }
        getAngle() {
            return 2 * Math.acos(this._w)
        }
        copy(t) {
            this.throwIfFrozen(),
            this._w = t._w,
            this._x = t._x,
            this._y = t._y,
            this._z = t._z
        }
        copyFromThreeJs(t) {
            this.throwIfFrozen(),
            this._w = t.w,
            this._x = t.x,
            this._y = t.y,
            this._z = t.z
        }
        set(t, e, i, s) {
            this.throwIfFrozen(),
            this._w = t,
            this._x = e,
            this._y = i,
            this._z = s
        }
        setFromAxisAngle(t, e) {
            this.throwIfFrozen();
            const i = Math.sin(e / 2);
            this._w = Math.cos(e / 2),
            this._x = i * t.x,
            this._y = i * t.y,
            this._z = i * t.z
        }
        setFromAxes(t, e, i) {
            let n;
            if (this.throwIfFrozen(),
            !t && e && i)
                n = t = s.Vector3.pool.get(),
                t.cross(e, i);
            else if (!e && i && t)
                n = e = s.Vector3.pool.get(),
                e.cross(i, t);
            else {
                if (i || !t || !e)
                    throw new Error("At least two of xAxis, yAxis, and zAxis must be defined");
                n = i = s.Vector3.pool.get(),
                i.cross(t, e)
            }
            const o = t.x + e.y + i.z;
            if (o > 0) {
                const s = 2 * Math.sqrt(o + 1);
                this._w = .25 * s,
                this._x = (e.z - i.y) / s,
                this._y = (i.x - t.z) / s,
                this._z = (t.y - e.x) / s
            } else if (t.x > e.y && t.x > i.z) {
                const s = 2 * Math.sqrt(1 + t.x - e.y - i.z);
                this._w = (e.z - i.y) / s,
                this._x = .25 * s,
                this._y = (e.x + t.y) / s,
                this._z = (i.x + t.z) / s
            } else if (e.y > i.z) {
                const s = 2 * Math.sqrt(1 + e.y - i.z - t.x);
                this._w = (i.x - t.z) / s,
                this._x = (e.x + t.y) / s,
                this._y = .25 * s,
                this._z = (i.y + e.z) / s
            } else {
                const s = 2 * Math.sqrt(1 + i.z - t.x - e.y);
                this._w = (t.y - e.x) / s,
                this._x = (i.x + t.z) / s,
                this._y = (i.y + e.z) / s,
                this._z = .25 * s
            }
            s.Vector3.pool.release(n)
        }
        setFromEuler(t, e, i) {
            this.throwIfFrozen();
            const s = .5 * t
              , n = .5 * e
              , o = .5 * i
              , a = Math.cos(s)
              , r = Math.sin(s)
              , l = Math.cos(n)
              , c = Math.sin(n)
              , h = Math.cos(o)
              , d = Math.sin(o);
            this._w = a * l * h + r * c * d,
            this._x = r * l * h - a * c * d,
            this._y = a * c * h + r * l * d,
            this._z = a * l * d - r * c * h
        }
        setFromVectorFromTo(t, e) {
            const i = s.Vector3.pool.get()
              , n = t.dot(e);
            if (n >= 1)
                this.set(1, 0, 0, 0);
            else if (n <= -1)
                this.set(0, 1, 0, 0);
            else {
                i.cross(t, e),
                i.normalize(i);
                const s = Math.acos(n);
                this.setFromAxisAngle(i, s)
            }
            s.Vector3.pool.release(i)
        }
        setFromAxis(t, e) {
            const i = s.Vector3.pool.get()
              , n = s.Vector3.pool.get();
            i.normalize(t),
            n.cross(i, s.Vector3.XAxis),
            n.isZero() && n.cross(i, s.Vector3.YAxis),
            n.normalize(n),
            0 === e ? this.setFromAxes(i, n, void 0) : 1 === e ? this.setFromAxes(void 0, i, n) : 2 === e && this.setFromAxes(n, void 0, i),
            s.Vector3.pool.release(i),
            s.Vector3.pool.release(n)
        }
        toString() {
            return `[${this._w}, ${this._x}, ${this._y}, ${this._z}]`
        }
        isNaN() {
            return this._w != this._w || this._x != this._x || this._y != this._y || this._z != this._z
        }
        magnitude() {
            return Math.sqrt(this._w * this._w + this._x * this._x + this._y * this._y + this._z * this._z)
        }
        normalize(t) {
            this.throwIfFrozen();
            const e = t.magnitude();
            e > 0 && (this._w = t._w / e,
            this._x = t._x / e,
            this._y = t._y / e,
            this._z = t._z / e)
        }
        inverse(t) {
            this.throwIfFrozen(),
            this._w = t._w,
            this._x = -t._x,
            this._y = -t._y,
            this._z = -t._z
        }
        mult(t, e) {
            this.throwIfFrozen();
            const i = Quaternion.pool.get();
            i._w = t._w * e._w - t._x * e._x - t._y * e._y - t._z * e._z,
            i._x = t._w * e._x + t._x * e._w + t._y * e._z - t._z * e._y,
            i._y = t._w * e._y - t._x * e._z + t._y * e._w + t._z * e._x,
            i._z = t._w * e._z + t._x * e._y - t._y * e._x + t._z * e._w,
            this.copy(i),
            Quaternion.pool.release(i)
        }
        multInverseL(t, e) {
            this.throwIfFrozen();
            const i = Quaternion.pool.get();
            i._w = t._w * e._w + t._x * e._x + t._y * e._y + t._z * e._z,
            i._x = t._w * e._x - t._x * e._w - t._y * e._z + t._z * e._y,
            i._y = t._w * e._y + t._x * e._z - t._y * e._w - t._z * e._x,
            i._z = t._w * e._z - t._x * e._y + t._y * e._x - t._z * e._w,
            this.copy(i),
            Quaternion.pool.release(i)
        }
        multInverseR(t, e) {
            this.throwIfFrozen();
            const i = Quaternion.pool.get();
            i._w = +t._w * e._w + t._x * e._x + t._y * e._y + t._z * e._z,
            i._x = -t._w * e._x + t._x * e._w - t._y * e._z + t._z * e._y,
            i._y = -t._w * e._y + t._x * e._z + t._y * e._w - t._z * e._x,
            i._z = -t._w * e._z - t._x * e._y + t._y * e._x + t._z * e._w,
            this.copy(i),
            Quaternion.pool.release(i)
        }
        scaleAngle(t, e) {
            this.throwIfFrozen();
            const i = Math.acos(t._w)
              , s = Math.sin(i);
            if (0 === s)
                return void this.copy(t);
            const n = Math.sin(i * e);
            this._w = Math.cos(i * e),
            this._x = t._x / s * n,
            this._y = t._y / s * n,
            this._z = t._z / s * n
        }
        angle(t) {
            return 2 * Math.acos(this._w * t._w + this._x * t._x + this._y * t._y + this._z * t._z)
        }
        slerp(t, e, i) {
            this.throwIfFrozen();
            let s = t._w * e._w + t._x * e._x + t._y * e._y + t._z * e._z
              , n = 1;
            if (s < 0 && (n = -1,
            s = -s),
            s <= .9995) {
                const o = Math.acos(s)
                  , a = n * Math.sin((1 - i) * o) / Math.sin(o)
                  , r = Math.sin(i * o) / Math.sin(o);
                this._w = a * t._w + r * e._w,
                this._x = a * t._x + r * e._x,
                this._y = a * t._y + r * e._y,
                this._z = a * t._z + r * e._z
            } else {
                const s = n * (1 - i)
                  , o = i;
                this._w = s * t._w + o * e._w,
                this._x = s * t._x + o * e._x,
                this._y = s * t._y + o * e._y,
                this._z = s * t._z + o * e._z,
                this.normalize(this)
            }
        }
        getAxis(t, e) {
            void 0 === e ? (t.set(this._x, this._y, this._z),
            t.normalize(t)) : 0 === e ? (t.x = this._w * this._w + this._x * this._x - this._y * this._y - this._z * this._z,
            t.y = 2 * this._w * this._z + 2 * this._x * this._y,
            t.z = 2 * this._x * this._z - 2 * this._w * this._y) : 1 === e ? (t.x = 2 * this._y * this._x - 2 * this._w * this._z,
            t.y = this._w * this._w - this._x * this._x + this._y * this._y - this._z * this._z,
            t.z = 2 * this._x * this._w + 2 * this._y * this._z) : 2 === e && (t.x = 2 * this._y * this._w + 2 * this._z * this._x,
            t.y = 2 * this._z * this._y - 2 * this._w * this._x,
            t.z = this._w * this._w - this._x * this._x - this._y * this._y + this._z * this._z)
        }
        static _pool = new s.Pool(Quaternion);
        static _threeJsPool = new s.Pool(s.THREE.Quaternion);
        static _identity = new Quaternion(1,0,0,0,!0);
        static _nan = new Quaternion(Number.NaN,Number.NaN,Number.NaN,Number.NaN,!0)
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        Vector2: function() {
            return Vector2
        }
    });
    var s = i(6);
    class Vector2 extends s.Freezable {
        static get pool() {
            return Vector2._pool
        }
        static get threeJsPool() {
            return Vector2._threeJsPool
        }
        static get NaN() {
            return Vector2._nan
        }
        static get Zero() {
            return Vector2._zero
        }
        static get XAxis() {
            return Vector2._xAxis
        }
        static get YAxis() {
            return Vector2._yAxis
        }
        constructor(t=0, e=0, i=!1) {
            super(i),
            this._x = t,
            this._y = e
        }
        get x() {
            return this._x
        }
        set x(t) {
            this.throwIfFrozen(),
            this._x = t
        }
        get y() {
            return this._y
        }
        set y(t) {
            this.throwIfFrozen(),
            this._y = t
        }
        toString() {
            return `[${this._x}, ${this._y}]`
        }
        equals(t) {
            return this._x === t._x && this._y === t._y
        }
        isZero() {
            return 0 === this._x && 0 === this._y
        }
        isNaN() {
            return this._x != this._x || this._y != this._y
        }
        copy(t) {
            this.throwIfFrozen(),
            this._x = t._x,
            this._y = t._y
        }
        copyFromThreeJs(t) {
            this.throwIfFrozen(),
            this._x = t.x,
            this._y = t.y
        }
        set(t, e) {
            this.throwIfFrozen(),
            this._x = t,
            this._y = e
        }
        neg(t) {
            this.throwIfFrozen(),
            this._x = -t._x,
            this._y = -t._y
        }
        add(t, e) {
            this.throwIfFrozen(),
            this._x = t._x + e._x,
            this._y = t._y + e._y
        }
        sub(t, e) {
            this.throwIfFrozen(),
            this._x = t._x - e._x,
            this._y = t._y - e._y
        }
        mult(t, e) {
            this.throwIfFrozen(),
            this._x = t._x * e,
            this._y = t._y * e
        }
        addMult(t, e, i) {
            this.throwIfFrozen(),
            this._x = t._x + e._x * i,
            this._y = t._y + e._y * i
        }
        div(t, e) {
            this.throwIfFrozen(),
            this._x = t._x / e,
            this._y = t._y / e
        }
        scale(t, e) {
            this.throwIfFrozen(),
            this._x = t._x * e._x,
            this._y = t._y * e._y
        }
        scaleInv(t, e) {
            this.throwIfFrozen(),
            this._x = t._x / e._x,
            this._y = t._y / e._y
        }
        dot(t) {
            return this._x * t._x + this._y * t._y
        }
        cross(t) {
            return this._x * t._y - this._y * t._x
        }
        magnitudeSqr() {
            return this._x * this._x + this._y * this._y
        }
        magnitude() {
            return Math.sqrt(this.magnitudeSqr())
        }
        normalize(t) {
            this.throwIfFrozen();
            const e = t.magnitude();
            e > 0 && (this._x = t._x / e,
            this._y = t._y / e)
        }
        setMagnitude(t, e) {
            this.throwIfFrozen(),
            this.normalize(t),
            this._x *= e,
            this._y *= e
        }
        distance(t) {
            const e = this._x - t._x
              , i = this._y - t._y;
            return Math.sqrt(e * e + i * i)
        }
        angle(t) {
            const e = this.magnitude() * t.magnitude();
            return e > 0 ? Math.acos(s.MathUtils.clamp(this.dot(t) / e, -1, 1)) : Number.NaN
        }
        clamp(t, e, i) {
            this.throwIfFrozen(),
            this._x = s.MathUtils.clamp(t._x, e._x, i._x),
            this._y = s.MathUtils.clamp(t._y, e._y, i._y)
        }
        lerp(t, e, i) {
            this.throwIfFrozen(),
            this._x = s.MathUtils.lerp(t._x, e._x, i),
            this._y = s.MathUtils.lerp(t._y, e._y, i)
        }
        static _pool = new s.Pool(Vector2);
        static _threeJsPool = new s.Pool(s.THREE.Vector2);
        static _zero = new Vector2(0,0,!0);
        static _xAxis = new Vector2(1,0,!0);
        static _yAxis = new Vector2(0,1,!0);
        static _nan = new Vector2(Number.NaN,Number.NaN,!0)
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        Vector3: function() {
            return Vector3
        }
    });
    var s = i(6);
    class Vector3 extends s.Freezable {
        static get pool() {
            return Vector3._pool
        }
        static get threeJsPool() {
            return Vector3._threeJsPool
        }
        static get NaN() {
            return Vector3._nan
        }
        static get Zero() {
            return Vector3._zero
        }
        static get XAxis() {
            return Vector3._xAxis
        }
        static get YAxis() {
            return Vector3._yAxis
        }
        static get ZAxis() {
            return Vector3._zAxis
        }
        static get XAxisNeg() {
            return Vector3._xAxisNeg
        }
        static get YAxisNeg() {
            return Vector3._yAxisNeg
        }
        static get ZAxisNeg() {
            return Vector3._zAxisNeg
        }
        static fromAER(t) {
            const e = new Vector3;
            return e.setFromAER(t),
            e
        }
        constructor(t=0, e=0, i=0, s=!1) {
            super(s),
            this._x = t,
            this._y = e,
            this._z = i
        }
        get x() {
            return this._x
        }
        set x(t) {
            this.throwIfFrozen(),
            this._x = t
        }
        get y() {
            return this._y
        }
        set y(t) {
            this.throwIfFrozen(),
            this._y = t
        }
        get z() {
            return this._z
        }
        set z(t) {
            this.throwIfFrozen(),
            this._z = t
        }
        toString() {
            return `[${this._x}, ${this._y}, ${this._z}]`
        }
        equals(t) {
            return this._x === t._x && this._y === t._y && this._z === t._z
        }
        isZero() {
            return 0 === this._x && 0 === this._y && 0 === this._z
        }
        isNaN() {
            return this._x != this._x || this._y != this._y || this._z != this._z
        }
        copy(t) {
            this.throwIfFrozen(),
            this._x = t._x,
            this._y = t._y,
            this._z = t._z
        }
        copyFromThreeJs(t) {
            this.throwIfFrozen(),
            this._x = t.x,
            this._y = t.y,
            this._z = t.z
        }
        set(t, e, i) {
            this.throwIfFrozen(),
            this._x = t,
            this._y = e,
            this._z = i
        }
        setFromAER(t) {
            this.throwIfFrozen();
            const e = Math.cos(t.elevation);
            this._x = t.range * e * Math.cos(t.azimuth),
            this._y = t.range * e * Math.sin(t.azimuth),
            this._z = t.range * Math.sin(t.elevation)
        }
        neg(t) {
            this.throwIfFrozen(),
            this._x = -t._x,
            this._y = -t._y,
            this._z = -t._z
        }
        add(t, e) {
            this.throwIfFrozen(),
            this._x = t._x + e._x,
            this._y = t._y + e._y,
            this._z = t._z + e._z
        }
        sub(t, e) {
            this.throwIfFrozen(),
            this._x = t._x - e._x,
            this._y = t._y - e._y,
            this._z = t._z - e._z
        }
        mult(t, e) {
            this.throwIfFrozen(),
            this._x = t._x * e,
            this._y = t._y * e,
            this._z = t._z * e
        }
        addMult(t, e, i) {
            this.throwIfFrozen(),
            this._x = t._x + e._x * i,
            this._y = t._y + e._y * i,
            this._z = t._z + e._z * i
        }
        div(t, e) {
            this.throwIfFrozen(),
            this._x = t._x / e,
            this._y = t._y / e,
            this._z = t._z / e
        }
        scale(t, e) {
            this.throwIfFrozen(),
            this._x = t._x * e._x,
            this._y = t._y * e._y,
            this._z = t._z * e._z
        }
        scaleInv(t, e) {
            this.throwIfFrozen(),
            this._x = t._x / e._x,
            this._y = t._y / e._y,
            this._z = t._z / e._z
        }
        dot(t) {
            return this._x * t._x + this._y * t._y + this._z * t._z
        }
        cross(t, e) {
            this.throwIfFrozen();
            const i = t._y * e._z - t._z * e._y
              , s = t._z * e._x - t._x * e._z
              , n = t._x * e._y - t._y * e._x;
            this._x = i,
            this._y = s,
            this._z = n
        }
        magnitudeSqr() {
            return this._x * this._x + this._y * this._y + this._z * this._z
        }
        magnitude() {
            return Math.sqrt(this.magnitudeSqr())
        }
        magnitudeXY() {
            return Math.sqrt(this._x * this._x + this._y * this._y)
        }
        normalize(t) {
            this.throwIfFrozen();
            const e = t.magnitude();
            e > 0 ? (this._x = t._x / e,
            this._y = t._y / e,
            this._z = t._z / e) : this.copy(t)
        }
        setMagnitude(t, e) {
            this.throwIfFrozen(),
            this.normalize(t),
            this._x *= e,
            this._y *= e,
            this._z *= e
        }
        distance(t) {
            const e = this._x - t._x
              , i = this._y - t._y
              , s = this._z - t._z;
            return Math.sqrt(e * e + i * i + s * s)
        }
        angle(t) {
            const e = this.magnitude() * t.magnitude();
            return e > 0 ? Math.acos(s.MathUtils.clamp(this.dot(t) / e, -1, 1)) : Number.NaN
        }
        angleAroundAxis(t, e) {
            const i = Vector3.pool.get()
              , s = Vector3.pool.get();
            i.addMult(this, e, -this.dot(e)),
            s.addMult(t, e, -t.dot(e));
            let n = i.angle(s);
            return i.cross(i, s),
            i.dot(e) < 0 && (n *= -1),
            Vector3.pool.release(i),
            Vector3.pool.release(s),
            n
        }
        clamp(t, e, i) {
            this.throwIfFrozen(),
            this._x = s.MathUtils.clamp(t._x, e._x, i._x),
            this._y = s.MathUtils.clamp(t._y, e._y, i._y),
            this._z = s.MathUtils.clamp(t._z, e._z, i._z)
        }
        lerp(t, e, i) {
            this.throwIfFrozen(),
            this._x = s.MathUtils.lerp(t._x, e._x, i),
            this._y = s.MathUtils.lerp(t._y, e._y, i),
            this._z = s.MathUtils.lerp(t._z, e._z, i)
        }
        slerp(t, e, i) {
            this.throwIfFrozen();
            const n = t.magnitude()
              , o = e.magnitude();
            if (n > 0 && o > 0) {
                const a = Math.acos(s.MathUtils.clamp(t.dot(e) / (n * o), -1, 1));
                if (Math.abs(a) > .01745327777) {
                    const s = 1 / Math.sin(a)
                      , r = Math.sin((1 - i) * a) * s
                      , l = Math.sin(i * a) * s;
                    this.set(t.x * r / n + e.x * l / o, t.y * r / n + e.y * l / o, t.z * r / n + e.z * l / o),
                    this.mult(this, (1 - i) * n + i * o)
                } else
                    this.lerp(t, e, i)
            } else
                this.lerp(t, e, i)
        }
        rotate(t, e) {
            this.throwIfFrozen();
            const i = t.w * e._x + t.y * e._z - t.z * e._y
              , s = t.w * e._y + t.z * e._x - t.x * e._z
              , n = t.w * e._z + t.x * e._y - t.y * e._x
              , o = -t.x * e._x - t.y * e._y - t.z * e._z;
            this._x = i * t.w - o * t.x - s * t.z + n * t.y,
            this._y = s * t.w - o * t.y - n * t.x + i * t.z,
            this._z = n * t.w - o * t.z - i * t.y + s * t.x
        }
        rotateInverse(t, e) {
            this.throwIfFrozen();
            const i = t.w * e._x - t.y * e._z + t.z * e._y
              , s = t.w * e._y - t.z * e._x + t.x * e._z
              , n = t.w * e._z - t.x * e._y + t.y * e._x
              , o = t.x * e._x + t.y * e._y + t.z * e._z;
            this._x = i * t.w + o * t.x + s * t.z - n * t.y,
            this._y = s * t.w + o * t.y + n * t.x - i * t.z,
            this._z = n * t.w + o * t.z + i * t.y - s * t.x
        }
        setNormalTo(t, e) {
            const i = e._x * (t._y * t._y + t._z * t._z) - t._x * (t._y * e._y + t._z * e._z)
              , s = e._y * (t._z * t._z + t._x * t._x) - t._y * (t._z * e._z + t._x * e._x)
              , n = e._z * (t._x * t._x + t._y * t._y) - t._z * (t._x * e._x + t._y * e._y);
            this._x = i,
            this._y = s,
            this._z = n,
            this.normalize(this)
        }
        static _pool = new s.Pool(Vector3);
        static _threeJsPool = new s.Pool(s.THREE.Vector3);
        static _zero = new Vector3(0,0,0,!0);
        static _xAxis = new Vector3(1,0,0,!0);
        static _yAxis = new Vector3(0,1,0,!0);
        static _zAxis = new Vector3(0,0,1,!0);
        static _xAxisNeg = new Vector3(-1,0,0,!0);
        static _yAxisNeg = new Vector3(0,-1,0,!0);
        static _zAxisNeg = new Vector3(0,0,-1,!0);
        static _nan = new Vector3(Number.NaN,Number.NaN,Number.NaN,!0)
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        Cache: function() {
            return Cache
        }
    });
    var s = i(6);
    class Cache extends s.FastIterable {
        constructor(t, e) {
            super(),
            this._keysToEntries = new s.FastMap,
            this._itemToKeys = new Map,
            this._itemLoad = t,
            this._itemUnload = e
        }
        async get(t) {
            const e = this._keysToEntries.get(t);
            if (e)
                return e.count += 1,
                e.promise;
            const i = {
                promise: this._itemLoad(t).then((e => (i.item = e,
                this._itemToKeys.set(e, t),
                e))),
                item: void 0,
                count: 1
            };
            return this._keysToEntries.set(t, i),
            i.promise
        }
        release(t) {
            const e = this._itemToKeys.get(t);
            if (void 0 !== e) {
                const i = this._keysToEntries.get(e);
                i && (i.count -= 1,
                0 === i.count && (this._itemUnload(t),
                this._keysToEntries.delete(e),
                this._itemToKeys.delete(t)))
            }
        }
        getSize() {
            return this._keysToEntries.getSize()
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        ComponentRef: function() {
            return ComponentRef
        }
    });
    var s = i(6);
    class ComponentRef extends s.BaseRef {
        constructor(t, e, i="", s) {
            super(t),
            this._entityName = i,
            this._componentClass = e,
            this._componentNameOrClassIndex = s
        }
        getComponentClass() {
            return this._componentClass
        }
        getEntityName() {
            return this._entityName
        }
        getComponentNameOrClassIndex() {
            return this._componentNameOrClassIndex
        }
        set(t, e=0) {
            this._entityName = t,
            this._componentNameOrClassIndex = e
        }
        update() {
            if ("" === this._entityName)
                this._setRef(null);
            else {
                const t = this._scene.getEntity(this._entityName);
                if (null !== t && t.isEnabled()) {
                    const e = t.getComponent(this._componentClass, this._componentNameOrClassIndex);
                    this._setRef(e)
                } else
                    this._setRef(null)
            }
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        ControllerRef: function() {
            return ControllerRef
        }
    });
    var s = i(6);
    class ControllerRef extends s.BaseRef {
        constructor(t, e, i="", s) {
            super(t),
            this._controllerClass = e,
            this._entityName = i,
            this._controllerNameOrClassIndex = s
        }
        getControllerClass() {
            return this._controllerClass
        }
        getEntityName() {
            return this._entityName
        }
        getControllerNameOrClassIndex() {
            return this._controllerNameOrClassIndex
        }
        set(t, e=0) {
            this._entityName = t,
            this._controllerNameOrClassIndex = e
        }
        update() {
            if ("" === this._entityName)
                this._setRef(null);
            else {
                const t = this._scene.getEntity(this._entityName);
                if (null !== t && t.isEnabled()) {
                    const e = t.getController(this._controllerClass, this._controllerNameOrClassIndex);
                    this._setRef(e)
                } else
                    this._setRef(null)
            }
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        CubeMap: function() {
            return CubeMap
        }
    });
    var s = i(6);
    class CubeMap {
        static xyzToUVFace(t, e, i=CubeMap.defaultCubeMapFaceFrames) {
            let n;
            for (let o = 0; o < 6; o++) {
                const a = i[o]
                  , r = a[2];
                let l, c, h, d;
                r === s.Vector3.XAxis || r === s.Vector3.XAxisNeg ? (l = e.x,
                c = e.y,
                h = e.z,
                d = r === s.Vector3.XAxisNeg) : r === s.Vector3.YAxis || r === s.Vector3.YAxisNeg ? (l = e.y,
                c = e.z,
                h = e.x,
                d = r === s.Vector3.YAxisNeg) : (l = e.z,
                c = e.x,
                h = e.y,
                d = r === s.Vector3.ZAxisNeg),
                Math.abs(l) >= Math.abs(c) && Math.abs(l) >= Math.abs(h) && (l >= 0 && !d || l < 0 && d) && (n = a,
                t.z = o)
            }
            if (void 0 === n)
                return void t.set(NaN, NaN, NaN);
            let o = n[2].x * e.x + n[2].y * e.y + n[2].z * e.z;
            o < 0 && (o = 1),
            t.x = (n[0].x * e.x + n[0].y * e.y + n[0].z * e.z) / o,
            t.y = (n[1].x * e.x + n[1].y * e.y + n[1].z * e.z) / o,
            t.x = .5 * (t.x + 1),
            t.y = .5 * (t.y + 1)
        }
        static defaultCubeMapFaceFrames = [[s.Vector3.YAxis, s.Vector3.ZAxis, s.Vector3.XAxis], [s.Vector3.XAxisNeg, s.Vector3.ZAxis, s.Vector3.YAxis], [s.Vector3.YAxisNeg, s.Vector3.ZAxis, s.Vector3.XAxisNeg], [s.Vector3.XAxis, s.Vector3.ZAxis, s.Vector3.YAxisNeg], [s.Vector3.YAxis, s.Vector3.XAxisNeg, s.Vector3.ZAxis], [s.Vector3.YAxis, s.Vector3.XAxis, s.Vector3.ZAxisNeg]]
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        EntityRef: function() {
            return EntityRef
        }
    });
    var s = i(6);
    class EntityRef extends s.BaseRef {
        constructor(t, e="") {
            super(t),
            this._name = e
        }
        getName() {
            return this._name
        }
        setName(t) {
            this._name = t
        }
        update() {
            if ("" === this._name)
                null !== this._ref && this._setRef(null);
            else if (null === this._ref || this._ref.isDestroyed() || !this._ref.isEnabled() || this._ref.getName() !== this._name) {
                const t = this._scene.getEntity(this._name);
                this._setRef(t)
            }
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        LatLonAlt: function() {
            return LatLonAlt
        }
    });
    var s = i(6);
    class LatLonAlt extends s.Freezable {
        static get pool() {
            return LatLonAlt._pool
        }
        constructor(t=0, e=0, i=0, s=!1) {
            super(s),
            this._lat = t,
            this._lon = e,
            this._alt = i
        }
        get lat() {
            return this._lat
        }
        set lat(t) {
            this.throwIfFrozen(),
            this._lat = t
        }
        get lon() {
            return this._lon
        }
        set lon(t) {
            this.throwIfFrozen(),
            this._lon = t
        }
        get alt() {
            return this._alt
        }
        set alt(t) {
            this.throwIfFrozen(),
            this._alt = t
        }
        toString(t=!1) {
            return t ? `[${s.MathUtils.radToDeg(this._lat)}, ${s.MathUtils.radToDeg(this._lon)}, ${this._alt}]` : `[${this._lat}, ${this._lon}, ${this._alt}]`
        }
        copy(t) {
            this.throwIfFrozen(),
            this._lat = t._lat,
            this._lon = t._lon,
            this._alt = t._alt
        }
        set(t, e, i) {
            this.throwIfFrozen(),
            this._lat = t,
            this._lon = e,
            this._alt = i
        }
        static _pool = new s.Pool(LatLonAlt)
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        LineMesh: function() {
            return LineMesh
        }
    });
    var s = i(6);
    class LineMesh {
        constructor(t) {
            this._component = t,
            this._alphaMultiplier = 1,
            this._position = new s.Vector3,
            this._orientation = new s.Quaternion,
            this._scale = 1,
            this._dashGapLength = 0,
            this._dashLength = 1,
            this._glowWidth = 0,
            this._threeJsObjects = [],
            this._threeJsMaterial = t.getEntity().getScene().getEngine().getMaterialManager().getPreloaded("line"),
            t.getThreeJsMaterials().push(this._threeJsMaterial),
            this._threeJsMaterial.uniforms.alphaMultiplier.value = this._alphaMultiplier,
            this._threeJsMaterial.uniforms.dashLength.value = this._dashLength,
            this._threeJsMaterial.uniforms.dashGapLength.value = this._dashGapLength,
            this._threeJsMaterial.uniforms.glowWidth.value = this._glowWidth
        }
        setPositions(t) {
            if (t.length % 2 != 0)
                throw new Error("Number of positions in the LineMesh must be even.");
            this._adjustVerticesInGeometries(2 * t.length);
            const e = s.Vector3.pool.get()
              , i = s.Vector3.pool.get()
              , n = s.Vector3.pool.get()
              , o = s.Vector3.pool.get()
              , a = s.Vector3.pool.get();
            let r = 0;
            for (let n = 0; n < this._threeJsObjects.length; n++) {
                const o = this._threeJsObjects[n].geometry.getAttribute("position")
                  , l = o.array;
                for (let o = 0; o < l.length / (2 * LineMesh._floatsPerVertex); o++) {
                    const c = o + n * (LineMesh._maxVerticesPerGeometry / 2);
                    l[2 * o * LineMesh._floatsPerVertex + 0] = t[c].x,
                    l[2 * o * LineMesh._floatsPerVertex + 1] = t[c].y,
                    l[2 * o * LineMesh._floatsPerVertex + 2] = t[c].z,
                    l[(2 * o + 1) * LineMesh._floatsPerVertex + 0] = t[c].x,
                    l[(2 * o + 1) * LineMesh._floatsPerVertex + 1] = t[c].y,
                    l[(2 * o + 1) * LineMesh._floatsPerVertex + 2] = t[c].z,
                    c % 2 == 0 ? t[c].equals(t[s.MathUtils.wrap(c - 1, 0, t.length)]) ? (e.copy(t[s.MathUtils.wrap(c - 2, 0, t.length)]),
                    i.copy(t[c + 1])) : (e.copy(t[c]),
                    i.copy(t[c + 1]),
                    r = 0) : c % 2 == 1 && (t[c].equals(t[s.MathUtils.wrap(c + 1, 0, t.length)]) ? (e.copy(t[c - 1]),
                    i.copy(t[s.MathUtils.wrap(c + 2, 0, t.length)])) : (e.copy(t[c - 1]),
                    i.copy(t[c])),
                    a.sub(t[c], t[c - 1]),
                    r += a.magnitude()),
                    l[2 * o * LineMesh._floatsPerVertex + 3] = e.x,
                    l[2 * o * LineMesh._floatsPerVertex + 4] = e.y,
                    l[2 * o * LineMesh._floatsPerVertex + 5] = e.z,
                    l[(2 * o + 1) * LineMesh._floatsPerVertex + 3] = e.x,
                    l[(2 * o + 1) * LineMesh._floatsPerVertex + 4] = e.y,
                    l[(2 * o + 1) * LineMesh._floatsPerVertex + 5] = e.z,
                    l[2 * o * LineMesh._floatsPerVertex + 6] = i.x,
                    l[2 * o * LineMesh._floatsPerVertex + 7] = i.y,
                    l[2 * o * LineMesh._floatsPerVertex + 8] = i.z,
                    l[(2 * o + 1) * LineMesh._floatsPerVertex + 6] = i.x,
                    l[(2 * o + 1) * LineMesh._floatsPerVertex + 7] = i.y,
                    l[(2 * o + 1) * LineMesh._floatsPerVertex + 8] = i.z,
                    l[2 * o * LineMesh._floatsPerVertex + 14] = r,
                    l[(2 * o + 1) * LineMesh._floatsPerVertex + 14] = r
                }
                o.data.needsUpdate = !0
            }
            s.Vector3.pool.release(n),
            s.Vector3.pool.release(o),
            s.Vector3.pool.release(e),
            s.Vector3.pool.release(i),
            s.Vector3.pool.release(a)
        }
        setColors(t) {
            if (t.length % 2 != 0)
                throw new Error("Number of colors in the LineMesh must be even.");
            this._adjustVerticesInGeometries(2 * t.length);
            for (let e = 0; e < this._threeJsObjects.length; e++) {
                const i = this._threeJsObjects[e].geometry.getAttribute("color")
                  , s = i.array;
                for (let i = 0; i < s.length / (2 * LineMesh._floatsPerVertex); i++) {
                    const n = i + e * (LineMesh._maxVerticesPerGeometry / 2);
                    s[2 * i * LineMesh._floatsPerVertex + 9] = t[n].r,
                    s[2 * i * LineMesh._floatsPerVertex + 10] = t[n].g,
                    s[2 * i * LineMesh._floatsPerVertex + 11] = t[n].b,
                    s[2 * i * LineMesh._floatsPerVertex + 12] = t[n].a,
                    s[(2 * i + 1) * LineMesh._floatsPerVertex + 9] = t[n].r,
                    s[(2 * i + 1) * LineMesh._floatsPerVertex + 10] = t[n].g,
                    s[(2 * i + 1) * LineMesh._floatsPerVertex + 11] = t[n].b,
                    s[(2 * i + 1) * LineMesh._floatsPerVertex + 12] = t[n].a
                }
                i.data.needsUpdate = !0
            }
        }
        setWidths(t) {
            if ("number" == typeof t)
                for (let e = 0; e < this._threeJsObjects.length; e++) {
                    const i = this._threeJsObjects[e].geometry.getAttribute("width")
                      , s = i.array;
                    for (let e = 0; e < s.length / (2 * LineMesh._floatsPerVertex); e++)
                        s[2 * e * LineMesh._floatsPerVertex + 13] = t,
                        s[(2 * e + 1) * LineMesh._floatsPerVertex + 13] = -t;
                    i.data.needsUpdate = !0
                }
            else {
                if (t.length % 2 != 0)
                    throw new Error("Number of widths in the LineMesh must be even.");
                this._adjustVerticesInGeometries(2 * t.length);
                for (let e = 0; e < this._threeJsObjects.length; e++) {
                    const i = this._threeJsObjects[e].geometry.getAttribute("width")
                      , s = i.array;
                    for (let i = 0; i < s.length / (2 * LineMesh._floatsPerVertex); i++) {
                        const n = i + e * (LineMesh._maxVerticesPerGeometry / 2);
                        s[2 * i * LineMesh._floatsPerVertex + 13] = t[n],
                        s[(2 * i + 1) * LineMesh._floatsPerVertex + 13] = -t[n]
                    }
                    i.data.needsUpdate = !0
                }
            }
        }
        setDashLength(t, e) {
            this._dashLength = t,
            this._dashGapLength = e,
            s.ThreeJsHelper.setUniformNumber(this._threeJsMaterial, "dashLength", this._dashLength),
            s.ThreeJsHelper.setUniformNumber(this._threeJsMaterial, "dashGapLength", this._dashGapLength)
        }
        setGlowWidth(t) {
            this._glowWidth = t,
            s.ThreeJsHelper.setUniformNumber(this._threeJsMaterial, "glowWidth", this._glowWidth)
        }
        setScale(t) {
            this._scale = t,
            s.ThreeJsHelper.setScale(this._threeJsObjects, t)
        }
        getAlphaMultiplier() {
            return this._alphaMultiplier
        }
        setAlphaMultiplier(t) {
            this._alphaMultiplier = t,
            s.ThreeJsHelper.setUniformNumber(this._threeJsMaterial, "alphaMultiplier", this._alphaMultiplier)
        }
        prepareForRender(t) {
            const e = s.Vector2.pool.get();
            if (t instanceof s.SpoutComponent)
                e.set(.1 * t.getRenderWidth(), .5 * t.getRenderWidth() * .1);
            else {
                const i = t.getViewport();
                i && e.copy(i.getBounds().size)
            }
            s.ThreeJsHelper.setUniformVector2(this._threeJsMaterial, "viewportSize", e),
            s.Vector2.pool.release(e)
        }
        _adjustVerticesInGeometries(t) {
            const e = Math.ceil(t / LineMesh._maxVerticesPerGeometry);
            for (; this._threeJsObjects.length > e; ) {
                const t = this._threeJsObjects[this._threeJsObjects.length - 1];
                s.ThreeJsHelper.destroyObject(t),
                this._threeJsObjects.splice(this._threeJsObjects.length - 1, 1);
                for (let e = 0, i = this._component.getThreeJsObjects().length; e < i; e++)
                    if (this._component.getThreeJsObjects()[e] === t) {
                        this._component.getThreeJsObjects().splice(e, 1);
                        break
                    }
            }
            if (this._threeJsObjects.length < e) {
                this._threeJsObjects.length > 0 && this._setupThreeJsGeometry(this._threeJsObjects[this._threeJsObjects.length - 1].geometry, LineMesh._maxVerticesPerGeometry);
                for (let i = this._threeJsObjects.length; i < e; i++) {
                    const e = s.ThreeJsHelper.createMeshObject(this._component, this._threeJsMaterial, [], !1);
                    this._threeJsObjects.push(e),
                    this._component.getThreeJsObjects().push(e);
                    const n = Math.min(t - i * LineMesh._maxVerticesPerGeometry, LineMesh._maxVerticesPerGeometry);
                    this._setupThreeJsGeometry(e.geometry, n),
                    s.ThreeJsHelper.setPosition(e, this._position),
                    s.ThreeJsHelper.setOrientation(e, this._orientation),
                    s.ThreeJsHelper.setScale(e, this._scale),
                    e.frustumCulled = !1
                }
            } else if (e > 0) {
                const i = this._threeJsObjects[e - 1].geometry
                  , s = t - (e - 1) * LineMesh._maxVerticesPerGeometry;
                i.getAttribute("position").array.length !== s * LineMesh._floatsPerVertex && this._setupThreeJsGeometry(i, s)
            }
        }
        _setupThreeJsGeometry(t, e) {
            const i = new Float32Array(e * LineMesh._floatsPerVertex)
              , n = new s.THREE.InterleavedBuffer(i,LineMesh._floatsPerVertex);
            t.setAttribute("position", new s.THREE.InterleavedBufferAttribute(n,3,0,!1)),
            t.setAttribute("positionPrev", new s.THREE.InterleavedBufferAttribute(n,3,3,!1)),
            t.setAttribute("positionNext", new s.THREE.InterleavedBufferAttribute(n,3,6,!1)),
            t.setAttribute("color", new s.THREE.InterleavedBufferAttribute(n,4,9,!1)),
            t.setAttribute("width", new s.THREE.InterleavedBufferAttribute(n,1,13,!1)),
            t.setAttribute("dashOffset", new s.THREE.InterleavedBufferAttribute(n,1,14,!1));
            const o = new Uint16Array(6 * e / 4);
            for (let t = 0; t < e / 4; t++)
                o[6 * t + 0] = 4 * t,
                o[6 * t + 1] = 4 * t + 2,
                o[6 * t + 2] = 4 * t + 3,
                o[6 * t + 3] = 4 * t,
                o[6 * t + 4] = 4 * t + 3,
                o[6 * t + 5] = 4 * t + 1;
            t.setIndex(new s.THREE.BufferAttribute(o,1))
        }
        static _floatsPerVertex = 15;
        static _maxVerticesPerGeometry = 65536
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        MaterialUtilsPhong: function() {
            return MaterialUtilsPhong
        }
    });
    var s = i(6);
    class MaterialUtilsPhong {
        static get() {
            null === MaterialUtilsPhong._material && (MaterialUtilsPhong._material = new s.THREE.ShaderMaterial({
                uniforms: {
                    entityPos: new s.THREE.Uniform(new s.THREE.Vector3),
                    ambientLightColor: new s.THREE.Uniform(new s.THREE.Color),
                    lightPositions: new s.THREE.Uniform([new s.THREE.Vector3(1,0,0), new s.THREE.Vector3(1,0,0), new s.THREE.Vector3(1,0,0), new s.THREE.Vector3(1,0,0), new s.THREE.Vector3(1,0,0)]),
                    lightColors: new s.THREE.Uniform([new s.THREE.Vector3(0,0,0), new s.THREE.Vector3(0,0,0), new s.THREE.Vector3(0,0,0), new s.THREE.Vector3(0,0,0), new s.THREE.Vector3(0,0,0)]),
                    lightRadii: new s.THREE.Uniform([0, 0, 0, 0, 0]),
                    numLights: new s.THREE.Uniform(0),
                    color: new s.THREE.Uniform(new s.THREE.Vector4(1,1,1,1)),
                    specularColor: new s.THREE.Uniform(new s.THREE.Vector3(1,1,1)),
                    specularIntensity: new s.THREE.Uniform(0),
                    specularHardness: new s.THREE.Uniform(50),
                    colorTexture: new s.THREE.Uniform(null),
                    normalTexture: new s.THREE.Uniform(null),
                    specularTexture: new s.THREE.Uniform(null),
                    nightTexture: new s.THREE.Uniform(null),
                    decalTexture: new s.THREE.Uniform(null),
                    normalScale: new s.THREE.Uniform(new s.THREE.Vector2(1,1)),
                    numShadowEntities: new s.THREE.Uniform(0),
                    shadowEntityPositions: new s.THREE.Uniform([new s.THREE.Vector3, new s.THREE.Vector3, new s.THREE.Vector3, new s.THREE.Vector3, new s.THREE.Vector3, new s.THREE.Vector3, new s.THREE.Vector3]),
                    shadowEntityRadii: new s.THREE.Uniform([0, 0, 0, 0, 0, 0, 0]),
                    shadowEntitySunsetIntensity: new s.THREE.Uniform([0, 0, 0, 0, 0, 0, 0]),
                    shadowEntitySunsetColors: new s.THREE.Uniform([new s.THREE.Vector3, new s.THREE.Vector3, new s.THREE.Vector3, new s.THREE.Vector3, new s.THREE.Vector3, new s.THREE.Vector3, new s.THREE.Vector3]),
                    shadowRingsInnerRadius: new s.THREE.Uniform(0),
                    shadowRingsOuterRadius: new s.THREE.Uniform(0),
                    shadowRingsTexture: new s.THREE.Uniform(null),
                    shadowRingsNormal: new s.THREE.Uniform(new s.THREE.Vector3),
                    atmospherePosition: new s.THREE.Uniform(new s.THREE.Vector3(0,0,0)),
                    atmosphereOrientation: new s.THREE.Uniform(new s.THREE.Vector4(1,0,0,0)),
                    atmosphereEquatorialRadius: new s.THREE.Uniform(1),
                    atmospherePolarRadius: new s.THREE.Uniform(1),
                    atmosphereDensity: new s.THREE.Uniform(0),
                    atmosphereScaleHeight: new s.THREE.Uniform(1),
                    atmosphereEmissivity: new s.THREE.Uniform(0),
                    atmosphereColor: new s.THREE.Uniform(new s.THREE.Vector3(0,0,0)),
                    atmosphereSunBrightness: new s.THREE.Uniform(1),
                    atmosphereSunsetColor: new s.THREE.Uniform(new s.THREE.Vector3(0,0,0)),
                    atmosphereSunsetIntensity: new s.THREE.Uniform(0),
                    atmosphereGroundIsSpheroid: new s.THREE.Uniform(0),
                    ...s.ShaderChunkLogDepth.ThreeUniforms
                },
                vertexShader: `\n\t\t\t\t\t#ifdef normalMap\n\t\t\t\t\t\tin vec4 tangent;\n\t\t\t\t\t\tout vec4 viewTangent;\n\t\t\t\t\t#endif\n\t\t\t\t\t#ifdef normalUVs\n\t\t\t\t\t\tin vec2 normalUV;\n\t\t\t\t\t\tout vec2 vNormalUV;\n\t\t\t\t\t#endif\n\t\t\t\t\t#ifdef specularUVs\n\t\t\t\t\t\tin vec2 specularUV;\n\t\t\t\t\t\tout vec2 vSpecularUV;\n\t\t\t\t\t#endif\n\t\t\t\t\t#ifdef nightUVs\n\t\t\t\t\t\tin vec2 nightUV;\n\t\t\t\t\t\tout vec2 vNightUV;\n\t\t\t\t\t#endif\n\t\t\t\t\t#ifdef decalUVs\n\t\t\t\t\t\tin vec2 decalUV;\n\t\t\t\t\t\tout vec2 vDecalUV;\n\t\t\t\t\t#endif\n\t\t\t\t\tout vec2 vColorUV;\n\t\t\t\t\tout vec3 cameraSpacePosition;\n\t\t\t\t\tout vec3 cameraSpaceNormal;\n\n\t\t\t\t\t${s.ShaderChunkLogDepth.VertexHead}\n\n\t\t\t\t\tvoid main() {\n\t\t\t\t\t\t#ifdef normalMap\n\t\t\t\t\t\t\tviewTangent = vec4((modelMatrix * vec4(tangent.xyz, 0.0)).xyz, tangent.w);\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\tvColorUV = uv;\n\t\t\t\t\t\t#ifdef normalUVs\n\t\t\t\t\t\t\tvNormalUV = normalUV;\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\t#ifdef specularUVs\n\t\t\t\t\t\t\tvSpecularUV = specularUV;\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\t#ifdef nightUVs\n\t\t\t\t\t\t\tvNightUV = nightUV;\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\t#ifdef decalUVs\n\t\t\t\t\t\t\tvDecalUV = decalUV;\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\tcameraSpacePosition = (modelMatrix * vec4(position, 1.)).xyz;\n\t\t\t\t\t\tcameraSpaceNormal = (modelMatrix * vec4(normal, 0.)).xyz;\n\t\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n\n\t\t\t\t\t\t${s.ShaderChunkLogDepth.Vertex}\n\t\t\t\t\t}`,
                fragmentShader: `\n\t\t\t\t\tprecision highp float;\n\n\t\t\t\t\t#ifndef saturate\n\t\t\t\t\t\t#define saturate(a) clamp(a, 0.0, 1.0)\n\t\t\t\t\t#endif\n\t\t\t\t\tuniform mat3 normalMatrix;\n\n\t\t\t\t\t// External lighting and camera.\n\t\t\t\t\tuniform vec3 entityPos;\n\n\t\t\t\t\t// Lights\n\t\t\t\t\tuniform vec3 ambientLightColor;\n\t\t\t\t\tuniform vec3 lightPositions[5];\n\t\t\t\t\tuniform vec3 lightColors[5];\n\t\t\t\t\tuniform float lightRadii[5];\n\t\t\t\t\tuniform int numLights;\n\n\t\t\t\t\t// Shading.\n\t\t\t\t\tuniform vec4 color;\n\t\t\t\t\tuniform vec3 specularColor;\n\t\t\t\t\tuniform float specularIntensity;\n\t\t\t\t\tuniform float specularHardness;\n\n\t\t\t\t\t// Shadow Entities.\n\t\t\t\t\t#ifdef shadowEntities\n\t\t\t\t\t\tuniform int numShadowEntities;\n\t\t\t\t\t\tuniform vec3 shadowEntityPositions[7];\n\t\t\t\t\t\tuniform float shadowEntityRadii[7];\n\t\t\t\t\t\tuniform float shadowEntitySunsetIntensity[7];\n\t\t\t\t\t\tuniform vec3 shadowEntitySunsetColors[7];\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#ifdef shadowRings\n\t\t\t\t\t\tuniform float shadowRingsInnerRadius;\n\t\t\t\t\t\tuniform float shadowRingsOuterRadius;\n\t\t\t\t\t\tuniform sampler2D shadowRingsTexture;\n\t\t\t\t\t\tuniform vec3 shadowRingsNormal;\n\t\t\t\t\t#endif\n\n\t\t\t\t\t// Textures.\n\t\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\t\t#ifdef normalMap\n\t\t\t\t\t\tuniform sampler2D normalTexture;\n\t\t\t\t\t#endif\n\t\t\t\t\t#ifdef specularMap\n\t\t\t\t\t\tuniform sampler2D specularTexture;\n\t\t\t\t\t#endif\n\t\t\t\t\t#ifdef nightMap\n\t\t\t\t\t\tuniform sampler2D nightTexture;\n\t\t\t\t\t#endif\n\t\t\t\t\t#ifdef decalMap\n\t\t\t\t\t\tuniform sampler2D decalTexture;\n\t\t\t\t\t#endif\n\n\t\t\t\t\t// Modifications on the textures.\n\t\t\t\t\t#ifdef normalMap\n\t\t\t\t\t\tuniform vec2 normalScale;\n\t\t\t\t\t#endif\n\n\t\t\t\t\t// The varying attributes.\n\t\t\t\t\t#ifdef normalMap\n\t\t\t\t\t\tin vec4 viewTangent;\n\t\t\t\t\t#endif\n\t\t\t\t\t#ifdef normalUVs\n\t\t\t\t\t\tin vec2 vNormalUV;\n\t\t\t\t\t#endif\n\t\t\t\t\t#ifdef specularUVs\n\t\t\t\t\t\tin vec2 vSpecularUV;\n\t\t\t\t\t#endif\n\t\t\t\t\t#ifdef nightUVs\n\t\t\t\t\t\tin vec2 vNightUV;\n\t\t\t\t\t#endif\n\t\t\t\t\t#ifdef decalUVs\n\t\t\t\t\t\tin vec2 vDecalUV;\n\t\t\t\t\t#endif\n\t\t\t\t\tin vec2 vColorUV;\n\t\t\t\t\tin vec3 cameraSpacePosition;\n\t\t\t\t\tin vec3 cameraSpaceNormal;\n\n\t\t\t\t\t${s.ShaderChunkLogDepth.FragmentHead}\n\n\t\t\t\t\t#ifdef normalMap\n\t\t\t\t\t\tvec3 getNormalFromMap() {\n\t\t\t\t\t\t\tvec3 normal = normalize(cameraSpaceNormal);\n\t\t\t\t\t\t\tvec3 tangent = normalize(viewTangent.xyz);\n\t\t\t\t\t\t\tvec3 bitangent = normalize(cross(normal, tangent));\n\t\t\t\t\t\t\tif (viewTangent.w < 0.0) {\n\t\t\t\t\t\t\t\tbitangent *= -1.0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmat3 transform = mat3(tangent, bitangent, normal);\n\t\t\t\t\t\t\t#ifdef normalUVs\n\t\t\t\t\t\t\t\tvec2 uv = vNormalUV;\n\t\t\t\t\t\t\t#else\n\t\t\t\t\t\t\t\tvec2 uv = vColorUV;\n\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t\tvec3 normalFromMap = texture(normalTexture, uv).rgb * 2.0 - 1.0;\n\t\t\t\t\t\t\tnormalFromMap.xy *= vec2(1, -1);\n\t\t\t\t\t\t\tnormalFromMap.xy *= normalScale;\n\t\t\t\t\t\t\treturn normalize(transform * normalFromMap);\n\t\t\t\t\t\t}\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#ifdef colorTextureEnvironment\n\t\t\t\t\t\tvec4 getColorFromEnvironmentMap(sampler2D environmentTexture, vec3 positionDir, vec3 normal) {\n\t\t\t\t\t\t\tvec3 r = reflect(positionDir, normal);\n\t\t\t\t\t\t\tfloat m = 2. * sqrt(r.x * r.x + r.y * r.y + (r.z + 1.) * (r.z + 1.));\n\t\t\t\t\t\t\tvec2 uv = r.xy / m + .5;\n\t\t\t\t\t\t\treturn vec4(texture(environmentTexture, uv).rgb, 1.);\n\t\t\t\t\t\t}\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#ifdef shadowEntities\n\t\t\t\t\t\tvec3 applyRayleighScattering(vec3 color, float amount) {\n\t\t\t\t\t\t\tfloat value = (color.r + color.g + color.b);\n\t\t\t\t\t\t\tif (value > 0.0) {\n\t\t\t\t\t\t\t\tfloat rFactor = 1.0; // 6.3^-4 / 6.3^-4\n\t\t\t\t\t\t\t\tfloat gFactor = 1.602; // 5.6^-4 / 6.3^-4\n\t\t\t\t\t\t\t\tfloat bFactor = 3.228; // 4.7^-4 / 6.3^-4\n\t\t\t\t\t\t\t\tcolor.r *= pow(rFactor, -amount);\n\t\t\t\t\t\t\t\tcolor.g *= pow(gFactor, -amount);\n\t\t\t\t\t\t\t\tcolor.b *= pow(bFactor, -amount);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn color;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvec3 getLightColorFromShadowEntities(vec3 lightColor, vec3 lightDir, vec3 lightPosition, float lightRadius, vec3 normal) {\n\t\t\t\t\t\t\tvec3 color = lightColor;\n\t\t\t\t\t\t\tfor (int i = 0; i < 7; i++) {\n\t\t\t\t\t\t\t\tif (i >= numShadowEntities || lightRadius < 0.0) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tvec3 origin = cameraSpacePosition - shadowEntityPositions[i];\n\t\t\t\t\t\t\t\tvec3 axis = normalize(shadowEntityPositions[i] - lightPosition);\n\t\t\t\t\t\t\t\tfloat sd = dot(origin, axis);\n\t\t\t\t\t\t\t\tif (sd > 0.0) {\n\t\t\t\t\t\t\t\t\tfloat e = length(origin - sd * axis);\n\t\t\t\t\t\t\t\t\tfloat ld = dot(cameraSpacePosition - lightPosition, axis);\n\t\t\t\t\t\t\t\t\tfloat lr = lightRadius;\n\t\t\t\t\t\t\t\t\tfloat sr = shadowEntityRadii[i];\n\t\t\t\t\t\t\t\t\tfloat e0 = (ld * sr - sd * lr) / (ld - sd);\n\t\t\t\t\t\t\t\t\tfloat e1 = (ld * sr + sd * lr) / (ld - sd);\n\t\t\t\t\t\t\t\t\tfloat lightLevel = 0.0;\n\t\t\t\t\t\t\t\t\tif (e1 < 0.0 || sd < 0.0) { // light in front of shadow entity\n\t\t\t\t\t\t\t\t\t\tlightLevel = 1.0;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse if (e0 < e1) {\n\t\t\t\t\t\t\t\t\t\te0 /= max(1.0, shadowEntitySunsetIntensity[i] * 2.0);\n\t\t\t\t\t\t\t\t\t\tlightLevel = (e - e0) / (e1 - e0);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\tlightLevel = e < e0 ? 0.0 : 1.0; // 0 radius light.\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcolor = saturate(lightLevel) * applyRayleighScattering(color, saturate(1.5 - lightLevel) * saturate(shadowEntitySunsetIntensity[i]));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn color;\n\t\t\t\t\t\t}\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#ifdef shadowRings\n\t\t\t\t\t\tvec3 getLightColorFromShadowRings(vec3 lightColor, vec3 lightDir) {\n\t\t\t\t\t\t\tvec3 position = cameraSpacePosition - entityPos;\n\t\t\t\t\t\t\tfloat d = dot(position, shadowRingsNormal) / dot(lightDir, shadowRingsNormal);\n\t\t\t\t\t\t\thighp vec3 pointOnDisc = -d * lightDir + position;\n\t\t\t\t\t\t\tfloat lengthOnDisc = length(pointOnDisc - dot(pointOnDisc, shadowRingsNormal) * shadowRingsNormal);\n\t\t\t\t\t\t\tfloat u = (lengthOnDisc - shadowRingsInnerRadius) / (shadowRingsOuterRadius - shadowRingsInnerRadius);\n\t\t\t\t\t\t\tfloat shadow = 1.0 - texture(shadowRingsTexture, vec2(u, 0.0), 0.0).a;\n\t\t\t\t\t\t\tif (shadowRingsInnerRadius <= lengthOnDisc && lengthOnDisc <= shadowRingsOuterRadius && d > 0.0) {\n\t\t\t\t\t\t\t\treturn lightColor * saturate(shadow);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\treturn lightColor;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t#endif\n\n\t\t\t\t\t// ATMOSPHERE\n\n\t\t\t\t\t#ifdef atmosphere\n\t\t\t\t\t\tuniform vec3 atmospherePosition;\n\t\t\t\t\t\tuniform vec4 atmosphereOrientation;\n\t\t\t\t\t\tuniform float atmosphereEquatorialRadius;\n\t\t\t\t\t\tuniform float atmospherePolarRadius;\n\t\t\t\t\t\tuniform float atmosphereDensity;\n\t\t\t\t\t\tuniform float atmosphereScaleHeight;\n\t\t\t\t\t\tuniform vec3 atmosphereColor;\n\t\t\t\t\t\tuniform float atmosphereEmissivity;\n\t\t\t\t\t\tuniform float atmosphereSunBrightness;\n\t\t\t\t\t\tuniform vec3 atmosphereSunsetColor;\n\t\t\t\t\t\tuniform float atmosphereSunsetIntensity;\n\t\t\t\t\t\tuniform float atmosphereGroundIsSpheroid;\n\n\t\t\t\t\t\tconst int atmosphereNumIterations = 5;\n\n\t\t\t\t\t\t// Inverse rotate a vector by a quaternion.\n\t\t\t\t\t\tvec3 quatRotInv(vec4 q, vec3 v) {\n\t\t\t\t\t\t\tfloat tx = q.w * v.x - q.y * v.z + q.z * v.y;\n\t\t\t\t\t\t\tfloat ty = q.w * v.y - q.z * v.x + q.x * v.z;\n\t\t\t\t\t\t\tfloat tz = q.w * v.z - q.x * v.y + q.y * v.x;\n\t\t\t\t\t\t\tfloat tw = q.x * v.x + q.y * v.y + q.z * v.z;\n\t\t\t\t\t\t\tfloat x = tx * q.w + tw * q.x + ty * q.z - tz * q.y;\n\t\t\t\t\t\t\tfloat y = ty * q.w + tw * q.y + tz * q.x - tx * q.z;\n\t\t\t\t\t\t\tfloat z = tz * q.w + tw * q.z + tx * q.y - ty * q.x;\n\t\t\t\t\t\t\treturn vec3(x, y, z);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Given an origin and direction, computes the sampling start and end as distance from the origin in the direction.\n\t\t\t\t\t\tvoid getStartEndSamples(out float start, out float end, vec3 origin, vec3 direction, float maxDistance, float groundRadius, float atmosphereScaleHeight) {\n\t\t\t\t\t\t\t// Get the along the ray perpendicular to the sphere.\n\t\t\t\t\t\t\tfloat perpD = -dot(origin, direction);\n\t\t\t\t\t\t\tvec3 perp = origin + direction * perpD;\n\n\t\t\t\t\t\t\t// Figure out the sample distance.\n\t\t\t\t\t\t\tfloat atmosphereRadius = groundRadius + atmosphereScaleHeight * 6.0;\n\t\t\t\t\t\t\tfloat chordHalfLength = sqrt(max(0.0, atmosphereRadius * atmosphereRadius - dot(perp, perp)));\n\n\t\t\t\t\t\t\t// Figure out starting and ending sample points.\n\t\t\t\t\t\t\tstart = max(0.0, perpD - chordHalfLength);\n\t\t\t\t\t\t\tend = min(maxDistance, perpD + chordHalfLength);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Gets the density of the atmosphere at a given position.\n\t\t\t\t\t\tfloat getDensity(vec3 position, float radius, float density, float atmosphereScaleHeight) {\n\t\t\t\t\t\t\treturn density * exp((radius - length(position)) / atmosphereScaleHeight);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Returns 0 if the ray does not intersect and 1.0 if the ray very intersects (with a gradient inbetween).\n\t\t\t\t\t\tfloat getDayLevel(vec3 origin, vec3 direction, float radius, float scaleHeight) {\n\t\t\t\t\t\t\tfloat blendHeight = scaleHeight * radius / 200.0;\n\t\t\t\t\t\t\tfloat perpD = -dot(origin, direction);\n\t\t\t\t\t\t\tfloat depth = radius - sqrt(dot(origin, origin) - sign(perpD) * perpD * perpD);\n\t\t\t\t\t\t\tif (depth < 0.0) { // day\n\t\t\t\t\t\t\t\treturn 1.0 - max(0.0, 0.25 * depth / blendHeight + 0.25);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse { // night\n\t\t\t\t\t\t\t\treturn 1.0 - min(1.0, 0.75 * depth / blendHeight + 0.25);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Adjusts the color if one of the RGB values is greater than 1.0.\n\t\t\t\t\t\tvec3 adjustOverbrightness(vec3 color) {\n\t\t\t\t\t\t\tfloat maxColor = max(color.r, max(color.g, color.b));\n\t\t\t\t\t\t\tif (maxColor > 1.0) {\n\t\t\t\t\t\t\t\tfloat f = (maxColor - 1.0) / maxColor;\n\t\t\t\t\t\t\t\tcolor.r = min(1.0, pow(color.r / maxColor, 1.0 / maxColor));\n\t\t\t\t\t\t\t\tcolor.g = min(1.0, pow(color.g / maxColor, 1.0 / maxColor));\n\t\t\t\t\t\t\t\tcolor.b = min(1.0, pow(color.b / maxColor, 1.0 / maxColor));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn color;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Calculates a glow around the light direction.\n\t\t\t\t\t\tfloat glow(float spread, float amount, float lightDotCamera) {\n\t\t\t\t\t\t\treturn amount * spread / (1.0 + spread - lightDotCamera);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstruct AtmosphereInfo {\n\t\t\t\t\t\t\tfloat spheroidRatio;\n\t\t\t\t\t\t\thighp vec3 position;\n\t\t\t\t\t\t\thighp vec3 cameraPosition;\n\t\t\t\t\t\t\thighp vec3 cameraToPosition;\n\t\t\t\t\t\t\tfloat cameraToPositionDist;\n\t\t\t\t\t\t\thighp vec3 cameraToPositionUnit;\n\t\t\t\t\t\t\tfloat start;\n\t\t\t\t\t\t\tfloat end;\n\t\t\t\t\t\t\tfloat totalDensity;\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// Get atmosphere info that is independent of any light.\n\t\t\t\t\t\tAtmosphereInfo getAtmosphereInfo() {\n\n\t\t\t\t\t\t\tAtmosphereInfo atmosphereInfo;\n\n\t\t\t\t\t\t\t// Get position and camera in the atmosphere frame.\n\t\t\t\t\t\t\tatmosphereInfo.position = quatRotInv(atmosphereOrientation, cameraSpacePosition - atmospherePosition);\n\t\t\t\t\t\t\tatmosphereInfo.cameraPosition = quatRotInv(atmosphereOrientation, -atmospherePosition);\n\n\t\t\t\t\t\t\t// Convert everything into a sphere frame.\n\t\t\t\t\t\t\tatmosphereInfo.spheroidRatio = atmosphereEquatorialRadius / atmospherePolarRadius;\n\t\t\t\t\t\t\tatmosphereInfo.position.z *= atmosphereInfo.spheroidRatio;\n\t\t\t\t\t\t\tatmosphereInfo.cameraPosition.z *= atmosphereInfo.spheroidRatio;\n\n\t\t\t\t\t\t\t// Make sure the position is right on the ground.\n\t\t\t\t\t\t\tatmosphereInfo.position = normalize(atmosphereInfo.position / 1.0e8) * atmosphereEquatorialRadius;\n\n\t\t\t\t\t\t\t// Get some shortcut vectors.\n\t\t\t\t\t\t\tatmosphereInfo.cameraToPosition = atmosphereInfo.position - atmosphereInfo.cameraPosition;\n\t\t\t\t\t\t\tatmosphereInfo.cameraToPositionDist = length(atmosphereInfo.cameraToPosition / 1.0e8) * 1.0e8;\n\t\t\t\t\t\t\tatmosphereInfo.cameraToPositionUnit = atmosphereInfo.cameraToPosition / atmosphereInfo.cameraToPositionDist;\n\n\t\t\t\t\t\t\t// Get the start and end of the sampling from the camera to the position.\n\t\t\t\t\t\t\tgetStartEndSamples(atmosphereInfo.start, atmosphereInfo.end, atmosphereInfo.cameraPosition, atmosphereInfo.cameraToPositionUnit, atmosphereInfo.cameraToPositionDist, atmosphereEquatorialRadius, atmosphereScaleHeight);\n\t\t\t\t\t\t\tfloat step = 1.0 / float(atmosphereNumIterations - 1);\n\t\t\t\t\t\t\tfloat stepDist = step * (atmosphereInfo.end - atmosphereInfo.start);\n\n\t\t\t\t\t\t\t// Do the sampling.\n\t\t\t\t\t\t\tatmosphereInfo.totalDensity = 0.0;\n\t\t\t\t\t\t\tfloat segmentStart = atmosphereInfo.start;\n\t\t\t\t\t\t\tfor (int j = 0; j < atmosphereNumIterations; j++) {\n\t\t\t\t\t\t\t\t// Get the distance that this segment covers.\n\t\t\t\t\t\t\t\tfloat segDist = stepDist;\n\t\t\t\t\t\t\t\tif (j == 0 || j == atmosphereNumIterations - 1) {\n\t\t\t\t\t\t\t\t\tsegDist *= 0.5;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Get the segment start that we're looking at.\n\t\t\t\t\t\t\t\tvec3 p = atmosphereInfo.cameraPosition + segmentStart * atmosphereInfo.cameraToPositionUnit;\n\n\t\t\t\t\t\t\t\t// Get the density at that segment start. It'll be the density for the whole segment.\n\t\t\t\t\t\t\t\tfloat densityAtP = getDensity(p, atmosphereEquatorialRadius, atmosphereDensity, atmosphereScaleHeight);\n\n\t\t\t\t\t\t\t\t// Add it to the total density.\n\t\t\t\t\t\t\t\tatmosphereInfo.totalDensity += densityAtP * segDist;\n\n\t\t\t\t\t\t\t\t// Next step.\n\t\t\t\t\t\t\t\tsegmentStart += stepDist;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn atmosphereInfo;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvec4 getAtmosphereEmissiveColor(AtmosphereInfo atmosphereInfo, vec3 color, float emissivity) {\n\n\t\t\t\t\t\t\t// Scale the total density with the emissivity.\n\t\t\t\t\t\t\tatmosphereInfo.totalDensity *= emissivity;\n\n\t\t\t\t\t\t\t// Apply the total density to the transparency of the atmosphere.\n\t\t\t\t\t\t\tvec4 emissiveColor = vec4(0.0);\n\t\t\t\t\t\t\temissiveColor.a = clamp(pow(3.0 * atmosphereInfo.totalDensity, 0.3), 0.0, 1.0);\n\n\t\t\t\t\t\t\t// Multiply it all together with the source light color.\n\t\t\t\t\t\t\temissiveColor.rgb = emissivity * color * clamp(pow(15.0 * atmosphereInfo.totalDensity / (atmosphereDensity * atmosphereEquatorialRadius), 0.2), 0.75, 1.0);\n\n\t\t\t\t\t\t\t// Make it more opaque when lower down.\n\t\t\t\t\t\t\temissiveColor.a *= 1.0 + 0.5 * getDensity(atmosphereInfo.cameraPosition, atmosphereEquatorialRadius, 1.0, atmosphereScaleHeight);\n\n\t\t\t\t\t\t\t// Clamp it to make it clean.\n\t\t\t\t\t\t\temissiveColor.a = clamp(emissiveColor.a, 0.0, 1.0);\n\n\t\t\t\t\t\t\t// Return the color.\n\t\t\t\t\t\t\treturn emissiveColor;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Adjust the incoming light for the atmosphere.\n\t\t\t\t\t\tvec4 getAtmosphereColor(AtmosphereInfo atmosphereInfo, vec3 incomingLight, vec3 lightPosition) {\n\n\t\t\t\t\t\t\t// The color starts out in full brightness (as if emissivity was 1.0).\n\t\t\t\t\t\t\tvec4 atmosphereColor = getAtmosphereEmissiveColor(atmosphereInfo, incomingLight * atmosphereColor, 1.0);\n\n\t\t\t\t\t\t\t// Get the light position in the sphere entity-space.\n\t\t\t\t\t\t\tlightPosition = quatRotInv(atmosphereOrientation, lightPosition);\n\t\t\t\t\t\t\tlightPosition.z *= atmosphereInfo.spheroidRatio;\n\t\t\t\t\t\t\thighp vec3 lightToPosition = atmosphereInfo.position - lightPosition;\n\t\t\t\t\t\t\thighp vec3 lightToPositionUnit = normalize(lightToPosition / 1.0e8);\n\n\t\t\t\t\t\t\t// Get the day level, from 0 to 1, and apply it to the alpha.\n\t\t\t\t\t\t\tfloat ambientLightIntensity = min(1.0, length(ambientLightColor));\n\t\t\t\t\t\t\tvec3 dayRefUp = normalize(atmosphereInfo.cameraPosition + atmosphereInfo.end * atmosphereInfo.cameraToPositionUnit);\n\t\t\t\t\t\t\tfloat dayLevel = -dot(lightToPositionUnit, dayRefUp);\n\t\t\t\t\t\t\tfloat lightIntensity = mix(dayLevel, 0.0, ambientLightIntensity);\n\t\t\t\t\t\t\tatmosphereColor.a *= min(1.0, 700.0 * atmosphereDensity * exp(-pow(abs(0.95 - lightIntensity), 16.0)));\n\n\t\t\t\t\t\t\t// Add broader sun glare.\n\t\t\t\t\t\t\tfloat lightDotCamera = max(0.0, -dot(lightToPositionUnit, atmosphereInfo.cameraToPositionUnit));\n\t\t\t\t\t\t\tatmosphereColor.rgb *= incomingLight * (1.0 + atmosphereSunBrightness * atmosphereColor.a * glow(0.04, 0.125, lightDotCamera));\n\n\t\t\t\t\t\t\t// Apply the sunset.\n\t\t\t\t\t\t\tfloat sunsetAmount = mix(atmosphereSunsetIntensity * 0.5 * exp(-(dayLevel / 0.15) * (dayLevel / 0.15)), 0.0, ambientLightIntensity);\n\t\t\t\t\t\t\tatmosphereColor.rgb *= mix(vec3(1.0), atmosphereSunsetColor, sunsetAmount);\n\n\t\t\t\t\t\t\t// Adjust for values that are greater than one.\n\t\t\t\t\t\t\tatmosphereColor.rgb = adjustOverbrightness(atmosphereColor.rgb);\n\n\t\t\t\t\t\t\treturn atmosphereColor;\n\t\t\t\t\t\t}\n\t\t\t\t\t#endif\n\n\t\t\t\t\tvoid main(void) {\n\t\t\t\t\t\t// Get the camera direction to the position.\n\t\t\t\t\t\tvec3 positionDir = normalize(cameraSpacePosition);\n\n\t\t\t\t\t\t// Calculate the normal.\n\t\t\t\t\t\t#ifdef normalMap\n\t\t\t\t\t\t\tvec3 normal = getNormalFromMap();\n\t\t\t\t\t\t#else\n\t\t\t\t\t\t\tvec3 normal = normalize(cameraSpaceNormal);\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t// The diffuse light.\n\t\t\t\t\t\tvec3 diffuseLight = ambientLightColor;\n\t\t\t\t\t\tvec3 specularLight = vec3(0, 0, 0);\n\n\t\t\t\t\t\t// Atmosphere emissive shading.\n\t\t\t\t\t\t#ifdef atmosphere\n\t\t\t\t\t\t\tAtmosphereInfo atmosphereInfo = getAtmosphereInfo();\n\t\t\t\t\t\t\tvec4 atmosphereColor = getAtmosphereEmissiveColor(atmosphereInfo, atmosphereColor, atmosphereEmissivity);\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t// For each light,\n\t\t\t\t\t\tfor (int i = 0; i < 5; i++) {\n\t\t\t\t\t\t\tif (i >= numLights) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Get lighting angles.\n\t\t\t\t\t\t\tvec3 lightDir = normalize(cameraSpacePosition - lightPositions[i]);\n\t\t\t\t\t\t\tfloat lightCosAngle = -dot(lightDir, normal);\n\n\t\t\t\t\t\t\t// Make the shadows a bit sharper, depending on atmospheres.\n\t\t\t\t\t\t\tfloat sharpness = 3.0;\n\t\t\t\t\t\t\t#ifdef atmosphere\n\t\t\t\t\t\t\t\tsharpness /= 1.0 + 700.0 * atmosphereDensity;\n\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t\tlightCosAngle = 2.0 * (1.0 + exp(-sharpness)) / (1.0 + exp(-sharpness * lightCosAngle)) - 1.0;\n\n\t\t\t\t\t\t\t// Get the incoming light after shadows.\n\t\t\t\t\t\t\tvec3 incomingLight = lightColors[i];\n\t\t\t\t\t\t\t#if !defined(colorMapEmissive) | !defined(nightMapEmissive) | !defined(decalMapEmissive)\n\t\t\t\t\t\t\t\t#ifdef shadowEntities\n\t\t\t\t\t\t\t\t\tincomingLight = getLightColorFromShadowEntities(incomingLight, lightDir, lightPositions[i], lightRadii[i], normal);\n\t\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t\t\t#ifdef shadowRings\n\t\t\t\t\t\t\t\t\tincomingLight = getLightColorFromShadowRings(incomingLight, lightDir);\n\t\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t\t// Diffuse shading.\n\t\t\t\t\t\t\tdiffuseLight += incomingLight * saturate(lightCosAngle);\n\n\t\t\t\t\t\t\t// Specular shading.\n\t\t\t\t\t\t\tvec3 reflectedLightDir = reflect(lightDir, normal);\n\t\t\t\t\t\t\tvec3 halfVector = normalize(-lightDir - positionDir);\n\t\t\t\t\t\t\tfloat phongHighlight = 0.25 * pow(saturate(-dot(reflectedLightDir, positionDir)), specularHardness / 2.0);\n\t\t\t\t\t\t\tfloat blinnHighlight = 4.0 * pow(saturate(dot(halfVector, normal)), specularHardness);\n\t\t\t\t\t\t\tfloat specularAngle = phongHighlight + pow(1.0 - saturate(-dot(positionDir, normal)), specularHardness / 12.0) * blinnHighlight;\n\t\t\t\t\t\t\tspecularLight += saturate(lightCosAngle * 20.0) * specularAngle * incomingLight;\n\n\t\t\t\t\t\t\t// Atmosphere shading.\n\t\t\t\t\t\t\t#ifdef atmosphere\n\t\t\t\t\t\t\t\tif (length(lightPositions[i]) > 0.0) { // don't use a camera light\n\t\t\t\t\t\t\t\t\tatmosphereColor += getAtmosphereColor(atmosphereInfo, incomingLight, lightPositions[i]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdiffuseLight = saturate(diffuseLight);\n\n\t\t\t\t\t\t// If there's ambience, remove the direct light components.\n\t\t\t\t\t\tspecularLight *= vec3(1, 1, 1) - ambientLightColor;\n\n\t\t\t\t\t\t// Main Color map.\n\t\t\t\t\t\tvec4 colorPixel = vec4(1, 0, 1, 1);\n\t\t\t\t\t\t#ifdef colorTextureEnvironment\n\t\t\t\t\t\t\tcolorPixel = getColorFromEnvironmentMap(colorTexture, positionDir, normal);\n\t\t\t\t\t\t#else\n\t\t\t\t\t\t\tcolorPixel = texture(colorTexture, vColorUV) * color;\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\t#ifdef baseColor\n\t\t\t\t\t\t\tcolorPixel = color;\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t// Apply diffuse shading.\n\t\t\t\t\t\t#ifndef colorMapEmissive\n\t\t\t\t\t\t\tcolorPixel *= vec4(diffuseLight, 1.0);\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\tpc_fragColor = colorPixel;\n\n\t\t\t\t\t\t// Specular Map\n\t\t\t\t\t\tvec3 specularPixel = specularColor * specularIntensity;\n\t\t\t\t\t\t#ifdef specularMap\n\t\t\t\t\t\t\t#ifdef specularUVs\n\t\t\t\t\t\t\t\tvec2 specularUV = vSpecularUV;\n\t\t\t\t\t\t\t#else\n\t\t\t\t\t\t\t\tvec2 specularUV = vColorUV;\n\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t\tspecularPixel = specularColor * texture(specularTexture, specularUV).r;\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t// Apply specular Shading\n\t\t\t\t\t\tpc_fragColor.rgb += specularLight * specularPixel;\n\n\t\t\t\t\t\t// Night-Side Map\n\t\t\t\t\t\t#ifdef nightMap\n\t\t\t\t\t\t\t#ifdef nightUVs\n\t\t\t\t\t\t\t\tvec2 nightUV = vNightUV;\n\t\t\t\t\t\t\t#else\n\t\t\t\t\t\t\t\tvec2 nightUV = vColorUV;\n\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t\tvec4 nightPixel = texture(nightTexture, nightUV);\n\t\t\t\t\t\t\t#ifndef nightMapEmissive\n\t\t\t\t\t\t\t\tnightPixel *= vec4(diffuseLight, 1.0);\n\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t\tpc_fragColor = mix(pc_fragColor, nightPixel, 1.0 - min(1.0, 3.0 * length(diffuseLight)));\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t// Decal Map\n\t\t\t\t\t\t#ifdef decalMap\n\t\t\t\t\t\t\t#ifdef decalUVs\n\t\t\t\t\t\t\t\tvec2 decalUV = vDecalUV;\n\t\t\t\t\t\t\t#else\n\t\t\t\t\t\t\t\tvec2 decalUV = vColorUV;\n\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t\tvec4 decalPixel = texture(decalTexture, decalUV);\n\t\t\t\t\t\t\t#ifndef decalMapEmissive\n\t\t\t\t\t\t\t\tdecalPixel *= vec4(diffuseLight, 1.0);\n\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t\tpc_fragColor.rgb = mix(pc_fragColor.rgb, decalPixel.rgb, decalPixel.a);\n\t\t\t\t\t\t\tpc_fragColor.a = 1.0 - (1.0 - pc_fragColor.a) * (1.0 - decalPixel.a);\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t// Atmosphere\n\t\t\t\t\t\t#ifdef atmosphere\n\t\t\t\t\t\t\tpc_fragColor.rgb = mix(pc_fragColor.rgb, atmosphereColor.rgb, clamp(atmosphereColor.a, 0.0, 1.0));\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t${s.ShaderChunkLogDepth.Fragment}\n\t\t\t\t\t}`
            }));
            const t = s.ThreeJsHelper.cloneMaterial(MaterialUtilsPhong._material);
            return t.needsUpdate = !0,
            t
        }
        static _material = null
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        MaterialUtilsStandard: function() {
            return MaterialUtilsStandard
        }
    });
    var s = i(6);
    class MaterialUtilsStandard {
        static get() {
            null === MaterialUtilsStandard._material && (MaterialUtilsStandard._material = new s.THREE.ShaderMaterial({
                uniforms: {
                    ambientLightColor: new s.THREE.Uniform(new s.THREE.Color),
                    lightPositions: new s.THREE.Uniform([new s.THREE.Vector3(1,0,0), new s.THREE.Vector3(1,0,0), new s.THREE.Vector3(1,0,0), new s.THREE.Vector3(1,0,0), new s.THREE.Vector3(1,0,0)]),
                    lightColors: new s.THREE.Uniform([new s.THREE.Vector3(0,0,0), new s.THREE.Vector3(0,0,0), new s.THREE.Vector3(0,0,0), new s.THREE.Vector3(0,0,0), new s.THREE.Vector3(0,0,0)]),
                    lightRadii: new s.THREE.Uniform([0, 0, 0, 0, 0]),
                    numLights: new s.THREE.Uniform(0),
                    environmentIntensity: new s.THREE.Uniform(1),
                    gammaCorrectionFactor: new s.THREE.Uniform(1),
                    entityPos: new s.THREE.Uniform(new s.THREE.Vector3),
                    color: new s.THREE.Uniform(new s.THREE.Color(1,1,1)),
                    metalness: new s.THREE.Uniform(0),
                    roughness: new s.THREE.Uniform(0),
                    emissiveColor: new s.THREE.Uniform(new s.THREE.Color(0,0,0)),
                    alphaMultiplier: new s.THREE.Uniform(1),
                    alphaTest: new s.THREE.Uniform(.5),
                    colorTexture: new s.THREE.Uniform(null),
                    roughnessTexture: new s.THREE.Uniform(null),
                    metalnessTexture: new s.THREE.Uniform(null),
                    normalTexture: new s.THREE.Uniform(null),
                    emissiveTexture: new s.THREE.Uniform(null),
                    uvTransform: new s.THREE.Uniform(new s.THREE.Matrix3),
                    numShadowEntities: new s.THREE.Uniform(0),
                    shadowEntityPositions: new s.THREE.Uniform([new s.THREE.Vector3, new s.THREE.Vector3, new s.THREE.Vector3, new s.THREE.Vector3, new s.THREE.Vector3, new s.THREE.Vector3, new s.THREE.Vector3]),
                    shadowEntityRadii: new s.THREE.Uniform([0, 0, 0, 0, 0, 0, 0]),
                    shadowEntitySunsetIntensity: new s.THREE.Uniform([0, 0, 0, 0, 0, 0, 0]),
                    shadowEntitySunsetColors: new s.THREE.Uniform([new s.THREE.Vector3, new s.THREE.Vector3, new s.THREE.Vector3, new s.THREE.Vector3, new s.THREE.Vector3, new s.THREE.Vector3, new s.THREE.Vector3]),
                    envTexture: new s.THREE.Uniform(null),
                    maxMipLevel: new s.THREE.Uniform(0),
                    dynEnvTexture: new s.THREE.Uniform(null),
                    dynEnvFaceSize: new s.THREE.Uniform(0),
                    normalScale: new s.THREE.Uniform(new s.THREE.Vector2(1,1)),
                    ...s.ShaderChunkLogDepth.ThreeUniforms
                },
                vertexShader: `\n\t\t\t\t\t#ifdef normalMap\n\t\t\t\t\t\tin vec4 tangent;\n\t\t\t\t\t\tout vec4 localTangent;\n\t\t\t\t\t\tout vec3 localNormal;\n\t\t\t\t\t#else\n\t\t\t\t\t\tout vec3 modelNormal;\n\t\t\t\t\t#endif\n\t\t\t\t\t#if defined(normalMap) || defined(colorMap) || defined(roughnessMap) || defined(metalnessMap) || defined(emissiveMap)\n\t\t\t\t\t\tuniform mat3 uvTransform;\n\t\t\t\t\t\tout vec2 localUV;\n\t\t\t\t\t#endif\n\t\t\t\t\tout vec3 cameraSpacePosition;\n\n\t\t\t\t\t${s.ShaderChunkLogDepth.VertexHead}\n\n\t\t\t\t\tvoid main() {\n\t\t\t\t\t\t#ifdef normalMap\n\t\t\t\t\t\t\tlocalTangent = tangent;\n\t\t\t\t\t\t\tlocalNormal = normal;\n\t\t\t\t\t\t#else\n\t\t\t\t\t\t\tmodelNormal = normalize((modelMatrix * vec4(normal, 0.)).xyz);\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\t#if defined(normalMap) || defined(colorMap) || defined(roughnessMap) || defined(metalnessMap) || defined(emissiveMap)\n\t\t\t\t\t\t\tlocalUV = (uvTransform * vec3(uv, 1)).xy;\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\tcameraSpacePosition = (modelMatrix * vec4(position, 1.)).xyz;\n\t\t\t\t\t\tvec4 viewPosition = modelViewMatrix * vec4(position, 1.);\n\t\t\t\t\t\tgl_Position = projectionMatrix * viewPosition;\n\n\t\t\t\t\t\t${s.ShaderChunkLogDepth.Vertex}\n\t\t\t\t\t}`,
                fragmentShader: `\n\t\t\t\t\tprecision highp float;\n\n\t\t\t\t\t#define DEFAULT_SPECULAR_COEFFICIENT 0.04\n\t\t\t\t\t#define EPSILON 1e-6\n\t\t\t\t\t#define PI 3.14159265359\n\t\t\t\t\t#define RECIPROCAL_PI 0.31830988618\n\t\t\t\t\t#define RECIPROCAL_PI2 0.15915494\n\t\t\t\t\t#ifndef saturate\n\t\t\t\t\t\t#define saturate(a) clamp( a, 0.0, 1.0 )\n\t\t\t\t\t#endif\n\n\t\t\t\t\tfloat pow2( float x ) { return x*x; }\n\n\t\t\t\t\tuniform mat4 modelMatrix;\n\n\t\t\t\t\t// Lights\n\t\t\t\t\tuniform vec3 ambientLightColor;\n\t\t\t\t\tuniform vec3 lightPositions[5];\n\t\t\t\t\tuniform vec3 lightColors[5];\n\t\t\t\t\tuniform float lightRadii[5];\n\t\t\t\t\tuniform int numLights;\n\t\t\t\t\tuniform float environmentIntensity;\n\t\t\t\t\tuniform float gammaCorrectionFactor;\n\n\t\t\t\t\t// External lighting and camera.\n\t\t\t\t\tuniform vec3 entityPos;\n\n\t\t\t\t\t// Textures.\n\t\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\t\tuniform sampler2D roughnessTexture;\n\t\t\t\t\tuniform sampler2D metalnessTexture;\n\t\t\t\t\t#ifdef normalMap\n\t\t\t\t\t\tuniform sampler2D normalTexture;\n\t\t\t\t\t#endif\n\t\t\t\t\t#ifdef emissiveMap\n\t\t\t\t\t\tuniform sampler2D emissiveTexture;\n\t\t\t\t\t#endif\n\t\t\t\t\t#ifdef dynEnvMap\n\t\t\t\t\t\tuniform sampler2D dynEnvTexture;\n\t\t\t\t\t\tuniform float dynEnvFaceSize;\n\t\t\t\t\t#elif defined( envMap )\n\t\t\t\t\t\t#ifdef envIsCube\n\t\t\t\t\t\t\tuniform samplerCube envTexture;\n\t\t\t\t\t\t#else\n\t\t\t\t\t\t\tuniform sampler2D envTexture;\n\t\t\t\t\t\t#endif\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#ifdef normalMap\n\t\t\t\t\t\tuniform vec2 normalScale;\n\t\t\t\t\t#endif\n\n\t\t\t\t\t// Shadow Entities.\n\t\t\t\t\t#ifdef shadowEntities\n\t\t\t\t\t\tuniform int numShadowEntities;\n\t\t\t\t\t\tuniform vec3 shadowEntityPositions[7];\n\t\t\t\t\t\tuniform float shadowEntityRadii[7];\n\t\t\t\t\t\tuniform float shadowEntitySunsetIntensity[7];\n\t\t\t\t\t\tuniform vec3 shadowEntitySunsetColors[7];\n\t\t\t\t\t#endif\n\n\t\t\t\t\t// Scalars\n\t\t\t\t\tuniform vec3 color;\n\t\t\t\t\tuniform float roughness;\n\t\t\t\t\tuniform float metalness;\n\t\t\t\t\tuniform vec3 emissiveColor;\n\t\t\t\t\tuniform float alphaMultiplier;\n\t\t\t\t\t#ifdef alphaTestEnabled\n\t\t\t\t\t\tuniform float alphaTest;\n\t\t\t\t\t#endif\n\n\t\t\t\t\t// The varying attributes.\n\t\t\t\t\t#ifdef normalMap\n\t\t\t\t\t\tin vec4 localTangent;\n\t\t\t\t\t\tin vec3 localNormal;\n\t\t\t\t\t#else\n\t\t\t\t\t\tin vec3 modelNormal;\n\t\t\t\t\t#endif\n\t\t\t\t\t#if defined(normalMap) || defined(colorMap) || defined(roughnessMap) || defined(metalnessMap) || defined(emissiveMap)\n\t\t\t\t\t\tin vec2 localUV;\n\t\t\t\t\t#endif\n\t\t\t\t\tin vec3 cameraSpacePosition;\n\n\t\t\t\t\t${s.ShaderChunkLogDepth.FragmentHead}\n\n\t\t\t\t\tstruct PhysicalMaterial {\n\t\t\t\t\t\tvec3 diffuseColor;\n\t\t\t\t\t\tvec3 specularColor;\n\t\t\t\t\t\tfloat specularRoughness;\n\t\t\t\t\t};\n\t\t\t\t\tstruct IncidentLight {\n\t\t\t\t\t\tvec3 color;\n\t\t\t\t\t\tvec3 direction;\n\t\t\t\t\t};\n\n\t\t\t\t\tstruct ReflectedLight {\n\t\t\t\t\t\tvec3 directDiffuse;\n\t\t\t\t\t\tvec3 directSpecular;\n\t\t\t\t\t\tvec3 indirectDiffuse;\n\t\t\t\t\t\tvec3 indirectSpecular;\n\t\t\t\t\t};\n\n\t\t\t\t\tstruct GeometricContext {\n\t\t\t\t\t\tvec3 normal;\n\t\t\t\t\t\tvec3 viewDir;\n\t\t\t\t\t};\n\n\t\t\t\t\t#ifdef normalMap\n\t\t\t\t\t\tvec3 getNormalFromMap() {\n\t\t\t\t\t\t\tvec3 normal = normalize(localNormal);\n\t\t\t\t\t\t\tvec3 tangent = normalize(localTangent.xyz);\n\t\t\t\t\t\t\tvec3 bitangent = normalize(cross(normal, tangent));\n\t\t\t\t\t\t\tif (localTangent.w < 0.0) {\n\t\t\t\t\t\t\t\tbitangent *= -1.0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmat3 transform = mat3(tangent, bitangent, normal);\n\t\t\t\t\t\t\tvec3 normalFromMap = texture(normalTexture, localUV).rgb * 2.0 - 1.0;\n\t\t\t\t\t\t\tnormalFromMap.xy *= vec2(1, -1);\n\t\t\t\t\t\t\tnormalFromMap.xy *= normalScale;\n\t\t\t\t\t\t\treturn normalize(transform * normalFromMap);\n\t\t\t\t\t\t}\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#ifdef shadowEntities\n\t\t\t\t\t\tvec3 applyRayleighScattering(vec3 color, float amount) {\n\t\t\t\t\t\t\tfloat value = (color.r + color.g + color.b);\n\t\t\t\t\t\t\tif (value > 0.0) {\n\t\t\t\t\t\t\t\tfloat rFactor = 1.0; // 6.3^-4 / 6.3^-4\n\t\t\t\t\t\t\t\tfloat gFactor = 1.602; // 5.6^-4 / 6.3^-4\n\t\t\t\t\t\t\t\tfloat bFactor = 3.228; // 4.7^-4 / 6.3^-4\n\t\t\t\t\t\t\t\tcolor.r *= pow(rFactor, -amount);\n\t\t\t\t\t\t\t\tcolor.g *= pow(gFactor, -amount);\n\t\t\t\t\t\t\t\tcolor.b *= pow(bFactor, -amount);\n\t\t\t\t\t\t\t\tcolor = value * color / (color.r + color.g + color.b);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn color;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvec3 getLightColorFromShadowEntities(vec3 lightColor, vec3 lightDir, vec3 lightPosition, float lightRadius, vec3 normal) {\n\t\t\t\t\t\t\tvec3 color = lightColor;\n\t\t\t\t\t\t\tfor (int i = 0; i < 7; i++) {\n\t\t\t\t\t\t\t\tif (i >= numShadowEntities || lightRadius < 0.0) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tvec3 origin = cameraSpacePosition - shadowEntityPositions[i];\n\t\t\t\t\t\t\t\tvec3 axis = normalize(shadowEntityPositions[i] - lightPosition);\n\t\t\t\t\t\t\t\tfloat sd = dot(origin, axis);\n\t\t\t\t\t\t\t\tif (sd > 0.0) {\n\t\t\t\t\t\t\t\t\tfloat e = length(origin - sd * axis);\n\t\t\t\t\t\t\t\t\tfloat ld = dot(cameraSpacePosition - lightPosition, axis);\n\t\t\t\t\t\t\t\t\tfloat lr = lightRadius;\n\t\t\t\t\t\t\t\t\tfloat sr = shadowEntityRadii[i];\n\t\t\t\t\t\t\t\t\tfloat e0 = (ld * sr - sd * lr) / (ld - sd);\n\t\t\t\t\t\t\t\t\tfloat e1 = (ld * sr + sd * lr) / (ld - sd);\n\t\t\t\t\t\t\t\t\tfloat lightLevel = 0.0;\n\t\t\t\t\t\t\t\t\tif (e1 < 0.0 || sd < 0.0) { // light in front of shadow entity\n\t\t\t\t\t\t\t\t\t\tlightLevel = 1.0;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse if (e0 < e1) {\n\t\t\t\t\t\t\t\t\t\te0 -= (e1 - e0) * saturate(shadowEntitySunsetIntensity[i] / 3.0);\n\t\t\t\t\t\t\t\t\t\tlightLevel = pow(saturate((e - e0) / (e1 - e0)), 0.5); // soft light\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\tlightLevel = e < e0 ? 0.0 : 1.0; // 0 radius light.\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcolor = lightLevel * mix(color, shadowEntitySunsetColors[i], (1.0 - lightLevel) * saturate(shadowEntitySunsetIntensity[i]));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn color;\n\t\t\t\t\t\t}\n\t\t\t\t\t#endif\n\n\t\t\t\t\tvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\t\t\t\t\t\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n\t\t\t\t\t}\n\n\t\t\t\t\t// These use optimizations found in https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf.\n\n\t\t\t\t\t// The Smith-method geometry function. Calculates the ratio of incident light that is blocked by the microfacets to never reach the viewer.\n\t\t\t\t\t// alpha is the roughness^2\n\t\t\t\t\t// dotNL is the normal Â· the light vector.\n\t\t\t\t\t// dotNV is the normal Â· the view vector.\n\t\t\t\t\tfloat G_GGX_SmithCorrelated( float alpha, float dotNL, float dotNV ) {\n\t\t\t\t\t\tfloat a2 = pow2( alpha );\n\t\t\t\t\t\t// Get the light direction part of the geometry function.\n\t\t\t\t\t\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\t\t\t\t\t\t// Get the view direction part of the geometry function.\n\t\t\t\t\t\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\t\t\t\t\t\t// It would normally be be gv * gl, but this is using an optimization by Heitz (2014),\n\t\t\t\t\t\t// including the BRDF denominator, simplifying the results.\n\t\t\t\t\t\treturn 0.5 / max( gv + gl, EPSILON );\n\t\t\t\t\t}\n\n\t\t\t\t\t// The Trowbridge-Reitz normal distribution function. Calculates the relative surface area microfacets exactly aligned to the halfway vector, how "smooth" the surface is.\n\t\t\t\t\t// alpha is the roughness^2.\n\t\t\t\t\t// dotNH is the normal Â· the halfway vector.\n\t\t\t\t\tfloat D_GGX( float alpha, float dotNH ) {\n\t\t\t\t\t\tfloat a2 = pow2( alpha );\n\t\t\t\t\t\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\t\t\t\t\t\treturn RECIPROCAL_PI * a2 / pow2( denom );\n\t\t\t\t\t}\n\n\t\t\t\t\t// The Schlick approximation for the Fresnel equation.\n\t\t\t\t\t// Since metallic and non-metallic surfaces have different equations, this function combines the two by approximation.\n\t\t\t\t\t// specularColor is the specular color at normal incidence.\n\t\t\t\t\t// dotLH is the light direction Â· the halfway vector.\n\t\t\t\t\tvec3 F_Schlick( vec3 specularColor, float dotLH ) {\n\t\t\t\t\t\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\t\t\t\t\t\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n\t\t\t\t\t}\n\n\t\t\t\t\t// The specular part of the main BRDF function that describes the weighting function for the sum of every incoming light.\n\t\t\t\t\t// It uses the Cook-Torrance model.\n\t\t\t\t\tvec3 BRDF_Specular_GGX( IncidentLight incidentLight, GeometricContext geometry, vec3 specularColor, float roughness ) {\n\t\t\t\t\t\tfloat alpha = pow2( roughness );\n\t\t\t\t\t\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\t\t\t\t\t\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\t\t\t\t\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\t\t\t\t\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\t\t\t\t\t\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\t\t\t\t\t\tvec3 F = F_Schlick( specularColor, dotLH );\n\t\t\t\t\t\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\t\t\t\t\tfloat D = D_GGX( alpha, dotNH );\n\t\t\t\t\t\treturn F * ( G * D );\n\t\t\t\t\t}\n\n\t\t\t\t\t// The diffuse part of the main BRDF function.\n\t\t\t\t\tvec3 BRDF_Diffuse_Lambert( vec3 diffuseColor ) {\n\t\t\t\t\t\treturn RECIPROCAL_PI * diffuseColor;\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat BlinnExponentToGGXRoughness( float blinnExponent ) {\n\t\t\t\t\t\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat GGXRoughnessToBlinnExponent( float ggxRoughness ) {\n\t\t\t\t\t\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n\t\t\t\t\t}\n\n\t\t\t\t\tvec2 integrateSpecularBRDF( float dotNV, float roughness ) {\n\t\t\t\t\t\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\t\t\t\t\t\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\t\t\t\t\t\tvec4 r = roughness * c0 + c1;\n\t\t\t\t\t\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\t\t\t\t\t\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n\t\t\t\t\t}\n\n\t\t\t\t\tvec3 BRDF_Specular_GGX_Environment( GeometricContext geometry, vec3 specularColor, float roughness ) {\n\t\t\t\t\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\t\t\t\t\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\t\t\t\t\t\treturn specularColor * brdf.x + brdf.y;\n\t\t\t\t\t}\n\n\t\t\t\t\tvoid BRDF_Specular_Multiscattering_Environment( GeometricContext geometry, vec3 specularColor, float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\t\t\t\t\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\t\t\t\t\tvec3 F = F_Schlick( specularColor, dotNV );\n\t\t\t\t\t\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\t\t\t\t\t\tvec3 FssEss = F * brdf.x + brdf.y;\n\t\t\t\t\t\tfloat Ess = brdf.x + brdf.y;\n\t\t\t\t\t\tfloat Ems = 1.0 - Ess;\n\t\t\t\t\t\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\t\t\t\t\t\tsingleScatter += FssEss;\n\t\t\t\t\t\tmultiScatter += Fms * Ems;\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat opacity = 1.0;\n\n\t\t\t\t\tuniform float reflectivity;\n\t\t\t\t\tuniform int maxMipLevel;\n\n\t\t\t\t\t// Returns the radiance: the incoming light * the cos(light angle to the normal)\n\t\t\t\t\tvec3 getIncomingLight( IncidentLight directLight, GeometricContext geometry) {\n\t\t\t\t\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\t\t\t\t\treturn (dotNL * directLight.color);\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat getSpecularMIPLevel( float blinnShininessExponent, int maxMIPLevel ) {\n\t\t\t\t\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\t\t\t\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\t\t\t\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t\t\t\t\t}\n\n\t\t\t\t\t#ifdef envIsCubeUV\n\t\t\t\t\t\t// These defines must match with PMREMGenerator\n\t\t\t\t\t\t#define cubeUV_maxMipLevel 8.0\n\t\t\t\t\t\t#define cubeUV_minMipLevel 4.0\n\t\t\t\t\t\t#define cubeUV_maxTileSize 256.0\n\t\t\t\t\t\t#define cubeUV_minTileSize 16.0\n\t\t\t\t\t\t// These shader functions convert between the UV coordinates of a single face of\n\t\t\t\t\t\t// a cubemap, the 0-5 integer index of a cube face, and the direction vector for\n\t\t\t\t\t\t// sampling a textureCube (not generally normalized ).\n\t\t\t\t\t\tfloat getFace( vec3 direction ) {\n\t\t\t\t\t\t\tvec3 absDirection = abs( direction );\n\t\t\t\t\t\t\tfloat face = - 1.0;\n\t\t\t\t\t\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\t\t\t\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\t\t\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\t\t\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn face;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// RH coordinate system; PMREM face-indexing convention\n\t\t\t\t\t\tvec2 getUV( vec3 direction, float face ) {\n\t\t\t\t\t\t\tvec2 uv;\n\t\t\t\t\t\t\tif ( face == 0.0 ) {\n\t\t\t\t\t\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x ); // pos x\n\t\t\t\t\t\t\t} else if ( face == 1.0 ) {\n\t\t\t\t\t\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y ); // pos y\n\t\t\t\t\t\t\t} else if ( face == 2.0 ) {\n\t\t\t\t\t\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z ); // pos z\n\t\t\t\t\t\t\t} else if ( face == 3.0 ) {\n\t\t\t\t\t\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x ); // neg x\n\t\t\t\t\t\t\t} else if ( face == 4.0 ) {\n\t\t\t\t\t\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y ); // neg y\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z ); // neg z\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn 0.5 * ( uv + 1.0 );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvec3 bilinearCubeUV( sampler2D environmentMap, vec3 direction, float mipInt ) {\n\t\t\t\t\t\t\tfloat face = getFace( direction );\n\t\t\t\t\t\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\t\t\t\t\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\t\t\t\t\t\tfloat faceSize = exp2( mipInt );\n\t\t\t\t\t\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\t\t\t\t\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\t\t\t\t\t\tvec2 f = fract( uv );\n\t\t\t\t\t\t\tuv += 0.5 - f;\n\t\t\t\t\t\t\tif ( face > 2.0 ) {\n\t\t\t\t\t\t\t\tuv.y += faceSize;\n\t\t\t\t\t\t\t\tface -= 3.0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tuv.x += face * faceSize;\n\t\t\t\t\t\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\t\t\t\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\t\t\t\t\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\t\t\t\t\t\tuv *= texelSize;\n\t\t\t\t\t\t\tvec3 tl = texture( environmentMap, uv ).rgb;\n\t\t\t\t\t\t\tuv.x += texelSize;\n\t\t\t\t\t\t\tvec3 tr = texture( environmentMap, uv ).rgb;\n\t\t\t\t\t\t\tuv.y += texelSize;\n\t\t\t\t\t\t\tvec3 br = texture( environmentMap, uv ).rgb;\n\t\t\t\t\t\t\tuv.x -= texelSize;\n\t\t\t\t\t\t\tvec3 bl = texture( environmentMap, uv ).rgb;\n\t\t\t\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\t\t\t\treturn mix( tm, bm, f.y );\n\t\t\t\t\t\t}\n\t\t\t\t\t\t#define r0 1.0\n\t\t\t\t\t\t#define v0 0.339\n\t\t\t\t\t\t#define m0 - 2.0\n\t\t\t\t\t\t#define r1 0.8\n\t\t\t\t\t\t#define v1 0.276\n\t\t\t\t\t\t#define m1 - 1.0\n\t\t\t\t\t\t#define r4 0.4\n\t\t\t\t\t\t#define v4 0.046\n\t\t\t\t\t\t#define m4 2.0\n\t\t\t\t\t\t#define r5 0.305\n\t\t\t\t\t\t#define v5 0.016\n\t\t\t\t\t\t#define m5 3.0\n\t\t\t\t\t\t#define r6 0.21\n\t\t\t\t\t\t#define v6 0.0038\n\t\t\t\t\t\t#define m6 4.0\n\t\t\t\t\t\tfloat roughnessToMip( float roughness ) {\n\t\t\t\t\t\t\tfloat mip = 0.0;\n\t\t\t\t\t\t\tif ( roughness >= r1 ) {\n\t\t\t\t\t\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t\t\t\t\t\t} else if ( roughness >= r4 ) {\n\t\t\t\t\t\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t\t\t\t\t\t} else if ( roughness >= r5 ) {\n\t\t\t\t\t\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t\t\t\t\t\t} else if ( roughness >= r6 ) {\n\t\t\t\t\t\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tmip = - 2.0 * log2( 1.16 * roughness ); // 1.16 = 1.79^0.25\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn mip;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvec4 textureCubeUV( sampler2D environmentMap, vec3 sampleDir, float roughness ) {\n\t\t\t\t\t\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\t\t\t\t\t\tfloat mipF = fract( mip );\n\t\t\t\t\t\t\tfloat mipInt = floor( mip );\n\t\t\t\t\t\t\tvec3 color0 = bilinearCubeUV( environmentMap, sampleDir, mipInt );\n\t\t\t\t\t\t\tif ( mipF == 0.0 ) {\n\t\t\t\t\t\t\t\treturn vec4( color0, 1.0 );\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tvec3 color1 = bilinearCubeUV( environmentMap, sampleDir, mipInt + 1.0 );\n\t\t\t\t\t\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#ifdef dynEnvMap\n\t\t\t\t\t\t// Converts an XY in cylindrical space to a face (z) with coordinates within that face (xy).\n\t\t\t\t\t\tvec3 xyzToUvFace(vec3 xyz, float pixelSize) {\n\t\t\t\t\t\t\t// Figure out which basis we're using.\n\t\t\t\t\t\t\tvec3 basis[3];\n\t\t\t\t\t\t\tfloat face;\n\t\t\t\t\t\t\tif (xyz.x * xyz.x >= xyz.y * xyz.y && xyz.x * xyz.x >= xyz.z * xyz.z) {\n\t\t\t\t\t\t\t\tif (xyz.x >= 0.0) {\n\t\t\t\t\t\t\t\t\tbasis[0] = vec3(0, 1, 0); basis[1] = vec3(0, 0, 1); basis[2] = vec3(1, 0, 0);\n\t\t\t\t\t\t\t\t\tface = 0.0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tbasis[0] = vec3(0, -1, 0); basis[1] = vec3(0, 0, 1); basis[2] = vec3(-1, 0, 0);\n\t\t\t\t\t\t\t\t\tface = 2.0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (xyz.y * xyz.y >= xyz.x * xyz.x && xyz.y * xyz.y >= xyz.z * xyz.z) {\n\t\t\t\t\t\t\t\tif (xyz.y >= 0.0) {\n\t\t\t\t\t\t\t\t\tbasis[0] = vec3(-1, 0, 0); basis[1] = vec3(0, 0, 1); basis[2] = vec3(0, 1, 0);\n\t\t\t\t\t\t\t\t\tface = 1.0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tbasis[0] = vec3(1, 0, 0); basis[1] = vec3(0, 0, 1); basis[2] = vec3(0, -1, 0);\n\t\t\t\t\t\t\t\t\tface = 3.0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (xyz.z >= 0.0) {\n\t\t\t\t\t\t\t\t\tbasis[0] = vec3(0, 1, 0); basis[1] = vec3(-1, 0, 0); basis[2] = vec3(0, 0, 1);\n\t\t\t\t\t\t\t\t\tface = 4.0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tbasis[0] = vec3(0, 1, 0); basis[1] = vec3(1, 0, 0); basis[2] = vec3(0, 0, -1);\n\t\t\t\t\t\t\t\t\tface = 5.0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Convert into the uv basis from the xyz basis.\n\t\t\t\t\t\t\tfloat z = basis[2].x * xyz.x + basis[2].y * xyz.y + basis[2].z * xyz.z;\n\t\t\t\t\t\t\tif (z < 0.0) {\n\t\t\t\t\t\t\t\tz = 1.0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvec2 uv = vec2(\n\t\t\t\t\t\t\t\t(basis[0].x * xyz.x + basis[0].y * xyz.y + basis[0].z * xyz.z) / z,\n\t\t\t\t\t\t\t\t(basis[1].x * xyz.x + basis[1].y * xyz.y + basis[1].z * xyz.z) / z);\n\n\t\t\t\t\t\t\t// Convert from -1 to +1, to 0 to 1.\n\t\t\t\t\t\t\tuv = 0.5 * (uv + vec2(1.0));\n\n\t\t\t\t\t\t\t// Convert to pixel-space.\n\t\t\t\t\t\t\tuv *= pixelSize;\n\n\t\t\t\t\t\t\t// Shrink to ignore 1 pixel borders.\n\t\t\t\t\t\t\tuv.x = (pixelSize - 2.0) / pixelSize * uv.x + 1.0;\n\t\t\t\t\t\t\tuv.y = (pixelSize - 2.0) / pixelSize * uv.y + 1.0;\n\n\t\t\t\t\t\t\t// Convert back to unit-space.\n\t\t\t\t\t\t\tuv /= pixelSize;\n\n\t\t\t\t\t\t\treturn vec3(uv, face);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Gets the dynamic environmental lighting given the outward direction.\n\t\t\t\t\t\tvec3 getEnvLight(vec3 direction, float roughness) {\n\t\t\t\t\t\t\t// Get the mip levels.\n\t\t\t\t\t\t\tfloat mipLevel = pow(roughness, 0.25) * (log2(dynEnvFaceSize) - 2.0);\n\t\t\t\t\t\t\tfloat mipLevel0 = floor(mipLevel);\n\t\t\t\t\t\t\tfloat mipLevel1 = floor(mipLevel) + 1.0;\n\t\t\t\t\t\t\tfloat mipLevelU = mipLevel - mipLevel0;\n\t\t\t\t\t\t\tfloat mipSizeX0 = pow(2.0, -mipLevel0);\n\t\t\t\t\t\t\tfloat mipOffsetY0 = 1.0 - pow(2.0, -mipLevel0);\n\t\t\t\t\t\t\tfloat mipSizeX1 = pow(2.0, -mipLevel1);\n\t\t\t\t\t\t\tfloat mipOffsetY1 = 1.0 - pow(2.0, -mipLevel1);\n\t\t\t\t\t\t\t// Get UV within a mip of cube faces.\n\t\t\t\t\t\t\tvec3 uvFace0 = xyzToUvFace(direction, dynEnvFaceSize * mipSizeX0);\n\t\t\t\t\t\t\tvec3 uvFace1 = xyzToUvFace(direction, dynEnvFaceSize * mipSizeX1);\n\t\t\t\t\t\t\tvec2 faceOffset = vec2(mod(uvFace0.z, 3.0) / 3.0, floor(uvFace0.z / 3.0) / 2.0);\n\t\t\t\t\t\t\tvec2 uvInMip0 = vec2(faceOffset.x + uvFace0.x / 3.0, faceOffset.y + uvFace0.y / 2.0);\n\t\t\t\t\t\t\tvec2 uvInMip1 = vec2(faceOffset.x + uvFace1.x / 3.0, faceOffset.y + uvFace1.y / 2.0);\n\t\t\t\t\t\t\t// Get the UVs within the textures.\n\t\t\t\t\t\t\tvec2 uv0 = vec2(uvInMip0.x * mipSizeX0 * 0.75, 0.5 * uvInMip0.y * mipSizeX0 + mipOffsetY0);\n\t\t\t\t\t\t\tvec2 uv1 = vec2(uvInMip1.x * mipSizeX1 * 0.75, 0.5 * uvInMip1.y * mipSizeX1 + mipOffsetY1);\n\t\t\t\t\t\t\tvec3 color0 = texture(dynEnvTexture, uv0).rgb;\n\t\t\t\t\t\t\tvec3 color1 = texture(dynEnvTexture, uv1).rgb;\n\t\t\t\t\t\t\treturn mix(color0, color1, mipLevelU) * environmentIntensity * ((PI - 1.0) * roughness + 1.0);\n\t\t\t\t\t\t}\n\t\t\t\t\t#endif\n\n\t\t\t\t\tvec3 getLightProbeIndirectRadiance( GeometricContext geometry, float blinnShininessExponent, int maxMIPLevel ) {\n\t\t\t\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t\t\t\t\t#if defined( envMap )\n\t\t\t\t\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\t\t\t\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t\t\t\t\t\tvec3 queryReflectVec = vec3( reflectVec.x, reflectVec.yz );\n\t\t\t\t\t\t\t#ifdef envIsCube\n\t\t\t\t\t\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\t\t\t\t\t\tvec4 envMapColor = textureLod( envTexture, queryReflectVec, specularMIPLevel );\n\t\t\t\t\t\t\t\t#else\n\t\t\t\t\t\t\t\t\tvec4 envMapColor = texture( envTexture, queryReflectVec, specularMIPLevel );\n\t\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t\t#elif defined( envIsCubeUV )\n\t\t\t\t\t\t\t\tvec4 envMapColor = textureCubeUV( envTexture, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));\n\t\t\t\t\t\t\t#else\n\t\t\t\t\t\t\t\tvec2 sampleUV;\n\t\t\t\t\t\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\t\t\t\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t\t\t\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\t\t\t\t\t\tvec4 envMapColor = textureLod( envTexture, sampleUV, specularMIPLevel );\n\t\t\t\t\t\t\t\t#else\n\t\t\t\t\t\t\t\t\tvec4 envMapColor = texture( envTexture, sampleUV, specularMIPLevel );\n\t\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t\treturn envMapColor.rgb * environmentIntensity;\n\t\t\t\t\t\t#else\n\t\t\t\t\t\t\treturn vec3(0, 0, 0);\n\t\t\t\t\t\t#endif\n\t\t\t\t\t}\n\n\t\t\t\t\t// Given the directLight, accumulates onto the reflectedLight the irradiance as the BRDF function.\n\t\t\t\t\tvoid RE_Direct_Physical( IncidentLight directLight, GeometricContext geometry, PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\t\t\t\t\tvec3 irradiance = getIncomingLight( directLight, geometry );\n\t\t\t\t\t\tirradiance *= PI;\n\t\t\t\t\t\tfloat clearCoatDHR = 0.0;\n\t\t\t\t\t\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\t\t\t\t\t\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t\t\t\t\t}\n\n\t\t\t\t\tvoid RE_IndirectDiffuse_Physical( vec3 irradiance, GeometricContext geometry, PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\t\t\t\t\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t\t\t\t\t}\n\n\t\t\t\t\tvoid RE_IndirectSpecular_Physical( vec3 radiance, vec3 irradiance, vec3 clearCoatRadiance, GeometricContext geometry, PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t\t\t\t\t\tfloat clearCoatDHR = 0.0;\n\t\t\t\t\t\tfloat clearCoatInv = 1.0 - clearCoatDHR;\n\t\t\t\t\t\treflectedLight.indirectSpecular += clearCoatInv * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t\t\t\t\t}\n\n\t\t\t\t\t#define RE_Direct RE_Direct_Physical\n\t\t\t\t\t#define Material_BlinnShininessExponent( material ) GGXRoughnessToBlinnExponent( material.specularRoughness )\n\t\t\t\t\t#define RE_IndirectDiffuse RE_IndirectDiffuse_Physical\n\t\t\t\t\t#define RE_IndirectSpecular RE_IndirectSpecular_Physical\n\n\t\t\t\t\tvoid main(void) {\n\t\t\t\t\t\tvec4 diffuseColor = vec4( color, 1.0 );\n\t\t\t\t\t\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\n\t\t\t\t\t\t#ifdef colorMap\n\t\t\t\t\t\t\tvec4 texelColor = texture(colorTexture, localUV);\n\t\t\t\t\t\t\tdiffuseColor *= texelColor;\n\t\t\t\t\t\t\topacity = texelColor.a;\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\t#ifdef alphaTestEnabled\n\t\t\t\t\t\t\tif (opacity < alphaTest) {\n\t\t\t\t\t\t\t\tdiscard;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t// PBR variables\n\t\t\t\t\t\tfloat roughnessFactor;\n\t\t\t\t\t\tfloat metalnessFactor;\n\n\t\t\t\t\t\troughnessFactor = roughness;\n\t\t\t\t\t\t#ifdef roughnessMap\n\t\t\t\t\t\t\troughnessFactor *= texture( roughnessTexture, localUV ).g;\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\tmetalnessFactor = metalness;\n\t\t\t\t\t\t#ifdef metalnessMap\n\t\t\t\t\t\t\tmetalnessFactor *= texture( metalnessTexture, localUV ).b;\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\tPhysicalMaterial material;\n\t\t\t\t\t\tmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\n\t\t\t\t\t\tmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n\t\t\t\t\t\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n\n\t\t\t\t\t\tGeometricContext geometry;\n\t\t\t\t\t\tgeometry.viewDir = -normalize(cameraSpacePosition);\n\t\t\t\t\t\t#ifdef normalMap\n\t\t\t\t\t\t\tgeometry.normal = normalize((modelMatrix * vec4(getNormalFromMap(), 0.)).xyz);\n\t\t\t\t\t\t#else\n\t\t\t\t\t\t\tgeometry.normal = modelNormal;\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t// Env Light\n\t\t\t\t\t\tvec3 irradiance = ambientLightColor;\n\t\t\t\t\t\t#ifdef dynEnvMap\n\t\t\t\t\t\t\tirradiance += getEnvLight(geometry.normal, 1.0);\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\tvec3 radiance = ambientLightColor / 2.0;\n\t\t\t\t\t\t#ifdef dynEnvMap\n\t\t\t\t\t\t\tradiance += getEnvLight(reflect(-geometry.viewDir, geometry.normal), material.specularRoughness);\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t// Add emissivity.\n\t\t\t\t\t\tvec3 totalEmissiveRadiance = emissiveColor;\n\t\t\t\t\t\t#ifdef emissiveMap\n\t\t\t\t\t\t\ttotalEmissiveRadiance *= texture(emissiveTexture, localUV).rgb;\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t// Add direct radiance.\n\t\t\t\t\t\tvec3 totalDirectIrradiance = ambientLightColor / 2.0;\n\t\t\t\t\t\t#ifdef dynEnvMap\n\t\t\t\t\t\t\ttotalDirectIrradiance += getEnvLight(reflect(-geometry.viewDir, geometry.normal), material.specularRoughness);\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t// For each light,\n\t\t\t\t\t\tfor (int i = 0; i < 5; i++) {\n\t\t\t\t\t\t\tif (i >= numLights) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tIncidentLight directLight;\n\t\t\t\t\t\t\tdirectLight.color = lightColors[i];\n\t\t\t\t\t\t\tdirectLight.direction = -normalize(cameraSpacePosition - lightPositions[i]);\n\t\t\t\t\t\t\t#ifdef shadowEntities\n\t\t\t\t\t\t\t\tdirectLight.color = getLightColorFromShadowEntities(directLight.color, directLight.direction, lightPositions[i], lightRadii[i], geometry.normal);\n\t\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t\tRE_Direct(directLight, geometry, material, reflectedLight);\n\n\t\t\t\t\t\t\tradiance += getLightProbeIndirectRadiance(geometry, Material_BlinnShininessExponent(material), maxMipLevel);\n\t\t\t\t\t\t\tRE_IndirectDiffuse(irradiance, geometry, material, reflectedLight);\n\t\t\t\t\t\t\tRE_IndirectSpecular(radiance, irradiance, vec3(0.0), geometry, material, reflectedLight);\n\n\t\t\t\t\t\t\t// Modify env light by total incoming light.\n\t\t\t\t\t\t\ttotalDirectIrradiance += getIncomingLight(directLight, geometry);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Multiply in the direct irradiance.\n\t\t\t\t\t\treflectedLight.indirectSpecular *= totalDirectIrradiance;\n\n\t\t\t\t\t\t// If there's ambience, remove the direct light components.\n\t\t\t\t\t\treflectedLight.directDiffuse *= vec3(1, 1, 1) - ambientLightColor;\n\t\t\t\t\t\treflectedLight.directSpecular *= vec3(1, 1, 1) - ambientLightColor;\n\n\t\t\t\t\t\t// Add the reflected light to the outgoing light.\n\t\t\t\t\t\tvec3 outgoingLight = totalEmissiveRadiance + reflectedLight.directDiffuse + reflectedLight.directSpecular + reflectedLight.indirectDiffuse + reflectedLight.indirectSpecular;\n\n\t\t\t\t\t\t// Set the frag color based on the total outgoing light.\n\t\t\t\t\t\tpc_fragColor = vec4( outgoingLight, opacity );\n\n\t\t\t\t\t\t// Gamma correction\n\t\t\t\t\t\tpc_fragColor = vec4( pow( abs(pc_fragColor.rgb), vec3( 1.0 / gammaCorrectionFactor ) ), pc_fragColor.a );\n\n\t\t\t\t\t\t// Convert to sRGB.\n\t\t\t\t\t\tpc_fragColor = sRGBTransferOETF(pc_fragColor);\n\n\t\t\t\t\t\t// Multiply the alphaMultiplier.\n\t\t\t\t\t\tpc_fragColor.a *= alphaMultiplier;\n\n\t\t\t\t\t\t${s.ShaderChunkLogDepth.Fragment}\n\t\t\t\t\t}`
            }));
            const t = s.ThreeJsHelper.cloneMaterial(MaterialUtilsStandard._material);
            return t.needsUpdate = !0,
            t
        }
        static _material = null
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        MaterialUtils: function() {
            return MaterialUtils
        }
    });
    var s = i(6);
    class MaterialUtils {
        static setLightSourceUniforms(t, e, i) {
            const n = e.getScene()
              , o = s.Color.pool.get();
            let a = 0;
            for (let r = 0, l = n.getNumLightSources(); r < Math.min(l, 5); r++) {
                const l = n.getLightSourceAt(r);
                if (null !== l && l !== e.getComponent(s.LightSourceComponent)) {
                    const e = l.getEntity().getCameraSpacePosition(i)
                      , n = 1;
                    o.mult(l.getColor(), n);
                    const r = null === l.getEntity().getComponent(s.CameraComponent) ? l.getEntity().getOcclusionRadius() : -1;
                    for (let i = 0, s = t.length; i < s; i++)
                        if (void 0 !== t[i].uniforms.lightPositions) {
                            const s = t[i].uniforms.lightPositions.value
                              , n = t[i].uniforms.lightColors.value
                              , l = t[i].uniforms.lightRadii.value;
                            s[a].set(e.x, e.y, e.z),
                            n[a].set(o.r, o.g, o.b),
                            l[a] = r
                        }
                    a += 1
                }
            }
            for (let e = 0, i = t.length; e < i; e++)
                void 0 !== t[e].uniforms.numLights && (t[e].uniforms.numLights.value = a);
            s.Color.pool.release(o)
        }
        static setUniforms(t, e, i, n, o, a) {
            const r = i.getScene().getEngine().getTime()
              , l = i.getScene().getAmbientLightColor();
            MaterialUtils.setLightSourceUniforms(t, i, e);
            for (let c = 0, h = t.length; c < h; c++) {
                const h = t[c]
                  , d = h.uniforms;
                if (h instanceof s.THREE.RawShaderMaterial)
                    void 0 !== d.time && (d.time.value = s.MathUtils.wrap(r, 0, 3600));
                else {
                    const o = i.getCameraSpacePosition(e);
                    d.entityPos.value.set(o.x, o.y, o.z);
                    if (d.ambientLightColor.value.setRGB(l.r, l.g, l.b),
                    void 0 !== n && n.length > 0) {
                        let t = 0;
                        for (let i = 0; i < n.length; i++) {
                            const o = n[i].get()
                              , a = d.shadowEntityRadii.value
                              , r = d.shadowEntitySunsetIntensity.value;
                            if (null !== o) {
                                const i = o.getCameraSpacePosition(e);
                                d.shadowEntityPositions.value[t].set(i.x, i.y, i.z),
                                a[t] = o.getOcclusionRadius();
                                const n = o.getComponent(s.AtmosphereComponent);
                                if (null !== n) {
                                    const e = n.getSunsetColor();
                                    d.shadowEntitySunsetColors.value[t].set(e.r, e.g, e.b),
                                    r[t] = n.getSunsetIntensity()
                                } else
                                    r[t] = 0;
                                t += 1
                            } else
                                a[t] = 0,
                                r[t] = 0
                        }
                        d.numShadowEntities.value = t
                    }
                    if (!0 === t[c].defines.shadowRings) {
                        const t = i.getComponent(s.RingsComponent);
                        if (t && t.isVisible()) {
                            const e = s.Vector3.pool.get();
                            i.getOrientation().getAxis(e, 2),
                            d.shadowRingsInnerRadius.value = t.getInnerRadius(),
                            d.shadowRingsOuterRadius.value = t.getOuterRadius(),
                            d.shadowRingsTexture.value = t.getTopTexture();
                            d.shadowRingsNormal.value.set(e.x, e.y, e.z),
                            s.Vector3.pool.release(e)
                        } else
                            d.shadowRingsTexture.value = null
                    }
                }
                if (null === o || "loaded" !== o.getLoadState().state || o.isExcludedFromCamera(e) || void 0 === d.atmospherePosition)
                    !0 === h.defines.atmosphere && (delete h.defines.atmosphere,
                    h.needsUpdate = !0);
                else {
                    const t = o.getSpheroid()
                      , i = o.getEntity().getCameraSpacePosition(e)
                      , s = o.getEntity().getOrientation()
                      , n = o.getColor()
                      , r = o.getSunsetColor()
                      , l = d.atmospherePosition.value
                      , c = d.atmosphereOrientation.value;
                    l.set(i.x, i.y, i.z),
                    c.set(s.x, s.y, s.z, s.w),
                    null !== t ? (d.atmosphereEquatorialRadius.value = t.getEquatorialRadius(),
                    d.atmospherePolarRadius.value = t.getPolarRadius()) : (d.atmosphereEquatorialRadius.value = 0,
                    d.atmospherePolarRadius.value = 0),
                    d.atmosphereDensity.value = o.getDensity(),
                    d.atmosphereScaleHeight.value = o.getScaleHeight(),
                    d.atmosphereEmissivity.value = o.getEmissivity();
                    const u = d.atmosphereColor.value
                      , p = d.atmosphereSunsetColor.value;
                    u.set(n.r, n.g, n.b),
                    p.set(r.r, r.g, r.b),
                    d.atmosphereSunsetIntensity.value = o.getSunsetIntensity(),
                    d.atmosphereGroundIsSpheroid.value = a ? 1 : 0,
                    void 0 === h.defines.atmosphere && (h.defines.atmosphere = !0,
                    h.needsUpdate = !0)
                }
            }
        }
        static get = s.MaterialUtilsPhong.get;
        static getPBR = s.MaterialUtilsStandard.get
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        SpriteParticles: function() {
            return SpriteParticles
        }
    });
    var s = i(6);
    class SpriteParticles {
        constructor(t) {
            this._component = t,
            this._relativeToEntityOrientation = !0,
            this._offsetArray = new Float32Array(0),
            this._colorArray = new Float32Array(0),
            this._scaleArray = new Float32Array(0),
            this._threeJsGeometry = new s.THREE.InstancedBufferGeometry,
            this._threeJsGeometry.setAttribute("position", new s.THREE.BufferAttribute(new Float32Array([-1, -1, 0, 1, -1, 0, 1, 1, 0, -1, 1, 0]),3)),
            this._threeJsGeometry.setIndex(new s.THREE.BufferAttribute(new Uint16Array([0, 1, 2, 2, 3, 0]),1)),
            this._threeJsGeometry.setAttribute("offset", new s.THREE.InstancedBufferAttribute(this._offsetArray,3)),
            this._threeJsGeometry.setAttribute("color", new s.THREE.InstancedBufferAttribute(this._colorArray,4)),
            this._threeJsGeometry.setAttribute("scale", new s.THREE.InstancedBufferAttribute(this._scaleArray,1)),
            this._threeJsMaterial = this._component.getEntity().getScene().getEngine().getMaterialManager().getPreloaded("sprite_particles"),
            this._threeJsObject = s.ThreeJsHelper.createMeshObjectGivenGeometry(t, this._threeJsMaterial, this._threeJsGeometry)
        }
        getThreeJsObject() {
            return this._threeJsObject
        }
        getThreeJsMaterial() {
            return this._threeJsMaterial
        }
        setParticleOffsets(t) {
            this._setAttribute("offset", t, 3)
        }
        setParticleColors(t) {
            this._setAttribute("color", t, 4)
        }
        setParticleScales(t) {
            this._setAttribute("scale", t, 1)
        }
        getRelativeToEntityOrientation() {
            return this._relativeToEntityOrientation
        }
        setRelativeToEntityOrientation(t) {
            this._relativeToEntityOrientation = t
        }
        prepareForRender(t) {
            s.ThreeJsHelper.setPositionToEntity(this._threeJsObject, this._component.getEntity(), t),
            this._relativeToEntityOrientation && s.ThreeJsHelper.setOrientationToEntity(this._threeJsObject, this._component.getEntity())
        }
        _setAttribute(t, e, i) {
            let n = this._threeJsGeometry.getAttribute(t);
            n instanceof s.THREE.InstancedBufferAttribute && n.count !== e.length / i && (this._offsetArray = new Float32Array(e.length / i * 3),
            this._colorArray = new Float32Array(e.length / i * 4),
            this._scaleArray = new Float32Array(e.length / i * 1),
            this._threeJsGeometry.instanceCount = e.length / i,
            this._threeJsGeometry.setAttribute("offset", new s.THREE.InstancedBufferAttribute(this._offsetArray,3)),
            this._threeJsGeometry.setAttribute("color", new s.THREE.InstancedBufferAttribute(this._colorArray,4)),
            this._threeJsGeometry.setAttribute("scale", new s.THREE.InstancedBufferAttribute(this._scaleArray,1))),
            n = this._threeJsGeometry.getAttribute(t),
            n instanceof s.THREE.InstancedBufferAttribute && (n.copyArray(e),
            n.needsUpdate = !0)
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        TextureLOD: function() {
            return TextureLOD
        }
    });
    var s = i(6);
    class TextureLOD {
        constructor(t) {
            this._engine = t.getEntity().getScene().getEngine(),
            this._component = t,
            this._uniform = null,
            this._url = "",
            this._sizes = [],
            this._currentSize = NaN,
            this._forcedSize = void 0,
            this._loadState = {
                state: "unloaded"
            },
            this._enabled = !0
        }
        setEnabled(t) {
            this._enabled = t
        }
        getUrl() {
            return this._url
        }
        setUrl(t) {
            this._url !== t && (this._url = t,
            this._loadState = {
                state: "unloaded"
            },
            this._currentSize = NaN)
        }
        getUniform() {
            return this._uniform
        }
        setUniform(t) {
            this._uniform !== t && (this._uniform = t,
            this._loadState = {
                state: "unloaded"
            },
            this._currentSize = NaN)
        }
        getSizes() {
            return this._sizes.slice()
        }
        setSizes(t) {
            (this._sizes.length !== t.length || this._sizes.map(( (e, i) => e !== t[i])).reduce(( (t, e) => t || e), !1)) && (this._sizes = [...t],
            this._loadState = {
                state: "unloaded"
            },
            this._currentSize = NaN)
        }
        getCurrentSize() {
            return this._currentSize
        }
        getForcedSize() {
            return this._forcedSize
        }
        setForcedSize(t) {
            this._forcedSize = t
        }
        async getLoadedPromise(t=5) {
            await (0,
            s.waitUntil)(( () => {
                if ("loaded" === this._loadState.state)
                    return !0;
                if ("failed" === this._loadState.state)
                    throw new Error(this._loadState.error);
                return !1
            }
            ), .25, t)
        }
        update() {
            if (!this._enabled || "loading" === this._loadState.state || null === this._uniform)
                return;
            if ("" === this._url || 0 === this._sizes.length || "unloaded" === this._component.getLoadState().state && void 0 === this._forcedSize)
                return void (this._uniform.value && (s.ThreeJsHelper.destroyTexture(this._uniform.value),
                this._uniform.value = null,
                this._currentSize = NaN));
            let t;
            t = void 0 !== this._forcedSize ? this._forcedSize : this._component.getEntity().getGreatestPixelSpaceExtentsRadius();
            let e = 0;
            for (let i = 0, s = this._sizes.length; i < s; i++) {
                const n = this._sizes[i];
                i === s - 1 && (e = i);
                const o = this._engine.getConfig().getValue("maxTextureSize");
                if (n >= t || "number" == typeof o && n >= o && void 0 === this._forcedSize) {
                    e = i;
                    break
                }
            }
            this._currentSize !== this._sizes[e] && (this._currentSize = this._sizes[e],
            this._loadTexture(this._currentSize))
        }
        _loadTexture(t) {
            const e = this._url.replace("$SIZE", t.toString());
            this._loadState.state = "loading",
            s.ThreeJsHelper.loadTexture(this._component, e, !0).then((t => {
                if (!this._enabled || !this._uniform)
                    return s.ThreeJsHelper.destroyTexture(t),
                    void (this._loadState.state = "unloaded");
                this._uniform.value && s.ThreeJsHelper.destroyTexture(this._uniform.value),
                this._uniform.value = t,
                this._loadState.state = "loaded"
            }
            )).catch((t => {
                t instanceof Error && (this._loadState.state = "failed",
                this._loadState.error = t.message)
            }
            ))
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        ThreeJsHelper: function() {
            return ThreeJsHelper
        }
    });
    var s = i(6);
    class ThreeJsHelper {
        static createGeometry(t, e) {
            const i = new s.THREE.BufferGeometry;
            if (e) {
                let e = 0;
                for (let i = 0; i < t.length; i++)
                    e += t[i].dimensions;
                const n = new s.THREE.InterleavedBuffer(new Float32Array(0),e);
                let o = 0;
                for (let e = 0; e < t.length; e++)
                    i.setAttribute(t[e].name, new s.THREE.InterleavedBufferAttribute(n,t[e].dimensions,o)),
                    o += t[e].dimensions
            } else
                for (let e = 0; e < t.length; e++)
                    i.setAttribute(t[e].name, new s.THREE.BufferAttribute(new Float32Array(0),t[e].dimensions));
            return i.setIndex(new s.THREE.BufferAttribute(new Uint16Array(0),1)),
            i
        }
        static setupObject(t, e) {
            e.name = `${t}.${Math.floor(1e4 * Math.random())}`,
            e.matrixAutoUpdate = !1,
            e.frustumCulled = !1,
            e.visible = !1,
            t.getEntity().getScene().getThreeJsScene().add(e)
        }
        static createMeshObjectGivenGeometry(t, e, i) {
            const n = new s.THREE.Mesh(i,e);
            return this.setupObject(t, n),
            n
        }
        static createMeshObject(t, e, i, s) {
            const n = this.createGeometry(i, s);
            return this.createMeshObjectGivenGeometry(t, e, n)
        }
        static destroyGeometry(t, e) {
            const i = e?.getEntity().getScene().getEngine().__getThreeJsRenderer().getContext();
            for (const e of Object.values(t.attributes))
                e instanceof s.THREE.GLBufferAttribute && i?.deleteBuffer(e.buffer);
            t.dispose()
        }
        static destroyObject(t, e) {
            for (; t.children.length > 0; )
                this.destroyObject(t.children[t.children.length - 1]);
            null !== t.parent && t.parent.remove(t),
            t instanceof s.THREE.Mesh && t.geometry instanceof s.THREE.BufferGeometry && this.destroyGeometry(t.geometry, e)
        }
        static destroyMaterial(t, e) {
            if (e) {
                const e = t.uniforms;
                for (const t in e)
                    if (Object.hasOwn(e, t)) {
                        const i = e[t].value;
                        i instanceof s.THREE.Texture && ThreeJsHelper.destroyTexture(i)
                    }
            }
            t.dispose()
        }
        static destroyTexture(t) {
            if (Array.isArray(t.source.data))
                for (let e = 0, i = t.source.data.length; e < i; e++) {
                    const i = t.source.data[e];
                    i instanceof ImageBitmap && i.close()
                }
            else
                t.source.data instanceof ImageBitmap && t.source.data.close();
            t.dispose()
        }
        static destroyRenderTarget(t) {
            t.dispose()
        }
        static destroyAllObjectsAndMaterials(t) {
            const e = t.getThreeJsObjects()
              , i = t.getThreeJsMaterials();
            for (let t = 0; t < e.length; t++)
                this.destroyObject(e[t]);
            for (let t = 0; t < i.length; t++)
                this.destroyMaterial(i[t], !0)
        }
        static setPosition(t, e) {
            if (t)
                if (Array.isArray(t))
                    for (let i = 0, s = t.length; i < s; i++)
                        t[i].position.set(e.x, e.y, e.z);
                else
                    t.position.set(e.x, e.y, e.z)
        }
        static setPositionToEntity(t, e, i, n, o) {
            if (!t)
                return;
            const a = e.getCameraSpacePosition(i)
              , r = s.Vector3.threeJsPool.get();
            if (r.set(a.x, a.y, a.z),
            n) {
                const t = s.Vector3.pool.get();
                !0 === o ? t.rotate(e.getOrientation(), n) : t.copy(n),
                r.x += t.x,
                r.y += t.y,
                r.z += t.z,
                s.Vector3.pool.release(t)
            }
            if (Array.isArray(t))
                for (let e = 0, i = t.length; e < i; e++)
                    t[e].position.copy(r);
            else
                t.position.copy(r);
            s.Vector3.threeJsPool.release(r)
        }
        static setScale(t, e) {
            if (t)
                if (Array.isArray(t))
                    for (let i = 0, s = t.length; i < s; i++)
                        "number" == typeof e ? t[i].scale.set(e, e, e) : t[i].scale.set(e.x, e.y, e.z);
                else
                    "number" == typeof e ? t.scale.set(e, e, e) : t.scale.set(e.x, e.y, e.z)
        }
        static setOrientation(t, e) {
            if (!t)
                return;
            const i = s.Quaternion.threeJsPool.get();
            if (i.set(e.x, e.y, e.z, e.w),
            Array.isArray(t))
                for (let e = 0, s = t.length; e < s; e++)
                    t[e].setRotationFromQuaternion(i);
            else
                t.setRotationFromQuaternion(i);
            s.Quaternion.threeJsPool.release(i)
        }
        static setOrientationToBillboard(t, e) {
            if (!t)
                return;
            const i = s.Quaternion.pool.get()
              , n = s.Vector3.pool.get()
              , o = s.Vector3.pool.get();
            e.getEntity().getOrientation().getAxis(n, 1),
            e.getEntity().getOrientation().getAxis(o, 0),
            o.setNormalTo(n, o),
            i.setFromAxes(o, void 0, n);
            const a = s.Quaternion.threeJsPool.get();
            if (a.set(i.x, i.y, i.z, i.w),
            Array.isArray(t))
                for (let e = 0, i = t.length; e < i; e++)
                    t[e].setRotationFromQuaternion(a);
            else
                t.setRotationFromQuaternion(a);
            s.Quaternion.threeJsPool.release(a),
            s.Quaternion.pool.release(i),
            s.Vector3.pool.release(n),
            s.Vector3.pool.release(o)
        }
        static setOrientationToEntity(t, e, i) {
            if (!t)
                return;
            const n = e.getOrientation()
              , o = s.Quaternion.threeJsPool.get();
            if (void 0 === i)
                o.set(n.x, n.y, n.z, n.w);
            else {
                const t = s.Quaternion.pool.get();
                t.mult(n, i),
                o.set(t.x, t.y, t.z, t.w),
                s.Quaternion.pool.release(t)
            }
            if (Array.isArray(t))
                for (let e = 0, i = t.length; e < i; e++)
                    t[e].setRotationFromQuaternion(o);
            else
                t.setRotationFromQuaternion(o);
            s.Quaternion.threeJsPool.release(o)
        }
        static useInDynEnvMap(t, e) {
            e ? t.layers.enable(1) : t.layers.disable(1)
        }
        static createGLBufferAttribute(t, e, i, n, o) {
            const a = o.getEntity().getScene().getEngine().__getThreeJsRenderer().getContext()
              , r = a.createBuffer()
              , l = "vertex" === t ? a.ARRAY_BUFFER : a.ELEMENT_ARRAY_BUFFER;
            let c;
            l === a.ELEMENT_ARRAY_BUFFER && (c = a.getParameter(a.ELEMENT_ARRAY_BUFFER_BINDING)),
            a.bindBuffer(l, r);
            let h = a.FLOAT
              , d = 4;
            return "unsignedByte" === i ? (h = a.UNSIGNED_BYTE,
            d = 1) : "unsignedShort" === i ? (h = a.UNSIGNED_SHORT,
            d = 2) : "unsignedInt" === i && (h = a.UNSIGNED_INT,
            d = 4),
            a.bufferData(l, e.length * d, a.STATIC_DRAW),
            l === a.ELEMENT_ARRAY_BUFFER && a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, c),
            new s.THREE.GLBufferAttribute(r,h,n,d,e.length / n)
        }
        static updateGLBufferAttribute(t, e, i, s, n, o) {
            const a = o.getEntity().getScene().getEngine().__getThreeJsRenderer().getContext()
              , r = "vertex" === e ? a.ARRAY_BUFFER : a.ELEMENT_ARRAY_BUFFER;
            let l;
            r === a.ELEMENT_ARRAY_BUFFER && (l = a.getParameter(a.ELEMENT_ARRAY_BUFFER_BINDING)),
            a.bindBuffer(r, t.buffer),
            a.bufferSubData(r, s * t.elementSize, i, s, n),
            r === a.ELEMENT_ARRAY_BUFFER && a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, l)
        }
        static setVertices(t, e, i) {
            const n = t.getAttribute(e);
            n instanceof s.THREE.BufferAttribute && (n.array.length === i.length ? (n.copyArray(i),
            n.needsUpdate = !0) : t.setAttribute(e, new s.THREE.BufferAttribute(i,t.getAttribute(e).itemSize)))
        }
        static setIndices(t, e) {
            const i = t.getIndex();
            i && i.array.length === e.length ? (i.copyArray(e),
            i.needsUpdate = !0) : t.setIndex(new s.THREE.BufferAttribute(e,1))
        }
        static computeTangents(t) {
            t.computeTangents()
        }
        static setRenderOrder(t, e) {
            t && (t.renderOrder = e)
        }
        static cloneMaterial(t) {
            const e = t.clone();
            for (const [i,s] of Object.entries(t.uniforms)) {
                const t = s.value;
                e.uniforms[i].value = this._cloneUniformValue(t)
            }
            return e.needsUpdate = !0,
            e
        }
        static _cloneUniformValue(t) {
            if (null === t)
                return null;
            if ("number" == typeof t)
                return t;
            if (Array.isArray(t)) {
                const e = [];
                for (let i = 0; i < t.length; i++)
                    e.push(this._cloneUniformValue(t[i]));
                return e
            }
            return t.clone()
        }
        static async loadTexture(t, e, i) {
            return t.getEntity().getScene().getEngine().getTextureLoader().loadTexture(e, -t.getEntity().getLeastCameraDepth(), i)
        }
        static loadTextureFromCanvas(t) {
            const e = new s.THREE.CanvasTexture(t);
            return e.magFilter = s.THREE.NearestFilter,
            e.minFilter = s.THREE.NearestFilter,
            e.flipY = !1,
            e.needsUpdate = !0,
            e
        }
        static async loadTextureIntoUniform(t, e, i, s) {
            const n = await this.loadTexture(t, i, s);
            e.value && ThreeJsHelper.destroyTexture(e.value),
            e.value = n
        }
        static setOverlay(t, e) {
            t && (t.depthFunc = e ? s.THREE.AlwaysDepth : s.THREE.LessEqualDepth)
        }
        static setTransparent(t, e) {
            t && (t.transparent = e,
            t.depthWrite = !e)
        }
        static setBlending(t, e) {
            if (t) {
                switch (e) {
                case "normal":
                    t.blending = s.THREE.NormalBlending;
                    break;
                case "additive":
                    t.blending = s.THREE.AdditiveBlending;
                    break;
                case "subtractive":
                    t.blending = s.THREE.SubtractiveBlending;
                    break;
                case "multiply":
                    t.blending = s.THREE.MultiplyBlending;
                    break;
                case "custom":
                    t.blending = s.THREE.CustomBlending;
                    break;
                default:
                    t.blending = s.THREE.NoBlending
                }
                t.needsUpdate = !0
            }
        }
        static setDefine(t, e, i) {
            !i || !1 !== t.defines[e] && void 0 !== t.defines[e] ? i || !0 !== t.defines[e] || (delete t.defines[e],
            t.needsUpdate = !0) : (t.defines[e] = !0,
            t.needsUpdate = !0)
        }
        static setUniformNumber(t, e, i) {
            t && (t.uniforms[e].value = i)
        }
        static setUniformVector2(t, e, i) {
            if (!t)
                return;
            t.uniforms[e].value.set(i.x, i.y)
        }
        static setUniformVector3(t, e, i) {
            if (!t)
                return;
            t.uniforms[e].value.set(i.x, i.y, i.z)
        }
        static setUniformColorRGB(t, e, i) {
            if (!t)
                return;
            t.uniforms[e].value.set(i.r, i.g, i.b)
        }
        static setUniformColorRGBA(t, e, i, s=1) {
            if (!t)
                return;
            t.uniforms[e].value.set(i.r, i.g, i.b, i.a * s)
        }
        static setUniformQuaternion(t, e, i) {
            if (!t)
                return;
            t.uniforms[e].value.set(i.x, i.y, i.z, i.w)
        }
        static setUniformTexture(t, e, i) {
            if (!t)
                return;
            const s = t.uniforms[e].value;
            s && ThreeJsHelper.destroyTexture(s),
            t.uniforms[e].value = i
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        Capabilities: function() {
            return Capabilities
        }
    });
    class Capabilities {
        static hasGLExtension(t) {
            if (null === Capabilities._context)
                return !1;
            let e = Capabilities._cache.get(t);
            return void 0 === e && (e = null !== Capabilities._context.getExtension(t),
            Capabilities._cache.set(t, e)),
            e
        }
        static __setContext(t) {
            Capabilities._context = t
        }
        static _cache = new Map;
        static _context = null
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        Config: function() {
            return Config
        }
    });
    class Config {
        constructor() {
            this._valueMap = new Map,
            this._callbacksMap = new Map,
            this.setValue("maxTextureSize", 512),
            this.setValue("fontFamily", "Arial"),
            this.setValue("fontSize", 16),
            this.setValue("gammaCorrection", 1)
        }
        getValue(t) {
            return this._valueMap.get(t)
        }
        setValue(t, e) {
            if (this._valueMap.get(t) !== e) {
                this._valueMap.set(t, e);
                const i = this._callbacksMap.get(t);
                if (i)
                    for (let s = 0; s < i.length; s++)
                        i[s](t, e)
            }
        }
        addEventListener(t, e) {
            let i = this._callbacksMap.get(t);
            void 0 === i && (i = [],
            this._callbacksMap.set(t, i)),
            i.push(e)
        }
        removeEventListener(t, e) {
            const i = this._callbacksMap.get(t);
            if (i)
                for (let t = 0; t < i.length; t++)
                    if (i[t] === e) {
                        i.splice(t, 1);
                        break
                    }
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        Download: function() {
            return Download
        },
        Downloader: function() {
            return Downloader
        }
    });
    var s = i(6);
    class Download {
        constructor(t, e) {
            this.url = t,
            this.actualUrl = e,
            this.progress = 0,
            this.totalBytes = 0,
            this.content = void 0,
            this.mimeType = "",
            this.status = "completed",
            this.errorMessage = ""
        }
    }
    class DownloadData {
        constructor(t, e, i) {
            this.download = new Download(t,e),
            this.type = i,
            this.promise = Promise.resolve(this.download),
            this.resolve = () => {}
            ,
            this.progressCallbacks = [],
            this.request = null
        }
    }
    class Downloader {
        constructor() {
            this._replacements = new Map,
            this._replacementTypes = new Map,
            this._currentDownloads = new Map,
            this._downloadQueue = [],
            this._maxCurrentDownloads = 20
        }
        getReplacement(t) {
            return this._replacements.get(t)
        }
        setReplacement(t, e) {
            this._replacements.set(t, e)
        }
        getReplacementType(t) {
            return this._replacementTypes.get(t)
        }
        setReplacementType(t, e) {
            void 0 !== e ? this._replacementTypes.set(t, e) : this._replacementTypes.delete(t)
        }
        cancel(t, e) {
            const i = this.processUrl(t)
              , s = this._currentDownloads.get(i + (e?.id ?? ""));
            if (s?.request)
                s.request.abort();
            else {
                const t = this._downloadQueue.findIndex(( ([t,e]) => e.download.actualUrl === i));
                if (-1 !== t) {
                    const e = this._downloadQueue[t][1];
                    e.download.content = void 0,
                    e.download.status = "cancelled",
                    this._downloadQueue.splice(t, 1),
                    e.resolve(e.download)
                }
            }
        }
        processUrl(t) {
            let e = t;
            for (const [t,i] of this._replacements)
                e = e.replace(`$${t}`, i);
            return e
        }
        download(t, e, i, n) {
            const o = this.processUrl(t)
              , a = this._currentDownloads.get(o);
            if (a?.promise) {
                if (!this.isType(a, e))
                    throw new Error("Already downloading same URL but with a different type.");
                return n && a.progressCallbacks.push(n),
                a.promise
            }
            const r = this._downloadQueue.findIndex(( ([t,e]) => e.download.actualUrl === o));
            if (-1 !== r) {
                const t = this._downloadQueue[r][1];
                if (!this.isType(t, e))
                    throw new Error("Already downloading same URL but with a different type.");
                return n && t.progressCallbacks.push(n),
                i > this._downloadQueue[r][0] && (this._downloadQueue.splice(r, 1),
                s.Sort.add([i, t], this._downloadQueue, ( (t, e) => t[0] > e[0]), ( (t, e) => t[0] === e[0]))),
                t.promise
            }
            const l = new DownloadData(t,o,e);
            return l.promise = new Promise((t => {
                l.resolve = t,
                s.Sort.add([i, l], this._downloadQueue, ( (t, e) => t[0] > e[0]), ( (t, e) => t[0] === e[0])),
                this.checkDownloadQueue()
            }
            )),
            l.promise
        }
        doRequest(t) {
            const e = this._replacementTypes.get(t.download.url) ?? t.type;
            if ("binary" === e || "text" === e) {
                const i = new XMLHttpRequest;
                i.onload = () => {
                    200 <= i.status && i.status <= 299 ? (t.download.content = i.response,
                    t.download.mimeType = i.getResponseHeader("Content-Type") ?? "application/octet-stream",
                    t.download.status = "completed") : (t.download.content = void 0,
                    t.download.status = "failed",
                    t.download.errorMessage = `Failed to download "${t.download.actualUrl}" (${i.status} ${i.statusText}).`),
                    this.cleanUpDownload(t)
                }
                ,
                i.onprogress = e => {
                    t.download.progress = e.lengthComputable ? e.loaded / e.total : 0,
                    t.download.totalBytes = e.lengthComputable ? e.total : 0;
                    for (const e of t.progressCallbacks)
                        e(t.download)
                }
                ,
                i.onabort = () => {
                    t.download.content = void 0,
                    t.download.status = "cancelled",
                    this.cleanUpDownload(t)
                }
                ,
                i.onerror = () => {
                    t.download.content = void 0,
                    t.download.status = "failed",
                    t.download.errorMessage = `Failed to download "${t.download.actualUrl}" (${i.status} ${i.statusText}).`,
                    this.cleanUpDownload(t)
                }
                ,
                i.responseType = "binary" === e ? "arraybuffer" : "text",
                t.request = i,
                i.open("GET", t.download.actualUrl),
                i.send()
            } else if ("image" === e) {
                const e = document.createElement("img");
                e.onload = () => {
                    const i = t.download.actualUrl.match(/\.([^.]+)$/u)?.[1] ?? "";
                    t.download.content = e,
                    t.download.mimeType = Downloader.mimeTypes[i] ?? "application/octet-stream",
                    t.download.status = "completed",
                    this.cleanUpDownload(t)
                }
                ,
                e.onabort = () => {
                    t.download.content = void 0,
                    t.download.status = "cancelled",
                    this.cleanUpDownload(t)
                }
                ,
                e.onerror = () => {
                    t.download.content = void 0,
                    t.download.status = "failed",
                    t.download.errorMessage = `Failed to download "${t.download.actualUrl}".`,
                    this.cleanUpDownload(t)
                }
                ,
                e.crossOrigin = "anonymous",
                e.src = t.download.actualUrl
            } else if ("video" === e) {
                const e = document.createElement("video")
                  , i = () => {
                    const i = t.download.actualUrl.match(/\.([^.]+)$/u)?.[1] ?? "";
                    t.download.content = e,
                    t.download.mimeType = Downloader.mimeTypes[i] ?? "application/octet-stream",
                    t.download.status = "completed",
                    this.cleanUpDownload(t)
                }
                ;
                e.onload = i,
                e.oncanplaythrough = i,
                e.onabort = () => {
                    t.download.content = void 0,
                    t.download.status = "cancelled",
                    this.cleanUpDownload(t)
                }
                ,
                e.onerror = () => {
                    t.download.content = void 0,
                    t.download.status = "failed",
                    t.download.errorMessage = `Failed to download "${t.download.actualUrl}".`,
                    this.cleanUpDownload(t)
                }
                ,
                e.muted = !0,
                e.playsInline = !0,
                e.loop = !1,
                e.crossOrigin = "anonymous",
                e.src = t.download.actualUrl,
                e.load()
            } else
                "imageBitmap" === e && fetch(t.download.actualUrl).then((e => {
                    if (200 <= e.status && e.status <= 299)
                        return t.download.mimeType = e.headers.get("Content-Type") ?? "application/octet-stream",
                        t.download.status = "completed",
                        e.blob();
                    throw new Error(`Failed to download "${t.download.actualUrl}" (${e.status} ${e.statusText})`)
                }
                )).then((t => createImageBitmap(t, {
                    premultiplyAlpha: "none",
                    colorSpaceConversion: "none"
                }))).then((e => {
                    t.download.content = e,
                    this.cleanUpDownload(t)
                }
                )).catch((e => {
                    t.download.content = void 0,
                    t.download.status = "failed",
                    t.download.errorMessage = e.message,
                    this.cleanUpDownload(t)
                }
                ))
        }
        cleanUpDownload(t) {
            this._currentDownloads.delete(t.download.actualUrl),
            this.checkDownloadQueue(),
            t.resolve(t.download)
        }
        checkDownloadQueue() {
            if (this._currentDownloads.size < this._maxCurrentDownloads) {
                const t = this._downloadQueue.shift()?.[1];
                t && (this._currentDownloads.set(t.download.actualUrl, t),
                this.doRequest(t))
            }
        }
        isType(t, e) {
            return t.type === e
        }
        static mimeTypes = {
            aac: "audio/aac",
            flac: "audio/flac",
            gif: "image/gif",
            jpg: "image/jpeg",
            jpeg: "image/jpeg",
            mid: "audio/mid",
            midi: "audio/midi",
            mp3: "audio/mpeg",
            mp4: "video/mp4",
            png: "image/png",
            svg: "image/svg+xml",
            weba: "audio/webm",
            webm: "video/webm",
            webp: "image/webp"
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        Engine: function() {
            return Engine
        }
    });
    var s = i(6);
    class Engine {
        constructor(t) {
            if (!(t instanceof HTMLDivElement))
                throw new Error("The root div param is not an actual div element.");
            if (this._environment = "development",
            this._rootDiv = t,
            this._renderSize = new s.Vector2,
            this._renderSize.freeze(),
            this._input = new s.Input(this),
            this._config = new s.Config,
            this._downloader = new s.Downloader,
            this._scenes = new s.Collection(this),
            this._viewports = new s.Collection(this),
            this._lastAppTime = Date.now(),
            this._realDeltaTime = 0,
            this._fps = new s.FPS,
            this._fpsLimit = Number.POSITIVE_INFINITY,
            this._time = 0,
            this._timeRate = 0,
            this._callbacks = [],
            this._callbacksToRemove = [],
            this._thisLoop = this._loop.bind(this),
            "relative" !== this._rootDiv.style.position && "absolute" !== this._rootDiv.style.position && (this._rootDiv.style.position = "relative"),
            this._rootDiv.style.userSelect = "none",
            this._rootDiv.style.touchAction = "none",
            this._canvas = document.createElement("canvas"),
            this._canvas.style.position = "absolute",
            this._canvas.style.left = "0px",
            this._canvas.style.top = "0px",
            this._canvas.style.width = "100%",
            this._canvas.style.height = "100%",
            this._rootDiv.appendChild(this._canvas),
            this._viewportDiv = document.createElement("div"),
            this._viewportDiv.style.position = "absolute",
            this._viewportDiv.style.left = "0px",
            this._viewportDiv.style.top = "0px",
            this._viewportDiv.style.width = "100%",
            this._viewportDiv.style.height = "100%",
            this._viewportDiv.style.overflow = "hidden",
            this._rootDiv.appendChild(this._viewportDiv),
            this._threeJsRenderer = new s.THREE.WebGLRenderer({
                antialias: !0,
                canvas: this._canvas
            }),
            !this._threeJsRenderer.capabilities.isWebGL2)
                throw new Error("Your browser does not support WebGL 2. Please upgrade your browser.");
            this._threeJsRenderer.setScissorTest(!0),
            this._threeJsRenderer.setPixelRatio(window.devicePixelRatio),
            this._textureLoader = new s.TextureLoader(this),
            s.THREE.Cache.enabled = !1,
            s.Capabilities.__setContext(this._threeJsRenderer.getContext()),
            this._materialManager = new s.MaterialManager(this._downloader),
            requestAnimationFrame(this._thisLoop)
        }
        getVersion() {
            return s.Version
        }
        getEnvironment() {
            return this._environment
        }
        setEnvironment(t) {
            this._environment = t
        }
        getRootDiv() {
            return this._rootDiv
        }
        getRenderSize() {
            return this._renderSize
        }
        getCanvas() {
            return this._canvas
        }
        getViewportDiv() {
            return this._viewportDiv
        }
        getConfig() {
            return this._config
        }
        getInput() {
            return this._input
        }
        getDownloader() {
            return this._downloader
        }
        getTextureLoader() {
            return this._textureLoader
        }
        getMaterialManager() {
            return this._materialManager
        }
        getScene(t) {
            return this._scenes.get(s.Scene, t)
        }
        getSceneAt(t) {
            return this._scenes.getAt(t)
        }
        getNumScenes() {
            return this._scenes.getSize()
        }
        addScene(t) {
            return this._scenes.add(s.Scene, t)
        }
        removeScene(t) {
            this._scenes.remove(t)
        }
        get(t, e, i, s=0) {
            const n = this._scenes.getAny(t);
            return void 0 === e || null === n ? n : n.get(e, i, s)
        }
        getViewport(t) {
            return this._viewports.get(s.Viewport, t)
        }
        getViewportAt(t) {
            return this._viewports.getAt(t)
        }
        getNumViewports() {
            return this._viewports.getSize()
        }
        addViewport(t) {
            return this._viewports.add(s.Viewport, t)
        }
        removeViewport(t) {
            this._viewports.remove(t)
        }
        getTime() {
            return this._time
        }
        setTime(t) {
            this._time = t
        }
        getTimeRate() {
            return this._timeRate
        }
        setTimeRate(t) {
            this._timeRate = t
        }
        getFPS() {
            return this._fps.getFPS()
        }
        getFPSLimit() {
            return this._fpsLimit
        }
        setFPSLimit(t) {
            this._fpsLimit = t
        }
        getDeltaTime() {
            return this._realDeltaTime
        }
        async waitUntilNextFrame() {
            await new Promise((t => {
                this.addCallback(( () => {
                    t(void 0)
                }
                ), !1)
            }
            ))
        }
        addCallback(t, e) {
            this._callbacks.push({
                callback: t,
                recurring: e
            })
        }
        removeCallback(t) {
            this._callbacksToRemove.push(t)
        }
        __getThreeJsRenderer() {
            return this._threeJsRenderer
        }
        _loop() {
            const t = Date.now();
            if (this._realDeltaTime = (t - this._lastAppTime) / 1e3,
            this._realDeltaTime < 1 / this._fpsLimit)
                requestAnimationFrame(this._thisLoop);
            else {
                this._lastAppTime = t,
                this._fps.update(this._realDeltaTime),
                this._time += this._timeRate * this._realDeltaTime,
                this._renderSize.x === this._rootDiv.clientWidth && this._renderSize.y === this._rootDiv.clientHeight || (this._renderSize.thaw(),
                this._renderSize.set(this._rootDiv.clientWidth, this._rootDiv.clientHeight),
                this._renderSize.freeze(),
                this._threeJsRenderer.setSize(this._renderSize.x, this._renderSize.y, !1));
                for (let t = 0; t < this._scenes.getSize(); t++)
                    this._scenes.getAt(t).__update();
                for (let t = 0; t < this._viewports.getSize(); t++)
                    this._viewports.getAt(t).__updateViewportVariables();
                for (let t = 0; t < this._scenes.getSize(); t++)
                    this._scenes.getAt(t).__updateVisuals();
                this._threeJsRenderer.setViewport(0, 0, this._renderSize.x, this._renderSize.y),
                this._threeJsRenderer.setScissor(0, 0, this._renderSize.x, this._renderSize.y),
                this._threeJsRenderer.clear();
                for (let t = 0; t < this._viewports.getSize(); t++)
                    this._viewports.getAt(t).__render();
                for (let t = 0, e = this._callbacksToRemove.length; t < e; t++)
                    for (let e = 0, i = this._callbacks.length; e < i; e++)
                        if (this._callbacks[e].callback === this._callbacksToRemove[t]) {
                            this._callbacks.splice(e, 1);
                            break
                        }
                this._callbacksToRemove = [];
                for (let t = 0; t < this._callbacks.length; t++)
                    this._callbacks[t].callback(),
                    this._callbacks[t].recurring || this._callbacksToRemove.push(this._callbacks[t].callback);
                this._input.__resetStatesForNextFrame(),
                requestAnimationFrame(this._thisLoop)
            }
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        Entity: function() {
            return Entity
        }
    });
    var s = i(6);
    class Entity extends s.CollectionItem {
        constructor(t, e) {
            super(t, e),
            this._enabled = !0,
            this._disabledByAncestor = !1,
            this._destroyed = !1,
            this._parent = null,
            this._lastParent = null,
            this._children = [],
            this._parentingTable = [],
            this._parentChangedCallbacks = [],
            this._childChangedCallbacks = [],
            this._state = new EntityState,
            this._lastState = new EntityState,
            this._cameraSpacePosition = new s.FastMap,
            this._normalSpacePosition = new s.FastMap,
            this._pixelSpacePosition = new s.FastMap,
            this._normalSpaceExtentsRadius = new s.FastMap,
            this._pixelSpaceExtentsRadius = new s.FastMap,
            this._greatestPixelSpaceExtentsRadius = 0,
            this._cameraDepths = new s.FastMap,
            this._leastCameraDepth = Number.MAX_SAFE_INTEGER,
            this._components = new s.Collection(this),
            this._controllers = new s.Collection(this),
            this._occlusionRadius = 0,
            this._extentsRadius = 0,
            this._groundComponent = null,
            this._canOcclude = !0,
            this._positionCoverage = new s.Interval(Number.NEGATIVE_INFINITY,Number.POSITIVE_INFINITY),
            this._positionCoverage.freeze(),
            this._orientationCoverage = new s.Interval(Number.NEGATIVE_INFINITY,Number.POSITIVE_INFINITY),
            this._orientationCoverage.freeze(),
            this._isInPositionCoverage = !1,
            this._isInOrientationCoverage = !1
        }
        getScene() {
            return this.__getCollectionParent()
        }
        isEnabled() {
            return this._enabled && !this._disabledByAncestor
        }
        isDisabledByAncestor() {
            return this._disabledByAncestor
        }
        setEnabled(t) {
            this._enabled !== t && (this._enabled = t,
            this._updateEnabled())
        }
        _updateEnabled() {
            for (let t = 0; t < this._components.getSize(); t++)
                this._components.getAt(t).__updateLoadState();
            for (let t = 0, e = this._children.length; t < e; t++)
                this._children[t]._updateDisabledByAncestor()
        }
        _updateDisabledByAncestor() {
            let t = !1
              , e = this._parent;
            for (; null !== e; ) {
                if (!e._enabled || e._disabledByAncestor) {
                    t = !0;
                    break
                }
                e = e._parent
            }
            this._disabledByAncestor !== t && (this._disabledByAncestor = t,
            this._updateEnabled())
        }
        isDestroyed() {
            return this._destroyed
        }
        getPosition() {
            return this._state.position
        }
        setPosition(t) {
            this._state.position.thaw(),
            this._state.position.copy(t),
            this._state.position.freeze()
        }
        getVelocity() {
            return this._state.velocity
        }
        setVelocity(t) {
            this._state.velocity.thaw(),
            this._state.velocity.copy(t),
            this._state.velocity.freeze()
        }
        getOrientation() {
            return this._state.orientation
        }
        setOrientation(t) {
            this._state.orientation.thaw(),
            this._state.orientation.copy(t),
            this._state.orientation.freeze()
        }
        getAngularVelocity() {
            return this._state.angularVelocity
        }
        setAngularVelocity(t) {
            this._state.angularVelocity.thaw(),
            this._state.angularVelocity.copy(t),
            this._state.angularVelocity.freeze()
        }
        getLastPosition() {
            return this._lastState.position
        }
        getLastVelocity() {
            return this._lastState.velocity
        }
        getLastOrientation() {
            return this._lastState.orientation
        }
        getLastAngularVelocity() {
            return this._lastState.angularVelocity
        }
        getPositionRelativeToEntity(t, e, i, n) {
            let o = this;
            if (t.copy(e),
            void 0 === n) {
                const e = this.getLowestCommonAncestor(i);
                if (null === e)
                    return void t.copy(s.Vector3.NaN);
                for (; o !== e; ) {
                    t.add(t, o.getPosition());
                    const e = o.getParent();
                    if (null === e)
                        return void t.copy(s.Vector3.NaN);
                    o = e
                }
                const n = s.Vector3.pool.get();
                for (n.copy(s.Vector3.Zero),
                o = i; o !== e; ) {
                    n.add(n, o.getPosition());
                    const e = o.getParent();
                    if (null === e)
                        return t.copy(s.Vector3.NaN),
                        void s.Vector3.pool.release(n);
                    o = e
                }
                t.sub(t, n),
                s.Vector3.pool.release(n)
            } else {
                const e = this.getScene()
                  , a = s.Vector3.pool.get()
                  , r = this.getLowestCommonAncestorAtTime(i, n);
                if (null === r)
                    return t.copy(s.Vector3.NaN),
                    void s.Vector3.pool.release(a);
                for (; o !== r; ) {
                    o.getPositionAtTime(a, n),
                    t.add(t, a);
                    const i = o.getParentAtTime(n)
                      , r = e.getEntity(i);
                    if (null === r)
                        return t.copy(s.Vector3.NaN),
                        void s.Vector3.pool.release(a);
                    o = r
                }
                o = i;
                const l = s.Vector3.pool.get();
                for (l.copy(s.Vector3.Zero); o !== r; ) {
                    o.getPositionAtTime(a, n),
                    l.add(l, a);
                    const i = o.getParentAtTime(n)
                      , r = e.getEntity(i);
                    if (null === r)
                        return t.copy(s.Vector3.NaN),
                        s.Vector3.pool.release(a),
                        void s.Vector3.pool.release(l);
                    o = r
                }
                t.sub(t, l),
                s.Vector3.pool.release(a),
                s.Vector3.pool.release(l)
            }
        }
        getVelocityRelativeToEntity(t, e, i, n) {
            let o = this;
            if (t.copy(e),
            void 0 === n) {
                const e = this.getLowestCommonAncestor(i);
                if (null === e)
                    return void t.copy(s.Vector3.NaN);
                for (t.add(t, o.getVelocity()); o !== e; ) {
                    const e = o.getParent();
                    if (null === e)
                        return void t.copy(s.Vector3.NaN);
                    t.add(t, e.getVelocity()),
                    o = e
                }
                if (null !== i)
                    for (o = i,
                    t.sub(t, o.getVelocity()); o !== e; ) {
                        const e = o.getParent();
                        if (null === e)
                            return void t.copy(s.Vector3.NaN);
                        t.sub(t, e.getVelocity()),
                        o = e
                    }
            } else {
                const e = this.getScene()
                  , a = s.Vector3.pool.get()
                  , r = this.getLowestCommonAncestorAtTime(i, n);
                if (null !== r) {
                    for (o.getVelocityAtTime(a, n),
                    t.add(t, a); o !== r; ) {
                        const i = o.getParentAtTime(n)
                          , r = e.getEntity(i);
                        if (null === r)
                            return void t.copy(s.Vector3.NaN);
                        r.getVelocityAtTime(a, n),
                        t.add(t, a),
                        o = r
                    }
                    if (null !== i)
                        for (o = i,
                        o.getVelocityAtTime(a, n),
                        t.sub(t, a); o !== r; ) {
                            const i = o.getParentAtTime(n)
                              , r = e.getEntity(i);
                            if (null === r)
                                return void t.copy(s.Vector3.NaN);
                            r.getVelocityAtTime(a, n),
                            t.sub(t, a),
                            o = r
                        }
                } else
                    t.copy(s.Vector3.NaN);
                s.Vector3.pool.release(a)
            }
        }
        getPositionAtTime(t, e) {
            if (this.isEnabled()) {
                let i = !0;
                if (void 0 !== e) {
                    t.set(Number.NaN, Number.NaN, Number.NaN);
                    for (let s = 0; s < this._controllers.getSize(); s++) {
                        const n = this._controllers.getAt(s);
                        n.hasModifiedState("position") && n.isEnabled() && (n.getCoverage().contains(e) && n.__updatePositionAtTime(t, e),
                        i = !1)
                    }
                }
                i && t.copy(this._state.position)
            } else
                t.set(Number.NaN, Number.NaN, Number.NaN)
        }
        getVelocityAtTime(t, e) {
            if (this.isEnabled()) {
                let i = !0;
                if (void 0 !== e) {
                    t.set(Number.NaN, Number.NaN, Number.NaN);
                    for (let s = 0; s < this._controllers.getSize(); s++) {
                        const n = this._controllers.getAt(s);
                        n.hasModifiedState("velocity") && n.isEnabled() && (n.getCoverage().contains(e) && n.__updateVelocityAtTime(t, e),
                        i = !1)
                    }
                }
                i && t.copy(this._state.velocity)
            } else
                t.set(Number.NaN, Number.NaN, Number.NaN)
        }
        getOrientationAtTime(t, e) {
            if (this.isEnabled()) {
                let i = !0;
                if (void 0 !== e) {
                    t.set(Number.NaN, Number.NaN, Number.NaN, Number.NaN);
                    for (let s = 0; s < this._controllers.getSize(); s++) {
                        const n = this._controllers.getAt(s);
                        n.hasModifiedState("orientation") && n.isEnabled() && (n.getCoverage().contains(e) && n.__updateOrientationAtTime(t, e),
                        i = !1)
                    }
                }
                i && t.copy(this._state.orientation)
            } else
                t.set(Number.NaN, Number.NaN, Number.NaN, Number.NaN)
        }
        getDistanceTo(t, e) {
            const i = s.Vector3.pool.get()
              , n = s.Vector3.pool.get();
            if (this.getPositionRelativeToEntity(i, s.Vector3.Zero, t),
            n.normalize(i),
            e) {
                const e = this.getGroundComponent();
                if (e) {
                    const t = s.Vector3.pool.get();
                    t.rotateInverse(this.getOrientation(), i),
                    e.getGroundPosition(t, void 0, t),
                    t.rotate(this.getOrientation(), t),
                    i.sub(i, t),
                    s.Vector3.pool.release(t)
                }
                const n = t.getGroundComponent();
                if (n) {
                    const e = s.Vector3.pool.get();
                    e.rotateInverse(t.getOrientation(), i),
                    n.getGroundPosition(e, void 0, e),
                    e.rotate(t.getOrientation(), e),
                    i.sub(i, e),
                    s.Vector3.pool.release(e)
                }
            }
            const o = i.dot(n);
            return s.Vector3.pool.release(n),
            s.Vector3.pool.release(i),
            o
        }
        getOcclusionRadius() {
            return this._occlusionRadius
        }
        getExtentsRadius() {
            return this._extentsRadius
        }
        setOcclusionRadius(t) {
            this._occlusionRadius = t
        }
        setExtentsRadius(t) {
            this._extentsRadius = t
        }
        getGroundComponent() {
            return this._groundComponent
        }
        __updateGroundComponent() {
            this._groundComponent = null;
            for (let t = this._components.getSize() - 1; t >= 0; t--) {
                const e = this._components.getAt(t);
                if (e.isGroundComponent()) {
                    this._groundComponent = e;
                    break
                }
            }
        }
        getPositionCoverage() {
            return this._positionCoverage
        }
        getOrientationCoverage() {
            return this._orientationCoverage
        }
        isInPositionCoverage() {
            return this._isInPositionCoverage
        }
        isInOrientationCoverage() {
            return this._isInOrientationCoverage
        }
        __updateLastState() {
            this._lastState.position.thaw(),
            this._lastState.position.copy(this._state.position),
            this._lastState.position.freeze(),
            this._lastState.velocity.thaw(),
            this._lastState.velocity.copy(this._state.velocity),
            this._lastState.velocity.freeze(),
            this._lastState.orientation.thaw(),
            this._lastState.orientation.copy(this._state.orientation),
            this._lastState.orientation.freeze(),
            this._lastState.angularVelocity.thaw(),
            this._lastState.angularVelocity.copy(this._state.angularVelocity),
            this._lastState.angularVelocity.freeze()
        }
        __updateCoverage() {
            this._positionCoverage.thaw(),
            this._orientationCoverage.thaw(),
            this._positionCoverage.set(Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY),
            this._orientationCoverage.set(Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY);
            let t = 0
              , e = 0;
            for (let i = 0; i < this._controllers.getSize(); i++) {
                const s = this._controllers.getAt(i);
                if (s.isEnabled()) {
                    if (s.getCoverage().isNaN()) {
                        this._positionCoverage.set(NaN, NaN),
                        this._orientationCoverage.set(NaN, NaN),
                        t++,
                        e++;
                        break
                    }
                    s.hasModifiedState("position") && (this._positionCoverage.union(this._positionCoverage, s.getCoverage()),
                    t++),
                    s.hasModifiedState("orientation") && (this._orientationCoverage.union(this._orientationCoverage, s.getCoverage()),
                    e++)
                }
            }
            if (0 === t && this._positionCoverage.set(Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY),
            0 === e && this._orientationCoverage.set(Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY),
            this._parentingTable.length > 0) {
                const t = this._parentingTable[0]
                  , e = this._parentingTable[this._parentingTable.length - 1];
                this._positionCoverage.min = Math.max(this._positionCoverage.min, "" !== t[1] ? t[0] : Number.POSITIVE_INFINITY),
                this._positionCoverage.max = Math.min(this._positionCoverage.max, "" !== e[1] ? Number.POSITIVE_INFINITY : e[0])
            }
            this._positionCoverage.freeze(),
            this._orientationCoverage.freeze()
        }
        canOcclude() {
            return this._canOcclude
        }
        setCanOcclude(t) {
            this._canOcclude = t
        }
        isOccludingPosition(t, e) {
            if (!this._canOcclude || !this.isInPositionCoverage())
                return !1;
            const i = Math.min(this._occlusionRadius, this.getCameraSpacePosition(t).magnitude())
              , n = s.Interval.pool.get();
            s.Geometry.getLineSphereIntersectionWithLineStartAtOrigin(n, e, this.getCameraSpacePosition(t), i);
            const o = n.min + n.max
              , a = n.min < n.max && 0 <= o && o < 2;
            return s.Interval.pool.release(n),
            a
        }
        getParent() {
            return this._parent
        }
        getParentAtTime(t) {
            const e = s.Sort.getIndex(t, this._parentingTable, Entity.isStartTimeLessThanTime);
            return e < this._parentingTable.length && t === this._parentingTable[e][0] ? this._parentingTable[e][1] : e > 0 ? this._parentingTable[e - 1][1] : this._parentingTable.length > 0 ? "" : null !== this._parent ? this._parent.getName() : ""
        }
        setParent(t) {
            if (t === this._parent)
                return;
            if (t) {
                const e = s.Vector3.pool.get();
                this.getPositionRelativeToEntity(e, s.Vector3.Zero, t),
                e.isNaN() || this.setPosition(e),
                s.Vector3.pool.release(e)
            }
            if (null !== this._parent)
                for (let t = 0; t < this._parent._children.length; t++) {
                    this._parent._children[t] === this && this._parent._children.splice(t, 1)
                }
            const e = this._parent;
            this._parent = t,
            null !== this._parent && this._parent._children.push(this),
            this._clearCameraReferences(),
            this._updateDisabledByAncestor();
            for (let t = 0, i = this._parentChangedCallbacks.length; t < i; t++)
                this._parentChangedCallbacks[t](this, e, this._parent);
            if (null !== e)
                for (let t = 0, i = e._childChangedCallbacks.length; t < i; t++)
                    e._childChangedCallbacks[t](e, this, !1);
            if (null !== this._parent)
                for (let t = 0, e = this._parent._childChangedCallbacks.length; t < e; t++)
                    this._parent._childChangedCallbacks[t](this._parent, this, !0)
        }
        _clearCameraReferences() {
            this._cameraSpacePosition.clear(),
            this._normalSpacePosition.clear(),
            this._pixelSpacePosition.clear(),
            this._normalSpaceExtentsRadius.clear(),
            this._pixelSpaceExtentsRadius.clear(),
            this._cameraDepths.clear();
            for (let t = 0, e = this._components.getSize(); t < e; t++) {
                this._components.getAt(t).__clearCameraDependentsBase()
            }
            for (let t = 0, e = this._children.length; t < e; t++)
                this._children[t]._clearCameraReferences()
        }
        getNumChildren() {
            return this._children.length
        }
        getChild(t) {
            return this._children[t]
        }
        getLowestCommonAncestor(t) {
            if (null === t)
                return null;
            let e = this
              , i = t
              , s = 0
              , n = 0;
            for (; ; ) {
                const t = e.getParent();
                if (null === t)
                    break;
                s += 1,
                e = t
            }
            for (; ; ) {
                const t = i.getParent();
                if (null === t)
                    break;
                n += 1,
                i = t
            }
            for (e = this,
            i = t; s > n; )
                s -= 1,
                e = e.getParent();
            for (; n > s; )
                n -= 1,
                i = i.getParent();
            for (; e !== i; ) {
                const t = e.getParent()
                  , s = i.getParent();
                if (!t || !s)
                    return null;
                e = t,
                i = s
            }
            return e
        }
        getLowestCommonAncestorAtTime(t, e) {
            if (null === t)
                return null;
            let i = this
              , s = t
              , n = 0
              , o = 0;
            const a = this.getScene();
            for (; ; ) {
                const t = i.getParentAtTime(e);
                if ("" === t)
                    break;
                const s = a.getEntity(t);
                if (null === s)
                    return null;
                n += 1,
                i = s
            }
            for (; ; ) {
                const t = s.getParentAtTime(e);
                if ("" === t)
                    break;
                const i = a.getEntity(t);
                if (null === i)
                    return null;
                o += 1,
                s = i
            }
            for (i = this,
            s = t; n > o; ) {
                n -= 1;
                const t = i.getParentAtTime(e)
                  , s = a.getEntity(t);
                if (null === s)
                    return null;
                i = s
            }
            for (; o > n; ) {
                o -= 1;
                const t = s.getParentAtTime(e)
                  , i = a.getEntity(t);
                if (null === i)
                    return null;
                s = i
            }
            for (; i !== s && null !== i; ) {
                const t = i.getParentAtTime(e)
                  , n = a.getEntity(t)
                  , o = s.getParentAtTime(e)
                  , r = a.getEntity(o);
                if (!n || !r)
                    return null;
                i = n,
                s = r
            }
            return i
        }
        getNumParentingTableEntries() {
            return this._parentingTable.length
        }
        getParentingTableEntry(t) {
            return this._parentingTable[t]
        }
        addParentingTableEntry(t, e) {
            s.Sort.add([t, e], this._parentingTable, Entity._isStartTimeLess, Entity._isStartTimeEqual),
            this.__updateCoverage()
        }
        removeParentingTableEntry(t) {
            this._parentingTable.splice(t),
            this.__updateCoverage()
        }
        clearParentingTableEntries() {
            this._parentingTable = [],
            this.__updateCoverage()
        }
        addParentChangedCallback(t) {
            this._parentChangedCallbacks.push(t)
        }
        removeParentChangedCallback(t) {
            const e = this._parentChangedCallbacks.indexOf(t);
            -1 !== e && this._parentChangedCallbacks.splice(e, 1)
        }
        addChildChangedCallback(t) {
            this._childChangedCallbacks.push(t)
        }
        removeChildChangedCallback(t) {
            const e = this._childChangedCallbacks.indexOf(t);
            -1 !== e && this._childChangedCallbacks.splice(e, 1)
        }
        getComponent(t, e) {
            return this._components.get(t, e)
        }
        getComponentAt(t) {
            return this._components.getAt(t)
        }
        getNumComponents() {
            return this._components.getSize()
        }
        addComponent(t, e="") {
            const i = this._components.add(t, e);
            return this.__updateGroundComponent(),
            i
        }
        removeComponent(t) {
            this._components.remove(t),
            this.__updateGroundComponent()
        }
        clearComponents() {
            this._components.clear()
        }
        getController(t, e) {
            return this._controllers.get(t, e)
        }
        getControllerAt(t) {
            return this._controllers.getAt(t)
        }
        getNumControllers() {
            return this._controllers.getSize()
        }
        addController(t, e="", i) {
            return this._controllers.add(t, e, i)
        }
        removeController(t) {
            this._controllers.remove(t),
            this.__updateCoverage()
        }
        clearControllers() {
            this._controllers.clear(),
            this.__updateCoverage()
        }
        getCameraSpacePosition(t) {
            const e = this._cameraSpacePosition.get(t);
            return void 0 !== e ? e : s.Vector3.NaN
        }
        getNormalSpacePosition(t) {
            const e = this._normalSpacePosition.get(t);
            return void 0 !== e ? e : s.Vector3.NaN
        }
        getPixelSpacePosition(t) {
            const e = this._pixelSpacePosition.get(t);
            return void 0 !== e ? e : s.Vector2.NaN
        }
        getNormalSpaceOcclusionRadius(t) {
            return 0 !== this._extentsRadius ? this.getNormalSpaceExtentsRadius(t) * this._occlusionRadius / this._extentsRadius : 0
        }
        getNormalSpaceExtentsRadius(t) {
            const e = this._normalSpaceExtentsRadius.get(t);
            return void 0 !== e ? e : Number.NaN
        }
        getPixelSpaceOcclusionRadius(t) {
            return 0 !== this._extentsRadius ? this.getPixelSpaceExtentsRadius(t) * this._occlusionRadius / this._extentsRadius : 0
        }
        getPixelSpaceExtentsRadius(t) {
            const e = this._pixelSpaceExtentsRadius.get(t);
            return void 0 !== e ? e : Number.NaN
        }
        getGreatestPixelSpaceOcclusionRadius() {
            return 0 !== this._extentsRadius ? this.getGreatestPixelSpaceExtentsRadius() * this._occlusionRadius / this._extentsRadius : 0
        }
        getGreatestPixelSpaceExtentsRadius() {
            return this._greatestPixelSpaceExtentsRadius
        }
        getLeastCameraDepth() {
            return this._leastCameraDepth
        }
        __setCameraDependentVariables(t, e, i) {
            const n = t.getViewport();
            if (null === n)
                return;
            let o = this._cameraSpacePosition.get(t);
            void 0 === o ? (o = new s.Vector3,
            this._cameraSpacePosition.set(t, o)) : o.thaw(),
            o.copy(e),
            o.freeze();
            let a = this._normalSpacePosition.get(t);
            void 0 === a ? (a = new s.Vector3,
            this._normalSpacePosition.set(t, a)) : a.thaw(),
            t.getNormalSpacePositionFromCameraSpacePosition(a, o),
            a.freeze();
            let r = this._pixelSpacePosition.get(t);
            void 0 === r ? (r = new s.Vector2,
            this._pixelSpacePosition.set(t, r)) : r.thaw(),
            n.getPixelSpacePositionFromNormalSpacePosition(r, a),
            r.freeze();
            const l = t.getNormalSpaceRadiusFromRadius(this._extentsRadius, o.magnitude());
            this._normalSpaceExtentsRadius.set(t, l);
            const c = n.getPixelSpaceRadiusFromNormalSpaceRadius(l);
            this._pixelSpaceExtentsRadius.set(t, c),
            this._cameraDepths.set(t, i)
        }
        __removeCameraDependents(t) {
            this._cameraSpacePosition.delete(t),
            this._normalSpacePosition.delete(t),
            this._pixelSpacePosition.delete(t),
            this._normalSpaceExtentsRadius.delete(t),
            this._pixelSpaceExtentsRadius.delete(t),
            this._cameraDepths.delete(t);
            for (let e = 0; e < this._components.getSize(); e++)
                this._components.getAt(e).__removeCameraDependentsBase(t)
        }
        get(t, e=0) {
            const i = this._components.getAny(t, e);
            return i || this._controllers.getAny(t, e)
        }
        async getLoadedPromise(t=!1, e=5) {
            const i = [];
            for (let s = 0, n = this._components.getSize(); s < n; s++) {
                const n = this._components.getAt(s);
                i.push(n.getLoadedPromise(t, e).catch((t => {
                    throw new Error(`${n} - ${t.message}`)
                }
                )))
            }
            const s = await Promise.allSettled(i);
            if (!s.every((t => "fulfilled" === t.status)))
                throw new Error(s.filter((t => "rejected" === t.status)).map((t => t.reason instanceof Error ? t.reason.message : "")).filter((t => "" !== t)).reduce(( (t, e) => `${t}\n${e}`), ""))
        }
        async waitTillInPlace(t, e=5) {
            return (0,
            s.waitUntil)(( () => {
                if (this.getPositionCoverage().isNaN() || this.getOrientationCoverage().isNaN())
                    return !1;
                t ??= this.getScene().getEngine().getTime();
                if (!(this.getPositionCoverage().contains(t) && this.getOrientationCoverage().contains(t)))
                    return !0;
                const e = s.Vector3.pool.get()
                  , i = s.Quaternion.pool.get();
                try {
                    return this.getPositionAtTime(e, t),
                    e.isNaN() ? !1 : (this.getOrientationAtTime(i, t),
                    !i.isNaN())
                } finally {
                    s.Quaternion.pool.release(i),
                    s.Vector3.pool.release(e)
                }
            }
            ), .25, e)
        }
        toString() {
            return this.getName()
        }
        __destroy() {
            this._destroyed = !0,
            super.__destroy();
            for (let t = 0; t < this._children.length; t++)
                this._children[t].setParent(null);
            null !== this._parent && this.setParent(null),
            this._controllers.__destroy(),
            this._components.__destroy()
        }
        __updateParent(t) {
            const e = this.getParentAtTime(t);
            if ("" !== e) {
                const t = this.getScene().getEntity(e);
                t !== this._parent && this.setParent(t)
            } else
                null !== this._parent && this.setParent(null);
            this._parent !== this._lastParent && (this.getScene().getControllerDependencyGraph().needsSorting(),
            this._lastParent = this._parent)
        }
        __updateIsInCoverages(t) {
            this._isInPositionCoverage = this._positionCoverage.contains(t),
            this._isInOrientationCoverage = this._orientationCoverage.contains(t);
            for (let t = 0; t < this._components.getSize(); t++)
                this._components.getAt(t).__updateLoadState()
        }
        __updateVisuals() {
            this._greatestPixelSpaceExtentsRadius = 0;
            for (let t = 0, e = this._pixelSpaceExtentsRadius.getSize(); t < e; t++) {
                const e = this._pixelSpaceExtentsRadius.getAt(t).value;
                this._greatestPixelSpaceExtentsRadius < e && (this._greatestPixelSpaceExtentsRadius = e)
            }
            this._leastCameraDepth = Number.MAX_SAFE_INTEGER;
            for (let t = 0, e = this._cameraDepths.getSize(); t < e; t++) {
                const e = this._cameraDepths.getAt(t).value;
                this._leastCameraDepth = Math.min(e, this._leastCameraDepth)
            }
            for (let t = 0, e = this._components.getSize(); t < e; t++) {
                const e = this._components.getAt(t);
                e.isEnabled() && e.__updateBase()
            }
        }
        __updateCameraVariables(t, e, i, n) {
            if (this.isEnabled()) {
                const o = s.Vector3.pool.get();
                null === e ? o.set(0, 0, 0) : i ? o.sub(e.getCameraSpacePosition(t), e.getPosition()) : o.add(e.getCameraSpacePosition(t), this._state.position),
                this.__setCameraDependentVariables(t, o, n),
                this._canOcclude && this.getPixelSpaceOcclusionRadius(t) >= 1 && t.__addToOccludingEntities(this),
                s.Vector3.pool.release(o);
                for (let e = 0, i = this._components.getSize(); e < i; e++) {
                    const i = this._components.getAt(e);
                    i !== t && i.isEnabled() && i.__updateCameraVariablesBase(t)
                }
            }
            null === this._parent || !i && this !== t.getEntity() || this._parent.__updateCameraVariables(t, this, !0, n + 1);
            for (let i = 0, s = this._children.length; i < s; i++) {
                const s = this._children[i];
                s !== e && s.__updateCameraVariables(t, this, !1, n + 1)
            }
        }
        __prepareForRender(t) {
            for (let e = 0, i = this._components.getSize(); e < i; e++) {
                const i = this._components.getAt(e);
                "__render"in i || i.__prepareForRenderBase(t)
            }
        }
        static _isStartTimeLess(t, e) {
            return t[0] < e[0]
        }
        static _isStartTimeEqual(t, e) {
            return t[0] === e[0]
        }
        static isStartTimeLessThanTime(t, e) {
            return t[0] < e
        }
    }
    class EntityState {
        constructor() {
            this.position = new s.Vector3(Number.NaN,Number.NaN,Number.NaN),
            this.position.freeze(),
            this.velocity = new s.Vector3(Number.NaN,Number.NaN,Number.NaN),
            this.velocity.freeze(),
            this.orientation = new s.Quaternion(Number.NaN,Number.NaN,Number.NaN,Number.NaN),
            this.orientation.freeze(),
            this.angularVelocity = new s.Vector3(Number.NaN,Number.NaN,Number.NaN),
            this.angularVelocity.freeze()
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        EntityItem: function() {
            return EntityItem
        }
    });
    var s = i(6);
    class EntityItem extends s.CollectionItem {
        constructor(t, e) {
            super(t, e),
            this._enabled = !0,
            this._destroyed = !1
        }
        getEntity() {
            return this.__getCollectionParent()
        }
        isDestroyed() {
            return this._destroyed
        }
        __destroy() {
            this._destroyed = !0,
            super.__destroy()
        }
        isEnabled() {
            return this._enabled
        }
        setEnabled(t) {
            this._enabled = t
        }
        __update() {}
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        Input: function() {
            return Input
        }
    });
    var s = i(6);
    class Touch {
        constructor() {
            this.identifier = 0,
            this.pressedPosition = new s.Vector2,
            this.pressedTime = 0,
            this.lastFramePosition = new s.Vector2,
            this.thisFramePosition = new s.Vector2
        }
    }
    class Input {
        constructor(t) {
            this._engine = t,
            this._activeViewport = null,
            this._draggedOffset = new s.Vector2,
            this._draggedOffset.freeze(),
            this._zoomedOffset = 0,
            this._rotatedOffset = 0,
            this._shiftPressed = !1,
            this._keysPressed = new Set,
            this._modifierKeysPressed = new Set,
            this._maxSelectTime = .5,
            this._maxSelectDistance = 5,
            this._cursorPosition = new s.Vector2,
            this._selected = !1,
            this._selectedPosition = new s.Vector2,
            this._selectedPosition.freeze(),
            this._touches = [],
            window.addEventListener("blur", ( () => {
                this._touches = [],
                this._keysPressed.clear(),
                this._modifierKeysPressed.clear(),
                this._shiftPressed = !1
            }
            )),
            window.addEventListener("keydown", (t => {
                t.target instanceof HTMLElement && ["INPUT", "SELECT", "TEXTAREA"].includes(t.target.tagName) || ("Shift" === t.key ? this._shiftPressed = !0 : Input._modifierKeys.has(t.key) ? (this._modifierKeysPressed.add(t.key.toLowerCase()),
                this._keysPressed.clear(),
                this._shiftPressed = !1) : 0 === this._modifierKeysPressed.size && this._keysPressed.add(t.key.toLowerCase()))
            }
            )),
            window.addEventListener("keyup", (t => {
                "Shift" === t.key ? this._shiftPressed = !1 : Input._modifierKeys.has(t.key) ? this._modifierKeysPressed.delete(t.key.toLowerCase()) : this._keysPressed.delete(t.key.toLowerCase())
            }
            )),
            this._engine.getRootDiv().addEventListener("mousedown", (t => {
                if (0 === t.button && (document.activeElement instanceof HTMLElement && document.activeElement.blur(),
                0 === this._touches.length)) {
                    const e = this._engine.getRootDiv().getBoundingClientRect();
                    let i = null;
                    for (let t = 0; t < this._touches.length; t++)
                        0 === this._touches[t].identifier && (i = this._touches[t]);
                    null === i && (i = new Touch),
                    i.identifier = 0,
                    i.pressedPosition.set(t.clientX - e.left, t.clientY - e.top),
                    i.pressedTime = Date.now(),
                    i.lastFramePosition.copy(i.pressedPosition),
                    i.thisFramePosition.copy(i.pressedPosition),
                    this._touches.push(i),
                    this._updateActiveViewport()
                }
            }
            )),
            window.addEventListener("mousemove", (t => {
                const e = this._engine.getRootDiv().getBoundingClientRect();
                if (1 === this._touches.length && 0 === this._touches[0].identifier) {
                    const i = this._touches[0];
                    i.thisFramePosition.set(t.clientX - e.left, t.clientY - e.top),
                    this._draggedOffset.thaw(),
                    this._draggedOffset.sub(i.thisFramePosition, i.lastFramePosition);
                    const s = Math.max(Math.abs(i.thisFramePosition.x - i.pressedPosition.x), Math.abs(i.thisFramePosition.y - i.pressedPosition.y));
                    (Date.now() - i.pressedTime) / 1e3 <= this._maxSelectTime && s <= this._maxSelectDistance && this._draggedOffset.set(0, 0),
                    this._draggedOffset.freeze()
                }
                this._touches.length <= 1 && this._cursorPosition.set(t.clientX - e.left, t.clientY - e.top)
            }
            )),
            window.addEventListener("mouseup", (t => {
                if (0 === t.button && 1 === this._touches.length && 0 === this._touches[0].identifier) {
                    const e = this._engine.getRootDiv().getBoundingClientRect()
                      , i = this._touches[0];
                    i.thisFramePosition.set(t.clientX - e.left, t.clientY - e.top);
                    const s = Math.max(Math.abs(i.thisFramePosition.x - i.pressedPosition.x), Math.abs(i.thisFramePosition.y - i.pressedPosition.y));
                    (Date.now() - i.pressedTime) / 1e3 <= this._maxSelectTime && s <= this._maxSelectDistance && (this._selected = !0,
                    this._selectedPosition.thaw(),
                    this._selectedPosition.copy(i.thisFramePosition),
                    this._selectedPosition.freeze()),
                    this._touches.splice(0, 1)
                }
            }
            )),
            this._engine.getRootDiv().addEventListener("wheel", (t => {
                this._zoomedOffset += .1 * t.deltaY,
                t.preventDefault()
            }
            ), {
                passive: !1
            }),
            this._engine.getRootDiv().addEventListener("touchstart", (t => {
                const e = this._engine.getRootDiv().getBoundingClientRect();
                for (let i = 0; i < t.changedTouches.length; i++) {
                    const s = t.changedTouches[i];
                    let n = null;
                    for (let t = 0; t < this._touches.length; t++)
                        this._touches[t].identifier === s.identifier && (n = this._touches[t]);
                    null === n && (n = new Touch),
                    n.identifier = s.identifier,
                    n.pressedPosition.thaw(),
                    n.pressedPosition.set(s.pageX - window.pageXOffset - e.left, s.pageY - window.pageYOffset - e.top),
                    n.pressedPosition.freeze(),
                    n.pressedTime = Date.now(),
                    n.lastFramePosition.copy(n.pressedPosition),
                    n.thisFramePosition.copy(n.pressedPosition),
                    this._touches.push(n),
                    1 === this._touches.length && this._cursorPosition.copy(n.thisFramePosition),
                    this._updateActiveViewport()
                }
            }
            ), {
                passive: !1
            }),
            window.addEventListener("touchmove", (t => {
                const e = this._engine.getRootDiv().getBoundingClientRect();
                for (let i = 0; i < t.changedTouches.length; i++) {
                    const n = t.changedTouches[i];
                    for (let t = 0; t < this._touches.length; t++) {
                        const o = this._touches[t];
                        if (o.identifier === n.identifier)
                            if (o.thisFramePosition.set(n.pageX - window.pageXOffset - e.left, n.pageY - window.pageYOffset - e.top),
                            1 === this._touches.length) {
                                this._draggedOffset.thaw(),
                                this._draggedOffset.sub(o.thisFramePosition, o.lastFramePosition);
                                const t = Math.max(Math.abs(o.thisFramePosition.x - o.pressedPosition.x), Math.abs(o.thisFramePosition.y - o.pressedPosition.y));
                                (Date.now() - o.pressedTime) / 1e3 <= this._maxSelectTime && t <= this._maxSelectDistance && this._draggedOffset.set(0, 0),
                                this._draggedOffset.freeze(),
                                this._cursorPosition.copy(o.thisFramePosition)
                            } else if (2 === this._touches.length) {
                                const t = s.Vector2.pool.get();
                                t.sub(this._touches[i].thisFramePosition, this._touches[1 - i].thisFramePosition);
                                const e = s.Vector2.pool.get();
                                e.sub(this._touches[i].thisFramePosition, this._touches[i].lastFramePosition);
                                const n = e.dot(t) / t.magnitude() / e.magnitude()
                                  , a = e.cross(t) / t.magnitude() / e.magnitude();
                                n < -.7 ? this._zoomedOffset += -(n + .7) * e.magnitude() : n > .7 ? this._zoomedOffset += -(n - .7) * e.magnitude() : Math.abs(a) > .3 && (this._rotatedOffset += a * e.magnitude()),
                                s.Vector2.pool.release(e),
                                s.Vector2.pool.release(t);
                                const r = Math.max(Math.abs(o.thisFramePosition.x - o.pressedPosition.x), Math.abs(o.thisFramePosition.y - o.pressedPosition.y));
                                (Date.now() - o.pressedTime) / 1e3 <= this._maxSelectTime && r <= this._maxSelectDistance && (this._zoomedOffset = 0,
                                this._rotatedOffset = 0)
                            }
                    }
                }
            }
            )),
            window.addEventListener("touchend", (t => {
                const e = this._engine.getRootDiv().getBoundingClientRect();
                for (let i = 0; i < t.changedTouches.length; i++) {
                    const s = t.changedTouches[i];
                    for (let t = 0; t < this._touches.length; t++) {
                        const i = this._touches[t];
                        if (i.identifier === s.identifier) {
                            if (i.thisFramePosition.set(s.pageX - window.pageXOffset - e.left, s.pageY - window.pageYOffset - e.top),
                            1 === this._touches.length) {
                                const t = Math.max(Math.abs(i.thisFramePosition.x - i.pressedPosition.x), Math.abs(i.thisFramePosition.y - i.pressedPosition.y));
                                (Date.now() - i.pressedTime) / 1e3 <= this._maxSelectTime && t <= this._maxSelectDistance && (this._selected = !0,
                                this._selectedPosition.thaw(),
                                this._selectedPosition.copy(i.thisFramePosition),
                                this._selectedPosition.freeze())
                            }
                            this._touches.splice(t, 1)
                        }
                    }
                }
            }
            )),
            window.addEventListener("touchcancel", ( () => {}
            ))
        }
        getActiveViewport() {
            return this._activeViewport
        }
        getDraggedOffset() {
            return this._draggedOffset
        }
        getZoomedOffset() {
            return this._zoomedOffset
        }
        getRotatedOffset() {
            return this._rotatedOffset
        }
        isShiftPressed() {
            return this._shiftPressed
        }
        isKeyPressed(t) {
            return this._keysPressed.has(t)
        }
        isSelected() {
            return this._selected
        }
        getSelectedPosition() {
            return this._selectedPosition
        }
        getCursorPosition() {
            return this._cursorPosition
        }
        __setActiveViewport(t) {
            this._activeViewport = t
        }
        __resetStatesForNextFrame() {
            for (let t = 0; t < this._touches.length; t++)
                this._touches[t].lastFramePosition.copy(this._touches[t].thisFramePosition);
            this._selected = !1,
            this._altSelected = !1,
            this._draggedOffset.thaw(),
            this._draggedOffset.set(0, 0),
            this._draggedOffset.freeze(),
            this._zoomedOffset = 0,
            this._rotatedOffset = 0
        }
        _updateActiveViewport() {
            this._activeViewport = null;
            for (let t = this._engine.getNumViewports() - 1; t >= 0; t--) {
                const e = this._engine.getViewportAt(t)
                  , i = e.getBounds();
                if (e.isEnabled() && i.contains(this._touches[0].pressedPosition)) {
                    this._activeViewport = e;
                    break
                }
            }
        }
        static _modifierKeys = new Set(["Alt", "AltGraph", "CapsLock", "Control", "Fn", "FnLock", "Hyper", "Meta", "NumLock", "ScrollLock", "Shift", "Super", "Symbol", "SymbolLock"])
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        MaterialManager: function() {
            return MaterialManager
        }
    });
    var s = i(6)
      , n = i(55)
      , o = i(56)
      , a = i(57)
      , r = i(58)
      , l = i(59)
      , c = i(60)
      , h = i(61)
      , d = i(62);
    class Resource {
        constructor(t) {
            this.value = t,
            this.useCount = 0
        }
    }
    class MaterialManager {
        constructor(t) {
            this._downloader = t,
            this._cache = new Map,
            this._clonedMaterials = new Map,
            this._promises = new Map,
            this._preload()
        }
        async get(t, e) {
            let i = this._cache.get(t);
            if (void 0 === i) {
                const e = this._promises.get(t);
                void 0 !== e && (i = await e)
            }
            if (void 0 === i) {
                const s = await this._downloader.download(t, "text", e);
                if ("completed" !== s.status || "string" != typeof s.content)
                    throw new Error(`Failed to download material "${t}".`);
                const n = JSON.parse(s.content);
                i = new Resource(this._load(t, n)),
                this._cache.set(t, i)
            }
            i.useCount += 1;
            const n = s.ThreeJsHelper.cloneMaterial(i.value);
            return this._clonedMaterials.set(n, t),
            n
        }
        getPreloaded(t) {
            const e = this._cache.get(t);
            if (void 0 === e)
                throw new Error(`Invalid pre-loaded material "${t}".`);
            e.useCount += 1;
            const i = s.ThreeJsHelper.cloneMaterial(e.value);
            return this._clonedMaterials.set(i, t),
            i
        }
        release(t) {
            const e = this._clonedMaterials.get(t);
            if (void 0 === e)
                return;
            this._clonedMaterials.delete(t);
            const i = this._cache.get(e);
            i && (i.useCount -= 1,
            0 === i.useCount && (s.ThreeJsHelper.destroyMaterial(i.value, !0),
            this._cache.delete(e)))
        }
        _preload() {
            const t = new Map;
            t.set("basic", o.BasicShader),
            t.set("basic_alpha", n.BasicAlphaShader),
            t.set("connected_sprite", a.ConnectedSpriteShader),
            t.set("line", r.LineShader),
            t.set("plumes", l.PlumesShader),
            t.set("sprite", h.SpriteShader),
            t.set("sprite_particles", c.SpriteParticlesShader),
            t.set("trail", d.TrailShader);
            for (const [e,i] of t) {
                const t = this._load(e, i)
                  , s = new Resource(t);
                s.useCount += 1,
                this._cache.set(e, s)
            }
        }
        _load(t, e) {
            try {
                const t = {};
                if (void 0 !== e.uniforms)
                    for (const [i,n] of Object.entries(e.uniforms))
                        ["modelMatrix", "modelViewMatrix", "projectionMatrix", "viewMatrix", "normalMatrix", "cameraPosition"].includes(i) || (t[i] = new s.THREE.Uniform(this._getUniformValueFromType(n)));
                let i = !1
                  , n = !0
                  , o = s.THREE.FrontSide
                  , a = s.THREE.NoBlending;
                if (e.properties) {
                    switch (!0 === e.properties.transparent && (i = !0),
                    !1 === e.properties.depthWrite && (n = !1),
                    e.properties.side) {
                    case "front":
                        o = s.THREE.FrontSide;
                        break;
                    case "back":
                        o = s.THREE.BackSide;
                        break;
                    case "double":
                        o = s.THREE.DoubleSide
                    }
                    switch (e.properties.blending) {
                    case "normal":
                        a = s.THREE.NormalBlending;
                        break;
                    case "additive":
                        a = s.THREE.AdditiveBlending;
                        break;
                    case "subtractive":
                        a = s.THREE.SubtractiveBlending;
                        break;
                    case "multiply":
                        a = s.THREE.MultiplyBlending;
                        break;
                    case "custom":
                        a = s.THREE.CustomBlending
                    }
                }
                if ("object" != typeof e.vertex || "string" != typeof e.vertex.code)
                    throw new Error("Missing vertex stage code.");
                if ("object" != typeof e.fragment || "string" != typeof e.fragment.code)
                    throw new Error("Missing fragment stage code.");
                if (Array.isArray(e.vertex.extensions)) {
                    let t = "";
                    for (const i of e.vertex.extensions)
                        s.Capabilities.hasGLExtension(i) && (t += `#extension GL_${i}: enable\n`);
                    for (const i of e.vertex.extensions)
                        s.Capabilities.hasGLExtension(i) && (t += `#define L_${i} true\n`);
                    e.vertex.code = t + e.vertex.code
                }
                if (Array.isArray(e.fragment.extensions)) {
                    let t = "";
                    for (const i of e.fragment.extensions)
                        s.Capabilities.hasGLExtension(i) && (t += `#extension GL_${i}: enable\n`);
                    for (const i of e.fragment.extensions)
                        s.Capabilities.hasGLExtension(i) && (t += `#define L_${i} true\n`);
                    e.fragment.code = t + e.fragment.code
                }
                const r = new s.THREE.RawShaderMaterial({
                    uniforms: t,
                    vertexShader: e.vertex.code,
                    fragmentShader: e.fragment.code,
                    glslVersion: s.THREE.GLSL3,
                    depthWrite: n,
                    transparent: i,
                    side: o,
                    blending: a
                });
                return r.needsUpdate = !0,
                r
            } catch (e) {
                throw e instanceof Error && (e.message = `While processing material "${t}": ${e.message}`),
                e
            }
        }
        _getUniformValueFromType(t) {
            const e = t.replace(/.* /u, "");
            switch (e) {
            case "int":
            case "float":
                return 0;
            case "ivec2":
            case "vec2":
                return new s.THREE.Vector2(0,0);
            case "ivec3":
            case "vec3":
                return new s.THREE.Vector3(0,0,0);
            case "ivec4":
            case "vec4":
                return new s.THREE.Vector4(0,0,0,0);
            case "mat3":
                return new s.THREE.Matrix3;
            case "mat4":
                return new s.THREE.Matrix4;
            case "sampler2D":
            case "samplerCube":
                return null
            }
            if (e.endsWith("]")) {
                const t = e.indexOf("[")
                  , i = e.indexOf("]")
                  , s = e.substring(0, t)
                  , n = Number.parseInt(e.substring(t + 1, i))
                  , o = [];
                for (let t = 0; t < n; t++)
                    o.push(this._getUniformValueFromType(s));
                return o
            }
            throw new Error(`Unrecognized type: ${e}.`)
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        BasicAlphaShader: function() {
            return n
        }
    });
    var s = i(8);
    const n = {
        uniforms: {
            modelViewMatrix: "mat4",
            projectionMatrix: "highp mat4",
            color: "vec4",
            ...s.ShaderChunkLogDepth.Uniforms
        },
        properties: {
            transparent: !0,
            depthWrite: !1,
            side: "double",
            blending: "normal"
        },
        vertex: {
            code: `\n\t\t\tin vec3 position;\n\t\t\tuniform mat4 modelViewMatrix;\n\t\t\tuniform mat4 projectionMatrix;\n\n\t\t\t${s.ShaderChunkLogDepth.VertexHead}\n\n\t\t\tvoid main() {\n\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\n\t\t\t\t${s.ShaderChunkLogDepth.Vertex}\n\t\t\t}\n\t\t\t`
        },
        fragment: {
            code: `\n\t\t\tprecision highp float;\n\n\t\t\tuniform vec4 color;\n\n\t\t\t// The output color.\n\t\t\tout vec4 outColor;\n\n\t\t\t${s.ShaderChunkLogDepth.FragmentHead}\n\t\n\t\t\tvoid main() {\n\t\t\t\toutColor = color;\n\n\t\t\t\t${s.ShaderChunkLogDepth.Fragment}\n\t\t\t}\n\t\t\t`
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        BasicShader: function() {
            return n
        }
    });
    var s = i(8);
    const n = {
        uniforms: {
            modelViewMatrix: "mat4",
            projectionMatrix: "highp mat4",
            color: "vec4",
            ...s.ShaderChunkLogDepth.Uniforms
        },
        properties: {},
        vertex: {
            code: `\n\t\t\tin vec3 position;\n\t\t\tuniform mat4 modelViewMatrix;\n\t\t\tuniform mat4 projectionMatrix;\n\n\t\t\t${s.ShaderChunkLogDepth.VertexHead}\n\n\t\t\tvoid main() {\n\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\n\t\t\t\t${s.ShaderChunkLogDepth.Vertex}\n\t\t\t}\n\t\t\t`
        },
        fragment: {
            code: `\n\t\t\tprecision highp float;\n\n\t\t\tuniform vec4 color;\n\n\t\t\t// The output color.\n\t\t\tout vec4 outColor;\n\n\t\t\t${s.ShaderChunkLogDepth.FragmentHead}\n\n\t\t\tvoid main() {\n\t\t\t\toutColor = color;\n\n\t\t\t\t${s.ShaderChunkLogDepth.Fragment}\n\t\t\t}\n\t\t\t`
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        ConnectedSpriteShader: function() {
            return n
        }
    });
    var s = i(8);
    const n = {
        uniforms: {
            projectionMatrix: "highp mat4",
            vAxis: "vec3",
            color: "vec4",
            colorTexture: "sampler2D",
            width1: "float",
            width2: "float",
            textureYOffset: "float",
            repeatAmount: "float",
            ...s.ShaderChunkLogDepth.Uniforms
        },
        properties: {
            side: "double",
            transparent: !0,
            depthWrite: !1,
            blending: "normal"
        },
        vertex: {
            code: `\n\t\t\tin vec3 position;\n\n\t\t\tuniform mat4 modelMatrix;\n\t\t\tuniform mat4 viewMatrix;\n\t\t\tuniform mat4 projectionMatrix;\n\n\t\t\tuniform vec3 vAxis;\n\t\t\tuniform float width1;\n\t\t\tuniform float width2;\n\n\t\t\tout vec2 vPosition;\n\t\t\tout float vU;\n\n\t\t\t${s.ShaderChunkLogDepth.VertexHead}\n\n\t\t\tvoid main() {\n\n\t\t\t\t// Get the width and the model origin in world-space.\n\t\t\t\tfloat width = mix(width1, width2, position.z);\n\t\t\t\tvec4 modelPosition = modelMatrix * vec4(0, 0, 0, 1);\n\n\t\t\t\t// Get the vertex position in world space.\n\t\t\t\t// It is a combination of the origin of the model, length axis, and width axis.\n\t\t\t\tvec4 worldPosition = modelPosition\n\t\t\t\t\t+ vec4(vAxis, 0) * position.z\n\t\t\t\t\t+ vec4(normalize(cross(normalize(modelPosition.xyz), normalize(vAxis))), 0) * position.x * width;\n\n\t\t\t\t// Set the final projected position.\n\t\t\t\tgl_Position = projectionMatrix * viewMatrix * worldPosition;\n\n\t\t\t\t// Setup a vPosition and vU for use in the fragment shader.\n\t\t\t\tvPosition = vec2(0.5 * (position.x + 1.0), position.z);\n\t\t\t\t#ifdef PIXEL_BASED\n\t\t\t\t\tvPosition.y *= abs(gl_Position.w);\n\t\t\t\t#endif\n\t\t\t\tvU = position.z;\n\n\t\t\t\t${s.ShaderChunkLogDepth.Vertex}\n\t\t\t}`
        },
        fragment: {
            code: `\n\t\t\tprecision highp float;\n\n\t\t\tuniform vec4 color;\n\t\t\tuniform sampler2D colorTexture;\n\t\t\tuniform float width1;\n\t\t\tuniform float width2;\n\t\t\tuniform float textureYOffset;\n\t\t\tuniform float repeatAmount;\n\n\t\t\tin vec2 vPosition;\n\t\t\tin float vU;\n\n\t\t\t// The output color.\n\t\t\tout vec4 outColor;\n\n\t\t\t${s.ShaderChunkLogDepth.FragmentHead}\n\n\t\t\tvoid main() {\n\n\t\t\t\t// If we're using pixel-based, we need to undo the perspective divide that happened.\n\t\t\t\t#ifdef PIXEL_BASED\n\t\t\t\t\tvec2 uv = vec2(vPosition.x, vPosition.y * gl_FragCoord.w);\n\t\t\t\t#else\n\t\t\t\t\tvec2 uv = vPosition;\n\t\t\t\t#endif\n\n\t\t\t\t// Get a correct use that uses the repeat amount and y offset.\n\t\t\t\t// There's a complicated formula, because the widths may be different and the shape of the sprite may be a trapezoid.\n\t\t\t\tfloat f = width2 * vU / (width1 * (1.0 - vU) + width2 * vU);\n\t\t\t\tfloat uFactor = step(vU, uv.x);\n\t\t\t\tuv.x = (1.0 - uFactor) * uv.x * f / vU + uFactor * (1.0 + (uv.x - 1.0) * (1.0 - f) / (1.0 - vU));\n\t\t\t\tuv.y = uv.y * repeatAmount + textureYOffset;\n\n\t\t\t\t// Apply the texture and color.\n\t\t\t\toutColor = color * texture(colorTexture, uv);\n\n\t\t\t\t${s.ShaderChunkLogDepth.Fragment}\n\t\t\t}`
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        LineShader: function() {
            return n
        }
    });
    var s = i(8);
    const n = {
        uniforms: {
            modelViewMatrix: "mat4",
            projectionMatrix: "highp mat4",
            viewportSize: "vec2",
            alphaMultiplier: "float",
            dashLength: "float",
            dashGapLength: "float",
            glowWidth: "float",
            ...s.ShaderChunkLogDepth.Uniforms
        },
        properties: {
            transparent: !0,
            depthWrite: !1,
            side: "double",
            blending: "additive"
        },
        vertex: {
            code: `\n\t\t\tin vec3 position;\n\t\t\tin vec3 positionPrev;\n\t\t\tin vec3 positionNext;\n\t\t\tin vec4 color;\n\t\t\tin float width;\n\t\t\tin float dashOffset;\n\n\t\t\tuniform mat4 modelViewMatrix;\n\t\t\tuniform mat4 projectionMatrix;\n\t\t\tuniform vec2 viewportSize;\n\t\t\tuniform float glowWidth;\n\n\t\t\tout vec4 fColor;\n\t\t\tout float fDashOffset;\n\t\t\tout float fWidth;\n\t\t\tout float fOffsetScalar;\n\n\t\t\t${s.ShaderChunkLogDepth.VertexHead}\n\n\t\t\tvoid main() {\n\t\t\t\t// Get the line vertices into pixel space.\n\t\t\t\tvec4 view_center = modelViewMatrix * vec4(position, 1.0);\n\t\t\t\tvec4 view_prev = modelViewMatrix * vec4(positionPrev, 1.0);\n\t\t\t\tvec4 view_next = modelViewMatrix * vec4(positionNext, 1.0);\n\t\t\t\tvec4 projected_center = projectionMatrix * view_center;\n\t\t\t\tvec4 projected_prev = projectionMatrix * view_prev;\n\t\t\t\tvec4 projected_next = projectionMatrix * view_next;\n\t\t\t\tvec2 ndc_center = projected_center.xy / view_center.y;\n\t\t\t\tvec2 ndc_prev = projected_prev.xy / view_prev.y;\n\t\t\t\tvec2 ndc_next = projected_next.xy / view_next.y;\n\t\t\t\tvec2 pixel_center = (ndc_center.xy + 1.0) / 2.0 * viewportSize;\n\t\t\t\tvec2 pixel_prev = (ndc_prev.xy + 1.0) / 2.0 * viewportSize;\n\t\t\t\tvec2 pixel_next = (ndc_next.xy + 1.0) / 2.0 * viewportSize;\n\n\t\t\t\t// Get the offset of the part perpendicular to the lines.\n\t\t\t\tvec2 l0 = normalize(pixel_center - pixel_prev);\n\t\t\t\tvec2 l1 = normalize(pixel_next - pixel_center);\n\t\t\t\tfloat resolutionFactor = max(1.0, min(viewportSize.x, viewportSize.y) / 800.0);\n\t\t\t\tfloat offsetScalar = sign(width) * (abs(width) / 2.0 + glowWidth) * resolutionFactor;\n\t\t\t\tvec2 offset = vec2(offsetScalar, offsetScalar);\n\t\t\t\tif (pixel_center == pixel_prev) {\n\t\t\t\t\tif (pixel_center == pixel_next) {\n\t\t\t\t\t\toffset = vec2(0.0, 0.0);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\toffset *= vec2(-l1.y, l1.x);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (pixel_center == pixel_next) {\n\t\t\t\t\toffset *= vec2(-l0.y, l0.x);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\toffset *= normalize(vec2(-l0.y - l1.y, l0.x + l1.x));\n\t\t\t\t\toffset /= max(0.25, sqrt((1.0 + dot(l0, l1)) / 2.0));\n\t\t\t\t}\n\n\t\t\t\t// Re-add the perpendicular part to the center as the final vertex.\n\t\t\t\tndc_center = (pixel_center + offset) / viewportSize * 2.0 - 1.0;\n\t\t\t\tgl_Position = vec4(ndc_center * view_center.y, projected_center.z, projected_center.w);\n\n\t\t\t\t// Set the varyings.\n\t\t\t\tfColor = color;\n\t\t\t\tfDashOffset = dashOffset;\n\t\t\t\tfWidth = width;\n\t\t\t\tfOffsetScalar = offsetScalar;\n\n\t\t\t\t${s.ShaderChunkLogDepth.Vertex}\n\t\t\t}\n\t\t\t`
        },
        fragment: {
            code: `\n\t\t\tprecision highp float;\n\n\t\t\tuniform float alphaMultiplier;\n\t\t\tuniform float dashLength;\n\t\t\tuniform float dashGapLength;\n\t\t\tuniform float glowWidth;\n\n\t\t\tin vec4 fColor;\n\t\t\tin float fDashOffset;\n\t\t\tin float fWidth;\n\t\t\tin float fOffsetScalar;\n\n\t\t\t// The output color.\n\t\t\tout vec4 outColor;\n\n\t\t\t${s.ShaderChunkLogDepth.FragmentHead}\n\n\t\t\tfloat line_dash_func() {\n\t\t\t\tfloat u = mod(fDashOffset, dashLength + dashGapLength);\n\t\t\t\treturn float(u < dashLength);\n\t\t\t}\n\n\t\t\tfloat edgeGlow() {\n\t\t\t\tif (glowWidth > 0.0) {\n\t\t\t\t\tfloat value = clamp((fWidth / 2.0 + glowWidth - abs(fOffsetScalar)) / glowWidth, 0.0, 1.0);\n\t\t\t\t\tif (value < 1.0) {\n\t\t\t\t\t\tvalue *= 0.75;\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t\treturn 1.0;\n\t\t\t}\n\n\t\t\tvoid main() {\n\t\t\t\toutColor = fColor;\n\t\t\t\toutColor.a *= alphaMultiplier * edgeGlow() * line_dash_func();\n\n\t\t\t\t${s.ShaderChunkLogDepth.Fragment}\n\t\t\t}\n\t\t\t`
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        PlumesShader: function() {
            return n
        }
    });
    var s = i(8);
    const n = {
        uniforms: {
            modelViewMatrix: "mat4",
            projectionMatrix: "highp mat4",
            colorTexture: "sampler2D",
            colorMultiplier: "vec4",
            speed: "float",
            time: "float",
            ...s.ShaderChunkLogDepth.Uniforms
        },
        properties: {
            transparent: !0,
            depthWrite: !1,
            side: "double",
            blending: "normal"
        },
        vertex: {
            code: `\n\t\t\tin vec3 position;\n\t\t\tin vec2 uv;\n\t\t\tuniform mat4 modelViewMatrix;\n\t\t\tuniform mat4 projectionMatrix;\n\n\t\t\t${s.ShaderChunkLogDepth.VertexHead}\n\n\t\t\tout vec2 vUV;\n\n\t\t\tvoid main() {\n\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\t\t\t\tvUV = uv;\n\n\t\t\t\t${s.ShaderChunkLogDepth.Vertex}\n\t\t\t}\n\t\t\t`
        },
        fragment: {
            code: `\n\t\t\tprecision highp float;\n\n\t\t\tuniform sampler2D colorTexture;\n\t\t\tuniform vec4 colorMultiplier;\n\t\t\tuniform float speed;\n\t\t\tuniform float time;\n\t\t\tin vec2 vUV;\n\n\t\t\t// The output color.\n\t\t\tout vec4 outColor;\n\n\t\t\t${s.ShaderChunkLogDepth.FragmentHead}\n\n\t\t\tvec2 v2_construct_func(float x, float y) {\n\t\t\t\treturn vec2(x, y);\n\t\t\t}\n\t\t\tfloat s_mult_func(float s1, float s2) {\n\t\t\t\treturn s1 * s2;\n\t\t\t}\n\t\t\tfloat s_mod_func(float s1, float s2) {\n\t\t\t\treturn mod(s1, s2);\n\t\t\t}\n\t\t\tvec2 v2s_mult_func(vec2 v, float s) {\n\t\t\t\treturn v * s;\n\t\t\t}\n\t\t\tvec2 v2_add_func(vec2 v1, vec2 v2) {\n\t\t\t\treturn v1 + v2;\n\t\t\t}\n\t\t\tvec4 texture_func(sampler2D tex, vec2 uv) {\n\t\t\t\treturn texture(tex, uv);\n\t\t\t}\n\t\t\tvec4 v4v4_mult_func(vec4 v1, vec4 v2) {\n\t\t\t\treturn v1 * v2;\n\t\t\t}\n\t\t\tfloat s_sub_func(float s1, float s2) {\n\t\t\t\treturn s1 - s2;\n\t\t\t}\n\t\t\tvec4 alpha_mult_func(vec4 color, float alpha) {\n\t\t\t\treturn vec4(color.rgb, color.a * alpha);\n\t\t\t}\n\t\t\tvoid main() {\n\t\t\t\tvec2 yAxis = v2_construct_func(0.0, 1.0);\n\t\t\t\tfloat yMultiplier = s_mult_func(time, speed);\n\t\t\t\tfloat yMultiplierMod = s_mod_func(yMultiplier, 1.0);\n\t\t\t\tvec2 uvOffset = v2s_mult_func(yAxis, yMultiplierMod);\n\t\t\t\tvec2 finalUV = v2_add_func(vUV, uvOffset);\n\t\t\t\tvec4 textureOffset = texture_func(colorTexture, finalUV);\n\t\t\t\tvec4 color = v4v4_mult_func(textureOffset, colorMultiplier);\n\t\t\t\tfloat fade = s_sub_func(1.0, vUV.y);\n\t\t\t\tvec4 color_with_fade = alpha_mult_func(color, fade);\n\t\t\t\toutColor = color_with_fade;\n\n\t\t\t\t${s.ShaderChunkLogDepth.Fragment}\n\t\t\t}\n\t\t\t`
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        SpriteParticlesShader: function() {
            return n
        }
    });
    var s = i(8);
    const n = {
        uniforms: {
            modelViewMatrix: "mat4",
            projectionMatrix: "highp mat4",
            ...s.ShaderChunkLogDepth.Uniforms
        },
        properties: {
            transparent: !0,
            depthWrite: !1,
            side: "double",
            blending: "additive"
        },
        vertex: {
            code: `\n\t\t\tin vec3 position;\n\t\t\tin vec4 color;\n\t\t\tin vec3 offset;\n\t\t\tin float scale;\n\n\t\t\tuniform mat4 modelViewMatrix;\n\t\t\tuniform mat4 projectionMatrix;\n\n\t\t\tout vec4 fColor;\n\t\t\tout vec2 fPosition;\n\n\t\t\t${s.ShaderChunkLogDepth.VertexHead}\n\n\t\t\tvoid main() {\n\t\t\t\tvec4 viewPosition = modelViewMatrix * vec4(offset, 1.0) + vec4(position.x, position.y, -1.0, 0.0) * scale;\n\t\t\t\tgl_Position = projectionMatrix * viewPosition;\n\t\t\t\tfColor = color;\n\t\t\t\tfPosition = position.xy;\n\n\t\t\t\t${s.ShaderChunkLogDepth.Vertex}\n\t\t\t}\n\t\t\t`
        },
        fragment: {
            code: `\n\t\t\tprecision highp float;\n\n\t\t\tin vec4 fColor;\n\t\t\tin vec2 fPosition;\n\n\t\t\t// The output color.\n\t\t\tout vec4 outColor;\n\n\t\t\t${s.ShaderChunkLogDepth.FragmentHead}\n\n\t\t\tvoid main() {\n\t\t\t\toutColor = fColor * (1.0 - length(fPosition));\n\n\t\t\t\t${s.ShaderChunkLogDepth.Fragment}\n\t\t\t}\n\t\t\t`
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        SpriteShader: function() {
            return n
        }
    });
    var s = i(8);
    const n = {
        uniforms: {
            modelViewMatrix: "mat4",
            projectionMatrix: "highp mat4",
            pixelBased: "float",
            color: "vec4",
            colorTexture: "sampler2D",
            ...s.ShaderChunkLogDepth.Uniforms
        },
        properties: {
            transparent: !0,
            depthWrite: !1,
            side: "double",
            blending: "normal"
        },
        vertex: {
            code: `\n\t\t\tin vec3 position;\n\t\t\tin vec2 uv;\n\n\t\t\tuniform mat4 modelViewMatrix;\n\t\t\tuniform mat4 projectionMatrix;\n\t\t\tuniform float pixelBased;\n\n\t\t\tout vec2 vUV;\n\n\t\t\t${s.ShaderChunkLogDepth.VertexHead}\n\n\t\t\tvoid main() {\n\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\t\t\t\tif (pixelBased != 0.0) {\n\t\t\t\t\tgl_Position /= abs(gl_Position.w);\n\t\t\t\t}\n\t\t\t\tvUV = uv;\n\n\t\t\t\t${s.ShaderChunkLogDepth.Vertex}\n\t\t\t}\n\t\t\t`
        },
        fragment: {
            code: `\n\t\t\tprecision highp float;\n\n\t\t\tuniform vec4 color;\n\t\t\tuniform sampler2D colorTexture;\n\n\t\t\tin vec2 vUV;\n\n\t\t\t// The output color.\n\t\t\tout vec4 outColor;\n\n\t\t\t${s.ShaderChunkLogDepth.FragmentHead}\n\n\t\t\tvoid main() {\n\t\t\t\toutColor = texture(colorTexture, vUV) * color;\n\n\t\t\t\t${s.ShaderChunkLogDepth.Fragment}\n\t\t\t}\n\t\t\t`
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        TrailShader: function() {
            return n
        }
    });
    var s = i(8);
    const n = {
        uniforms: {
            modelViewMatrix: "mat4",
            projectionMatrix: "highp mat4",
            viewportSize: "vec2",
            alphaMultiplier: "float",
            dashLength: "float",
            dashGapLength: "float",
            glowWidth: "float",
            indexStart: "float",
            indexCount: "float",
            indexLength: "float",
            color: "vec4",
            alphaFade: "float",
            widthMin: "float",
            widthMax: "float",
            ...s.ShaderChunkLogDepth.Uniforms
        },
        properties: {
            transparent: !0,
            depthWrite: !1,
            side: "double",
            blending: "additive"
        },
        vertex: {
            code: `\n\t\t\tin vec3 positionCurr;\n\t\t\tin vec3 positionPrev;\n\t\t\tin vec3 positionNext;\n\t\t\tin float side;\n\t\t\tin float index;\n\t\t\tin float dashOffset;\n\n\t\t\tuniform mat4 modelViewMatrix;\n\t\t\tuniform mat4 projectionMatrix;\n\n\t\t\tuniform vec2 viewportSize;\n\t\t\tuniform float glowWidth;\n\t\t\tuniform float indexStart;\n\t\t\tuniform float indexCount;\n\t\t\tuniform float indexLength;\n\t\t\tuniform float widthMin;\n\t\t\tuniform float widthMax;\n\n\t\t\tout float fDashOffset;\n\t\t\tout float fWidth;\n\t\t\tout float fOffsetScalar;\n\t\t\tout float fIndexU;\n\n\t\t\t${s.ShaderChunkLogDepth.VertexHead}\n\n\t\t\tvoid main() {\n\t\t\t\t// Get the width depending on the length.\n\t\t\t\tfloat indexU = mod(index - indexStart + indexLength, indexLength) / (indexCount - 1.0);\n\t\t\t\tfloat width = mix(widthMin, widthMax, indexU);\n\n\t\t\t\t// Get the line vertices into pixel space.\n\t\t\t\tvec4 viewCenter = modelViewMatrix * vec4(positionCurr, 1.0);\n\t\t\t\tvec4 viewPrev = modelViewMatrix * vec4(positionPrev, 1.0);\n\t\t\t\tvec4 viewNext = modelViewMatrix * vec4(positionNext, 1.0);\n\t\t\t\tvec4 projectedCenter = projectionMatrix * viewCenter;\n\t\t\t\tvec4 projected_prev = projectionMatrix * viewPrev;\n\t\t\t\tvec4 projected_next = projectionMatrix * viewNext;\n\t\t\t\tvec2 ndcCenter = projectedCenter.xy / viewCenter.y;\n\t\t\t\tvec2 ndcPrev = projected_prev.xy / viewPrev.y;\n\t\t\t\tvec2 ndcNext = projected_next.xy / viewNext.y;\n\t\t\t\tvec2 pixelCenter = (ndcCenter.xy + 1.0) / 2.0 * viewportSize;\n\t\t\t\tvec2 pixelPrev = (ndcPrev.xy + 1.0) / 2.0 * viewportSize;\n\t\t\t\tvec2 pixelNext = (ndcNext.xy + 1.0) / 2.0 * viewportSize;\n\n\t\t\t\t// Get the offset of the part perpendicular to the lines.\n\t\t\t\tvec2 l0 = normalize(pixelCenter - pixelPrev);\n\t\t\t\tvec2 l1 = normalize(pixelNext - pixelCenter);\n\t\t\t\tfloat resolutionFactor = max(1.0, min(viewportSize.x, viewportSize.y) / 800.0);\n\t\t\t\tfloat offsetScalar = side * (width / 2.0 + glowWidth) * resolutionFactor;\n\t\t\t\tvec2 offset = vec2(offsetScalar, offsetScalar);\n\t\t\t\tif (pixelCenter == pixelPrev) {\n\t\t\t\t\tif (pixelCenter == pixelNext) {\n\t\t\t\t\t\toffset = vec2(0.0, 0.0);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\toffset *= vec2(-l1.y, l1.x);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (pixelCenter == pixelNext) {\n\t\t\t\t\toffset *= vec2(-l0.y, l0.x);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\toffset *= normalize(vec2(-l0.y - l1.y, l0.x + l1.x));\n\t\t\t\t\toffset /= sqrt((1.0 + max(0.0, dot(l0, l1))) / 2.0);\n\t\t\t\t}\n\n\t\t\t\t// Re-add the perpendicular part to the center as the final vertex.\n\t\t\t\tndcCenter = (pixelCenter + offset) / viewportSize * 2.0 - 1.0;\n\t\t\t\tgl_Position = vec4(ndcCenter * viewCenter.y, projectedCenter.z, projectedCenter.w);\n\n\t\t\t\t// Set the varyings.\n\t\t\t\tfIndexU = indexU;\n\t\t\t\tfDashOffset = dashOffset;\n\t\t\t\tfWidth = width;\n\t\t\t\tfOffsetScalar = offsetScalar;\n\n\t\t\t\t${s.ShaderChunkLogDepth.Vertex}\n\t\t\t}\n\t\t\t`
        },
        fragment: {
            code: `\n\t\t\tprecision highp float;\n\n\t\t\tuniform vec4 color;\n\t\t\tuniform float alphaMultiplier;\n\t\t\tuniform float alphaFade;\n\t\t\tuniform float dashLength;\n\t\t\tuniform float dashGapLength;\n\t\t\tuniform float glowWidth;\n\n\t\t\tin float fIndexU;\n\t\t\tin float fDashOffset;\n\t\t\tin float fWidth;\n\t\t\tin float fOffsetScalar;\n\n\t\t\t// The output color.\n\t\t\tout vec4 outColor;\n\n\t\t\t${s.ShaderChunkLogDepth.FragmentHead}\n\t\n\t\t\tfloat lineDash() {\n\t\t\t\tfloat u = mod(fDashOffset, dashLength + dashGapLength);\n\t\t\t\treturn float(u < dashLength);\n\t\t\t}\n\n\t\t\tfloat edgeGlow() {\n\t\t\t\tif (glowWidth > 0.0) {\n\t\t\t\t\tfloat value = clamp((fWidth / 2.0 + glowWidth - abs(fOffsetScalar)) / glowWidth, 0.0, 1.0);\n\t\t\t\t\tif (value < 1.0) {\n\t\t\t\t\t\tvalue *= 0.75;\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t\treturn 1.0;\n\t\t\t}\n\n\t\t\tvoid main() {\n\t\t\t\toutColor = color;\n\t\t\t\toutColor.a *= alphaMultiplier * edgeGlow() * lineDash() * mix(alphaFade, 1.0, fIndexU);\n\n\t\t\t\t${s.ShaderChunkLogDepth.Fragment}\n\t\t\t}\n\t\t\t`
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        Scene: function() {
            return Scene
        }
    });
    var s = i(6);
    class Scene extends s.CollectionItem {
        constructor(t, e) {
            super(t, e),
            this._entities = new s.Collection(this),
            this._controllerDependencyGraph = new s.DependencyGraph(Scene._updateController,Scene._compareControllers),
            this._ambientLightColor = new s.Color(.02,.02,.02),
            this._ambientLightColor.freeze(),
            this._lightSources = [],
            this._threeJsScene = new s.THREE.Scene
        }
        getEngine() {
            return this.__getCollectionParent()
        }
        getEntity(t) {
            return this._entities.get(s.Entity, t)
        }
        getEntityAt(t) {
            return this._entities.getAt(t)
        }
        getNumEntities() {
            return this._entities.getSize()
        }
        addEntity(t) {
            return this._entities.add(s.Entity, t)
        }
        removeEntity(t) {
            this._entities.remove(t)
        }
        moveEntity(t, e) {
            let i;
            this._entities.move(t, e._entities),
            i = "string" == typeof t ? e._entities.get(s.Entity, t) : t;
            for (let t = 0, s = i.getNumControllers(); t < s; t++)
                this._controllerDependencyGraph.removeItem(i.getControllerAt(t)),
                e._controllerDependencyGraph.addItem(i.getControllerAt(t));
            for (let t = 0; ; t++) {
                const e = i.getComponent(s.LightSourceComponent, t);
                if (null === e || "loaded" !== e.getLoadState().state)
                    break;
                for (let t = 0, s = this._lightSources.length; t < s; t++)
                    if (this._lightSources[t].getEntityName() === i.getName() && this._lightSources[t].getComponentNameOrClassIndex() === e.getClassIndex()) {
                        this.__removeLightSource(i.getName(), e.getClassIndex()),
                        this.__addLightSource(i.getName(), e.getClassIndex());
                        break
                    }
            }
        }
        get(t, e, i=0) {
            const s = this._entities.getAny(t);
            return void 0 === e || null === s ? s : s.get(e, i)
        }
        getControllerDependencyGraph() {
            return this._controllerDependencyGraph
        }
        getAmbientLightColor() {
            return this._ambientLightColor
        }
        setAmbientLightColor(t) {
            this._ambientLightColor.thaw(),
            this._ambientLightColor.copy(t),
            this._ambientLightColor.freeze()
        }
        __addLightSource(t, e) {
            for (let i = 0, s = this._lightSources.length; i < s; i++) {
                const s = this._lightSources[i];
                if (s.getEntityName() === t && s.getComponentNameOrClassIndex() === e)
                    throw new Error(`Light source on ${t} with type index ${e} already added.`)
            }
            const i = new s.ComponentRef(this,s.LightSourceComponent,t,e);
            this._lightSources.push(i)
        }
        __removeLightSource(t, e=0) {
            for (let i = 0, s = this._lightSources.length; i < s; i++) {
                const s = this._lightSources[i];
                if (s.getEntityName() === t && s.getComponentNameOrClassIndex() === e)
                    return void this._lightSources.splice(i, 1)
            }
            throw new Error(`Light source on ${t} with type index ${e} not found.`)
        }
        getLightSourceAt(t) {
            return this._lightSources[t].get()
        }
        getNumLightSources() {
            return this._lightSources.length
        }
        async getLoadedPromise(t, e=!1, i=5) {
            const n = [];
            if (t)
                for (const e of t) {
                    const t = this._entities.get(s.Entity, e);
                    if (!t)
                        throw new Error(`Entity "${e}" not added yet. Make sure it is in the scene.`);
                    n.push(t)
                }
            else
                for (let t = 0, e = this._entities.getSize(); t < e; t++)
                    n.push(this._entities.getAt(t));
            const o = [];
            for (let t = 0, s = n.length; t < s; t++) {
                const s = n[t];
                o.push(s.getLoadedPromise(e, i).catch((t => {
                    throw new Error(`${s.getName()} - ${t.message}`)
                }
                )))
            }
            const a = await Promise.allSettled(o);
            if (!a.every((t => "fulfilled" === t.status)))
                throw new Error(a.filter((t => "rejected" === t.status)).map((t => t.reason instanceof Error ? t.reason.message : "")).filter((t => "" !== t)).reduce(( (t, e) => `${t}\n${e}`), ""))
        }
        async waitTillEntitiesInPlace(t, e, i=5) {
            const n = [];
            if (t)
                for (const e of t) {
                    const t = this._entities.get(s.Entity, e);
                    if (!t)
                        throw new Error(`Entity "${e}" not added yet. Make sure it is in the scene.`);
                    n.push(t)
                }
            else
                for (let t = 0, e = this._entities.getSize(); t < e; t++)
                    n.push(this._entities.getAt(t));
            const o = n.map((t => t.waitTillInPlace(e, i).catch(( () => {
                throw new Error(t.getName())
            }
            ))))
              , a = (await Promise.allSettled(o)).filter((t => "rejected" === t.status)).map((t => t.reason.message));
            if (a.length > 0)
                throw new Error(`Timed out (${i} seconds) while waiting for entities to be in place. The remaining entities were [${a.join(",")}].`)
        }
        __destroy() {
            super.__destroy(),
            this._entities.__destroy()
        }
        getThreeJsScene() {
            return this._threeJsScene
        }
        __update() {
            const t = this.getEngine().getTime();
            for (let e = this._entities.getSize() - 1; e >= 0; e--) {
                const i = this._entities.getAt(e);
                i.__updateLastState(),
                i.__updateParent(t),
                i.__updateIsInCoverages(t)
            }
            this._controllerDependencyGraph.update()
        }
        __updateVisuals() {
            for (let t = this._entities.getSize() - 1; t >= 0; t--) {
                const e = this._entities.getAt(t);
                e.isInPositionCoverage() && e.isEnabled() && e.__updateVisuals()
            }
        }
        __removeCameraDependents(t) {
            for (let e = this._entities.getSize() - 1; e >= 0; e--)
                this._entities.getAt(e).__removeCameraDependents(t)
        }
        static _updateController(t) {
            t.getEntity().isEnabled() && t.getCoverage().contains(t.getEntity().getScene().getEngine().getTime()) && t.isEnabled() && t.__update()
        }
        static _compareControllers(t, e) {
            if (t === e)
                return !1;
            if (!(t.getEntity().isEnabled() && e.getEntity().isEnabled() && t.isEnabled() && e.isEnabled()))
                return !1;
            const i = t.getEntity().getScene().getEngine().getTime();
            if (!t.getCoverage().contains(i) || !e.getCoverage().contains(i))
                return !1;
            if (t.getEntity() === e.getEntity()) {
                const i = t.getEntity();
                for (let s = 0, n = i.getNumControllers(); s < n; s++) {
                    const n = i.getControllerAt(s);
                    if (e === n)
                        return !0;
                    if (t === n)
                        break
                }
            }
            if (t.getEntity().getParent() === e.getEntity()) {
                if (t.hasModifiedState("position") && e.hasModifiedState("position") || t.hasModifiedState("velocity") && e.hasModifiedState("velocity"))
                    return !0;
                for (const i of e.__getModifiedStates())
                    if (t.hasDependentState("parent", i))
                        return !0
            }
            for (const i of e.__getModifiedStates())
                if (t.hasDependentState(e.getEntity().getName(), i))
                    return !0;
            return !1
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        TextureLoader: function() {
            return TextureLoader
        }
    });
    var s = i(6)
      , n = i(65);
    class TextureLoader {
        constructor(t) {
            this._engine = t,
            this._white = TextureLoader._newTexture(new s.Color(1,1,1,1)),
            this._black = TextureLoader._newTexture(new s.Color(0,0,0,1)),
            this._clear = TextureLoader._newTexture(new s.Color(0,0,0,0)),
            this._pink = TextureLoader._newTexture(new s.Color(1,0,192 / 255,1)),
            this._gray = TextureLoader._newTexture(new s.Color(.4,.4,.4,1))
        }
        async loadCubeTexture(t, e, i) {
            const n = new s.THREE.CubeTexture
              , o = n.images
              , a = [];
            for (let s = 0; s < 6; s++) {
                const n = t.replace("$FACE", TextureLoader._cubeFaceNames[s]);
                a.push(this.loadTexture(n, e, i).then((t => {
                    o[s] = t.image,
                    t.dispose()
                }
                )))
            }
            return await Promise.all(a),
            n.needsUpdate = !0,
            n
        }
        generateEnvMap(t) {
            let e = t;
            if (!(t instanceof s.THREE.CubeTexture)) {
                const i = {
                    depthBuffer: !1,
                    stencilBuffer: !1,
                    generateMipmaps: !0,
                    minFilter: s.THREE.LinearMipMapLinearFilter,
                    magFilter: s.THREE.LinearFilter
                };
                e = new s.THREE.WebGLCubeRenderTarget(512,i).fromEquirectangularTexture(this._engine.__getThreeJsRenderer(), t).texture
            }
            const i = new s.THREE.PMREMGenerator(this._engine.__getThreeJsRenderer());
            i.compileEquirectangularShader();
            return i.fromEquirectangular(e).texture
        }
        async loadTexture(t, e, i) {
            if ("white" === t)
                return this._white.clone();
            if ("black" === t)
                return this._black.clone();
            if ("clear" === t)
                return this._clear.clone();
            if ("pink" === t)
                return this._pink.clone();
            if ("gray" === t)
                return this._gray.clone();
            let n = "imageBitmap";
            null !== t.match(/\.(mp4|webm)$/u) ? n = "video" : null !== t.match(/\.ktx2$/u) && (n = "binary");
            const o = await this._engine.getDownloader().download(t, n, e);
            if ("completed" === o.status) {
                let e;
                if (o.content instanceof HTMLVideoElement)
                    e = new s.THREE.VideoTexture(o.content),
                    e.flipY = !1;
                else if (o.content instanceof ImageBitmap)
                    e = new s.THREE.CanvasTexture(o.content),
                    e.minFilter = i ? s.THREE.LinearMipMapLinearFilter : s.THREE.LinearFilter,
                    e.generateMipmaps = i;
                else {
                    if (!(o.content instanceof ArrayBuffer && t.match(/\.ktx2$/u)))
                        throw new Error;
                    {
                        const t = this.getKTX2Loader();
                        t && (e = await t._createTexture(o.content))
                    }
                }
                return e
            }
            if ("failed" === o.status)
                throw new Error(o.errorMessage);
            return this._gray.clone()
        }
        getKTX2Loader() {
            if (!TextureLoader._ktx2Loader && !1 !== this._engine.getConfig().getValue("ktx2")) {
                TextureLoader._ktx2Loader = new n.KTX2Loader;
                const t = this._engine.getConfig().getValue("ktx2Path")
                  , e = this._engine.getDownloader().processUrl("string" == typeof t ? t : "$STATIC_ASSETS_URL/wasm/ktx2/");
                TextureLoader._ktx2Loader.setTranscoderPath(e),
                TextureLoader._ktx2Loader.detectSupport(this._engine.__getThreeJsRenderer())
            }
            return TextureLoader._ktx2Loader
        }
        static _newTexture(t) {
            const e = document.createElement("canvas");
            e.width = 1,
            e.height = 1;
            const i = e.getContext("2d");
            if (!i)
                throw new Error("Could not get 2D context.");
            return i.fillStyle = `rgba(${255 * t.r},${255 * t.g},${255 * t.b},${255 * t.a})`,
            i.fillRect(0, 0, 1, 1),
            new s.THREE.CanvasTexture(e)
        }
        static _ktx2Loader;
        static _cubeFaceNames = ["posx", "negx", "posy", "negy", "posz", "negz"]
    }
}
, , , , , function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        Version: function() {
            return s
        }
    });
    const s = "64.1.0"
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        Viewport: function() {
            return Viewport
        }
    });
    var s = i(6);
    class Viewport extends s.CollectionItem {
        constructor(t, e) {
            super(t, e),
            this._enabled = !0,
            this._camera = null,
            this._div = document.createElement("div"),
            this._bounds = new s.Rect(0,0,0,0),
            this._bounds.freeze(),
            this._backgroundColor = new s.Color(0,0,0,1),
            this._backgroundColor.freeze(),
            this._threeJsBackgroundColor = new s.THREE.Color,
            this._div.style.position = "absolute",
            this._div.style.overflow = "hidden",
            this._div.id = t ?? "",
            this._div.classList.add("viewport"),
            this._enabled || (this._div.style.display = "none"),
            this.getEngine().getViewportDiv().appendChild(this._div);
            const i = this.getEngine().getRootDiv();
            this._bounds.thaw(),
            this._bounds.set(this._div.offsetLeft - i.offsetLeft, this._div.offsetTop - i.offsetTop, this._div.offsetWidth, this._div.offsetHeight),
            this._bounds.freeze();
            const n = this.getEngine().getInput();
            null === n.getActiveViewport() && n.__setActiveViewport(this)
        }
        getEngine() {
            return this.__getCollectionParent()
        }
        getDiv() {
            return this._div
        }
        getBounds() {
            return this._bounds
        }
        getBackgroundColor() {
            return this._backgroundColor
        }
        setBackgroundColor(t) {
            this._backgroundColor.thaw(),
            this._backgroundColor = t,
            this._backgroundColor.freeze(),
            this._threeJsBackgroundColor.setRGB(this._backgroundColor.r, this._backgroundColor.g, this._backgroundColor.b)
        }
        getCamera() {
            return this._camera
        }
        setCamera(t) {
            null !== this._camera && this._camera.__setViewport(null),
            this._camera = t,
            null !== this._camera && this._camera.__setViewport(this)
        }
        isEnabled() {
            return this._enabled
        }
        setEnabled(t) {
            this._enabled = t,
            this._enabled ? this._div.style.display = "block" : this._div.style.display = "none"
        }
        getNormalSpacePositionFromPixelSpacePosition(t, e) {
            t.x = 2 * (e.x - this._bounds.origin.x) / this._bounds.size.x - 1,
            t.y = 1 - 2 * (e.y - this._bounds.origin.y) / this._bounds.size.y,
            t.z = -1
        }
        getPixelSpacePositionFromNormalSpacePosition(t, e) {
            -1 < e.z && e.z < 1 ? (t.x = this._bounds.size.x * (e.x + 1) / 2 + this._bounds.origin.x,
            t.y = this._bounds.size.y * (1 - e.y) / 2 + this._bounds.origin.y) : t.copy(s.Vector2.NaN)
        }
        getPixelSpaceRadiusFromNormalSpaceRadius(t) {
            return t * Math.max(this._bounds.size.x, this._bounds.size.y)
        }
        getNormalSpaceRadiusFromPixelSpaceRadius(t) {
            return t / Math.max(this._bounds.size.x, this._bounds.size.y)
        }
        getDirectionOfCursor(t) {
            const e = this.getCamera();
            if (null === e)
                return void t.copy(s.Vector3.NaN);
            const i = this.getEngine().getInput();
            this.getNormalSpacePositionFromPixelSpacePosition(t, i.getCursorPosition()),
            t.x < -1 || t.x > 1 || t.y < -1 || t.y > 1 || t.z < -1 || t.z > 1 ? t.copy(s.Vector3.NaN) : (e.getCameraSpacePositionFromNormalSpacePosition(t, t),
            t.normalize(t))
        }
        __destroy() {
            super.__destroy(),
            this._div.remove()
        }
        __updateViewportVariables() {
            this._enabled && (this._bounds.thaw(),
            this._bounds.set(this._div.offsetLeft, this._div.offsetTop, this._div.offsetWidth, this._div.offsetHeight),
            this._bounds.freeze(),
            null !== this._camera && this._camera.__updateCameraVariablesForConnectedScene())
        }
        __render() {
            if (!this._enabled)
                return;
            const t = this.getEngine().__getThreeJsRenderer()
              , e = this.getEngine().getRootDiv().offsetHeight - this._div.offsetTop - this._div.offsetHeight;
            t.setViewport(this._bounds.origin.x, e, this._bounds.size.x, this._bounds.size.y),
            t.setScissor(this._bounds.origin.x, e, this._bounds.size.x, this._bounds.size.y),
            this._threeJsBackgroundColor.setRGB(this._backgroundColor.r, this._backgroundColor.g, this._backgroundColor.b),
            t.setClearColor(this._threeJsBackgroundColor, this._backgroundColor.a),
            null !== this._camera ? (this._camera.__prepareForRender(),
            this._camera.__render()) : this.getEngine().__getThreeJsRenderer().clear()
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        BaseComponent: function() {
            return BaseComponent
        }
    });
    var s = i(6);
    class BaseComponent extends s.EntityItem {
        constructor(t, e) {
            super(t, e),
            this._radius = .5,
            this._pixelSpaceRadiusPerCamera = new s.FastMap,
            this._greatestPixelSpaceRadius = 0,
            this._isGroundComponent = !1,
            this._loadState = {
                state: "unloaded"
            },
            this._forceLoaded = !1,
            this._resourcesLoadedCallback = null,
            this._resourcesUnloadedCallback = null,
            this._excludedCameras = new Set,
            this._visible = !0,
            this._threeJsObjects = [],
            this._threeJsMaterials = [],
            this._usesEntityOrientation = !1
        }
        __destroy() {
            "loaded" === this._loadState.state && this._unloadResources(),
            super.__destroy()
        }
        setEnabled(t) {
            super.setEnabled(t),
            this.__updateLoadState()
        }
        getRadius() {
            return this._radius
        }
        __setRadius(t) {
            this._radius = t
        }
        getPixelSpaceRadiusInCamera(t) {
            return this._pixelSpaceRadiusPerCamera.get(t)
        }
        getGreatestPixelSpaceRadius() {
            return this._greatestPixelSpaceRadius
        }
        isGroundComponent() {
            return this._isGroundComponent
        }
        setIsGroundComponent(t) {
            this._isGroundComponent !== t && (this._isGroundComponent = t,
            this.getEntity().__updateGroundComponent())
        }
        getThreeJsObjects() {
            return this._threeJsObjects
        }
        getThreeJsMaterials() {
            return this._threeJsMaterials
        }
        getThreeJsObjectByName(t) {
            for (let e = 0; e < this._threeJsObjects.length; e++) {
                const i = this._threeJsObjects[e];
                if (i.name === t)
                    return i
            }
            return null
        }
        getThreeJsPositionInObject(t, e) {
            const i = s.Vector3.threeJsPool.get();
            i.set(0, 0, 0);
            let n = e;
            for (; null !== n && n !== this._threeJsObjects[0]; )
                i.applyMatrix4(n.matrix),
                n = n.parent;
            t.copyFromThreeJs(i),
            s.Vector3.threeJsPool.release(i)
        }
        getThreeJsOrientationInObject(t, e) {
            const i = s.Vector3.threeJsPool.get()
              , n = s.Quaternion.threeJsPool.get();
            i.set(0, 0, 0),
            n.set(0, 0, 0, 1);
            let o = e;
            for (; null !== o && o !== this._threeJsObjects[0]; )
                i.applyMatrix4(o.matrix),
                n.multiplyQuaternions(o.quaternion, n),
                o = o.parent;
            t.copyFromThreeJs(n),
            s.Quaternion.threeJsPool.release(n),
            s.Vector3.threeJsPool.release(i)
        }
        getLoadState() {
            return this._loadState
        }
        setForceLoaded(t) {
            this._forceLoaded = t,
            this._forceLoaded && "unloaded" === this._loadState.state && this._loadResources()
        }
        __updateLoadState() {
            const t = this.getEntity()
              , e = t.isEnabled() && this.isEnabled()
              , i = t.isInPositionCoverage() && (t.isInOrientationCoverage() || !this._usesEntityOrientation);
            e && (this._forceLoaded || i && this._greatestPixelSpaceRadius > .5) && "unloaded" === this._loadState.state ? this._loadResources() : e && (this._forceLoaded || i && !(this._greatestPixelSpaceRadius < .25)) || "loaded" !== this._loadState.state || this._unloadResources()
        }
        resetResources() {
            "loading" === this._loadState.state ? this._loadState = {
                state: "unloaded"
            } : "loaded" === this._loadState.state && this._unloadResources()
        }
        setResourcesLoadedCallback(t) {
            this._resourcesLoadedCallback = t
        }
        setResourcesUnloadedCallback(t) {
            this._resourcesUnloadedCallback = t
        }
        _loadResources() {
            this._loadState.state = "loading",
            this.__loadResources().then(( () => {
                "unloaded" !== this._loadState.state ? (this._loadState.state = "loaded",
                null !== this._resourcesLoadedCallback && this._resourcesLoadedCallback()) : this._unloadResources()
            }
            )).catch((t => {
                t instanceof Error && (console.warn(`While loading ${this}:`, t),
                this._loadState.state = "failed",
                this._loadState.error = `While loading ${this}: ${t.message}`)
            }
            ))
        }
        _unloadResources() {
            this.__unloadResources(),
            this._loadState.state = "unloaded",
            this._threeJsObjects = [],
            this._threeJsMaterials = [],
            null !== this._resourcesUnloadedCallback && this._resourcesUnloadedCallback()
        }
        async __loadResources() {}
        __unloadResources() {}
        async getLoadedPromise(t=!1, e=5) {
            await this.getEntity().getScene().getEngine().waitUntilNextFrame(),
            await (0,
            s.waitUntil)(( () => !t && "unloaded" === this._loadState.state || "loaded" === this._loadState.state), .25, e)
        }
        __updateCameraVariablesBase(t) {
            const e = t.getViewport();
            if (!e)
                return;
            const i = t.getNormalSpaceRadiusFromRadius(this._radius, this.getEntity().getCameraSpacePosition(t).magnitude())
              , s = e.getPixelSpaceRadiusFromNormalSpaceRadius(i);
            this._pixelSpaceRadiusPerCamera.set(t, s),
            this.__updateCameraVariables(t)
        }
        __updateBase() {
            this._greatestPixelSpaceRadius = 0;
            for (let t = 0, e = this._pixelSpaceRadiusPerCamera.getSize(); t < e; t++) {
                const e = this._pixelSpaceRadiusPerCamera.getAt(t).value;
                this._greatestPixelSpaceRadius < e && (this._greatestPixelSpaceRadius = e)
            }
            this.__updateLoadState(),
            this.__update()
        }
        __prepareForRenderBase(t) {
            if ("loaded" === this._loadState.state)
                if (!this._excludedCameras.has(t) && this._visible) {
                    for (let t = 0; t < this._threeJsObjects.length; t++)
                        this._threeJsObjects[t].visible = !0;
                    this.__prepareForRender(t);
                    for (let e = 0; e < this._threeJsMaterials.length; e++) {
                        const i = this._threeJsMaterials[e].uniforms;
                        void 0 !== i.invertDepth && (i.invertDepth.value = t.getInvertDepth(),
                        i.nearDistance.value = t.getAutoNearDistance(),
                        i.midDistance.value = t.getAutoMidDistance())
                    }
                    for (let t = 0; t < this._threeJsObjects.length; t++)
                        this._threeJsObjects[t].updateMatrix()
                } else
                    for (let t = 0; t < this._threeJsObjects.length; t++)
                        this._threeJsObjects[t].visible = !1
        }
        __updateCameraVariables(t) {}
        __prepareForRender(t) {}
        getUsesEntityOrientation() {
            return this._usesEntityOrientation
        }
        __setUsesEntityOrientation(t) {
            this._usesEntityOrientation = t,
            this.__updateLoadState()
        }
        isExcludedFromCamera(t) {
            return this._excludedCameras.has(t)
        }
        setExcludedFromCamera(t, e) {
            !e && this._excludedCameras.has(t) ? this._excludedCameras.delete(t) : e && !this._excludedCameras.has(t) && (this.__removeCameraDependents(t),
            this._excludedCameras.add(t))
        }
        isVisible() {
            return this._visible
        }
        setVisible(t) {
            this._visible = t
        }
        __removeCameraDependentsBase(t) {
            this._pixelSpaceRadiusPerCamera.delete(t),
            this.__removeCameraDependents(t)
        }
        __clearCameraDependentsBase() {
            this._pixelSpaceRadiusPerCamera.clear(),
            this.__clearCameraDependents()
        }
        __removeCameraDependents(t) {}
        __clearCameraDependents() {}
        toString() {
            let t = 0;
            for (let e = 0, i = this.getEntity().getNumComponents(); e < i; e++) {
                const i = this.getEntity().getComponentAt(e);
                if (this === i)
                    break;
                this.constructor === i.constructor && (t += 1)
            }
            return `${this.getEntity().getName()}.${this.constructor.name}.${t}`
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        AtmosphereComponent: function() {
            return AtmosphereComponent
        }
    });
    var s = i(6);
    class AtmosphereComponent extends s.BaseComponent {
        constructor(t, e) {
            super(t, e),
            this._density = 0,
            this._scaleHeight = 1,
            this._emissivity = 0,
            this._color = new s.Color,
            this._color.freeze(),
            this._sunBrightness = 1,
            this._sunsetColor = new s.Color,
            this._sunsetColor.freeze(),
            this._sunsetIntensity = 0,
            this._spheroidComponentRef = new s.ComponentRef(this.getEntity().getScene(),s.SpheroidComponent,this.getEntity().getName()),
            this._spheroidComponentRef.setRefChangedCallback(this._spheroidRefChangedCallback.bind(this)),
            this._spheroidChangedCallback = this._spheroidChangedCallback.bind(this),
            this.__setUsesEntityOrientation(!0)
        }
        getSpheroid() {
            return this._spheroidComponentRef.get()
        }
        getDensity() {
            return this._density
        }
        setDensity(t) {
            this._density = t,
            s.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], "density", t)
        }
        getScaleHeight() {
            return this._scaleHeight
        }
        setScaleHeight(t) {
            this._scaleHeight = t,
            s.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], "scaleHeight", t)
        }
        getEmissivity() {
            return this._emissivity
        }
        setEmissivity(t) {
            this._emissivity = t,
            s.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], "emissivity", t)
        }
        getColor() {
            return this._color
        }
        setColor(t) {
            this._color.thaw(),
            this._color.copy(t),
            this._color.freeze(),
            s.ThreeJsHelper.setUniformColorRGB(this.getThreeJsMaterials()[0], "color", t)
        }
        getSunBrightness() {
            return this._sunBrightness
        }
        setSunBrightness(t) {
            this._sunBrightness = t,
            s.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], "sunBrightness", t)
        }
        getSunsetColor() {
            return this._sunsetColor
        }
        setSunsetColor(t) {
            this._sunsetColor.thaw(),
            this._sunsetColor.copy(t),
            this._sunsetColor.freeze(),
            s.ThreeJsHelper.setUniformColorRGB(this.getThreeJsMaterials()[0], "sunsetColor", t)
        }
        getSunsetIntensity() {
            return this._sunsetIntensity
        }
        setSunsetIntensity(t) {
            this._sunsetIntensity = t,
            s.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], "sunsetIntensity", t)
        }
        setSpheroidReference(t) {
            this._spheroidComponentRef.set(this.getEntity().getName(), t)
        }
        __destroy() {
            const t = this._spheroidComponentRef.get();
            null !== t && t.removeChangedCallback(this._spheroidChangedCallback),
            super.__destroy()
        }
        __update() {
            this._spheroidComponentRef.update()
        }
        __prepareForRender(t) {
            const e = s.Vector3.pool.get();
            e.neg(this.getEntity().getCameraSpacePosition(t)),
            e.rotateInverse(this.getEntity().getOrientation(), e),
            s.ThreeJsHelper.setUniformVector3(this.getThreeJsMaterials()[0], "cameraPosition", e),
            s.Vector3.pool.release(e),
            s.MaterialUtils.setLightSourceUniforms(this.getThreeJsMaterials(), this.getEntity(), t),
            s.ThreeJsHelper.setUniformQuaternion(this.getThreeJsMaterials()[0], "entityOrientation", this.getEntity().getOrientation()),
            s.ThreeJsHelper.setOrientationToEntity(this.getThreeJsObjects()[0], this.getEntity()),
            s.ThreeJsHelper.setPositionToEntity(this.getThreeJsObjects()[0], this.getEntity(), t)
        }
        async __loadResources() {
            const t = new s.THREE.RawShaderMaterial({
                uniforms: {
                    lightPositions: new s.THREE.Uniform([new s.THREE.Vector3(1,0,0), new s.THREE.Vector3(1,0,0), new s.THREE.Vector3(1,0,0), new s.THREE.Vector3(1,0,0), new s.THREE.Vector3(1,0,0)]),
                    lightColors: new s.THREE.Uniform([new s.THREE.Vector3(0,0,0), new s.THREE.Vector3(0,0,0), new s.THREE.Vector3(0,0,0), new s.THREE.Vector3(0,0,0), new s.THREE.Vector3(0,0,0)]),
                    lightRadii: new s.THREE.Uniform([0, 0, 0, 0, 0]),
                    numLights: new s.THREE.Uniform(0),
                    density: new s.THREE.Uniform(this._density),
                    scaleHeight: new s.THREE.Uniform(this._scaleHeight),
                    emissivity: new s.THREE.Uniform(this._emissivity),
                    equatorialRadius: new s.THREE.Uniform(1),
                    polarRadius: new s.THREE.Uniform(1),
                    cameraPosition: new s.THREE.Uniform(new s.THREE.Vector3(1,0,0)),
                    entityOrientation: new s.THREE.Uniform(new s.THREE.Vector4(1,0,0,0)),
                    color: new s.THREE.Uniform(new s.THREE.Vector3(this._color.r,this._color.g,this._color.b)),
                    sunBrightness: new s.THREE.Uniform(this._sunBrightness),
                    sunsetColor: new s.THREE.Uniform(new s.THREE.Vector3(this._sunsetColor.r,this._sunsetColor.g,this._sunsetColor.b)),
                    sunsetIntensity: new s.THREE.Uniform(this._sunsetIntensity),
                    ...s.ShaderChunkLogDepth.ThreeUniforms
                },
                vertexShader: AtmosphereComponent._vertexShader,
                fragmentShader: AtmosphereComponent._fragmentShader,
                glslVersion: s.THREE.GLSL3,
                transparent: !0,
                depthWrite: !1,
                blending: s.THREE.NormalBlending
            });
            this.getThreeJsMaterials().push(t);
            const e = s.ThreeJsHelper.createMeshObject(this, t, [{
                name: "position",
                dimensions: 3
            }], !1);
            this.getThreeJsObjects().push(e);
            const i = 128
              , n = s.MathUtils.pi / 63
              , o = s.MathUtils.twoPi / i
              , a = new Float32Array(24768)
              , r = new Uint16Array(48384)
              , l = s.Vector3.pool.get()
              , c = s.LatLonAlt.pool.get();
            for (let t = 0; t < 64; t++) {
                c.lat = t * n - s.MathUtils.halfPi,
                c.alt = 0;
                const e = Math.cos(c.lat)
                  , l = Math.sin(c.lat);
                for (let n = 0; n < 129; n++) {
                    c.lon = n * o - s.MathUtils.pi;
                    const h = 129 * t + n;
                    a[3 * h + 0] = e * Math.cos(c.lon),
                    a[3 * h + 1] = e * Math.sin(c.lon),
                    a[3 * h + 2] = l;
                    const d = t * i + n;
                    t < 63 && n < i && (r[6 * d + 0] = 129 * (t + 0) + (n + 0),
                    r[6 * d + 1] = 129 * (t + 1) + (n + 0),
                    r[6 * d + 2] = 129 * (t + 1) + (n + 1),
                    r[6 * d + 3] = 129 * (t + 0) + (n + 0),
                    r[6 * d + 4] = 129 * (t + 1) + (n + 1),
                    r[6 * d + 5] = 129 * (t + 0) + (n + 1))
                }
            }
            s.LatLonAlt.pool.release(c),
            s.Vector3.pool.release(l),
            s.ThreeJsHelper.setVertices(e.geometry, "position", a),
            s.ThreeJsHelper.setIndices(e.geometry, r),
            s.ThreeJsHelper.setRenderOrder(e, -1),
            s.ThreeJsHelper.useInDynEnvMap(e, !0),
            this._spheroidChangedCallback()
        }
        __unloadResources() {
            s.ThreeJsHelper.destroyAllObjectsAndMaterials(this)
        }
        _spheroidRefChangedCallback(t, e) {
            null !== t && t.removeChangedCallback(this._spheroidChangedCallback),
            null !== e && e.addChangedCallback(this._spheroidChangedCallback),
            this._spheroidChangedCallback()
        }
        _spheroidChangedCallback() {
            const t = this._spheroidComponentRef.get()
              , e = this.getThreeJsMaterials()[0];
            null !== t ? (this.__setRadius(Math.max(t.getEquatorialRadius(), t.getPolarRadius())),
            void 0 !== e && (s.ThreeJsHelper.setUniformNumber(e, "equatorialRadius", t.getEquatorialRadius()),
            s.ThreeJsHelper.setUniformNumber(e, "polarRadius", t.getPolarRadius()))) : (this.__setRadius(0),
            void 0 !== e && (s.ThreeJsHelper.setUniformNumber(e, "equatorialRadius", 0),
            s.ThreeJsHelper.setUniformNumber(e, "polarRadius", 0)))
        }
        static _vertexShader = `\n\t\tin vec3 position;\n\t\tuniform mat4 projectionMatrix;\n\t\tuniform mat4 modelViewMatrix;\n\n\t\tuniform float scaleHeight;\n\t\tuniform float equatorialRadius;\n\t\tuniform float polarRadius;\n\n\t\t${s.ShaderChunkLogDepth.VertexHead}\n\n\t\tout vec3 localPosition;\n\n\t\tvoid main() {\n\t\t\tfloat scaleHeightMultiplier = 20.0;\n\t\t\tlocalPosition = vec3(position.x * (equatorialRadius + scaleHeight * scaleHeightMultiplier), position.y * (equatorialRadius + scaleHeight * scaleHeightMultiplier), position.z * (polarRadius + scaleHeight * scaleHeightMultiplier));\n\t\t\tvec4 viewPosition = modelViewMatrix * vec4(localPosition, 1.);\n\t\t\tgl_Position = projectionMatrix * viewPosition;\n\t\t\tgl_Position.w = viewPosition.y;\n\n\t\t\t${s.ShaderChunkLogDepth.Vertex}\n\t\t}`;
        static _fragmentShader = `\n\t\tprecision highp float;\n\n\t\tuniform vec3 lightPositions[5];\n\t\tuniform vec3 lightColors[5];\n\t\tuniform int numLights;\n\n\t\tuniform float density;\n\t\tuniform float scaleHeight;\n\t\tuniform float equatorialRadius;\n\t\tuniform float polarRadius;\n\t\tuniform vec3 cameraPosition;\n\t\tuniform vec4 entityOrientation;\n\t\tuniform vec3 color;\n\t\tuniform float emissivity;\n\t\tuniform float sunBrightness;\n\t\tuniform vec3 sunsetColor;\n\t\tuniform float sunsetIntensity;\n\n\t\t${s.ShaderChunkLogDepth.FragmentHead}\n\n\t\tin vec3 localPosition;\n\n\t\t// The output color.\n\t\tout vec4 outColor;\n\n\t\tconst int numIterations = 5;\n\n\t\t// Inverse rotate a vector by a quaternion.\n\t\tvec3 quatRotInv(vec4 q, vec3 v) {\n\t\t\tfloat tx = q.w * v.x - q.y * v.z + q.z * v.y;\n\t\t\tfloat ty = q.w * v.y - q.z * v.x + q.x * v.z;\n\t\t\tfloat tz = q.w * v.z - q.x * v.y + q.y * v.x;\n\t\t\tfloat tw = q.x * v.x + q.y * v.y + q.z * v.z;\n\t\t\tfloat x = tx * q.w + tw * q.x + ty * q.z - tz * q.y;\n\t\t\tfloat y = ty * q.w + tw * q.y + tz * q.x - tx * q.z;\n\t\t\tfloat z = tz * q.w + tw * q.z + tx * q.y - ty * q.x;\n\t\t\treturn vec3(x, y, z);\n\t\t}\n\n\t\t// Given an origin and direction, computes the sampling start and end as distance from the origin in the direction.\n\t\tvoid getStartEndSamples(out float start, out float end, vec3 origin, vec3 direction, float maxDistance, float groundRadius, float atmosphereScaleHeight) {\n\t\t\t// Get the along the ray perpendicular to the sphere.\n\t\t\tfloat perpD = -dot(origin, direction);\n\t\t\tvec3 perp = origin + direction * perpD;\n\n\t\t\t// Figure out the sample distance.\n\t\t\tfloat atmosphereRadius = groundRadius + atmosphereScaleHeight * 6.0;\n\t\t\tfloat chordHalfLength = sqrt(max(0.0, atmosphereRadius * atmosphereRadius - dot(perp, perp)));\n\n\t\t\t// Figure out starting and ending sample points, and step distance.\n\t\t\tstart = max(0.0, perpD - chordHalfLength);\n\t\t\tend = min(maxDistance, perpD + chordHalfLength);\n\t\t}\n\n\t\t// Gets the density of the atmosphere at a given position.\n\t\tfloat getDensity(vec3 position, float radius, float density, float atmosphereScaleHeight) {\n\t\t\treturn density * exp(min(radius - length(position), 0.0) / atmosphereScaleHeight);\n\t\t}\n\n\t\t// Returns 0 if the ray does not intersect and 1.0 if the ray very intersects (with a gradient inbetween).\n\t\tfloat getDayLevel(vec3 origin, vec3 direction, float radius, float scaleHeight) {\n\t\t\tfloat blendHeight = scaleHeight * radius / 200.0;\n\t\t\tfloat perpD = -dot(origin, direction);\n\t\t\tfloat depth = radius - sqrt(dot(origin, origin) - sign(perpD) * perpD * perpD);\n\t\t\tif (depth < 0.0) { // day\n\t\t\t\treturn 1.0 - max(0.0, 0.25 * depth / blendHeight + 0.25);\n\t\t\t}\n\t\t\telse { // night\n\t\t\t\treturn 1.0 - min(1.0, 0.75 * depth / blendHeight + 0.25);\n\t\t\t}\n\t\t}\n\n\t\tfloat easeInOut(float x, float sharpness) {\n\t\t\tfloat b = sharpness;\n\t\t\tif (x < 0.5) {\n\t\t\t\treturn max(0.0, (pow(b, 2.0 * x) - 1.0) / (2.0 * (b - 1.0)));\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn min(1.0, 1.0 - (pow(b, 2.0 * (1.0 - x)) - 1.0) / (2.0 * (b - 1.0)));\n\t\t\t}\n\t\t}\n\n\t\tvec3 adjustOverbrightness(vec3 color) {\n\t\t\tfloat maxColor = max(color.r, max(color.g, color.b));\n\t\t\tif (maxColor > 1.0) {\n\t\t\t\tfloat f = (maxColor - 1.0) / maxColor;\n\t\t\t\tcolor.r = min(1.0, pow(color.r / maxColor, 1.0 / maxColor));\n\t\t\t\tcolor.g = min(1.0, pow(color.g / maxColor, 1.0 / maxColor));\n\t\t\t\tcolor.b = min(1.0, pow(color.b / maxColor, 1.0 / maxColor));\n\t\t\t}\n\t\t\treturn color;\n\t\t}\n\n\t\t// Calculates a glow around the light direction (the star).\n\t\tfloat glow(float spread, float amount, float lightDotCamera) {\n\t\t\treturn amount * spread / (1.0 + spread - lightDotCamera);\n\t\t}\n\n\t\tvec4 getEmissiveColor(float totalDensity, vec3 cameraPositionS, vec3 color, float emissivity) {\n\n\t\t\t// The color that will be added onto outColor.\n\t\t\tvec4 emissiveColor;\n\n\t\t\t// Apply the total density to the transparency of the atmosphere.\n\t\t\temissiveColor.a = emissivity * clamp(totalDensity, 0.0, 1.0);\n\n\t\t\t// Multiply it all together with the source light color.\n\t\t\temissiveColor.rgb = emissivity * color * clamp(pow(15.0 * totalDensity / (density * equatorialRadius), 0.2), 0.75, 1.0);\n\n\t\t\t// Make it more opaque when lower down.\n\t\t\temissiveColor.a = mix(emissiveColor.a, emissivity, getDensity(cameraPositionS, equatorialRadius + scaleHeight, 1.0, 2.0 * scaleHeight));\n\n\t\t\t// Clamp it to make it clean for the day/night transition.\n\t\t\temissiveColor.a = clamp(emissiveColor.a, 0.0, 1.0);\n\n\t\t\treturn emissiveColor;\n\t\t}\n\n\t\t// Gets the color for an atmosphere for a light.\n\t\tvec4 getColor(float totalDensity, vec3 lightColor, vec3 lightPosition, float spheroidRatio, vec3 positionS, vec3 cameraPositionS, vec3 cameraToPositionUnit) {\n\n\t\t\t// The color starts out in full brightness (as if emissivity was 1.0).\n\t\t\tvec4 atmosphereColor = getEmissiveColor(totalDensity, cameraPositionS, lightColor * color, 1.0);\n\n\t\t\t// Make the alpha dependent on the brightness of the light.\n\t\t\tatmosphereColor.a *= length(lightColor) / sqrt(3.0);\n\n\t\t\t// Setup vectors.\n\t\t\thighp vec3 lightPositionS = quatRotInv(entityOrientation, lightPosition);\n\t\t\tlightPositionS.z *= spheroidRatio;\n\t\t\thighp vec3 lightToPosition = positionS - lightPositionS;\n\t\t\thighp vec3 lightToPositionUnit = normalize(lightToPosition / 1.0e8);\n\n\t\t\t// Get the day level, from 0 to 1, and apply it to the alpha. Lots of tricks to get it looking good on earth.\n\t\t\tvec3 dayRefUp = normalize(cameraPositionS - min(0.0, dot(cameraPositionS, cameraToPositionUnit)) * cameraToPositionUnit);\n\t\t\tfloat dayLevel = -dot(lightToPositionUnit, dayRefUp);\n\t\t\tatmosphereColor.rgb *= easeInOut(0.5 + 2.0 * dayLevel, 2.0);\n\t\t\tatmosphereColor.a *= easeInOut(1.0 + 2.0 * dayLevel, 2.0);\n\n\t\t\t// Brighten up the atmosphere when looking from space toward the sun.\n\t\t\tfloat lightDotCamera = max(0.0, -dot(lightToPositionUnit, cameraToPositionUnit));\n\t\t\tatmosphereColor.a = clamp(atmosphereColor.a * (1.0 + glow(0.004, 1.0, lightDotCamera)), 0.0, 1.0);\n\n\t\t\t// Add narrower sun glare.\n\t\t\tatmosphereColor.rgb *= lightColor * (1.0 + sunBrightness * atmosphereColor.a * glow(0.00004, 1.0, lightDotCamera));\n\n\t\t\t// Add broader sun glare.\n\t\t\tatmosphereColor.rgb *= lightColor * (1.0 + sunBrightness * atmosphereColor.a * glow(0.04, 0.125, lightDotCamera));\n\n\t\t\t// Apply the sunset.\n\t\t\tfloat lightDotHorizon = pow(clamp(1.0 - dot(lightToPositionUnit, dayRefUp), 0.0, 1.0), 2.0);\n\t\t\tfloat cameraDotHorizon = pow(clamp(1.0 - dot(cameraToPositionUnit, dayRefUp), 0.0, 1.0), 8.0);\n\t\t\tfloat sunsetAmount = sunsetIntensity * lightDotHorizon * cameraDotHorizon * glow(0.04, 0.5, lightDotCamera);\n\t\t\tatmosphereColor.rgb = mix(atmosphereColor.rgb, sunsetColor, clamp(sunsetAmount, 0.0, 1.0));\n\n\t\t\treturn atmosphereColor;\n\t\t}\n\n\t\tvoid main(void) {\n\t\t\t// Convert everything into a sphere frame.\n\t\t\tfloat spheroidRatio = equatorialRadius / polarRadius;\n\t\t\thighp vec3 positionS = localPosition;\n\t\t\thighp vec3 cameraPositionS = cameraPosition;\n\t\t\tpositionS.z *= spheroidRatio;\n\t\t\tcameraPositionS.z *= spheroidRatio;\n\n\t\t\thighp vec3 cameraToPosition = positionS - cameraPositionS;\n\t\t\tfloat cameraToPositionDist = length(cameraToPosition / 1.0e8) * 1.0e8;\n\t\t\thighp vec3 cameraToPositionUnit = cameraToPosition / cameraToPositionDist;\n\n\t\t\t// Get the start and end of the sampling from the camera to the position.\n\t\t\tfloat start;\n\t\t\tfloat end;\n\t\t\tgetStartEndSamples(start, end, cameraPositionS, cameraToPositionUnit, 1.0e24, equatorialRadius, scaleHeight);\n\t\t\tfloat fracPerStep = 1.0 / float(numIterations - 1);\n\t\t\tfloat stepDist = fracPerStep * (end - start);\n\n\t\t\t// Do the sampling.\n\t\t\tfloat totalDensity = 0.0;\n\t\t\tfloat segmentStart = start;\n\t\t\tfor (int j = 0; j < numIterations; j++) {\n\t\t\t\t// Get the distance that this segment covers.\n\t\t\t\tfloat segDist = stepDist;\n\t\t\t\tif (j == 0 || j == numIterations - 1) {\n\t\t\t\t\tsegDist *= 0.5;\n\t\t\t\t}\n\n\t\t\t\t// Get the segment start that we're looking at.\n\t\t\t\tvec3 p = cameraPositionS + segmentStart * cameraToPositionUnit;\n\n\t\t\t\t// Get the density at that segment start. It'll be the density for the whole segment.\n\t\t\t\tfloat densityAtP = getDensity(p, equatorialRadius, density, scaleHeight);\n\n\t\t\t\t// Add it to the total density.\n\t\t\t\ttotalDensity += densityAtP * segDist;\n\n\t\t\t\t// Next step.\n\t\t\t\tsegmentStart += stepDist;\n\t\t\t}\n\n\t\t\t// Add emissivity lightness.\n\t\t\toutColor += getEmissiveColor(totalDensity, cameraPositionS, color, emissivity);\n\n\t\t\t// For each light,\n\t\t\tfor (int i = 0; i < 5; i++) {\n\t\t\t\tif (i >= numLights) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// If it's not a camera light,\n\t\t\t\tif (length(lightPositions[i]) > 0.0) {\n\t\t\t\t\t// Add on the color for the light.\n\t\t\t\t\toutColor += getColor(totalDensity, lightColors[i], lightPositions[i], spheroidRatio, positionS, cameraPositionS, cameraToPositionUnit);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Adjust for values that are greater than one.\n\t\t\toutColor.rgb = adjustOverbrightness(outColor.rgb);\n\n\t\t\t${s.ShaderChunkLogDepth.Fragment}\n\t\t}`
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        CameraComponent: function() {
            return CameraComponent
        }
    });
    var s = i(6)
      , n = i(79)
      , o = i(74)
      , a = i(82)
      , r = i(77);
    class CameraComponent extends s.BaseComponent {
        constructor(t, e) {
            super(t, e),
            this._threeJsRenderer = this.getEntity().getScene().getEngine().__getThreeJsRenderer(),
            this._viewport = null,
            this._threeJsScene = e.getScene().getThreeJsScene(),
            this._fieldOfView = 1.0471975512,
            this._nearDistance = void 0,
            this._autoNearDistance = 0,
            this._midDistance = void 0,
            this._autoMidDistance = 0,
            this._invertDepth = 0,
            this._aspectRatio = 1,
            this._renderSize = new s.Vector2,
            this._occludingEntities = [],
            this._threeJsCamera = new s.THREE.PerspectiveCamera(75,this._aspectRatio,.1,1e3),
            this._outlinePass = new o.OutlinePass(new s.THREE.Vector2(0,0),this._threeJsScene,this._threeJsCamera,[]),
            this._outlinePass.enabled = !1,
            this._threeJsUnrealBloomPass = new r.UnrealBloomPass(new s.THREE.Vector2(0,0),0,0,0),
            this._threeJsUnrealBloomPass.enabled = !1;
            const i = new s.THREE.Vector2;
            this._threeJsRenderer.getSize(i);
            const l = {
                samples: this._outlinePass.enabled ? 0 : 4
            }
              , c = new s.THREE.WebGLRenderTarget(i.x,i.y,l);
            this._threeJsComposer = new n.EffectComposer(this._threeJsRenderer,c);
            const h = new a.RenderPass(this._threeJsScene,this._threeJsCamera);
            this._threeJsComposer.addPass(h),
            this._threeJsComposer.addPass(this._outlinePass),
            this._threeJsComposer.addPass(this._threeJsUnrealBloomPass)
        }
        getViewport() {
            return this._viewport
        }
        getFieldOfView() {
            return this._fieldOfView
        }
        getHorizontalFieldOfView() {
            return this._aspectRatio >= 1 ? this._fieldOfView : 2 * Math.atan(Math.tan(this._fieldOfView / 2) * this._aspectRatio)
        }
        getVerticalFieldOfView() {
            return this._aspectRatio > 1 ? 2 * Math.atan(Math.tan(this._fieldOfView / 2) / this._aspectRatio) : this._fieldOfView
        }
        setFieldOfView(t) {
            this._fieldOfView = t
        }
        getInvertDepth() {
            return this._invertDepth
        }
        setInvertDepth(t) {
            this._invertDepth = t
        }
        getNearDistance() {
            return this._nearDistance
        }
        setNearDistance(t) {
            this._nearDistance = t
        }
        getAutoNearDistance() {
            return this._autoNearDistance
        }
        getMidDistance() {
            return this._midDistance
        }
        setMidDistance(t) {
            this._midDistance = t
        }
        getAutoMidDistance() {
            return this._autoMidDistance
        }
        getNormalSpacePositionFromCameraSpacePosition(t, e) {
            const i = s.Quaternion.pool.get();
            i.copy(this.getEntity().getOrientation()),
            i.inverse(i);
            const n = s.Vector3.pool.get();
            n.rotate(i, e),
            s.Quaternion.pool.release(i),
            t.x = this._threeJsCamera.projectionMatrix.elements[0] * n.x / n.y,
            t.y = this._threeJsCamera.projectionMatrix.elements[9] * n.z / n.y,
            t.z = this._threeJsCamera.projectionMatrix.elements[6] + this._threeJsCamera.projectionMatrix.elements[14] / n.y,
            s.Vector3.pool.release(n)
        }
        getNormalSpaceRadiusFromRadius(t, e) {
            return t / Math.abs(e) / Math.tan(this._fieldOfView / 2)
        }
        getCameraSpacePositionFromNormalSpacePosition(t, e) {
            const i = s.Vector3.pool.get();
            i.y = this._threeJsCamera.projectionMatrix.elements[14] / (e.z - this._threeJsCamera.projectionMatrix.elements[6]),
            i.x = e.x * i.y / this._threeJsCamera.projectionMatrix.elements[0],
            i.z = e.y * i.y / this._threeJsCamera.projectionMatrix.elements[9],
            t.rotate(this.getEntity().getOrientation(), i),
            s.Vector3.pool.release(i)
        }
        getRadiusFromNormalSpaceRadius(t, e) {
            return t * Math.abs(e) * Math.tan(this._fieldOfView / 2)
        }
        getRaycast(t, e, i) {
            const n = new s.THREE.Raycaster
              , o = new s.THREE.Vector3(t.x,t.y,t.z)
              , a = new s.THREE.Vector3(e.x,e.y,e.z);
            n.set(o, a),
            i.__prepareForRender(this);
            const r = [];
            for (let t = 0, e = i.getNumComponents(); t < e; t++) {
                const e = i.getComponentAt(t);
                if (!e.isVisible() || e.isExcludedFromCamera(this))
                    continue;
                for (let t = 0; t < e.getThreeJsObjects().length; t++)
                    e.getThreeJsObjects()[t].updateMatrixWorld();
                const o = n.intersectObjects(e.getThreeJsObjects());
                for (let t = 0, i = o.length; t < i; t++) {
                    const i = o[t];
                    if (!i.face)
                        continue;
                    if (t > 0) {
                        const e = o[t - 1];
                        if (e.face && i.object === e.object && i.face.a === e.face.a && i.face.b === e.face.b && i.face.c === e.face.c)
                            continue
                    }
                    const n = i.object
                      , a = new s.Vector3;
                    a.copyFromThreeJs(i.point),
                    this.getEntity().getPositionRelativeToEntity(a, a, e.getEntity()),
                    a.rotateInverse(e.getEntity().getOrientation(), a),
                    r.push({
                        component: e,
                        object: n,
                        frameSpacePosition: a
                    })
                }
            }
            return r
        }
        getRaycastColor(t, e, i) {
            const n = new s.THREE.Raycaster
              , o = new s.THREE.Vector3(t.x,t.y,t.z)
              , a = new s.THREE.Vector3(e.x,e.y,e.z);
            n.set(o, a),
            i.__prepareForRender(this);
            const r = [];
            for (let t = 0, e = i.getNumComponents(); t < e; t++) {
                const e = i.getComponentAt(t);
                if (!e.isVisible() || e.isExcludedFromCamera(this))
                    continue;
                for (let t = 0; t < e.getThreeJsObjects().length; t++)
                    e.getThreeJsObjects()[t].updateMatrixWorld();
                const o = n.intersectObjects(e.getThreeJsObjects());
                for (let t = 0; t < o.length; t++) {
                    const i = o[t];
                    if (!i.face)
                        continue;
                    if (t > 0) {
                        const e = o[t - 1];
                        if (e.face && i.object === e.object && i.face.a === e.face.a && i.face.b === e.face.b && i.face.c === e.face.c)
                            continue
                    }
                    const n = i.object;
                    if (!(n instanceof s.THREE.Mesh))
                        continue;
                    let a = i.object.material;
                    if (Array.isArray(a) && (a = a[i.face.materialIndex]),
                    a instanceof s.THREE.ShaderMaterial)
                        for (const [t,o] of Object.entries(a.uniforms)) {
                            const a = o.value;
                            if (!(a instanceof s.THREE.Texture))
                                continue;
                            const l = a.image
                              , c = t
                              , h = document.createElement("canvas");
                            h.width = l.width,
                            h.height = l.height;
                            const d = h.getContext("2d");
                            if (!d)
                                continue;
                            try {
                                d.drawImage(l, 0, 0)
                            } catch {
                                continue
                            }
                            const u = d.getImageData(0, 0, l.width, l.height)
                              , p = i.uv;
                            if (!p)
                                continue;
                            const m = a.format === s.THREE.RGBAFormat ? 4 : 3
                              , _ = (Math.floor(p.y * u.height) * u.width + Math.floor(p.x * u.width)) * m
                              , g = new s.Color;
                            g.set(u.data[_ + 0], u.data[_ + 1], u.data[_ + 2], 4 === m ? u.data[_ + 3] : 1),
                            r.push({
                                component: e,
                                object: n,
                                textureName: c,
                                color: g
                            })
                        }
                }
            }
            return r
        }
        isPositionOccluded(t) {
            for (let e = 0; e < this._occludingEntities.length; e++)
                if (this._occludingEntities[e].isOccludingPosition(this, t))
                    return !0;
            return !1
        }
        getNearestIntersectingEntity(t) {
            let e = Number.POSITIVE_INFINITY
              , i = null;
            const n = s.Interval.pool.get();
            for (let o = 0; o < this._occludingEntities.length; o++) {
                const a = this._occludingEntities[o].getCameraSpacePosition(this);
                if (s.Geometry.getLineSphereIntersectionWithLineStartAtOrigin(n, t, a, this._occludingEntities[o].getOcclusionRadius()),
                !Number.isNaN(n.min) && n.min >= 0) {
                    const t = n.min * a.magnitude();
                    t < e && (e = t,
                    i = this._occludingEntities[o])
                }
            }
            return s.Interval.pool.release(n),
            i
        }
        setBloom(t) {
            this._threeJsUnrealBloomPass.enabled = t > 0,
            this._threeJsUnrealBloomPass.strength = t
        }
        setOutline(t, e, i) {
            if (this._outlinePass.enabled = null !== e,
            null !== e) {
                if (void 0 !== i) {
                    const t = e.getThreeJsObjectByName(i);
                    if (null === t)
                        throw new Error(`Could not set outline on component ${e} sub-object ${i}.`);
                    this._outlinePass.selectedObjects = [t]
                } else {
                    const t = e.getThreeJsObjects();
                    this._outlinePass.selectedObjects = [];
                    for (let e = 0, i = t.length; e < i; e++)
                        t[e].parent === this._threeJsScene && this._outlinePass.selectedObjects.push(t[e])
                }
                this._outlinePass.visibleEdgeColor.setRGB(t.r, t.g, t.b),
                this._outlinePass.hiddenEdgeColor.setRGB(t.r / 4, t.g / 4, t.b / 4)
            }
        }
        __addToOccludingEntities(t) {
            for (let e = 0; e < this._occludingEntities.length; e++)
                if (this._occludingEntities[e] === t)
                    return;
            this._occludingEntities.push(t)
        }
        __destroy() {
            super.__destroy(),
            this.getEntity().getScene().__removeCameraDependents(this),
            null !== this._viewport && this._viewport.setCamera(null)
        }
        __updateCameraVariablesForConnectedScene() {
            if (this._viewport) {
                const t = this._viewport.getBounds().size;
                if (!t.equals(this._renderSize)) {
                    this._renderSize.copy(t);
                    const e = t.x / t.y;
                    this._aspectRatio !== e && (this._aspectRatio = e),
                    this._threeJsComposer.setSize(t.x, t.y)
                }
            }
            const t = this.getEntity().getParent();
            if (t) {
                if (void 0 === this._nearDistance ? this._autoNearDistance = Math.max(1e-5, .1 * (this.getEntity().getPosition().magnitude() - t.getExtentsRadius())) : this._autoNearDistance = this._nearDistance,
                void 0 === this._midDistance ? this._autoMidDistance = Math.min(1e4 * this._autoNearDistance, this.getEntity().getPosition().magnitude() + 10 * t.getExtentsRadius()) : this._autoMidDistance = this._midDistance,
                void 0 === this._nearDistance || void 0 === this._midDistance) {
                    let e = t;
                    for (; e && !e.getGroundComponent(); )
                        e = e.getParent();
                    if (e) {
                        const t = Math.max(1e-5, this.getEntity().getDistanceTo(e, !0));
                        .1 * t < this._autoNearDistance && (this._autoNearDistance = .1 * t),
                        10 * t < this._autoMidDistance && (this._autoMidDistance = 10 * t)
                    }
                }
                this._updateProjectionMatrix(),
                this.getEntity().__updateCameraVariables(this, null, !1, 0);
                for (let t = 0; t < this._occludingEntities.length; t++)
                    (this._occludingEntities[t].getPixelSpaceOcclusionRadius(this) < 1 || !this._occludingEntities[t].isEnabled() || !this._occludingEntities[t].canOcclude() || null === this.getEntity().getScene().getEntity(this._occludingEntities[t].getName())) && (this._occludingEntities.splice(t, 1),
                    t--)
            }
        }
        __prepareForRender() {
            const t = this.getEntity().getScene();
            for (let e = 0; e < t.getNumEntities(); e++) {
                const i = t.getEntityAt(e);
                i.isEnabled() && i.__prepareForRender(this)
            }
            const e = this.getEntity().getComponent(s.DynamicEnvironmentMapComponent);
            null !== e && e.__render()
        }
        __render() {
            const t = this.getEntity().getOrientation()
              , e = s.Quaternion.threeJsPool.get();
            e.set(t.x, t.y, t.z, t.w),
            this._threeJsCamera.setRotationFromQuaternion(e),
            s.Quaternion.threeJsPool.release(e),
            this._threeJsComposer.render()
        }
        __setViewport(t) {
            this._viewport = t
        }
        _updateProjectionMatrix() {
            if (0 < this._fieldOfView && this._fieldOfView < 180 && this._aspectRatio > 0) {
                const t = Math.tan(this._fieldOfView / 2);
                let e, i;
                this._aspectRatio >= 1 ? (e = 1 / t,
                i = this._aspectRatio / t) : (e = 1 / (t * this._aspectRatio),
                i = 1 / t);
                const n = 1 - Number.EPSILON
                  , o = this._autoNearDistance * (Number.EPSILON - 2)
                  , a = new s.THREE.Matrix4;
                a.set(e, 0, 0, 0, 0, 0, i, 0, 0, n, 0, o, 0, 1, 0, 0),
                this._threeJsCamera.projectionMatrix = a;
                const r = new s.THREE.Matrix4;
                r.set(1 / e, 0, 0, 0, 0, 0, 0, 1, 0, 1 / i, 0, 0, 0, 0, 1 / o, -n / o),
                this._threeJsCamera.projectionMatrixInverse = r
            }
        }
        async __loadResources() {}
        __unloadResources() {}
    }
}
, , , , , , , , , , function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        CMTSComponent: function() {
            return CMTSComponent
        }
    });
    var s = i(6);
    class CMTSComponent extends s.BaseComponent {
        constructor(t, e) {
            super(t, e),
            this._threeJsScene = this.getEntity().getScene().getThreeJsScene(),
            this._endPoints = new s.FastMap,
            this._heightOffset = 0,
            this._heightScale = 1,
            this._numEndPointsLoading = 0,
            this._minLevel = Number.NEGATIVE_INFINITY,
            this._maxLevel = Number.POSITIVE_INFINITY,
            this._splitJoinThresholdFactor = 256,
            this._colorTileSize = 512,
            this._shadowEntities = [],
            this._materialOptions = new Set,
            this._transparent = !1,
            this._engine = this.getEntity().getScene().getEngine(),
            this._cameraPositions = [],
            this._cameraFieldsOfView = [],
            this._rootTiles = null,
            this._activatedTiles = new s.FastSet,
            this._tilesLoadedPromise = null,
            this._transitionsCompleteCallback = null,
            this._numCurrentLoads = 0,
            this._maxCurrentLoads = 10,
            this._atmosphereComponentRef = new s.ComponentRef(this.getEntity().getScene(),s.AtmosphereComponent,this.getEntity().getName()),
            this._spheroidComponentRef = new s.ComponentRef(this.getEntity().getScene(),s.SpheroidComponent,this.getEntity().getName()),
            this._spheroidComponentRef.setRefChangedCallback(this._spheroidRefChangedCallback.bind(this)),
            this._spheroidChangedCallback = this._spheroidChangedCallback.bind(this),
            this.__setUsesEntityOrientation(!0),
            this.setIsGroundComponent(!0)
        }
        setBaseUrl(t, e) {
            this.resetResources(),
            void 0 !== e ? this._endPoints.set(t, {
                url: e,
                configuration: null,
                cache: new s.Cache((async e => {
                    const i = await s.ThreeJsHelper.loadTexture(this, e, !0);
                    let n = null;
                    if ("height" === t) {
                        const t = document.createElement("canvas")
                          , e = i.image;
                        t.width = e.width,
                        t.height = e.height;
                        const s = t.getContext("2d", {
                            desynchronized: !0,
                            alpha: !1
                        });
                        if (!s)
                            throw new Error(`Could not acquire 2D context in ${this}.`);
                        s.drawImage(e, 0, 0),
                        n = s.getImageData(0, 0, e.width, e.height)
                    }
                    return {
                        texture: i,
                        heightData: n
                    }
                }
                ),(t => {
                    s.ThreeJsHelper.destroyTexture(t.texture)
                }
                ))
            }) : this._endPoints.delete(t)
        }
        getHeightOffset() {
            return this._heightOffset
        }
        setHeightOffset(t) {
            this._heightOffset = t,
            this.resetResources()
        }
        getHeightScale() {
            return this._heightScale
        }
        setHeightScale(t) {
            this._heightScale = t,
            this.resetResources()
        }
        getMinLevel() {
            return this._minLevel
        }
        setMinLevel(t) {
            this._minLevel = t
        }
        getMaxLevel() {
            return this._maxLevel
        }
        setMaxLevel(t) {
            this._maxLevel = t
        }
        getNumShadowEntities() {
            return this._shadowEntities.length
        }
        getShadowEntity(t) {
            return this._shadowEntities[t]?.getName()
        }
        setShadowEntities(t) {
            this._shadowEntities = [];
            for (const e of t)
                this._shadowEntities.push(new s.EntityRef(this.getEntity().getScene(),e));
            const e = t.length > 0;
            for (let t = 0, i = this.getThreeJsMaterials().length; t < i; t++)
                s.ThreeJsHelper.setDefine(this.getThreeJsMaterials()[t], "shadowEntities", e)
        }
        isMaterialOptionEnabled(t) {
            return this._materialOptions.has(t)
        }
        setMaterialOption(t, e) {
            const i = this.getThreeJsMaterials();
            if (e && !this._materialOptions.has(t)) {
                this._materialOptions.add(t);
                for (let e = 0, s = i.length; e < s; e++) {
                    const s = i[e];
                    s.defines[t] = !0,
                    s.needsUpdate = !0
                }
            } else if (!e && this._materialOptions.has(t)) {
                this._materialOptions.delete(t);
                for (let e = 0, s = i.length; e < s; e++) {
                    const s = i[e];
                    delete s.defines[t],
                    s.needsUpdate = !0
                }
            }
        }
        getGroundPosition(t, e, i) {
            const n = this._spheroidComponentRef.get();
            if (null === n)
                return void t.copy(s.Vector3.NaN);
            const o = s.LatLonAlt.pool.get();
            n.llaFromXYZ(o, i);
            if (void 0 !== this._endPoints.get("height") && this._rootTiles) {
                const t = s.Vector3.pool.get()
                  , e = s.Vector3.pool.get();
                o.alt = 1,
                s.Geometry.getXYZFromLLAOnSphere(e, o, 0),
                s.CubeMap.xyzToUVFace(t, e);
                let i = this._rootTiles[t.z];
                if (!i)
                    return s.Vector3.pool.release(e),
                    s.Vector3.pool.release(t),
                    void s.LatLonAlt.pool.release(o);
                for (; i?.getChildren().length > 0; ) {
                    const e = 1 << i.getLevel() + 1
                      , s = Math.floor(t.x * e - 2 * i.getTileCoord().x)
                      , n = Math.floor(t.y * e - 2 * i.getTileCoord().y);
                    i = i?.getChildren()[2 * n + s]
                }
                for (; i && !i.shouldBeVisible() && null !== i.getParent(); )
                    i = i.getParent();
                if (i) {
                    const e = i.getHeight(t);
                    o.alt = e
                }
                s.Vector3.pool.release(e),
                s.Vector3.pool.release(t)
            } else
                o.alt = this._heightOffset;
            n.xyzFromLLA(t, o),
            e && n.upFromLLA(e, o),
            s.LatLonAlt.pool.release(o)
        }
        areTilesLoaded() {
            return null === this._tilesLoadedPromise
        }
        async getTilesLoadedPromise() {
            this._tilesLoadedPromise && await this._tilesLoadedPromise
        }
        setSpheroidReference(t) {
            this._spheroidComponentRef.set(this.getEntity().getName(), t)
        }
        setTransparent(t) {
            this._transparent = t,
            this.resetResources()
        }
        __destroy() {
            const t = this._spheroidComponentRef.get();
            null !== t && t.removeChangedCallback(this._spheroidChangedCallback),
            super.__destroy()
        }
        __update() {
            if (this._spheroidComponentRef.update(),
            "loaded" !== this.getLoadState().state || null === this._spheroidComponentRef.get())
                return;
            if (null === this._rootTiles) {
                if (this._numEndPointsLoading > 0)
                    return;
                this._rootTiles = [];
                for (let t = 0; t < 6; t++) {
                    const e = new CMTSTile(this,null,t,0,new s.Vector2(0,0));
                    this._rootTiles.push(e),
                    e.forceLoad()
                }
            }
            for (; this._cameraPositions.length > this._engine.getNumViewports(); )
                this._cameraPositions.pop(),
                this._cameraFieldsOfView.pop();
            for (; this._cameraPositions.length < this._engine.getNumViewports(); )
                this._cameraPositions.push(new s.Vector3),
                this._cameraFieldsOfView.push(1);
            for (let t = 0, e = this._engine.getNumViewports(); t < e; t++) {
                const e = this._cameraPositions[t]
                  , i = this._engine.getViewportAt(t).getCamera();
                i && (i.getEntity().getPositionRelativeToEntity(e, s.Vector3.Zero, this.getEntity()),
                e.rotateInverse(this.getEntity().getOrientation(), e),
                this._cameraFieldsOfView[t] = i.getFieldOfView())
            }
            let t = !1;
            for (let e = 0, i = this._activatedTiles.getSize(); e < i; e++) {
                const i = this._activatedTiles.getAt(e);
                t ||= i.update()
            }
            if (null === this._tilesLoadedPromise && t && (this._tilesLoadedPromise = new Promise((t => {
                this._transitionsCompleteCallback = t
            }
            ))),
            null !== this._tilesLoadedPromise && !t) {
                const t = this._transitionsCompleteCallback;
                this._tilesLoadedPromise = null,
                this._transitionsCompleteCallback = null,
                t && t()
            }
        }
        __prepareForRender(t) {
            for (let e = 0, i = this._activatedTiles.getSize(); e < i; e++) {
                this._activatedTiles.getAt(e).prepareForRender(t)
            }
            s.ThreeJsHelper.setOrientationToEntity(this.getThreeJsObjects(), this.getEntity());
            const e = this._atmosphereComponentRef.get();
            s.MaterialUtils.setUniforms(this.getThreeJsMaterials(), t, this.getEntity(), this._shadowEntities, e, !0)
        }
        async __loadResources() {
            const t = [];
            for (let e = 0, i = this._endPoints.getSize(); e < i; e++) {
                const i = this._endPoints.getAt(e)
                  , s = i.value.url;
                this._numEndPointsLoading += 1;
                const n = this.getEntity().getScene().getEngine().getDownloader().download(`${s}/configuration.json`, "text", -this.getEntity().getLeastCameraDepth()).then((t => {
                    if ("failed" === t.status)
                        throw new Error(`Failed to download ${s}/configuration.json`);
                    if ("completed" === t.status && "string" == typeof t.content) {
                        const e = JSON.parse(t.content);
                        i.value.configuration = e,
                        "color" === i.key && (this._colorTileSize = e.tile_size),
                        this._numEndPointsLoading -= 1
                    }
                }
                ));
                t.push(n)
            }
            await Promise.allSettled(t)
        }
        __unloadResources() {
            if (this._rootTiles)
                for (let t = 0; t < 6; t++)
                    this._rootTiles[t].destroy();
            this._rootTiles = null
        }
        __getNumCurrentLoads() {
            return this._numCurrentLoads
        }
        __incNumCurrentLoads() {
            this._numCurrentLoads += 1
        }
        __decNumCurrentLoads() {
            this._numCurrentLoads -= 1
        }
        __getMaxCurrentLoads() {
            return this._maxCurrentLoads
        }
        __getEndPoints() {
            return this._endPoints
        }
        __endPointsAreLoaded() {
            return 0 === this._numEndPointsLoading
        }
        __getCameraPositions() {
            return this._cameraPositions
        }
        __getCameraFieldsOfView() {
            return this._cameraFieldsOfView
        }
        __getThreeJsScene() {
            return this._threeJsScene
        }
        __getSplitJoinThresholdFactor() {
            return this._splitJoinThresholdFactor
        }
        __getColorTileSize() {
            return this._colorTileSize
        }
        __getSpheroidComponent() {
            return this._spheroidComponentRef.get()
        }
        __addActivatedTile(t) {
            this._activatedTiles.add(t)
        }
        __removeActivatedTile(t) {
            this._activatedTiles.delete(t)
        }
        __getTransparent() {
            return this._transparent
        }
        __getMaterialOptions() {
            return this._materialOptions
        }
        _spheroidRefChangedCallback(t, e) {
            t && t.removeChangedCallback(this._spheroidChangedCallback),
            e && e.addChangedCallback(this._spheroidChangedCallback),
            this._spheroidChangedCallback()
        }
        _spheroidChangedCallback() {
            const t = this._spheroidComponentRef.get();
            null !== t ? this.__setRadius(Math.max(t.getEquatorialRadius(), t.getPolarRadius())) : this.__setRadius(0),
            this.resetResources()
        }
    }
    class CMTSTile extends s.Tile {
        constructor(t, e, i, n, o) {
            super(e),
            this._component = t,
            this._face = i,
            this._level = n,
            this._levelPow = 2 ** -Math.max(0, n),
            this._tile = new s.Vector2,
            this._tile.copy(o),
            this._isLeaf = !0,
            this._center = new s.Vector3,
            this._centerLLA = new s.LatLonAlt,
            this._radius = 0,
            this._threeJsMaterial = null,
            this._textureLevels = new s.FastMap,
            this._cacheEntries = new s.FastMap,
            this._numNonPositiveTexturesLoading = 0,
            this._threeJsObject = null,
            this._heightData = null,
            this._updateMeshIndex = 0,
            this._numVerts = new s.Vector2,
            this._uvOffsets = new s.FastMap,
            this._uvScales = new s.FastMap,
            this._heightOffset = 0,
            this._heightScale = 1,
            this._meshPositions = new Float32Array(0),
            this._meshNormals = new Float32Array(0),
            this._meshTangents = new Float32Array(0),
            this._meshBitangents = new Float32Array(0),
            this._meshUVs = new s.FastMap,
            this._meshIndices = new Uint16Array(0);
            for (let t = 0; t < this._component.__getEndPoints().getSize(); t++) {
                const e = this._component.__getEndPoints().getAt(t).value.configuration;
                if (e)
                    for (let t = 0; t < 2; t++)
                        for (let i = 0; i < 2; i++)
                            this._isLeaf &&= !CMTSTile._isInABoundary(e, this._face, this._level + 1, new s.Vector2(2 * this._tile.x + i,2 * this._tile.y + t))
            }
            const a = t.__getSpheroidComponent();
            if (!a)
                throw new Error(`No spheroid component on the ${t}!`);
            CMTSTile.cmtsCoordToPosition(this._center, this._face, this._levelPow, this._tile.x + .5, this._tile.y + .5, a),
            a.llaFromXYZ(this._centerLLA, this._center);
            const r = new s.Vector3
              , l = new s.Vector3
              , c = new s.Vector3
              , h = new s.Vector3;
            CMTSTile.cmtsCoordToPosition(r, this._face, this._levelPow, this._tile.x, this._tile.y, a),
            CMTSTile.cmtsCoordToPosition(l, this._face, this._levelPow, this._tile.x + 1, this._tile.y, a),
            CMTSTile.cmtsCoordToPosition(c, this._face, this._levelPow, this._tile.x + 1, this._tile.y + 1, a),
            CMTSTile.cmtsCoordToPosition(h, this._face, this._levelPow, this._tile.x, this._tile.y + 1, a),
            r.sub(this._center, r),
            l.sub(this._center, l),
            c.sub(this._center, c),
            h.sub(this._center, h),
            this._radius = Math.max(r.magnitude(), l.magnitude(), c.magnitude(), h.magnitude());
            const d = this._component.__getEndPoints();
            for (let t = 0; t < d.getSize(); t++) {
                const e = d.getAt(t).key
                  , i = d.getAt(t).value;
                if (i.configuration && CMTSTile._isInABoundary(i.configuration, this._face, this._level, this._tile)) {
                    const t = 0 === this._level ? this._getNonPositiveLevel(e) : 0
                      , i = 0 === this._level ? t : this._level;
                    isNaN(i) || this._textureLevels.set(e, i)
                } else {
                    let i = this.getParent();
                    for (; null !== i && i._level !== i._textureLevels.getAt(t).value; )
                        i = i.getParent();
                    null !== i ? this._textureLevels.set(e, i._textureLevels.getAt(t).value) : this._textureLevels.set(e, 0)
                }
            }
        }
        getLevel() {
            return this._level
        }
        getTileCoord() {
            return this._tile
        }
        hasHeightData() {
            return null !== this._heightData
        }
        getHeight(t) {
            if (!this._heightData)
                return 0;
            const e = this._uvOffsets.get("height")
              , i = this._uvScales.get("height");
            if (!e || !i)
                return 0;
            const s = 1 << this._level
              , n = t.x * s - this._tile.x
              , o = t.y * s - this._tile.y
              , a = this._heightData.width - 4
              , r = (e.x + n * i.x) * a + 2
              , l = this._heightData.height - ((e.y + o * i.y) * a + 2)
              , c = CMTSTile.getLinearInterpolatedHeightPixel(r, l, this._heightData.data, this._heightData.width);
            return this._heightOffset + c * this._heightScale
        }
        createNewTile(t, e, i) {
            const n = this._level + 1
              , o = new s.Vector2(2 * t._tile.x + i,2 * t._tile.y + e);
            return new CMTSTile(t._component,this,this._face,n,o)
        }
        checkSplit() {
            if (this._isLeaf || this._level >= this._component.getMaxLevel())
                return !1;
            if (this._component.__getNumCurrentLoads() >= this._component.__getMaxCurrentLoads())
                return !1;
            if (this._level < this._component.getMinLevel())
                return !0;
            const t = this._component.__getColorTileSize();
            return this._getNearestDistance() < this._component.__getSplitJoinThresholdFactor() * this._radius / t
        }
        checkJoin() {
            if (this._level >= this._component.getMaxLevel())
                return !0;
            if (this._component.__getNumCurrentLoads() >= this._component.__getMaxCurrentLoads())
                return !1;
            if (this._level < this._component.getMinLevel())
                return !1;
            const t = this._component.__getColorTileSize();
            return this._getNearestDistance() > this._component.__getSplitJoinThresholdFactor() * this._radius / t * 4
        }
        async load() {
            if (this._component.__incNumCurrentLoads(),
            null !== this._threeJsMaterial)
                throw this._component.__decNumCurrentLoads(),
                new Error("Tile already has material.");
            this._threeJsMaterial = s.MaterialUtils.get(),
            this._component.getThreeJsMaterials().push(this._threeJsMaterial),
            this._threeJsMaterial.defines.shadowEntities = this._component.getNumShadowEntities() > 0;
            for (const t of this._component.__getMaterialOptions())
                this._threeJsMaterial.defines[t] = !0;
            const t = this._component.__getEndPoints()
              , e = [];
            for (let i = 0; i < t.getSize(); i++) {
                const s = t.getAt(i).key
                  , n = t.getAt(i).value;
                if (!n.configuration)
                    continue;
                const o = this._textureLevels.get(s);
                if (void 0 === o || !isFinite(o))
                    continue;
                const a = this._tile.x >> this._level - o
                  , r = this._tile.y >> this._level - o
                  , l = `${n.url}/${this._face}/${o}/${a}/${r}.${n.configuration.extension}`;
                e.push(n.cache.get(l).catch((async () => n.cache.get("pink"))).then((t => {
                    this._setTexture(s, t),
                    this._cacheEntries.set(s, t)
                }
                )))
            }
            await Promise.allSettled(e).finally(( () => {
                this._component.__decNumCurrentLoads()
            }
            ))
        }
        unload() {
            if (null === this._threeJsMaterial)
                throw new Error("Tile has no material to unload.");
            const t = this._component.getThreeJsMaterials();
            for (let e = 0, i = t.length; e < i; e++)
                if (t[e] === this._threeJsMaterial) {
                    t.splice(e, 1);
                    break
                }
            for (let t = 0; t < this._cacheEntries.getSize(); t++) {
                const {key: e, value: i} = this._cacheEntries.getAt(t)
                  , s = this._component.__getEndPoints().get(e);
                s && s.cache.release(i)
            }
            this._cacheEntries.clear(),
            s.ThreeJsHelper.destroyMaterial(this._threeJsMaterial, !1),
            this._threeJsMaterial = null
        }
        async activate() {
            if (null !== this._threeJsObject || null === this._threeJsMaterial)
                throw new Error;
            for (let t = 0; t < this._textureLevels.getSize(); t++) {
                const {key: e, value: i} = this._textureLevels.getAt(t)
                  , n = 1 << this._level - Math.max(0, i);
                this._uvOffsets.set(e, new s.Vector2((this._tile.x - Math.floor(this._tile.x / n) * n) / n,(this._tile.y - Math.floor(this._tile.y / n) * n) / n)),
                this._uvScales.set(e, new s.Vector2(1 / n,1 / n))
            }
            const t = this._uvScales.get("height");
            this._numVerts.x = 7 << s.MathUtils.clamp(2 - this._level / 2, 0, 2),
            this._numVerts.y = 7 << s.MathUtils.clamp(2 - this._level / 2, 0, 2),
            this._heightData && t && (this._numVerts.x = s.MathUtils.clamp(Math.ceil(this._heightData.width * t.x) - 2, this._numVerts.x, 129),
            this._numVerts.y = s.MathUtils.clamp(Math.ceil(this._heightData.height * t.y) - 2, this._numVerts.y, 129));
            const e = this._numVerts.x * this._numVerts.y;
            this._meshPositions = new Float32Array(3 * e),
            this._meshNormals = new Float32Array(3 * e),
            this._textureLevels.has("normal") && (this._meshTangents = new Float32Array(3 * e),
            this._meshBitangents = new Float32Array(3 * e));
            const i = (this._numVerts.x - 1) * (this._numVerts.y - 1) * 6;
            this._meshIndices = i <= 65536 ? new Uint16Array(i) : new Uint32Array(i);
            for (let t = 0; t < this._textureLevels.getSize(); t++) {
                const i = this._textureLevels.getAt(t).key;
                this._meshUVs.set(i, new Float32Array(2 * e))
            }
            const n = this._component.__getEndPoints().get("height")?.configuration;
            this._heightOffset = this._component.getHeightOffset() + (n?.height_range.min ?? 0) * this._component.getHeightScale(),
            this._heightScale = ((n?.height_range.max ?? 0) - (n?.height_range.min ?? 0)) * this._component.getHeightScale();
            const o = new s.THREE.BufferGeometry;
            o.boundingSphere = new s.THREE.Sphere;
            const a = s.ThreeJsHelper.createGLBufferAttribute("vertex", this._meshPositions, "float", 3, this._component);
            o.setAttribute("position", a);
            const r = s.ThreeJsHelper.createGLBufferAttribute("vertex", this._meshNormals, "float", 3, this._component);
            o.setAttribute("normal", r);
            const l = this._meshUVs.get("color");
            if (l) {
                const t = s.ThreeJsHelper.createGLBufferAttribute("vertex", l, "float", 2, this._component);
                o.setAttribute("uv", t)
            }
            if (this._textureLevels.has("normal")) {
                const t = s.ThreeJsHelper.createGLBufferAttribute("vertex", this._meshTangents, "float", 3, this._component);
                o.setAttribute("tangent", t);
                const e = s.ThreeJsHelper.createGLBufferAttribute("vertex", this._meshBitangents, "float", 3, this._component);
                o.setAttribute("bitangent", e)
            }
            for (let t = 0; t < this._meshUVs.getSize(); t++) {
                const e = this._meshUVs.getAt(t);
                if ("color" !== e.key && "height" !== e.key) {
                    const t = s.ThreeJsHelper.createGLBufferAttribute("vertex", e.value, "float", 2, this._component);
                    o.setAttribute(`${e.key}UV`, t)
                }
            }
            const c = s.ThreeJsHelper.createGLBufferAttribute("index", this._meshIndices, 2 === this._meshIndices.BYTES_PER_ELEMENT ? "unsignedShort" : "unsignedInt", 1, this._component);
            o.setIndex(c),
            await new Promise(( (t, e) => {
                this._updateMeshIndex = 0;
                const i = setInterval(( () => {
                    try {
                        this._updateMesh(o) && (clearInterval(i),
                        t())
                    } catch (t) {
                        s.ThreeJsHelper.destroyGeometry(o, this._component),
                        clearInterval(i),
                        e(t)
                    }
                }
                ), 0)
            }
            )),
            this._threeJsObject = s.ThreeJsHelper.createMeshObjectGivenGeometry(this._component, this._threeJsMaterial, o),
            this._component.getThreeJsObjects().push(this._threeJsObject),
            s.ThreeJsHelper.useInDynEnvMap(this._threeJsObject, !0),
            this._component.__addActivatedTile(this)
        }
        deactivate() {
            this._component.__removeActivatedTile(this);
            const t = this._component.getThreeJsObjects();
            for (let e = 0, i = t.length; e < i; e++)
                if (t[e] === this._threeJsObject) {
                    t.splice(e, 1);
                    break
                }
            this._threeJsObject && (s.ThreeJsHelper.destroyObject(this._threeJsObject, this._component),
            this._threeJsObject = null)
        }
        update() {
            if (!this._component.__endPointsAreLoaded())
                return !1;
            let t = this.check();
            const e = this.getParent();
            if (t || e?.getChildren()[0] !== this || (t ||= e.check()),
            !t && 0 === this._numNonPositiveTexturesLoading && 0 === this._level && 0 === this.getChildren().length) {
                const t = this._component.__getEndPoints();
                for (let e = 0; e < t.getSize(); e++) {
                    const i = t.getAt(e).key;
                    if ("height" === i)
                        continue;
                    const s = t.getAt(e).value;
                    if (!s.configuration)
                        continue;
                    const n = this._getNonPositiveLevel(i);
                    if (isFinite(n) && n !== this._textureLevels.get(i)) {
                        this._textureLevels.set(i, n),
                        this._numNonPositiveTexturesLoading += 1;
                        const t = `${s.url}/${this._face}/${n}/0/0.${s.configuration.extension}`
                          , e = this._cacheEntries.get(i);
                        s.cache.get(t).catch((async () => s.cache.get("pink"))).then((t => {
                            this.isDestroyed() ? s.cache.release(t) : (this._cacheEntries.set(i, t),
                            this._setTexture(i, t))
                        }
                        )).finally(( () => {
                            void 0 !== e && s.cache.release(e),
                            this._numNonPositiveTexturesLoading -= 1
                        }
                        ))
                    }
                }
            }
            return this._numNonPositiveTexturesLoading > 0 || t
        }
        _updateMesh(t) {
            if (this.isDestroyed())
                return !0;
            const e = this._component.__getSpheroidComponent();
            if (!e)
                return !0;
            const i = this._uvOffsets.get("height")
              , n = this._uvScales.get("height")
              , o = this._component.__getColorTileSize()
              , a = this._textureLevels.has("normal")
              , r = this._component.__getTransparent()
              , l = s.Vector3.pool.get()
              , c = s.Vector3.pool.get()
              , h = s.Vector3.pool.get()
              , d = s.LatLonAlt.pool.get();
            let u, p, m, _, g, y, f, b;
            a ? (f = s.Vector3.pool.get(),
            b = s.Vector3.pool.get()) : (u = s.Vector3.pool.get(),
            p = s.Vector3.pool.get(),
            m = s.Vector3.pool.get(),
            _ = s.Vector3.pool.get(),
            g = s.Vector3.pool.get(),
            y = s.Vector3.pool.get());
            const T = this._component.getEntity().getScene().getEngine().getFPS()
              , v = Math.floor(50 * T)
              , S = this._numVerts.x * this._numVerts.y
              , E = this._updateMeshIndex
              , C = Math.min(this._updateMeshIndex + v, S);
            let x = Number.POSITIVE_INFINITY
              , w = 0;
            for (; this._updateMeshIndex < C; this._updateMeshIndex++) {
                const t = this._updateMeshIndex
                  , a = t % this._numVerts.x
                  , T = Math.floor(t / this._numVerts.x)
                  , v = this._tile.x + (a - 1) / (this._numVerts.x - 3)
                  , S = this._tile.y + (T - 1) / (this._numVerts.y - 3)
                  , E = this._tile.x + s.MathUtils.clamp01((a - 1) / (this._numVerts.x - 3))
                  , C = this._tile.y + s.MathUtils.clamp01((T - 1) / (this._numVerts.y - 3));
                if (CMTSTile.cmtsCoordToPosition(l, this._face, this._levelPow, E, C, e),
                f && CMTSTile.cmtsCoordToTangent(f, this._face, this._levelPow, v, S, e),
                b && CMTSTile.cmtsCoordToBitangent(b, this._face, this._levelPow, v, S, e),
                e.llaFromXYZ(d, l),
                e.upFromLLA(h, d),
                e.isPlanetographic() ? c.copy(h) : c.normalize(l),
                this._heightData && i && n) {
                    const t = this._heightData.data
                      , o = this._heightData.width - 4;
                    CMTSTile.getHeightPos(l, c, s.MathUtils.clamp(a, 1, this._numVerts.x - 2), s.MathUtils.clamp(T, 1, this._numVerts.y - 2), t, i, this._numVerts.x, this._numVerts.y, n, o, this._heightOffset, this._heightScale),
                    u && p && m && _ && g && y && (CMTSTile.cmtsCoordToPosition(u, this._face, this._levelPow, v - 1 / (this._numVerts.x - 3), S, e),
                    CMTSTile.getHeightPos(u, c, a - 1, T, t, i, this._numVerts.x, this._numVerts.y, n, o, this._heightOffset, this._heightScale),
                    CMTSTile.cmtsCoordToPosition(p, this._face, this._levelPow, v + 1 / (this._numVerts.x - 3), S, e),
                    CMTSTile.getHeightPos(p, c, a + 1, T, t, i, this._numVerts.x, this._numVerts.y, n, o, this._heightOffset, this._heightScale),
                    CMTSTile.cmtsCoordToPosition(m, this._face, this._levelPow, v, S - 1 / (this._numVerts.y - 3), e),
                    CMTSTile.getHeightPos(m, c, a, T - 1, t, i, this._numVerts.x, this._numVerts.y, n, o, this._heightOffset, this._heightScale),
                    CMTSTile.cmtsCoordToPosition(_, this._face, this._levelPow, v, S + 1 / (this._numVerts.y - 3), e),
                    CMTSTile.getHeightPos(_, c, a, T + 1, t, i, this._numVerts.x, this._numVerts.y, n, o, this._heightOffset, this._heightScale),
                    CMTSTile.cmtsCoordToPosition(g, this._face, this._levelPow, v - 1 / (this._numVerts.x - 3), S - 1 / (this._numVerts.y - 3), e),
                    CMTSTile.getHeightPos(g, c, a - 1, T - 1, t, i, this._numVerts.x, this._numVerts.y, n, o, this._heightOffset, this._heightScale),
                    CMTSTile.cmtsCoordToPosition(y, this._face, this._levelPow, v + 1 / (this._numVerts.x - 3), S + 1 / (this._numVerts.y - 3), e),
                    CMTSTile.getHeightPos(y, c, a + 1, T + 1, t, i, this._numVerts.x, this._numVerts.y, n, o, this._heightOffset, this._heightScale),
                    u.sub(p, u),
                    m.sub(_, m),
                    c.cross(u, m),
                    c.normalize(c))
                } else
                    l.addMult(l, c, this._heightOffset);
                r || 0 !== a && 0 !== T && a !== this._numVerts.x - 1 && T !== this._numVerts.y - 1 || l.setMagnitude(l, l.magnitude() - Math.max(2 * this._heightScale * this._levelPow, .01 * this._radius)),
                l.sub(l, this._center),
                this._meshPositions[3 * t + 0] = l.x,
                this._meshPositions[3 * t + 1] = l.y,
                this._meshPositions[3 * t + 2] = l.z,
                this._meshNormals[3 * t + 0] = c.x,
                this._meshNormals[3 * t + 1] = c.y,
                this._meshNormals[3 * t + 2] = c.z,
                f && b && (this._meshTangents[3 * t + 0] = f.x,
                this._meshTangents[3 * t + 1] = f.y,
                this._meshTangents[3 * t + 2] = f.z,
                this._meshBitangents[3 * t + 0] = b.x,
                this._meshBitangents[3 * t + 1] = b.y,
                this._meshBitangents[3 * t + 2] = b.z);
                for (let e = 0; e < this._textureLevels.getSize(); e++) {
                    const i = this._textureLevels.getAt(e).key
                      , s = this._uvOffsets.get(i)
                      , n = this._uvScales.get(i)
                      , r = this._meshUVs.get(i);
                    s && n && r && (r[2 * t + 0] = (s.x + (a - 1) / (this._numVerts.x - 3) * n.x) * o / (o + 4) + 2 / (o + 4),
                    r[2 * t + 1] = 1 - ((s.y + (T - 1) / (this._numVerts.y - 3) * n.y) * o / (o + 4) + 2 / (o + 4)))
                }
                if (a < this._numVerts.x - 1 && T < this._numVerts.y - 1) {
                    const t = T * (this._numVerts.x - 1) + a;
                    this._meshIndices[6 * t + 0] = this._numVerts.x * (T + 0) + (a + 0),
                    this._meshIndices[6 * t + 1] = this._numVerts.x * (T + 0) + (a + 1),
                    this._meshIndices[6 * t + 2] = this._numVerts.x * (T + 1) + (a + 1),
                    this._meshIndices[6 * t + 3] = this._numVerts.x * (T + 0) + (a + 0),
                    this._meshIndices[6 * t + 4] = this._numVerts.x * (T + 1) + (a + 1),
                    this._meshIndices[6 * t + 5] = this._numVerts.x * (T + 1) + (a + 0),
                    x > 6 * t + 0 && (x = 6 * t + 0),
                    w < 6 * t + 5 && (w = 6 * t + 5)
                }
            }
            u && p && m && _ && g && y && (s.Vector3.pool.release(u),
            s.Vector3.pool.release(p),
            s.Vector3.pool.release(m),
            s.Vector3.pool.release(_),
            s.Vector3.pool.release(g),
            s.Vector3.pool.release(y)),
            f && b && (s.Vector3.pool.release(f),
            s.Vector3.pool.release(b)),
            s.Vector3.pool.release(l),
            s.Vector3.pool.release(c),
            s.LatLonAlt.pool.release(d),
            s.Vector3.pool.release(h),
            s.ThreeJsHelper.updateGLBufferAttribute(t.getAttribute("position"), "vertex", this._meshPositions, 3 * E, 3 * (C - E), this._component),
            s.ThreeJsHelper.updateGLBufferAttribute(t.getAttribute("normal"), "vertex", this._meshNormals, 3 * E, 3 * (C - E), this._component),
            a && (s.ThreeJsHelper.updateGLBufferAttribute(t.getAttribute("tangent"), "vertex", this._meshTangents, 3 * E, 3 * (C - E), this._component),
            s.ThreeJsHelper.updateGLBufferAttribute(t.getAttribute("bitangent"), "vertex", this._meshBitangents, 3 * E, 3 * (C - E), this._component));
            for (let e = 0; e < this._meshUVs.getSize(); e++) {
                const i = this._meshUVs.getAt(e)
                  , n = i.key;
                "height" !== n && s.ThreeJsHelper.updateGLBufferAttribute(t.getAttribute("color" === n ? "uv" : `${n}UV`), "vertex", i.value, 2 * E, 2 * (C - E), this._component)
            }
            const I = t.getIndex();
            return s.ThreeJsHelper.updateGLBufferAttribute(I, "index", this._meshIndices, x, w - x + 1, this._component),
            this._updateMeshIndex === S
        }
        _getNonPositiveLevel(t) {
            const e = this._component.__getEndPoints().get(t);
            if (!e?.configuration)
                return NaN;
            const i = this._getNearestDistance();
            if (!Number.isFinite(i))
                return e.configuration.first_level;
            const n = e.configuration.tile_size;
            return s.MathUtils.clamp(4 - Math.floor(Math.log2(i / this._radius / this._component.__getSplitJoinThresholdFactor() * n * 4)), e.configuration.first_level, 0)
        }
        _getNearestDistance() {
            let t = Number.POSITIVE_INFINITY;
            const e = this._component.__getCameraPositions()
              , i = this._component.__getCameraFieldsOfView();
            for (let n = 0, o = e.length; n < o; n++) {
                const o = e[n]
                  , a = i[n]
                  , r = s.Vector3.pool.get();
                r.sub(o, this._center);
                const l = Math.max(0, r.magnitude() - this._radius) * Math.tan(a / 2);
                t > l && (t = l),
                s.Vector3.pool.release(r)
            }
            return t
        }
        toString() {
            return `${this._face}/${this._level}/${this._tile.x}/${this._tile.y}`
        }
        prepareForRender(t) {
            if (null !== this._threeJsObject) {
                if (!this.shouldBeVisible())
                    return void (this._threeJsObject.visible = !1);
                const e = this._component.getEntity()
                  , i = e.getCameraSpacePosition(t)
                  , n = s.Vector3.pool.get();
                n.rotate(e.getOrientation(), this._center);
                const o = Math.acos(n.dot(i) / n.magnitude() / i.magnitude());
                if (s.Vector3.pool.release(n),
                o < Math.PI / 2 - Math.PI / 4 * this._levelPow)
                    return void (this._threeJsObject.visible = !1);
                s.ThreeJsHelper.setPositionToEntity(this._threeJsObject, this._component.getEntity(), t, this._center, !0)
            }
        }
        _setTexture(t, e) {
            if ("loaded" !== this._component.getLoadState().state)
                throw new Error(`Already loaded in ${this._component}.`);
            if (e.heightData) {
                this._heightData = e.heightData;
                const t = this._component.__getSpheroidComponent();
                if (!t)
                    throw new Error(`Could not find spheroid component for height texture in ${this._component}.`);
                const i = this._component.__getEndPoints().get("height")?.configuration;
                if (!i)
                    throw new Error(`Configuration missing in ${this._component}`);
                CMTSTile.cmtsCoordToPosition(this._center, this._face, this._levelPow, this._tile.x + .5, this._tile.y + .5, t);
                const n = s.Vector3.pool.get()
                  , o = s.LatLonAlt.pool.get();
                t.llaFromXYZ(o, this._center),
                t.upFromLLA(n, o);
                const a = CMTSTile.getLinearInterpolatedHeightPixel(this._heightData.width / 2, this._heightData.height / 2, this._heightData.data, this._heightData.width)
                  , r = i.height_range.min * this._component.getHeightScale()
                  , l = (i.height_range.max - i.height_range.min) * this._component.getHeightScale();
                this._center.addMult(this._center, n, r + a * l),
                s.Vector3.pool.release(n),
                s.LatLonAlt.pool.release(o)
            } else if (this._threeJsMaterial) {
                if (this._threeJsMaterial.uniforms[`${t}Texture`].value = e.texture,
                "normal" === t) {
                    this._threeJsMaterial.defines.normalMap = !0,
                    this._threeJsMaterial.defines.normalUVs = !0,
                    this._threeJsMaterial.defines.hasBitangents = !0;
                    this._threeJsMaterial.uniforms.normalScale.value.set(this._component.getHeightScale(), this._component.getHeightScale()),
                    this._threeJsMaterial.uniforms.specularIntensity.value = 0,
                    this._threeJsMaterial.uniforms.specularHardness.value = 100
                } else
                    "specular" === t ? (this._threeJsMaterial.defines.specularMap = !0,
                    this._threeJsMaterial.defines.specularUVs = !0) : "night" === t ? (this._threeJsMaterial.defines.nightMap = !0,
                    this._threeJsMaterial.defines.nightUVs = !0,
                    this._threeJsMaterial.defines.nightMapEmissive = !0) : "decal" === t && (this._threeJsMaterial.defines.decalMap = !0,
                    this._threeJsMaterial.defines.decalUVs = !0);
                this._component.__getTransparent() && (s.ThreeJsHelper.setTransparent(this._threeJsMaterial, !0),
                this._threeJsMaterial.side = s.THREE.DoubleSide)
            }
        }
        static _getGreatestLevel(t, e, i, s) {
            let n = Number.NEGATIVE_INFINITY;
            for (let o = 0, a = t.boundaries.length; o < a; o++) {
                const a = t.boundaries[o];
                if (a.face !== e)
                    continue;
                const r = a.last_level - i;
                a.min[0] <= s.x >> r && s.x >> r <= a.max[0] && a.min[1] <= s.y >> r && s.y >> r <= a.max[1] && n < a.last_level && (n = a.last_level)
            }
            return n
        }
        static _isInABoundary(t, e, i, s) {
            let n = !1;
            for (let o = 0, a = t.boundaries.length; o < a; o++) {
                const a = t.boundaries[o];
                if (a.face !== e)
                    continue;
                if (a.last_level < i)
                    continue;
                const r = 1 << a.last_level - i;
                s.x < Math.floor(a.min[0] / r) || Math.floor(a.max[0] / r) < s.x || (s.y < Math.floor(a.min[1] / r) || Math.floor(a.max[1] / r) < s.y || (n = !0))
            }
            return n
        }
        static getHeightPos(t, e, i, s, n, o, a, r, l, c, h, d) {
            const u = (o.x + (i - 1) / (a - 3) * l.x) * c + 2
              , p = c + 4 - ((o.y + (s - 1) / (r - 3) * l.y) * c + 2)
              , m = this.getLinearInterpolatedHeightPixel(u, p, n, c + 4);
            t.addMult(t, e, h + m * d)
        }
        static getLinearInterpolatedHeightPixel(t, e, i, s) {
            const n = Math.floor(t)
              , o = Math.floor(e)
              , a = t - n
              , r = e - o
              , l = Math.abs(a - .5)
              , c = Math.abs(r - .5);
            let h = this.getHeightFromPixel(n, o, i, s) * ((1 - l) * (1 - c));
            return a >= .5 ? (h += this.getHeightFromPixel(n + 1, o, i, s) * (l * (1 - c)),
            r < .5 ? h += this.getHeightFromPixel(n + 1, o - 1, i, s) * (l * c) : r >= .5 && (h += this.getHeightFromPixel(n + 1, o + 1, i, s) * (l * c))) : a < .5 && (h += this.getHeightFromPixel(n - 1, o, i, s) * (l * (1 - c)),
            r < .5 ? h += this.getHeightFromPixel(n - 1, o - 1, i, s) * (l * c) : r >= .5 && (h += this.getHeightFromPixel(n - 1, o + 1, i, s) * (l * c))),
            r >= .5 ? h += this.getHeightFromPixel(n, o + 1, i, s) * ((1 - l) * c) : r < .5 && (h += this.getHeightFromPixel(n, o - 1, i, s) * ((1 - l) * c)),
            h
        }
        static getHeightFromPixel(t, e, i, n) {
            t = s.MathUtils.clamp(t, 0, n - 1);
            const o = 4 * ((e = s.MathUtils.clamp(e, 0, n - 1)) * n + t);
            return i[o + 0] / 256 + i[o + 1] / 65536 + i[o + 2] / 16777216
        }
        static cmtsCoordToPosition(t, e, i, n, o, a) {
            let r = n * i
              , l = o * i;
            for (; r < 0 || r > 1 || l < 0 || l > 1; )
                if (0 <= e && e <= 3) {
                    if (r > 1)
                        r -= 1,
                        e = (e + 1) % 4;
                    else if (r < 0)
                        r += 1,
                        e = (e + 3) % 4;
                    else if (0 === e)
                        l < 0 ? (l += 1,
                        e = 5) : l > 1 && (l -= 1,
                        e = 4);
                    else if (1 === e) {
                        if (l < 0) {
                            const t = r;
                            r = l + 1,
                            l = 1 - t,
                            e = 5
                        } else if (l > 1) {
                            const t = r;
                            r = 2 - l,
                            l = t,
                            e = 4
                        }
                    } else if (2 === e)
                        l < 0 ? (r = 1 - r,
                        l = 0 - l,
                        e = 5) : l > 1 && (r = 1 - r,
                        l = 2 - l,
                        e = 4);
                    else if (3 === e)
                        if (l < 0) {
                            const t = r;
                            r = 0 - l,
                            l = t,
                            e = 5
                        } else if (l > 1) {
                            const t = r;
                            r = l - 1,
                            l = 1 - t,
                            e = 4
                        }
                } else if (4 === e)
                    if (r < 0) {
                        const t = r;
                        r = 1 - l,
                        l = t + 1,
                        e = 3
                    } else if (r > 1) {
                        const t = r;
                        r = l,
                        l = 2 - t,
                        e = 1
                    } else
                        l < 0 ? (l += 1,
                        e = 0) : l > 1 && (r = 1 - r,
                        l = 2 - l,
                        e = 2);
                else if (5 === e)
                    if (r < 0) {
                        const t = r;
                        r = l,
                        l = 0 - t,
                        e = 3
                    } else if (r > 1) {
                        const t = r;
                        r = 1 - l,
                        l = t - 1,
                        e = 1
                    } else
                        l < 0 ? (r = 1 - r,
                        l = 0 - l,
                        e = 2) : l > 1 && (l -= 1,
                        e = 0);
            const c = 2 * r - 1
              , h = 2 * l - 1
              , d = this._basis[e];
            t.set(d[0].x * c + d[1].x * h + d[2].x, d[0].y * c + d[1].y * h + d[2].y, d[0].z * c + d[1].z * h + d[2].z),
            t.normalize(t);
            const u = s.LatLonAlt.pool.get();
            s.Geometry.getLLAFromXYZOnSphere(u, t, 0),
            u.alt = 0,
            a.xyzFromLLA(t, u),
            s.LatLonAlt.pool.release(u)
        }
        static cmtsCoordToTangent(t, e, i, s, n, o) {
            this.cmtsCoordToPosition(t, e, i, s, n, o);
            const a = this._basis[e];
            t.setNormalTo(t, a[0])
        }
        static cmtsCoordToBitangent(t, e, i, s, n, o) {
            this.cmtsCoordToPosition(t, e, i, s, n, o);
            const a = this._basis[e];
            t.setNormalTo(t, a[1])
        }
        static _basis = [[s.Vector3.YAxis, s.Vector3.ZAxis, s.Vector3.XAxis], [s.Vector3.XAxisNeg, s.Vector3.ZAxis, s.Vector3.YAxis], [s.Vector3.YAxisNeg, s.Vector3.ZAxis, s.Vector3.XAxisNeg], [s.Vector3.XAxis, s.Vector3.ZAxis, s.Vector3.YAxisNeg], [s.Vector3.YAxis, s.Vector3.XAxisNeg, s.Vector3.ZAxis], [s.Vector3.YAxis, s.Vector3.XAxis, s.Vector3.ZAxisNeg]]
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        CometTailComponent: function() {
            return CometTailComponent
        }
    });
    var s = i(6);
    class CometTailComponent extends s.BaseComponent {
        constructor(t, e) {
            super(t, e),
            this._lightSource = new s.EntityRef(this.getEntity().getScene()),
            this._timeLength = 6e5,
            this._numberOfParticles = 200,
            this._color = new s.Color,
            this._color.freeze(),
            this._starAccelerationMultiplier = 1,
            this._timeOfParticle0 = 0
        }
        getLightSource() {
            return this._lightSource.getName()
        }
        setLightSource(t) {
            this._lightSource.setName(t)
        }
        getTimeLength() {
            return this._timeLength
        }
        setTimeLength(t) {
            this._timeLength = t,
            this.resetResources()
        }
        getStarAccelerationMultiplier() {
            return this._starAccelerationMultiplier
        }
        setStarAccelerationMultiplier(t) {
            this._starAccelerationMultiplier = t,
            s.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], "starAccelerationMultiplier", this._starAccelerationMultiplier)
        }
        getNumberOfParticles() {
            return this._numberOfParticles
        }
        setNumberOfParticles(t) {
            this._numberOfParticles = t,
            this.resetResources()
        }
        getColor() {
            return this._color
        }
        setColor(t) {
            this._color.thaw(),
            this._color.copy(t),
            this._color.freeze(),
            s.ThreeJsHelper.setUniformColorRGBA(this.getThreeJsMaterials()[0], "color", this._color)
        }
        __update() {
            if (this.__setRadius(Math.max(this.getEntity().getExtentsRadius(), this._timeLength * this.getEntity().getVelocity().magnitude())),
            "loaded" !== this.getLoadState().state)
                return;
            const t = this.getEntity().getScene().getEngine().getTime()
              , e = this.getThreeJsObjects()[0].geometry.attributes.originTime.array;
            for (let i = 0, n = this._numberOfParticles; i < n; i++) {
                const n = e[i] + this._timeOfParticle0;
                (n < t - this._timeLength || n > t) && this._newParticle(i, s.MathUtils.wrap(n, t - this._timeLength, t))
            }
            this._numberOfParticles > 1 ? s.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], "time", t - this._timeOfParticle0) : s.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], "time", 0);
            const i = this._lightSource.get();
            if (null !== i) {
                const t = i.getComponent(s.LightSourceComponent);
                null !== t && s.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], "starAbsoluteMagnitude", t.getAbsoluteMagnitude());
                const e = s.Vector3.pool.get();
                this.getEntity().getPositionRelativeToEntity(e, s.Vector3.Zero, i),
                s.ThreeJsHelper.setUniformVector3(this.getThreeJsMaterials()[0], "positionOfEntity", e),
                s.Vector3.pool.release(e)
            }
        }
        __prepareForRender(t) {
            s.ThreeJsHelper.setPositionToEntity(this.getThreeJsObjects(), this.getEntity(), t);
            const e = this.getEntity().getCameraSpacePosition(t);
            if (s.ThreeJsHelper.setUniformVector3(this.getThreeJsMaterials()[0], "positionInCamera", e),
            e.magnitude() < 4e4)
                this.getThreeJsObjects()[0].visible = !1;
            else {
                const t = (e.magnitude() - 4e4) / 4e5;
                this.getThreeJsMaterials()[0].uniforms.color.value.w = this._color.a * s.MathUtils.clamp01(t),
                this.getThreeJsObjects()[0].visible = !0
            }
        }
        async __loadResources() {
            const t = new s.THREE.RawShaderMaterial({
                uniforms: {
                    time: new s.THREE.Uniform(0),
                    timeLength: new s.THREE.Uniform(0),
                    positionInCamera: new s.THREE.Uniform(new s.THREE.Vector3),
                    starAbsoluteMagnitude: new s.THREE.Uniform(0),
                    starAccelerationMultiplier: new s.THREE.Uniform(0),
                    positionOfEntity: new s.THREE.Uniform(new s.THREE.Vector3),
                    color: new s.THREE.Uniform(new s.THREE.Vector4),
                    ...s.ShaderChunkLogDepth.ThreeUniforms
                },
                vertexShader: CometTailComponent._vertexShader,
                fragmentShader: CometTailComponent._fragmentShader,
                glslVersion: s.THREE.GLSL3,
                transparent: !0,
                depthWrite: !1,
                blending: s.THREE.AdditiveBlending,
                side: s.THREE.DoubleSide
            });
            this.getThreeJsMaterials().push(t);
            const e = new Float32Array([-1, -1, 0, 1, -1, 0, 1, 1, 0, -1, 1, 0])
              , i = new Uint16Array([0, 1, 2, 2, 3, 0])
              , n = new Float32Array(1 * this._numberOfParticles)
              , o = new Float32Array(3 * this._numberOfParticles)
              , a = new Float32Array(1 * this._numberOfParticles)
              , r = new s.THREE.InstancedBufferGeometry;
            r.setAttribute("position", new s.THREE.BufferAttribute(e,3)),
            r.setAttribute("originTime", new s.THREE.InstancedBufferAttribute(n,1)),
            r.setAttribute("originPosition", new s.THREE.InstancedBufferAttribute(o,3)),
            r.setAttribute("accelerationMultiplier", new s.THREE.InstancedBufferAttribute(a,1)),
            r.setIndex(new s.THREE.BufferAttribute(i,1)),
            r.instanceCount = this._numberOfParticles;
            const l = s.ThreeJsHelper.createMeshObjectGivenGeometry(this, t, r);
            this.getThreeJsObjects().push(l);
            const c = this.getEntity().getScene().getEngine().getTime();
            for (let t = 0, e = this._numberOfParticles; t < e; t++)
                this._newParticle(t, c - t / e * this._timeLength);
            s.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], "timeLength", this._timeLength),
            s.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], "starAccelerationMultiplier", this._starAccelerationMultiplier),
            s.ThreeJsHelper.setUniformColorRGBA(this.getThreeJsMaterials()[0], "color", this._color)
        }
        __unloadResources() {
            s.ThreeJsHelper.destroyAllObjectsAndMaterials(this)
        }
        _newParticle(t, e) {
            const i = e
              , n = this.getThreeJsObjects()[0].geometry.attributes.originTime
              , o = n.array;
            if (t > 0)
                o[t] = i - this._timeOfParticle0;
            else {
                for (let t = 1, e = this._numberOfParticles; t < e; t++)
                    o[t] += this._timeOfParticle0 - i;
                this._timeOfParticle0 = i,
                o[0] = 0
            }
            n.needsUpdate = !0;
            const a = s.Vector3.pool.get()
              , r = this._lightSource.get();
            null !== r && this.getEntity().getPositionRelativeToEntity(a, s.Vector3.Zero, r, i);
            const l = this.getThreeJsObjects()[0].geometry.attributes.originPosition
              , c = l.array;
            c[3 * t + 0] = a.x,
            c[3 * t + 1] = a.y,
            c[3 * t + 2] = a.z,
            l.needsUpdate = !0,
            s.Vector3.pool.release(a);
            const h = this.getThreeJsObjects()[0].geometry.attributes.accelerationMultiplier;
            h.array[t] = 0 + 1 * Math.random(),
            h.needsUpdate = !0
        }
        static _vertexShader = `\n\t\tin vec3 position;\n\t\tin float originTime;\n\t\tin vec3 originPosition;\n\t\tin vec3 originStarPosition;\n\t\tin vec3 originExternalAcceleration;\n\t\tin float accelerationMultiplier;\n\n\t\tuniform float time;\n\t\tuniform float timeLength;\n\t\tuniform vec3 positionInCamera;\n\t\tuniform float starAbsoluteMagnitude;\n\t\tuniform float starAccelerationMultiplier;\n\t\tuniform vec3 positionOfEntity;\n\t\tuniform mat4 viewMatrix;\n\t\tuniform mat4 modelViewMatrix;\n\t\tuniform mat4 projectionMatrix;\n\n\t\tout vec2 vPosition;\n\t\tout float vAlpha;\n\n\t\t${s.ShaderChunkLogDepth.VertexHead}\n\n\t\tvoid main() {\n\t\t\t// Get the position of the center point of the quad in model space.\n\t\t\tfloat deltaTime = time - originTime;\n\t\t\tvec3 externalAcceleration = starAccelerationMultiplier * accelerationMultiplier * normalize(originPosition) * 5.0e7 * pow(2.51188643151, 20.0 - starAbsoluteMagnitude) / dot(originPosition, originPosition);\n\t\t\tvec3 modelPosition = externalAcceleration * pow(deltaTime, 1.5);\n\n\t\t\t// Get a general expansion scale in all directions.\n\t\t\tfloat expansion = 0.2 * max(1.0e5, length(modelPosition));\n\n\t\t\t// Get the stretch direction in view space.\n\t\t\tvec3 modelStretch = modelPosition;\n\t\t\tvec3 cameraDirection = normalize(positionInCamera);\n\t\t\tmodelStretch = modelStretch - dot(cameraDirection, modelStretch) * cameraDirection;\n\t\t\tvec4 viewStretch = viewMatrix * vec4(modelStretch, 1.0);\n\n\t\t\t// Get the stretch amounts in the x and y directions.\n\t\t\tvec2 stretch2d = vec2(max(expansion, 2.0 * length(viewStretch.xz)), expansion);\n\n\t\t\t// Do the stretch calculation on the vertex position in view space.\n\t\t\t// It translates it, rotates it, stretches it, and unrotates it.\n\t\t\tvec2 translate = 0.5 * normalize(vec2(viewStretch.xz));\n\t\t\tfloat angle = length(viewStretch.xz) > 0.0 ? atan(viewStretch.z, viewStretch.x) : 0.0;\n\t\t\tfloat cosAngle = cos(angle);\n\t\t\tfloat sinAngle = sin(angle);\n\t\t\tfloat stretchedX = (stretch2d.x * cosAngle * cosAngle + stretch2d.y * sinAngle * sinAngle) * 0.5 * (position.x + translate.x) + (stretch2d.x - stretch2d.y) * sinAngle * cosAngle * 0.5 * (position.y + translate.y);\n\t\t\tfloat stretchedY = (stretch2d.x - stretch2d.y) * sinAngle * cosAngle * 0.5 * (position.x + translate.x) + (stretch2d.x * sinAngle * sinAngle + stretch2d.y * cosAngle * cosAngle) * 0.5 * (position.y + translate.y);\n\n\t\t\t// Get the position in view space and then in normalized space.\n\t\t\tvec4 viewPosition = vec4(stretchedX, 0.0, stretchedY, 0.0) + modelViewMatrix * vec4(modelPosition, 1.0);\n\t\t\tgl_Position = projectionMatrix * viewPosition;\n\t\t\tgl_Position.w = viewPosition.y;\n\n\t\t\t// Set the varying variables for adjusting te\n\t\t\tvPosition = vec2(cosAngle * position.x + sinAngle * position.y, -sinAngle * position.x + cosAngle * position.y);\n\t\t\tvAlpha = sqrt(1.0 - sqrt(deltaTime / timeLength));\n\n\t\t\t// Make the gas fade far from the star.\n\t\t\tvAlpha *= min(1.0, 1.0 - length(originPosition) / 7.0e8);\n\n\t\t\t${s.ShaderChunkLogDepth.Vertex}\n\t\t}`;
        static _fragmentShader = `\n\t\tprecision highp float;\n\n\t\tuniform vec4 color;\n\n\t\tin vec2 vPosition;\n\t\tin float vAlpha;\n\n\t\t// The output color.\n\t\tout vec4 outColor;\n\n\t\t${s.ShaderChunkLogDepth.FragmentHead}\n\n\t\tvoid main(void) {\n\t\t\t// Set the color to be a circle tinted by the color.\n\t\t\toutColor = vec4(color.rgb, 0.5 * color.a) * max(0.0, 1.0 - dot(vPosition, vPosition)) * vAlpha;\n\n\t\t\t${s.ShaderChunkLogDepth.Fragment}\n\t\t}`
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        ConnectedSpriteComponent: function() {
            return ConnectedSpriteComponent
        }
    });
    var s = i(6);
    class ConnectedSpriteComponent extends s.BaseComponent {
        constructor(t, e) {
            super(t, e),
            this._entity1 = new s.EntityRef(this.getEntity().getScene()),
            this._entity1Offset = new s.Vector3,
            this._entity1Offset.freeze(),
            this._entity2 = new s.EntityRef(this.getEntity().getScene()),
            this._entity2Offset = new s.Vector3,
            this._entity2Offset.freeze(),
            this._width1 = 1,
            this._width2 = 1,
            this._widthUnits = "km",
            this._textureUrl = "",
            this._textureAspectRatio = 1,
            this._textureRepeat = !0,
            this._textureStretch = 1,
            this._textureYOffset = 0,
            this._uOffsetStart = 0,
            this._uOffsetEnd = 1,
            this._colorMultiplier = new s.Color(1,1,1,1),
            this._colorMultiplier.freeze(),
            this._blending = "normal"
        }
        getEntity1() {
            return this._entity1.getName()
        }
        setEntity1(t) {
            this._entity1.setName(t)
        }
        getEntity1Offset() {
            return this._entity1Offset
        }
        setEntity1Offset(t) {
            this._entity1Offset.thaw(),
            this._entity1Offset.copy(t),
            this._entity1Offset.freeze()
        }
        getEntity2() {
            return this._entity2.getName()
        }
        setEntity2(t) {
            this._entity2.setName(t)
        }
        getEntity2Offset() {
            return this._entity2Offset
        }
        setEntity2Offset(t) {
            this._entity2Offset.thaw(),
            this._entity2Offset.copy(t),
            this._entity2Offset.freeze()
        }
        getWidth1() {
            return this._width1
        }
        getWidth2() {
            return this._width2
        }
        setWidths(t, e) {
            this._width1 = t,
            this._width2 = e
        }
        getWidthUnits() {
            return this._widthUnits
        }
        setWidthUnits(t) {
            if (this._widthUnits = t,
            "loaded" === this.getLoadState().state) {
                const e = this.getThreeJsMaterials()[0];
                e.defines.PIXEL_BASED = "px" === t,
                e.needsUpdate = !0
            }
        }
        getTextureUrl() {
            return this._textureUrl
        }
        setTextureUrl(t) {
            this._textureUrl = t,
            this.resetResources()
        }
        getTextureRepeat() {
            return this._textureRepeat
        }
        setTextureRepeat(t) {
            this._textureRepeat = t
        }
        getTextureStretch() {
            return this._textureStretch
        }
        setTextureStretch(t) {
            this._textureStretch = t
        }
        getTextureYOffset() {
            return this._textureYOffset
        }
        setTextureYOffset(t) {
            this._textureYOffset = t
        }
        getUOffsetStart() {
            return this._uOffsetStart
        }
        setUOffsetStart(t) {
            this._uOffsetStart = t
        }
        getUOffsetEnd() {
            return this._uOffsetEnd
        }
        setUOffsetEnd(t) {
            this._uOffsetEnd = t
        }
        getColorMultiplier() {
            return this._colorMultiplier
        }
        setColorMultiplier(t) {
            this._colorMultiplier.thaw(),
            this._colorMultiplier.copy(t),
            this._colorMultiplier.freeze(),
            s.ThreeJsHelper.setUniformColorRGBA(this.getThreeJsMaterials()[0], "color", this._colorMultiplier, 1)
        }
        setBlending(t) {
            this._blending = t,
            s.ThreeJsHelper.setBlending(this.getThreeJsMaterials()[0], t)
        }
        __update() {
            const t = this._entity1.get()
              , e = this._entity2.get();
            if (null === t || null === e)
                return;
            const i = s.Vector3.pool.get();
            t.getPositionRelativeToEntity(i, s.Vector3.Zero, e),
            this.__setRadius(i.magnitude() + t.getExtentsRadius() + e.getExtentsRadius()),
            s.Vector3.pool.release(i)
        }
        __prepareForRender(t) {
            const e = this._entity1.get()
              , i = this._entity2.get();
            if (null === e || null === i)
                return void (this.getThreeJsObjects()[0].visible = !1);
            const n = s.Vector3.pool.get()
              , o = s.Vector3.pool.get()
              , a = s.Vector3.pool.get();
            n.rotate(e.getOrientation(), this._entity1Offset),
            n.add(e.getCameraSpacePosition(t), n),
            o.rotate(i.getOrientation(), this._entity2Offset),
            o.add(i.getCameraSpacePosition(t), o),
            a.copy(n),
            n.lerp(n, o, this._uOffsetStart),
            o.lerp(a, o, this._uOffsetEnd);
            let r = !1;
            n.magnitude() > o.magnitude() && (a.copy(n),
            n.copy(o),
            o.copy(a),
            r = !0),
            s.Vector3.pool.release(a);
            const l = s.Vector3.pool.get();
            l.sub(o, n),
            l.magnitude() / n.magnitude() > 1e3 && (l.setMagnitude(l, 1e3 * n.magnitude()),
            o.add(n, l));
            let c = r ? this._width2 : this._width1
              , h = r ? this._width1 : this._width2;
            if ("px" === this._widthUnits) {
                const e = t.getViewport();
                if (e) {
                    const i = s.Vector3.pool.get();
                    t.getEntity().getOrientation().getAxis(i, 1),
                    c = e.getNormalSpaceRadiusFromPixelSpaceRadius(c),
                    h = e.getNormalSpaceRadiusFromPixelSpaceRadius(h),
                    c = t.getRadiusFromNormalSpaceRadius(c, n.dot(i)),
                    h = t.getRadiusFromNormalSpaceRadius(h, o.dot(i)),
                    s.Vector3.pool.release(i)
                }
            }
            let d = 1 / this._textureStretch;
            if ("px" === this._widthUnits) {
                const e = t.getViewport();
                if (e && this._textureRepeat) {
                    const i = s.Vector2.pool.get()
                      , a = s.Vector2.pool.get()
                      , r = s.Vector3.pool.get()
                      , l = s.Vector3.pool.get();
                    t.getNormalSpacePositionFromCameraSpacePosition(r, n),
                    t.getNormalSpacePositionFromCameraSpacePosition(l, o),
                    e.getPixelSpacePositionFromNormalSpacePosition(i, r),
                    e.getPixelSpacePositionFromNormalSpacePosition(a, l);
                    const c = s.Vector2.pool.get();
                    if (c.sub(i, a),
                    c.isNaN()) {
                        const t = e.getBounds();
                        c.x = t.size.x * (l.x - r.x) / 2,
                        c.y = t.size.y * (l.y - r.y) / 2
                    }
                    d *= c.magnitude() / Math.max(this._width1, this._width2) * this._textureAspectRatio,
                    s.Vector2.pool.release(c),
                    s.Vector2.pool.release(i),
                    s.Vector2.pool.release(a),
                    s.Vector3.pool.release(r),
                    s.Vector3.pool.release(l)
                }
            } else
                this._textureRepeat && (d *= l.magnitude() / Math.max(this._width1, this._width2) * this._textureAspectRatio);
            s.ThreeJsHelper.setPosition(this.getThreeJsObjects(), n),
            s.ThreeJsHelper.setUniformVector3(this.getThreeJsMaterials()[0], "vAxis", l),
            s.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], "width1", c),
            s.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], "width2", h),
            s.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], "textureYOffset", this._textureYOffset * (r ? -1 : 1)),
            s.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], "repeatAmount", d),
            s.Vector3.pool.release(n),
            s.Vector3.pool.release(o),
            s.Vector3.pool.release(l)
        }
        async __loadResources() {
            const t = await s.ThreeJsHelper.loadTexture(this, this._textureUrl, !0);
            t.wrapT = s.THREE.RepeatWrapping;
            const e = t.image;
            if (this._textureAspectRatio = e.width / e.height,
            "loading" !== this.getLoadState().state)
                return void s.ThreeJsHelper.destroyTexture(t);
            const i = this.getEntity().getScene().getEngine().getMaterialManager().getPreloaded("connected_sprite");
            this.getThreeJsMaterials().push(i),
            s.ThreeJsHelper.setBlending(this.getThreeJsMaterials()[0], this._blending),
            s.ThreeJsHelper.setDefine(i, "PIXEL_BASED", "px" === this._widthUnits),
            s.ThreeJsHelper.setUniformColorRGBA(i, "color", this._colorMultiplier, 1),
            s.ThreeJsHelper.setUniformTexture(i, "colorTexture", t);
            const n = s.ThreeJsHelper.createMeshObject(this, i, [{
                name: "position",
                dimensions: 3
            }], !1);
            this.getThreeJsObjects().push(n),
            s.ThreeJsHelper.setVertices(n.geometry, "position", new Float32Array([-1, -1, 0, 1, -1, 0, -1, -1, 1, 1, -1, 1])),
            s.ThreeJsHelper.setIndices(n.geometry, new Uint16Array([0, 2, 3, 3, 1, 0]))
        }
        __unloadResources() {
            s.ThreeJsHelper.destroyAllObjectsAndMaterials(this)
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        DivComponent: function() {
            return DivComponent
        }
    });
    var s = i(6);
    class DivComponent extends s.BaseComponent {
        constructor(t, e) {
            super(t, e),
            this._activeCamera = null,
            this._fadeWhenCloseToCamera = !0,
            this._fadeWhenCloseToEntity = new s.EntityRef(this.getEntity().getScene()),
            this._canBeOccluded = !0,
            this._hiddenClass = "hidden",
            this._div = document.createElement("div"),
            this._div.style.position = "absolute",
            this._div.style.translate = "",
            this._alignment = new s.Vector2(0,.5,!0),
            this._bounds = new s.Rect(0,0,0,0,!0),
            this._currentHTML = "",
            this.__setRadius(Number.POSITIVE_INFINITY)
        }
        getDiv() {
            return this._div
        }
        getActiveCamera() {
            return this._activeCamera
        }
        setActiveCamera(t) {
            this._activeCamera = t,
            this.resetResources()
        }
        getBounds() {
            return this._bounds
        }
        getFadeWhenCloseToCamera() {
            return this._fadeWhenCloseToCamera
        }
        setFadeWhenCloseToCamera(t) {
            this._fadeWhenCloseToCamera = t
        }
        getFadeWhenCloseToEntity() {
            return this._fadeWhenCloseToEntity.getName()
        }
        setFadeWhenCloseToEntity(t) {
            this._fadeWhenCloseToEntity.setName(t)
        }
        getCanBeOccluded() {
            return this._canBeOccluded
        }
        setCanBeOccluded(t) {
            this._canBeOccluded = t
        }
        getHiddenClass() {
            return this._hiddenClass
        }
        setHiddenClass(t) {
            const e = this._div.classList.contains(this._hiddenClass);
            this._div.classList.remove(this._hiddenClass),
            this._hiddenClass = t,
            e && this._div.classList.add(this._hiddenClass)
        }
        getAlignment() {
            return this._alignment
        }
        setAlignment(t) {
            this._alignment.thaw(),
            this._alignment.copy(t),
            this._alignment.freeze()
        }
        __unloadResources() {
            null !== this._div.parentNode && this._div.parentNode.removeChild(this._div)
        }
        __prepareForRender(t) {
            if (null === this._activeCamera) {
                const t = this.getEntity().getScene().getEngine().getViewportAt(0);
                null !== t && (this._activeCamera = t.getCamera())
            }
            if (this._activeCamera !== t)
                return;
            const e = this._activeCamera.getViewport();
            e && e.getDiv() !== this._div.parentNode && e.getDiv().appendChild(this._div);
            let i = !1;
            if (!i && this._fadeWhenCloseToCamera) {
                i = this.getEntity().getNormalSpaceExtentsRadius(t) > .02
            }
            const n = this.getEntity().getCameraSpacePosition(t);
            if (!i) {
                let e = "" !== this._fadeWhenCloseToEntity.getName() ? this._fadeWhenCloseToEntity.get() : this.getEntity().getParent();
                for (; null !== e; ) {
                    const t = e.getComponent(DivComponent);
                    if (null !== t && !t.getDiv().classList.contains(t.getHiddenClass()))
                        break;
                    e = e.getParent()
                }
                if (null !== e) {
                    const n = s.Vector3.pool.get();
                    n.sub(this.getEntity().getNormalSpacePosition(t), e.getNormalSpacePosition(t));
                    i = n.magnitude() < .04,
                    s.Vector3.pool.release(n)
                }
            }
            if (!i && this._canBeOccluded && (i = t.isPositionOccluded(n)),
            !i) {
                const e = s.Vector3.pool.get();
                t.getEntity().getOrientation().getAxis(e, 1),
                i = e.dot(this.getEntity().getCameraSpacePosition(t)) <= 0,
                s.Vector3.pool.release(e)
            }
            const o = this._div.classList.contains(this._hiddenClass);
            this._div.classList.toggle(this._hiddenClass, i),
            this._bounds.thaw(),
            this._currentHTML === this._div.innerHTML && o === i || (this._bounds.size.x = this._div.offsetWidth,
            this._bounds.size.y = this._div.offsetHeight,
            this._currentHTML = this._div.innerHTML);
            const a = t.getViewport();
            if (a) {
                const e = a.getBounds()
                  , i = s.Vector2.pool.get();
                i.copy(this.getEntity().getPixelSpacePosition(t)),
                i.x = e.size.x % 2 == 0 ? Math.round(i.x) : Math.floor(i.x),
                i.y = e.size.y % 2 == 0 ? Math.round(i.y) : Math.floor(i.y),
                this._bounds.origin.x = i.x - this._bounds.size.x * this._alignment.x - e.origin.x,
                this._bounds.origin.y = i.y - this._bounds.size.y * this._alignment.y - e.origin.y,
                s.Vector2.pool.release(i),
                this._bounds.origin.isNaN() ? this._div.style.translate = "" : this._div.style.translate = `${Math.round(this._bounds.origin.x)}px ${Math.round(this._bounds.origin.y)}px`
            }
            this._bounds.freeze()
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        DynamicEnvironmentMapComponent: function() {
            return DynamicEnvironmentMapComponent
        }
    });
    var s = i(6);
    class DynamicEnvironmentMapComponent extends s.BaseComponent {
        constructor(t, e) {
            super(t, e),
            this._faceSize = 64,
            this._invalidColor = new s.Color(0,1,64 / 255),
            "production" === this.getEntity().getScene().getEngine().getEnvironment() && this._invalidColor.set(0, 0, 0),
            this._invalidColor.freeze(),
            this._threeJsRenderer = this.getEntity().getScene().getEngine().__getThreeJsRenderer(),
            this._threeJsFaceCameras = [],
            this._threeJsFaceRenderTargets = [],
            this._threeJsQuad = new s.THREE.Mesh,
            this._threeJsScene = new s.THREE.Scene,
            this._threeJsCubeCamera = new s.THREE.OrthographicCamera(-1,1,-1,1,-1,1),
            this._envMapTexture = new s.THREE.WebGLRenderTarget(4 * this._faceSize,4 * this._faceSize,{
                minFilter: s.THREE.LinearFilter,
                magFilter: s.THREE.LinearFilter,
                wrapS: s.THREE.ClampToEdgeWrapping,
                wrapT: s.THREE.ClampToEdgeWrapping
            }),
            this._setupFaceCameras(),
            this._setupQuad()
        }
        getFaceSize() {
            return this._faceSize
        }
        setFaceSize(t) {
            this._faceSize = t,
            this._envMapTexture.width !== 4 * this._faceSize && (this._envMapTexture.setSize(4 * this._faceSize, 4 * this._faceSize),
            this._threeJsQuad.material.uniforms.faceSize.value = this._faceSize);
            for (let t = 0; t < 6; t++)
                this._threeJsFaceRenderTargets[t].setSize(this._faceSize, this._faceSize)
        }
        getTexture() {
            return this._envMapTexture.texture
        }
        __destroy() {
            s.ThreeJsHelper.destroyMaterial(this._threeJsQuad.material, !0),
            s.ThreeJsHelper.destroyObject(this._threeJsQuad),
            s.ThreeJsHelper.destroyRenderTarget(this._envMapTexture);
            for (let t = 0; t < this._threeJsFaceRenderTargets.length; t++)
                s.ThreeJsHelper.destroyRenderTarget(this._threeJsFaceRenderTargets[t]);
            super.__destroy()
        }
        __render() {
            this._updateProjectionMatrix();
            const t = .7071067811865476
              , e = s.Quaternion.threeJsPool.get();
            e.set(0, 0, -t, t),
            this._threeJsFaceCameras[0].setRotationFromQuaternion(e),
            e.set(0, 0, 0, 1),
            this._threeJsFaceCameras[1].setRotationFromQuaternion(e),
            e.set(0, 0, t, t),
            this._threeJsFaceCameras[2].setRotationFromQuaternion(e),
            e.set(0, 0, 1, 0),
            this._threeJsFaceCameras[3].setRotationFromQuaternion(e),
            e.set(.5, -.5, -.5, .5),
            this._threeJsFaceCameras[4].setRotationFromQuaternion(e),
            e.set(-.5, .5, -.5, .5),
            this._threeJsFaceCameras[5].setRotationFromQuaternion(e),
            s.Quaternion.threeJsPool.release(e);
            for (let t = 0; t < 6; t++)
                this._threeJsRenderer.setRenderTarget(this._threeJsFaceRenderTargets[t]),
                this._threeJsRenderer.render(this.getEntity().getScene().getThreeJsScene(), this._threeJsFaceCameras[t]);
            this._threeJsRenderer.setRenderTarget(this._envMapTexture),
            this._threeJsRenderer.render(this._threeJsScene, this._threeJsCubeCamera)
        }
        _setupFaceCameras() {
            for (let t = 0; t < 6; t++) {
                this._threeJsFaceCameras.push(new s.THREE.PerspectiveCamera(90,1,.1,1e3));
                const e = new s.THREE.Matrix4;
                e.set(1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0),
                this._threeJsFaceCameras[t].projectionMatrix = e;
                const i = new s.THREE.Matrix4;
                i.set(1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0),
                this._threeJsFaceCameras[t].projectionMatrixInverse = i,
                this._threeJsFaceCameras[t].layers.set(1);
                const n = new s.THREE.WebGLRenderTarget(this._faceSize,this._faceSize,{
                    minFilter: s.THREE.LinearFilter,
                    magFilter: s.THREE.LinearFilter
                });
                this._threeJsFaceRenderTargets.push(n)
            }
        }
        _updateProjectionMatrix() {
            const t = this.getEntity().getComponent(s.CameraComponent);
            if (null === t)
                return;
            const e = 1 - Number.EPSILON
              , i = -t.getAutoNearDistance() * (2 - Number.EPSILON);
            for (let t = 0; t < 6; t++)
                this._threeJsFaceCameras[t].projectionMatrix.elements[6] = e,
                this._threeJsFaceCameras[t].projectionMatrix.elements[14] = i,
                this._threeJsFaceCameras[t].projectionMatrixInverse.elements[11] = 1 / i,
                this._threeJsFaceCameras[t].projectionMatrixInverse.elements[15] = -e / i
        }
        _setupQuad() {
            const t = new s.THREE.BufferGeometry
              , e = new Float32Array([-1, -1, 0, 1, -1, 0, 1, 1, 0, -1, 1, 0])
              , i = new Uint16Array([0, 1, 2, 0, 2, 3]);
            t.setAttribute("position", new s.THREE.BufferAttribute(e,3)),
            t.setIndex(new s.THREE.BufferAttribute(i,1));
            const n = {
                textures: new s.THREE.Uniform([]),
                faceSize: new s.THREE.Uniform(this._faceSize),
                invalidColor: new s.THREE.Uniform(new s.THREE.Vector3(this._invalidColor.r,this._invalidColor.g,this._invalidColor.b))
            };
            for (let t = 0; t < 6; t++)
                n.textures.value.push(this._threeJsFaceRenderTargets[t].texture);
            const o = new s.THREE.RawShaderMaterial({
                uniforms: n,
                vertexShader: "\n\t\t\t\tin vec3 position;\n\t\t\t\tout vec2 xy;\n\t\t\t\tvoid main() {\n\t\t\t\t\tgl_Position = vec4(position, 1.0);\n\t\t\t\t\txy = position.xy;\n\t\t\t\t}",
                fragmentShader: "\n\t\t\t\tprecision highp float;\n\n\t\t\t\tuniform sampler2D textures[6];\n\t\t\t\tuniform float faceSize;\n\t\t\t\tuniform vec3 invalidColor;\n\n\t\t\t\tin vec2 xy;\n\n\t\t\t\t// The output color.\n\t\t\t\tout vec4 outColor;\n\n\t\t\t\tvoid adjustTextureCoordsForBorders(inout int textureIndex, inout vec2 xyInTexture, in float pixelSize) {\n\t\t\t\t\t// Get the pixells in pixel-space.\n\t\t\t\t\tvec2 xyInPixels = xyInTexture * pixelSize;\n\n\t\t\t\t\t// Flip the x since this code is for surface cubes, but we're inside out.\n\t\t\t\t\txyInPixels.x = pixelSize - xyInPixels.x;\n\n\t\t\t\t\t// If it's a border, adjust the pixel it's reading the next pixel in one face over.\n\t\t\t\t\t// This allows for nice linear filtering to happen on the material side of things.\n\t\t\t\t\tif (xyInPixels.x < 0.6 || xyInPixels.x > pixelSize - 0.6 || xyInPixels.y < 0.6 || xyInPixels.y > pixelSize - 0.6) {\n\t\t\t\t\t\tif (0 <= textureIndex && textureIndex <= 3) { // One of the horizontal faces\n\t\t\t\t\t\t\tif (xyInPixels.x > pixelSize - 0.6) {\n\t\t\t\t\t\t\t\txyInPixels.x = 1.5;\n\t\t\t\t\t\t\t\ttextureIndex = (textureIndex + 1);\n\t\t\t\t\t\t\t\tif (textureIndex == 4) {\n\t\t\t\t\t\t\t\t\ttextureIndex = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (xyInPixels.x < 0.6) {\n\t\t\t\t\t\t\t\txyInPixels.x = pixelSize - 1.5;\n\t\t\t\t\t\t\t\ttextureIndex = textureIndex - 1;\n\t\t\t\t\t\t\t\tif (textureIndex == -1) {\n\t\t\t\t\t\t\t\t\ttextureIndex = 3;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (textureIndex == 0) {\n\t\t\t\t\t\t\tif (xyInPixels.y < 0.6) {\n\t\t\t\t\t\t\t\txyInPixels.y = pixelSize - 1.5;\n\t\t\t\t\t\t\t\ttextureIndex = 5;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (xyInPixels.y > pixelSize - 0.6) {\n\t\t\t\t\t\t\t\txyInPixels.y = 1.5;\n\t\t\t\t\t\t\t\ttextureIndex = 4;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (textureIndex == 1) {\n\t\t\t\t\t\t\tif (xyInPixels.y < 0.6) {\n\t\t\t\t\t\t\t\txyInPixels.y = pixelSize - xyInPixels.x;\n\t\t\t\t\t\t\t\txyInPixels.x = pixelSize - 1.5;\n\t\t\t\t\t\t\t\ttextureIndex = 5;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (xyInPixels.y > pixelSize - 0.6) {\n\t\t\t\t\t\t\t\txyInPixels.y = xyInPixels.x;\n\t\t\t\t\t\t\t\txyInPixels.x = pixelSize - 1.5;\n\t\t\t\t\t\t\t\ttextureIndex = 4;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (textureIndex == 2) {\n\t\t\t\t\t\t\tif (xyInPixels.y < 0.6) {\n\t\t\t\t\t\t\t\txyInPixels.x = pixelSize - xyInPixels.x;\n\t\t\t\t\t\t\t\txyInPixels.y = 1.5;\n\t\t\t\t\t\t\t\ttextureIndex = 5;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (xyInPixels.y > pixelSize - 0.6) {\n\t\t\t\t\t\t\t\txyInPixels.x = pixelSize - xyInPixels.x;\n\t\t\t\t\t\t\t\txyInPixels.y = pixelSize - 1.5;\n\t\t\t\t\t\t\t\ttextureIndex = 4;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (textureIndex == 3) {\n\t\t\t\t\t\t\tif (xyInPixels.y < 0.6) {\n\t\t\t\t\t\t\t\txyInPixels.y = xyInPixels.x;\n\t\t\t\t\t\t\t\txyInPixels.x = 1.5;\n\t\t\t\t\t\t\t\ttextureIndex = 5;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (xyInPixels.y > pixelSize - 0.6) {\n\t\t\t\t\t\t\t\txyInPixels.y = pixelSize - xyInPixels.x;\n\t\t\t\t\t\t\t\txyInPixels.x = 1.5;\n\t\t\t\t\t\t\t\ttextureIndex = 4;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (textureIndex == 4) {\n\t\t\t\t\t\t\tif (xyInPixels.x < 0.6) {\n\t\t\t\t\t\t\t\txyInPixels.x = pixelSize - xyInPixels.y;\n\t\t\t\t\t\t\t\txyInPixels.y = pixelSize - 1.5;\n\t\t\t\t\t\t\t\ttextureIndex = 3;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (xyInPixels.x > pixelSize - 0.6) {\n\t\t\t\t\t\t\t\txyInPixels.x = xyInPixels.y;\n\t\t\t\t\t\t\t\txyInPixels.y = pixelSize - 1.5;\n\t\t\t\t\t\t\t\ttextureIndex = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (xyInPixels.y < 0.6) {\n\t\t\t\t\t\t\t\txyInPixels.y = pixelSize - 1.5;\n\t\t\t\t\t\t\t\ttextureIndex = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (xyInPixels.y > pixelSize - 0.6) {\n\t\t\t\t\t\t\t\txyInPixels.x = pixelSize - xyInPixels.x;\n\t\t\t\t\t\t\t\txyInPixels.y = pixelSize - 1.5;\n\t\t\t\t\t\t\t\ttextureIndex = 2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (textureIndex == 5) {\n\t\t\t\t\t\t\tif (xyInPixels.x < 0.6) {\n\t\t\t\t\t\t\t\txyInPixels.x = xyInPixels.y;\n\t\t\t\t\t\t\t\txyInPixels.y = 1.5;\n\t\t\t\t\t\t\t\ttextureIndex = 3;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (xyInPixels.x > pixelSize - 0.6) {\n\t\t\t\t\t\t\t\txyInPixels.x = pixelSize - xyInPixels.y;\n\t\t\t\t\t\t\t\txyInPixels.y = 1.5;\n\t\t\t\t\t\t\t\ttextureIndex = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (xyInPixels.y < 0.6) {\n\t\t\t\t\t\t\t\txyInPixels.x = pixelSize - xyInPixels.x;\n\t\t\t\t\t\t\t\txyInPixels.y = 1.5;\n\t\t\t\t\t\t\t\ttextureIndex = 2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (xyInPixels.y > pixelSize - 0.6) {\n\t\t\t\t\t\t\t\txyInPixels.y = 1.5;\n\t\t\t\t\t\t\t\ttextureIndex = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Shrink all pixels so that they fit within the border.\n\t\t\t\t\t// The border pixels have already been modified so that they work with this equation.\n\t\t\t\t\txyInPixels.x = ((pixelSize - 1.0) * xyInPixels.x - pixelSize) / (pixelSize - 3.0);\n\t\t\t\t\txyInPixels.y = ((pixelSize - 1.0) * xyInPixels.y - pixelSize) / (pixelSize - 3.0);\n\n\t\t\t\t\t// Flip the x back.\n\t\t\t\t\txyInPixels.x = pixelSize - xyInPixels.x;\n\n\t\t\t\t\t// Go back into unit-space.\n\t\t\t\t\txyInTexture = xyInPixels / pixelSize;\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\t\t\t\t\t// Make it pink everywhere else for easy debugging.\n\t\t\t\t\tvec3 color = invalidColor;\n\t\t\t\t\t// Get the mip level, size, and offset.\n\t\t\t\t\tfloat level = floor(1.0 - log2(1.0 - xy.y)); // 0 is base, then 1, etc.\n\t\t\t\t\tfloat mipSizeX = pow(2.0, -level); // 1, .5, .25, .125, etc.\n\t\t\t\t\tfloat mipOffsetY = 1.0 - pow(2.0, -level); // 0, .5, .75, .875, etc.\n\t\t\t\t\t// Get the xy within the mip level. Note the x value is * 3 for less computing further on.\n\t\t\t\t\tvec2 xyInMip;\n\t\t\t\t\txyInMip.x = 0.5 * (xy.x + 1.0) / mipSizeX * 4.0;\n\t\t\t\t\txyInMip.y = (xy.y + 1.0 - 2.0 * mipOffsetY) / mipSizeX;\n\t\t\t\t\tif (xyInMip.x <= 3.0) {\n\t\t\t\t\t\tint textureIndex = int(floor(xyInMip.y * 2.0) * 3.0 + floor(xyInMip.x));\n\t\t\t\t\t\t// Get the xy within the face/texture.\n\t\t\t\t\t\tvec2 xyInTexture;\n\t\t\t\t\t\txyInTexture.x = 1.0 - xyInMip.x + floor(xyInMip.x);\n\t\t\t\t\t\txyInTexture.y = 2.0 * (xyInMip.y - floor(xyInMip.y * 2.0) / 2.0);\n\t\t\t\t\t\t// Adjust the coordinates and face to account for borders.\n\t\t\t\t\t\tadjustTextureCoordsForBorders(textureIndex, xyInTexture, faceSize * mipSizeX);\n\t\t\t\t\t\t// Set the color based on the face (textureIndex) and the coords.\n\t\t\t\t\t\tif (textureIndex == 0) {\n\t\t\t\t\t\t\tcolor = texture(textures[0], xyInTexture).rgb;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (textureIndex == 1) {\n\t\t\t\t\t\t\tcolor = texture(textures[1], xyInTexture).rgb;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (textureIndex == 2) {\n\t\t\t\t\t\t\tcolor = texture(textures[2], xyInTexture).rgb;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (textureIndex == 3) {\n\t\t\t\t\t\t\tcolor = texture(textures[3], xyInTexture).rgb;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (textureIndex == 4) {\n\t\t\t\t\t\t\tcolor = texture(textures[4], xyInTexture).rgb;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (textureIndex == 5) {\n\t\t\t\t\t\t\tcolor = texture(textures[5], xyInTexture).rgb;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\toutColor = vec4(color, 1.0);\n\t\t\t\t}",
                glslVersion: s.THREE.GLSL3,
                depthTest: !1,
                depthWrite: !1
            });
            this._threeJsQuad = new s.THREE.Mesh(t,o),
            this._threeJsQuad.frustumCulled = !1,
            this._threeJsScene.add(this._threeJsQuad)
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        GizmoComponent: function() {
            return GizmoComponent
        }
    });
    var s = i(6);
    class GizmoComponent extends s.BaseComponent {
        constructor(t, e) {
            super(t, e),
            this._size = void 0,
            this._relativeToEntity = !0,
            this._joint = "",
            this._jointObject = null,
            this._model = null,
            this._lineMesh = null,
            this.__setRadius(2 * e.getExtentsRadius()),
            this.__setUsesEntityOrientation(this._relativeToEntity)
        }
        getSize() {
            return void 0 !== this._size ? this._size : Math.max(1e-4, 2 * this.getEntity().getExtentsRadius())
        }
        setSize(t) {
            this._size = t,
            this.__setRadius(this.getSize())
        }
        isRelativeToEntity() {
            return this._relativeToEntity
        }
        setRelativeToEntity(t) {
            this._relativeToEntity = t,
            this.__setUsesEntityOrientation(this._relativeToEntity)
        }
        setJoint(t, e) {
            if (this._joint = t,
            e)
                this._model = e;
            else {
                const t = this.getEntity().getComponent(s.ModelComponent);
                null !== t && (this._model = t)
            }
        }
        __prepareForRender(t) {
            if (this._lineMesh) {
                if ("" !== this._joint) {
                    if (!this._model)
                        return;
                    if (null !== this._jointObject && this._jointObject.name === this._joint || (this._jointObject = this._model.getThreeJsObjectByName(this._joint)),
                    !this._jointObject)
                        return;
                    const e = s.Vector3.pool.get()
                      , i = s.Quaternion.pool.get();
                    this._model.getThreeJsPositionInObject(e, this._jointObject),
                    this._model.getThreeJsOrientationInObject(i, this._jointObject),
                    e.scale(e, this._model.getScale()),
                    e.rotate(this._model.getRotation(), e),
                    e.add(this._model.getTranslation(), e),
                    i.mult(this._model.getRotation(), i),
                    s.ThreeJsHelper.setPositionToEntity(this.getThreeJsObjects()[0], this.getEntity(), t, e, !0),
                    s.ThreeJsHelper.setOrientationToEntity(this.getThreeJsObjects()[0], this.getEntity(), i),
                    s.Vector3.pool.release(e),
                    s.Quaternion.pool.release(i)
                } else
                    this._relativeToEntity ? s.ThreeJsHelper.setOrientationToEntity(this.getThreeJsObjects()[0], this.getEntity()) : s.ThreeJsHelper.setOrientation(this.getThreeJsObjects()[0], s.Quaternion.Identity),
                    s.ThreeJsHelper.setPositionToEntity(this.getThreeJsObjects()[0], this.getEntity(), t);
                s.ThreeJsHelper.setScale(this.getThreeJsObjects()[0], this.getSize()),
                this._lineMesh.prepareForRender(t)
            }
        }
        async __loadResources() {
            this._lineMesh = new s.LineMesh(this);
            const t = [];
            t.push(new s.Vector3(0,0,0)),
            t.push(new s.Vector3(1,0,0)),
            t.push(new s.Vector3(0,0,0)),
            t.push(new s.Vector3(0,1,0)),
            t.push(new s.Vector3(0,0,0)),
            t.push(new s.Vector3(0,0,1)),
            this._lineMesh.setPositions(t);
            const e = [];
            e.push(new s.Color(1,0,0)),
            e.push(new s.Color(1,0,0)),
            e.push(new s.Color(0,1,0)),
            e.push(new s.Color(0,1,0)),
            e.push(new s.Color(0,0,1)),
            e.push(new s.Color(0,0,1)),
            this._lineMesh.setColors(e);
            const i = [];
            i.push(2),
            i.push(2),
            i.push(2),
            i.push(2),
            i.push(2),
            i.push(2),
            this._lineMesh.setWidths(i)
        }
        __unloadResources() {
            s.ThreeJsHelper.destroyAllObjectsAndMaterials(this),
            this._lineMesh = null
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        LabelComponent: function() {
            return LabelComponent
        }
    });
    var s = i(6);
    class LabelComponent extends s.BaseComponent {
        constructor(t, e) {
            super(t, e),
            this._text = "<PLACEHOLDER>",
            this._fontFamily = "Arial",
            this._fontSize = 16,
            this._color = new s.Color,
            this._color.freeze(),
            this._ignoreDistance = !1,
            this._alignment = new s.Vector2(0,.5),
            this._alignment.freeze(),
            this._pixelOffset = new s.Vector2(0,0),
            this._pixelOffset.freeze(),
            this._pixelSize = new s.Vector2,
            this._devicePixelRatio = 1,
            this._canvas = null,
            this._normalSpaceBounds = new Map;
            const i = e.getScene().getEngine().getConfig().getValue("fontFamily");
            "string" == typeof i && (this._fontFamily = i);
            const n = e.getScene().getEngine().getConfig().getValue("fontSize");
            "number" == typeof n && (this._fontSize = n),
            this.__setRadius(Number.POSITIVE_INFINITY)
        }
        getText() {
            return this._text
        }
        setText(t) {
            this._text = t,
            this._updateText()
        }
        getFontFamily() {
            return this._fontFamily
        }
        setFontFamily(t) {
            this._fontFamily = t,
            this._updateText()
        }
        getFontSize() {
            return this._fontSize
        }
        setFontSize(t) {
            this._fontSize = t,
            this._updateText()
        }
        getColor() {
            return this._color
        }
        setColor(t) {
            this._color.thaw(),
            this._color.copy(t),
            this._color.freeze()
        }
        setIgnoreDistance(t) {
            this._ignoreDistance = t
        }
        getAlignment() {
            return this._alignment
        }
        setAlignment(t) {
            this._alignment.thaw(),
            this._alignment.copy(t),
            this._alignment.freeze(),
            this._updateText()
        }
        getPixelOffset() {
            return this._pixelOffset
        }
        setPixelOffset(t) {
            this._pixelOffset.thaw(),
            this._pixelOffset.copy(t),
            this._pixelOffset.freeze()
        }
        getNormalSpaceBounds(t) {
            return this._normalSpaceBounds.get(t)
        }
        __prepareForRender(t) {
            const e = this.getEntity().getCameraSpacePosition(t);
            let i;
            if (s.ThreeJsHelper.setPositionToEntity(this.getThreeJsObjects()[0], this.getEntity(), t),
            s.ThreeJsHelper.setOrientation(this.getThreeJsObjects()[0], s.Quaternion.Identity),
            t instanceof s.SpoutComponent) {
                const e = t;
                s.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], "flipX", e.getForGlobe() ? -1 : 1),
                i = e.getRenderWidth(),
                i /= 4
            } else {
                s.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], "flipX", 1);
                const e = t.getViewport()?.getBounds().size ?? s.Vector2.Zero;
                i = Math.max(e.x, e.y)
            }
            if (!this._canvas)
                return;
            const n = s.Vector2.pool.get()
              , o = s.Vector2.pool.get()
              , a = s.Vector3.pool.get()
              , r = s.Vector3.pool.get();
            if (n.set(this._pixelOffset.x - this._alignment.x * this._canvas.width, this._pixelOffset.y - this._alignment.y * this._canvas.height),
            o.set(this._canvas.width, this._canvas.height),
            t.getEntity().getOrientation().getAxis(a, 2),
            t.getEntity().getOrientation().getAxis(r, 0),
            s.ThreeJsHelper.setUniformVector2(this.getThreeJsMaterials()[0], "pixelOffset", n),
            s.ThreeJsHelper.setUniformVector2(this.getThreeJsMaterials()[0], "pixelSize", o),
            s.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], "renderSize", i),
            s.ThreeJsHelper.setUniformVector3(this.getThreeJsMaterials()[0], "renderUp", a),
            s.ThreeJsHelper.setUniformVector3(this.getThreeJsMaterials()[0], "renderRight", r),
            !(t instanceof s.SpoutComponent)) {
                let e = this._normalSpaceBounds.get(t);
                e || (e = new s.Rect,
                this._normalSpaceBounds.set(t, e)),
                e.thaw();
                const n = this.getEntity().getNormalSpacePosition(t);
                e.origin.x = n.x + 2 * (this._pixelOffset.x - this._alignment.x * this._pixelSize.x) / i,
                e.origin.y = n.y + 2 * (this._pixelOffset.y - this._alignment.y * this._pixelSize.y) / i,
                e.size.x = 2 * this._pixelSize.x / i,
                e.size.y = 2 * this._pixelSize.y / i,
                e.freeze()
            }
            s.Vector2.pool.release(o),
            s.Vector2.pool.release(n),
            s.Vector3.pool.release(a),
            s.Vector3.pool.release(r);
            let l = 1;
            const c = this.getEntity().getNormalSpaceExtentsRadius(t);
            this._ignoreDistance || (l *= s.MathUtils.clamp01((.02 - c) / .02));
            const h = this.getEntity().getParent();
            if (h) {
                const i = t.getNormalSpaceRadiusFromRadius(this.getEntity().getPosition().magnitude(), e.magnitude())
                  , n = h.getNormalSpaceExtentsRadius(t);
                !this._ignoreDistance && n < .02 && (l *= s.MathUtils.clamp01((i - .02) / .02)),
                h.isOccludingPosition(t, e) && (l = 0)
            }
            t.isPositionOccluded(e) && (l = 0);
            const d = s.Color.pool.get();
            d.copy(this._color),
            d.a *= l,
            s.ThreeJsHelper.setUniformColorRGBA(this.getThreeJsMaterials()[0], "colorMultiplier", d),
            s.Color.pool.release(d)
        }
        async __loadResources() {
            LabelComponent._threeJsGeometry || (LabelComponent._threeJsGeometry = s.ThreeJsHelper.createGeometry([{
                name: "position",
                dimensions: 3
            }, {
                name: "uv",
                dimensions: 2
            }], !1),
            s.ThreeJsHelper.setVertices(LabelComponent._threeJsGeometry, "position", new Float32Array([0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0])),
            s.ThreeJsHelper.setVertices(LabelComponent._threeJsGeometry, "uv", new Float32Array([0, 1, 1, 1, 1, 0, 0, 0])),
            s.ThreeJsHelper.setIndices(LabelComponent._threeJsGeometry, new Uint16Array([0, 1, 2, 2, 3, 0]))),
            LabelComponent._threeJsMaterial || (LabelComponent._threeJsMaterial = new s.THREE.ShaderMaterial({
                uniforms: {
                    colorMultiplier: new s.THREE.Uniform(new s.THREE.Vector4(1,1,1,1)),
                    colorTexture: new s.THREE.Uniform(null),
                    pixelOffset: new s.THREE.Uniform(new s.THREE.Vector2(0,0)),
                    pixelSize: new s.THREE.Uniform(new s.THREE.Vector2(1,1)),
                    renderSize: new s.THREE.Uniform(1),
                    renderUp: new s.THREE.Uniform(new s.THREE.Vector3(0,1,0)),
                    renderRight: new s.THREE.Uniform(new s.THREE.Vector3(1,0,0)),
                    flipX: new s.THREE.Uniform(1),
                    ...s.ShaderChunkLogDepth.ThreeUniforms
                },
                vertexShader: `\n\t\t\t\t\tuniform vec2 pixelOffset;\n\t\t\t\t\tuniform vec2 pixelSize;\n\t\t\t\t\tuniform float renderSize;\n\t\t\t\t\tuniform vec3 renderUp;\n\t\t\t\t\tuniform vec3 renderRight;\n\t\t\t\t\tuniform float flipX;\n\t\t\t\t\tout vec2 fUV;\n\n\t\t\t\t\t${s.ShaderChunkLogDepth.VertexHead}\n\n\t\t\t\t\tvoid main() {\n\t\t\t\t\t\t// Get a frame for the label to be on the x-y axis.\n\t\t\t\t\t\tvec3 forward = (modelMatrix * vec4(0, 0, 0, 1.)).xyz;\n\t\t\t\t\t\tfloat distance = length(forward);\n\t\t\t\t\t\tforward = normalize(forward);\n\t\t\t\t\t\tvec3 up = normalize(renderUp);\n\t\t\t\t\t\tvec3 right = normalize(cross(forward, up));\n\n\t\t\t\t\t\t// Setup the up and right vectors.\n\t\t\t\t\t\tup *= (position.y * pixelSize.y + pixelOffset.y) / renderSize * distance;\n\t\t\t\t\t\tright *= (position.x * pixelSize.x + pixelOffset.x) / renderSize * distance * flipX;\n\n\t\t\t\t\t\t// Do the transforms.\n\t\t\t\t\t\tvec4 viewPosition = modelViewMatrix * vec4(up + right, 1.);\n\t\t\t\t\t\tgl_Position = projectionMatrix * viewPosition;\n\n\t\t\t\t\t\tfUV = uv;\n\n\t\t\t\t\t\t${s.ShaderChunkLogDepth.Vertex}\n\t\t\t\t\t}`,
                fragmentShader: `\n\t\t\t\t\tprecision highp float;\n\n\t\t\t\t\tuniform vec4 colorMultiplier;\n\t\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\t\tin vec2 fUV;\n\n\t\t\t\t\t${s.ShaderChunkLogDepth.FragmentHead}\n\n\t\t\t\t\tvoid main(void) {\n\t\t\t\t\t\tpc_fragColor = texture(colorTexture, fUV);\n\t\t\t\t\t\tpc_fragColor *= colorMultiplier;\n\n\t\t\t\t\t\t${s.ShaderChunkLogDepth.Fragment}\n\t\t\t\t\t}`,
                side: s.THREE.DoubleSide
            })),
            LabelComponent._useCount += 1;
            const t = LabelComponent._threeJsMaterial.clone();
            this.getThreeJsMaterials().push(t),
            s.ThreeJsHelper.setTransparent(t, !0),
            s.ThreeJsHelper.setOverlay(t, !0),
            s.ThreeJsHelper.setUniformColorRGBA(t, "colorMultiplier", this._color);
            const e = s.ThreeJsHelper.createMeshObjectGivenGeometry(this, t, LabelComponent._threeJsGeometry);
            this.getThreeJsObjects().push(e),
            this._canvas = document.createElement("canvas"),
            this._canvas.width = 1,
            this._canvas.height = 1,
            this._updateText()
        }
        __unloadResources() {
            LabelComponent._useCount -= 1,
            0 === LabelComponent._useCount && (LabelComponent._threeJsGeometry && (s.ThreeJsHelper.destroyGeometry(LabelComponent._threeJsGeometry),
            LabelComponent._threeJsGeometry = null),
            LabelComponent._threeJsMaterial && (s.ThreeJsHelper.destroyMaterial(LabelComponent._threeJsMaterial, !0),
            LabelComponent._threeJsMaterial = null));
            const t = this.getThreeJsObjects()[0];
            null !== t.parent && t.parent.remove(t),
            s.ThreeJsHelper.destroyMaterial(this.getThreeJsMaterials()[0], !0),
            this._canvas = null
        }
        _updateText() {
            if (null === this._canvas)
                return;
            const t = this._canvas.getContext("2d");
            if (!t)
                return;
            this._devicePixelRatio = window.devicePixelRatio,
            t.font = `${this._fontSize}px ${this._fontFamily}`;
            const e = t.measureText(this._text);
            this._pixelSize.set(e.width * this._devicePixelRatio, this._fontSize * this._devicePixelRatio);
            const i = s.MathUtils.ceilPow2(this._pixelSize.x)
              , n = s.MathUtils.ceilPow2(this._pixelSize.y);
            i === this._canvas.width && n === this._canvas.height || (this._canvas.width = i,
            this._canvas.height = n),
            t.clearRect(0, 0, this._canvas.width, this._canvas.height),
            this._canvas.style.width = i / this._devicePixelRatio + "px",
            this._canvas.style.height = n / this._devicePixelRatio + "px",
            t.font = `${this._pixelSize.y}px ${this._fontFamily}`,
            t.fillStyle = "rgba(255, 255, 255, 255)",
            t.fillText(this._text, (this._canvas.width - this._pixelSize.x) * s.MathUtils.clamp01(this._alignment.x), this._canvas.height - .1875 * this._pixelSize.y - (this._canvas.height - this._pixelSize.y) * s.MathUtils.clamp01(this._alignment.y));
            const o = this.getThreeJsMaterials()[0];
            s.ThreeJsHelper.setUniformTexture(o, "colorTexture", s.ThreeJsHelper.loadTextureFromCanvas(this._canvas))
        }
        static _threeJsMaterial = null;
        static _threeJsGeometry = null;
        static _useCount = 0
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        LightSourceComponent: function() {
            return LightSourceComponent
        }
    });
    var s = i(6);
    class LightSourceComponent extends s.BaseComponent {
        constructor(t, e) {
            super(t, e),
            this._color = new s.Color(1,1,1),
            this._color.freeze(),
            this._absoluteMagnitude = 1,
            this.__setRadius(Number.POSITIVE_INFINITY)
        }
        getColor() {
            return this._color
        }
        setColor(t) {
            this._color.thaw(),
            this._color.copy(t),
            this._color.freeze()
        }
        getAbsoluteMagnitude() {
            return this._absoluteMagnitude
        }
        setAbsoluteMagnitude(t) {
            this._absoluteMagnitude = t
        }
        async __loadResources() {
            this.getEntity().getScene().__addLightSource(this.getEntity().getName(), this.getClassIndex())
        }
        __unloadResources() {
            this.getEntity().getScene().__removeLightSource(this.getEntity().getName(), this.getClassIndex())
        }
        __setClassIndex(t) {
            "loaded" === this.getLoadState().state && this.getEntity().getScene().__removeLightSource(this.getEntity().getName(), this.getClassIndex()),
            super.__setClassIndex(t),
            "loaded" === this.getLoadState().state && this.getEntity().getScene().__addLightSource(this.getEntity().getName(), this.getClassIndex())
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        ModelComponent: function() {
            return ModelComponent
        }
    });
    var s = i(6)
      , n = i(93)
      , o = i(92)
      , a = i(65);
    class ModelComponent extends s.BaseComponent {
        constructor(t, e) {
            super(t, e),
            this._url = "",
            this._shadowEntities = [],
            this._translation = new s.Vector3,
            this._translation.freeze(),
            this._rotation = new s.Quaternion,
            this._rotation.freeze(),
            this._urlReferenceMap = new Map,
            this._threeJsAnimationClips = new Map,
            this._hiddenObjects = new s.FastMap,
            this._scale = new s.Vector3(.001,.001,.001),
            this._scale.freeze(),
            this._modelRadius = NaN,
            this._environmentCubemapUrl = "",
            this._environmentCylindricalUrl = "",
            this._environmentCubemap = null,
            this._environmentIntensity = .5,
            this._dynamicEnvironmentMapComponent = null,
            this._pixelRadiusVisibleInterval = void 0,
            this._onConfigChanged = this._onConfigChanged.bind(this),
            this.__setRadius(this.getEntity().getExtentsRadius())
        }
        getUrl() {
            return this._url
        }
        setUrl(t) {
            "" !== this._url && this.getEntity().getScene().getEngine().getDownloader().cancel(this._url),
            this.resetResources(),
            this._modelRadius = NaN,
            this._loading = !1,
            this._url = t
        }
        setHiddenObject(t, e) {
            e && !this._hiddenObjects.has(t) ? this._hiddenObjects.set(t, null) : !e && this._hiddenObjects.has(t) && this._hiddenObjects.delete(t)
        }
        getTranslation() {
            return this._translation
        }
        setTranslation(t) {
            this._translation.thaw(),
            this._translation = t,
            this._translation.freeze()
        }
        getScale() {
            return this._scale
        }
        setScale(t) {
            this._scale.thaw(),
            "number" == typeof t ? this._scale.set(t, t, t) : this._scale.copy(t),
            this._scale.freeze(),
            s.ThreeJsHelper.setScale(this.getThreeJsObjects()[0], this._scale),
            isNaN(this._modelRadius) ? this.__setRadius(this.getEntity().getExtentsRadius()) : this.__setRadius(Math.max(this._scale.x, this._scale.y, this._scale.z) * this._modelRadius)
        }
        getRotation() {
            return this._rotation
        }
        setRotation(t) {
            this._rotation.thaw(),
            this._rotation.copy(t),
            this._rotation.freeze()
        }
        getEnvironmentCubemapUrl() {
            return this._environmentCubemapUrl
        }
        setEnvironmentCubemapUrl(t) {
            this._environmentCubemapUrl = t
        }
        getEnvironmentIntensity() {
            return this._environmentIntensity
        }
        setEnvironmentIntensity(t) {
            this._environmentIntensity = t;
            for (let t = 0, e = this.getThreeJsMaterials().length; t < e; t++)
                s.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[t], "environmentIntensity", this._environmentIntensity)
        }
        getEnvironmentCylindricalUrl() {
            return this._environmentCylindricalUrl
        }
        setEnvironmentCylindricalUrl(t) {
            this._environmentCylindricalUrl = t
        }
        setPixelRadiusVisibleInterval(t) {
            if (void 0 !== t)
                void 0 === this._pixelRadiusVisibleInterval ? this._pixelRadiusVisibleInterval = new s.Interval(t.min,t.max) : this._pixelRadiusVisibleInterval.copy(t);
            else {
                this._pixelRadiusVisibleInterval = void 0;
                for (const t of this.getThreeJsMaterials())
                    s.ThreeJsHelper.setUniformNumber(t, "alphaMultiplier", 1);
                this.getThreeJsObjects()[0].visible = !0
            }
        }
        setDynamicEnvironmentMapComponent(t) {
            this._dynamicEnvironmentMapComponent = t;
            for (let e = 0, i = this.getThreeJsMaterials().length; e < i; e++) {
                const i = this.getThreeJsMaterials()[e];
                void 0 !== i.uniforms.dynEnvTexture && (s.ThreeJsHelper.setDefine(i, "dynEnvMap", !0),
                s.ThreeJsHelper.setUniformTexture(i, "dynEnvTexture", this._dynamicEnvironmentMapComponent.getTexture()),
                s.ThreeJsHelper.setUniformNumber(i, "dynEnvFaceSize", t.getFaceSize()))
            }
            null !== this._environmentCubemap && (s.ThreeJsHelper.destroyTexture(this._environmentCubemap),
            this._environmentCubemap = null)
        }
        setURLReferenceMap(t) {
            this._urlReferenceMap.clear();
            for (const e of t)
                this._urlReferenceMap.set(e[0], e[1])
        }
        getAnimationClip(t) {
            return this._threeJsAnimationClips.get(t) ?? null
        }
        getMaterial(t) {
            const e = this.getThreeJsMaterials();
            for (let i = 0, s = e.length; i < s; i++)
                if (e[i].name === t)
                    return e[i];
            return null
        }
        updateMaterial(t, e) {
            const i = this.getThreeJsMaterials();
            let n;
            for (let s = 0; s < i.length; s++) {
                const o = i[s];
                if (o.name === t) {
                    n = o,
                    i.splice(s, 1),
                    i.push(e);
                    break
                }
            }
            if (!n)
                throw new Error(`No material with the name ${t} was found in ${this}.`);
            for (let i = 0, o = this.getThreeJsObjects().length; i < o; i++) {
                const o = this.getThreeJsObjects()[i];
                o instanceof s.THREE.Mesh && o.material === n && (e.name = t,
                n = e)
            }
        }
        getNumShadowEntities() {
            return this._shadowEntities.length
        }
        getShadowEntity(t) {
            return this._shadowEntities[t]?.getName()
        }
        setShadowEntities(t) {
            this._shadowEntities = [];
            for (const e of t)
                this._shadowEntities.push(new s.EntityRef(this.getEntity().getScene(),e));
            const e = t.length > 0;
            for (let t = 0, i = this.getThreeJsMaterials().length; t < i; t++)
                s.ThreeJsHelper.setDefine(this.getThreeJsMaterials()[t], "shadowEntities", e)
        }
        __prepareForRender(t) {
            for (let t = 0, e = this._hiddenObjects.getSize(); t < e; t++) {
                const e = this._hiddenObjects.getAt(t);
                null === e.value && (e.value = this.getThreeJsObjectByName(e.key)),
                null !== e.value && (e.value.visible = !1)
            }
            if (void 0 !== this._pixelRadiusVisibleInterval) {
                const e = this.getEntity().getPixelSpaceExtentsRadius(t)
                  , i = s.MathUtils.clamp01(Math.min(1 + 2 * (e - this._pixelRadiusVisibleInterval.min) / this._pixelRadiusVisibleInterval.min, isFinite(this._pixelRadiusVisibleInterval.max) ? 1 - 2 * (e - this._pixelRadiusVisibleInterval.max) / this._pixelRadiusVisibleInterval.max : 1));
                for (const t of this.getThreeJsMaterials())
                    s.ThreeJsHelper.setUniformNumber(t, "alphaMultiplier", i);
                0 === i && (this.getThreeJsObjects()[0].visible = !1)
            }
            s.ThreeJsHelper.setPositionToEntity(this.getThreeJsObjects()[0], this.getEntity(), t, this._translation, !0),
            s.ThreeJsHelper.setOrientationToEntity(this.getThreeJsObjects()[0], this.getEntity(), this._rotation),
            s.MaterialUtils.setUniforms(this.getThreeJsMaterials(), t, this.getEntity(), this._shadowEntities, null, !1)
        }
        async __loadResources() {
            const t = this.getEntity().getScene().getEngine()
              , e = this._url.startsWith("blob:") || this._url.endsWith(".glb") ? "binary" : "text";
            try {
                const i = t.getDownloader()
                  , a = await i.download(this._url, e, -this.getEntity().getLeastCameraDepth());
                if ("loading" !== this.getLoadState().state || "cancelled" === a.status)
                    return;
                if ("failed" === a.status)
                    throw new Error(`Failed to load model component file "${a.url}": ${a.errorMessage}`);
                if (!a.actualUrl.endsWith(".gltf") && !a.actualUrl.endsWith(".glb") && !a.actualUrl.startsWith("blob:"))
                    throw new Error("Unknown model format.");
                const r = new s.THREE.LoadingManager
                  , l = new CustomThreeJsTextureLoader(t.getTextureLoader(),this._urlReferenceMap,-this.getEntity().getLeastCameraDepth(),this.getLoadState());
                if (r.addHandler(/.$/u, l),
                r.setURLModifier((t => {
                    const e = t.substring(t.lastIndexOf("/") + 1);
                    return this._urlReferenceMap.get(e) ?? t
                }
                )),
                !ModelComponent._dracoLoader && !1 !== t.getConfig().getValue("draco")) {
                    ModelComponent._dracoLoader = new o.DRACOLoader;
                    const e = t.getConfig().getValue("dracoPath")
                      , s = i.processUrl("string" == typeof e ? e : "$STATIC_ASSETS_URL/wasm/draco/");
                    ModelComponent._dracoLoader.setDecoderPath(s)
                }
                const c = new n.GLTFLoader(r);
                ModelComponent._dracoLoader && c.setDRACOLoader(ModelComponent._dracoLoader);
                const h = new CustomThreeJsKTX2Loader(l);
                h && c.setKTX2Loader(h),
                await new Promise(( (e, i) => {
                    void 0 !== a.content && c.parse(a.content, s.THREE.LoaderUtils.extractUrlBase(a.actualUrl), (i => {
                        if ("failed" === this.getLoadState().state)
                            throw new Error(this.getLoadState().error);
                        const n = i.scene;
                        this._populateThreeJsObjectsAndMaterials(i.scene),
                        "loading" !== this.getLoadState().state && s.ThreeJsHelper.destroyAllObjectsAndMaterials(this),
                        this._clean(),
                        s.ThreeJsHelper.setupObject(this, n),
                        s.ThreeJsHelper.setScale(n, this._scale);
                        const o = (new s.THREE.Box3).setFromObject(n);
                        this._modelRadius = Math.max(o.min.length(), o.max.length()),
                        this.__setRadius(Math.max(this._scale.x, this._scale.y, this._scale.z) * this._modelRadius);
                        for (let t = 0; t < i.animations.length; t++)
                            this._threeJsAnimationClips.set(i.animations[t].name, i.animations[t]);
                        let a = Promise.resolve();
                        null === this._dynamicEnvironmentMapComponent && null === this._environmentCubemap && ("" !== this._environmentCubemapUrl ? a = t.getTextureLoader().loadCubeTexture(this._environmentCubemapUrl, -this.getEntity().getLeastCameraDepth(), !0).then((e => {
                            this._environmentCubemap = t.getTextureLoader().generateEnvMap(e),
                            s.ThreeJsHelper.destroyTexture(e)
                        }
                        )) : "" !== this._environmentCylindricalUrl && (a = s.ThreeJsHelper.loadTexture(this, this._environmentCubemapUrl, !0).then((e => {
                            this._environmentCubemap = t.getTextureLoader().generateEnvMap(e),
                            s.ThreeJsHelper.destroyTexture(e)
                        }
                        )))),
                        a.then(( () => {
                            this._updateMaterials(),
                            this.getEntity().getScene().getEngine().getConfig().addEventListener("gammaCorrection", this._onConfigChanged),
                            e(void 0)
                        }
                        ))
                    }
                    ), (t => {
                        i(t)
                    }
                    ))
                }
                ))
            } catch (t) {
                throw t instanceof Error && (t.message = `While loading model "${this._url}": ${t.message}`),
                t
            }
        }
        __unloadResources() {
            for (let t = 0, e = this._hiddenObjects.getSize(); t < e; t++)
                this._hiddenObjects.getAt(t).value = null;
            this.getEntity().getScene().getEngine().getConfig().removeEventListener("gammaCorrection", this._onConfigChanged),
            s.ThreeJsHelper.destroyAllObjectsAndMaterials(this)
        }
        _populateThreeJsObjectsAndMaterials(t) {
            if (t.matrixAutoUpdate = !1,
            t.frustumCulled = !1,
            t.visible = !1,
            this.getThreeJsObjects().push(t),
            t instanceof s.THREE.Mesh) {
                let e = t.material;
                Array.isArray(e) || (e = [e]);
                for (const t of e) {
                    let e = !1;
                    for (let i = 0, s = this.getThreeJsMaterials().length; i < s; i++)
                        if (this.getThreeJsMaterials()[i] === t) {
                            e = !0;
                            break
                        }
                    e || this.getThreeJsMaterials().push(t)
                }
            }
            for (let e = 0; e < t.children.length; e++)
                this._populateThreeJsObjectsAndMaterials(t.children[e])
        }
        _clean() {
            const t = /_(?:lamp|hemi)/iu;
            for (let e = 0; e < this.getThreeJsObjects().length; e++) {
                const i = this.getThreeJsObjects()[e];
                i.name.match(t) && (i.parent && i.parent.remove(i),
                this.getThreeJsObjects().splice(e, 1),
                e--)
            }
            for (let t = 0, e = this.getThreeJsObjects().length; t < e; t++) {
                let e = !1;
                const i = this.getThreeJsObjects()[t];
                i instanceof s.THREE.Mesh && i.geometry instanceof s.THREE.BufferGeometry && (i.name.startsWith("_root") && (e = !0),
                i instanceof s.THREE.Mesh && i.material instanceof s.THREE.Material && "transparent" === i.material.name && (e = !0),
                e && (i.geometry.deleteAttribute("position"),
                i.geometry.deleteAttribute("normal")))
            }
        }
        _onConfigChanged() {
            this._updateMaterials()
        }
        _updateMaterials() {
            for (let t = 0, e = this.getThreeJsMaterials().length; t < e; t++) {
                const e = this.getThreeJsMaterials()[t];
                if (!(e instanceof s.THREE.MeshStandardMaterial))
                    continue;
                const i = this._getNewPioneerMaterial(e);
                this.getThreeJsMaterials()[t] = i;
                let n = !1;
                !0 === i.defines.normalMap && (n = !0);
                for (const t of this.getThreeJsObjects())
                    if (t instanceof s.THREE.Mesh) {
                        let o = !1;
                        if (Array.isArray(t.material))
                            for (let s = 0, n = t.material.length; s < n; s++)
                                t.material[s] === e && (t.material[s] = i,
                                o = !0);
                        else
                            t.material === e && (t.material = i,
                            o = !0);
                        o && n && t.geometry instanceof s.THREE.BufferGeometry && void 0 === t.geometry.getAttribute("tangent") && s.ThreeJsHelper.computeTangents(t.geometry)
                    }
                s.ThreeJsHelper.destroyMaterial(e, !0)
            }
        }
        _getNewPioneerMaterial(t) {
            const e = s.MaterialUtils.getPBR();
            if (e.name = t.name,
            e.transparent = t.transparent,
            e.alphaTest = t.alphaTest,
            e.defines.alphaTestEnabled = 0 !== t.alphaTest,
            e.depthWrite = t.depthWrite,
            e.side = t.side,
            null !== t.map) {
                e.uniforms.colorTexture.value = t.map,
                e.defines.colorMap = !0;
                e.uniforms.uvTransform.value.setUvTransform(t.map.offset.x, t.map.offset.y, t.map.repeat.x, t.map.repeat.y, t.map.rotation, t.map.center.x, t.map.center.y),
                t.map = null
            }
            t.roughnessMap && (e.uniforms.roughnessTexture.value = t.roughnessMap,
            e.defines.roughnessMap = !0,
            t.roughnessMap = null),
            t.metalnessMap && (e.uniforms.metalnessTexture.value = t.metalnessMap,
            e.defines.metalnessMap = !0,
            t.metalnessMap = null),
            null !== t.normalMap && (e.uniforms.normalTexture.value = t.normalMap,
            e.uniforms.normalScale.value = t.normalScale,
            e.defines.normalMap = !0,
            t.normalMap = null);
            const i = e.uniforms.emissiveColor.value;
            if (i.copy(t.emissive),
            i.multiplyScalar(t.emissiveIntensity),
            null !== t.emissiveMap && (e.uniforms.emissiveTexture.value = t.emissiveMap,
            e.defines.emissiveMap = !0,
            t.emissiveMap = null),
            e.uniforms.color.value = t.color,
            e.uniforms.roughness.value = t.roughness,
            e.uniforms.metalness.value = t.metalness,
            null !== this._dynamicEnvironmentMapComponent)
                e.defines.dynEnvMap = !0,
                e.uniforms.dynEnvTexture.value = this._dynamicEnvironmentMapComponent.getTexture(),
                e.uniforms.dynEnvFaceSize.value = this._dynamicEnvironmentMapComponent.getFaceSize();
            else if (null !== this._environmentCubemap) {
                e.defines.envMap = !0,
                e.defines.envIsCubeUV = !0;
                const t = this._environmentCubemap.image;
                e.uniforms.envTexture.value = this._environmentCubemap,
                e.uniforms.maxMipLevel.value = Math.log(t.height) * Math.LOG2E
            }
            return e.uniforms.environmentIntensity.value = this._environmentIntensity,
            e.uniforms.gammaCorrectionFactor.value = this.getEntity().getScene().getEngine().getConfig().getValue("gammaCorrection"),
            this._shadowEntities.length > 0 && (e.defines.shadowEntities = !0),
            e.needsUpdate = !0,
            e
        }
        static _dracoLoader
    }
    class CustomThreeJsTextureLoader extends s.THREE.Loader {
        constructor(t, e, i, s) {
            super(),
            this._textureLoader = t,
            this._urlReferenceMap = e,
            this._downloadPriority = i,
            this._loadState = s
        }
        load(t, e, i, s) {
            const n = t.substring(t.lastIndexOf("/") + 1);
            t = this._urlReferenceMap.get(n) ?? t,
            this._textureLoader.loadTexture(t, this._downloadPriority, !0).then((t => {
                e(t)
            }
            )).catch((t => {
                t instanceof Error && (this._loadState.state = "failed",
                this._loadState.error = t.message,
                s?.(t.message))
            }
            ))
        }
    }
    class CustomThreeJsKTX2Loader extends a.KTX2Loader {
        constructor(t) {
            super(),
            this._customThreeJsTextureLoader = t
        }
        load(t, e, i, s) {
            return this._customThreeJsTextureLoader.load(t, e, i, s)
        }
    }
}
, , , , function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        OrbitalParticlesComponent: function() {
            return OrbitalParticlesComponent
        }
    });
    var s = i(6);
    class OrbitalParticlesComponent extends s.BaseComponent {
        constructor(t, e) {
            super(t, e),
            this._scaleOfParticles = 1,
            this._loadFunction = null,
            this._orbitalElementsList = [],
            this._offsetArray = new Float32Array(0),
            this._spriteParticles = null,
            this.__setRadius(100 * this.getEntity().getExtentsRadius())
        }
        getScaleOfParticles() {
            return this._scaleOfParticles
        }
        setScaleOfParticles(t) {
            this._scaleOfParticles = t,
            this.resetResources()
        }
        setLoadFunction(t) {
            this._loadFunction = t,
            this.resetResources()
        }
        __update() {
            if (!this._spriteParticles)
                return;
            const t = s.Vector3.pool.get()
              , e = s.Vector3.pool.get()
              , i = this.getEntity().getScene().getEngine().getTime();
            for (let s = 0, n = this._orbitalElementsList.length; s < n; s++)
                this._orbitalElementsList[s].project(t, e, i),
                this._offsetArray[3 * s + 0] = t.x,
                this._offsetArray[3 * s + 1] = t.y,
                this._offsetArray[3 * s + 2] = t.z;
            s.Vector3.pool.release(t),
            s.Vector3.pool.release(e),
            this._spriteParticles.setParticleOffsets(this._offsetArray)
        }
        __prepareForRender(t) {
            this._spriteParticles && this._spriteParticles.prepareForRender(t)
        }
        async __loadResources() {
            this._spriteParticles = new s.SpriteParticles(this),
            this.getThreeJsMaterials().push(this._spriteParticles.getThreeJsMaterial()),
            this.getThreeJsObjects().push(this._spriteParticles.getThreeJsObject()),
            await this._initializeParticles()
        }
        __unloadResources() {
            s.ThreeJsHelper.destroyAllObjectsAndMaterials(this),
            this._spriteParticles = null
        }
        async _initializeParticles() {
            if (!this._loadFunction || !this._spriteParticles)
                return;
            const t = await this._loadFunction()
              , e = t.orbitalElements.length;
            this._orbitalElementsList = [];
            let i = 0;
            for (let n = 0, o = e; n < o; n++) {
                const e = new s.OrbitalElements;
                e.copy(t.orbitalElements[n]),
                this._orbitalElementsList.push(e);
                const o = e.semiMajorAxis * (1 + e.eccentricity);
                i = Math.max(i, o)
            }
            this.__setRadius(i),
            this._offsetArray = new Float32Array(3 * e);
            const n = new Float32Array(4 * e)
              , o = new Float32Array(1 * e);
            for (let i = 0, s = e; i < s; i++)
                n[4 * i + 0] = t.colors[i].r,
                n[4 * i + 1] = t.colors[i].g,
                n[4 * i + 2] = t.colors[i].b,
                n[4 * i + 3] = t.colors[i].a,
                o[1 * i + 0] = t.scales[i] * this._scaleOfParticles;
            this._spriteParticles.setParticleColors(n),
            this._spriteParticles.setParticleScales(o)
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        ParticleSprayComponent: function() {
            return ParticleSprayComponent
        }
    });
    var s = i(6);
    class ParticleSprayComponent extends s.BaseComponent {
        constructor(t, e) {
            super(t, e),
            this._length = 1,
            this._spread = 30,
            this._numberOfParticles = 0,
            this._speedOfParticles = .1,
            this._sizeOfParticles = .1,
            this._particleSpacingRandom = !0,
            this._colorOfParticles = new s.Color,
            this._colorOfParticles.freeze(),
            this._originOffset = new s.Vector3,
            this._originOffset.freeze(),
            this._direction = new s.Vector3,
            this._direction.freeze(),
            this._relativeToEntityOrientation = !0,
            this.__setRadius(this._length)
        }
        getLength() {
            return this._length
        }
        setLength(t) {
            this._length = t,
            this.__setRadius(this._length),
            s.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], "length", this._length),
            s.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], "totalTime", this._length / this._speedOfParticles)
        }
        getSpread() {
            return this._spread
        }
        setSpread(t) {
            this._spread = t,
            s.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], "spread", s.MathUtils.degToRad(this._spread))
        }
        getNumberOfParticles() {
            return this._numberOfParticles
        }
        setNumberOfParticles(t) {
            this._numberOfParticles = t,
            this.resetResources()
        }
        getSpeedOfParticles() {
            return this._speedOfParticles
        }
        setSpeedOfParticles(t) {
            this._speedOfParticles = t,
            s.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], "totalTime", this._length / this._speedOfParticles)
        }
        getSizeOfParticles() {
            return this._sizeOfParticles
        }
        setSizeOfParticles(t) {
            this._sizeOfParticles = t,
            this.resetResources()
        }
        getParticleSpacingRandom() {
            return this._particleSpacingRandom
        }
        setParticleSpacingRandom(t) {
            this._particleSpacingRandom = t,
            this.resetResources()
        }
        getColorOfParticles() {
            return this._colorOfParticles
        }
        setColorOfParticles(t) {
            this._colorOfParticles.thaw(),
            this._colorOfParticles.copy(t),
            this._colorOfParticles.freeze(),
            s.ThreeJsHelper.setUniformColorRGBA(this.getThreeJsMaterials()[0], "globalColor", this._colorOfParticles)
        }
        getOriginOffset() {
            return this._originOffset
        }
        setOriginOffset(t) {
            this._originOffset.thaw(),
            this._originOffset.copy(t),
            this._originOffset.freeze(),
            s.ThreeJsHelper.setUniformVector3(this.getThreeJsMaterials()[0], "originOffset", this._originOffset)
        }
        getDirection() {
            return this._direction
        }
        setDirection(t) {
            this._direction.thaw(),
            this._direction.normalize(t),
            this._direction.freeze(),
            s.ThreeJsHelper.setUniformVector3(this.getThreeJsMaterials()[0], "direction", this._direction);
            const e = s.Vector3.pool.get();
            e.cross(this._direction, s.Vector3.XAxis),
            e.isZero() && e.cross(this._direction, s.Vector3.YAxis),
            e.normalize(e),
            s.ThreeJsHelper.setUniformVector3(this.getThreeJsMaterials()[0], "directionPerp", e),
            s.Vector3.pool.release(e)
        }
        getRelativeToEntityOrientation() {
            return this._relativeToEntityOrientation
        }
        setRelativeToEntityOrientation(t) {
            this._relativeToEntityOrientation = t
        }
        __prepareForRender(t) {
            const e = s.MathUtils.wrap(this.getEntity().getScene().getEngine().getTime(), 0, this._length / this._speedOfParticles);
            if (s.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], "time", e),
            this._relativeToEntityOrientation) {
                const t = s.Vector3.pool.get()
                  , e = s.Vector3.pool.get();
                t.rotate(this.getEntity().getOrientation(), this._originOffset),
                e.rotate(this.getEntity().getOrientation(), this._direction),
                s.ThreeJsHelper.setUniformVector3(this.getThreeJsMaterials()[0], "originOffset", t),
                s.ThreeJsHelper.setUniformVector3(this.getThreeJsMaterials()[0], "direction", e);
                const i = s.Vector3.pool.get();
                i.cross(e, s.Vector3.XAxis),
                i.isZero() && i.cross(e, s.Vector3.YAxis),
                i.normalize(i),
                s.ThreeJsHelper.setUniformVector3(this.getThreeJsMaterials()[0], "directionPerp", i),
                s.Vector3.pool.release(i),
                s.Vector3.pool.release(t),
                s.Vector3.pool.release(e)
            }
            s.ThreeJsHelper.setPositionToEntity(this.getThreeJsObjects()[0], this.getEntity(), t)
        }
        async __loadResources() {
            const t = new s.THREE.RawShaderMaterial({
                uniforms: {
                    spread: new s.THREE.Uniform(0),
                    originOffset: new s.THREE.Uniform(new s.THREE.Vector3),
                    direction: new s.THREE.Uniform(new s.THREE.Vector3),
                    directionPerp: new s.THREE.Uniform(new s.THREE.Vector3),
                    length: new s.THREE.Uniform(0),
                    time: new s.THREE.Uniform(0),
                    totalTime: new s.THREE.Uniform(0),
                    globalColor: new s.THREE.Uniform(new s.THREE.Vector4(1,1,1,1)),
                    ...s.ShaderChunkLogDepth.ThreeUniforms
                },
                vertexShader: ParticleSprayComponent.vertexShader,
                fragmentShader: ParticleSprayComponent.fragmentShader,
                glslVersion: s.THREE.GLSL3,
                transparent: !0,
                depthWrite: !1,
                blending: s.THREE.AdditiveBlending,
                side: s.THREE.DoubleSide
            });
            this.getThreeJsMaterials().push(t);
            const e = new Float32Array([-1, -1, 0, 1, -1, 0, 1, 1, 0, -1, 1, 0])
              , i = new Float32Array(3 * this._numberOfParticles)
              , n = new Float32Array(4 * this._numberOfParticles)
              , o = new Float32Array(1 * this._numberOfParticles)
              , a = new Uint16Array([0, 1, 2, 2, 3, 0])
              , r = new s.THREE.InstancedBufferGeometry;
            r.setAttribute("position", new s.THREE.BufferAttribute(e,3)),
            r.setAttribute("params", new s.THREE.InstancedBufferAttribute(i,3)),
            r.setAttribute("color", new s.THREE.InstancedBufferAttribute(n,4)),
            r.setAttribute("size", new s.THREE.InstancedBufferAttribute(o,1)),
            r.setIndex(new s.THREE.BufferAttribute(a,1)),
            r.instanceCount = this._numberOfParticles;
            const l = s.ThreeJsHelper.createMeshObjectGivenGeometry(this, t, r);
            this.getThreeJsObjects().push(l),
            s.ThreeJsHelper.setOrientation(this.getThreeJsObjects()[0], s.Quaternion.Identity),
            this._initializeParticles(),
            s.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], "length", this._length),
            s.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], "spread", s.MathUtils.degToRad(this._spread)),
            s.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], "totalTime", this._length / this._speedOfParticles),
            s.ThreeJsHelper.setUniformVector3(this.getThreeJsMaterials()[0], "originOffset", this._originOffset),
            s.ThreeJsHelper.setUniformVector3(this.getThreeJsMaterials()[0], "direction", this._direction),
            s.ThreeJsHelper.setUniformColorRGBA(this.getThreeJsMaterials()[0], "globalColor", this._colorOfParticles);
            const c = s.Vector3.pool.get();
            c.cross(this._direction, s.Vector3.XAxis),
            c.isZero() && c.cross(this._direction, s.Vector3.YAxis),
            c.normalize(c),
            s.ThreeJsHelper.setUniformVector3(this.getThreeJsMaterials()[0], "directionPerp", c),
            s.Vector3.pool.release(c)
        }
        __unloadResources() {
            s.ThreeJsHelper.destroyAllObjectsAndMaterials(this)
        }
        _initializeParticles() {
            const t = this.getThreeJsObjects()[0].geometry.attributes.params
              , e = this.getThreeJsObjects()[0].geometry.attributes.color
              , i = this.getThreeJsObjects()[0].geometry.attributes.size
              , s = t.array
              , n = e.array
              , o = i.array;
            for (let t = 0, e = this._numberOfParticles; t < e; t++)
                s[3 * t + 0] = 2 * Math.random() - 1,
                s[3 * t + 1] = 2 * Math.random() - 1,
                this._particleSpacingRandom ? s[3 * t + 2] = Math.random() : s[3 * t + 2] = t / this._numberOfParticles,
                n[4 * t + 0] = 1,
                n[4 * t + 1] = 1,
                n[4 * t + 2] = 1,
                n[4 * t + 3] = 1,
                o[1 * t + 0] = this._sizeOfParticles;
            t.needsUpdate = !0,
            e.needsUpdate = !0,
            i.needsUpdate = !0
        }
        static vertexShader = `\n\t\tin vec3 position;\n\t\tin vec3 params; // x, y are in plane made by direction if z were 1, z is 0 to 1 where the particle is in the total length at time = 0\n\t\tin vec4 color;\n\t\tin float size;\n\n\t\tuniform float spread;\n\t\tuniform vec3 originOffset; // in model-space\n\t\tuniform vec3 direction; // in model-space\n\t\tuniform vec3 directionPerp; // in model-space\n\t\tuniform float length;\n\t\tuniform float time;\n\t\tuniform float totalTime;\n\n\t\tuniform mat4 modelViewMatrix;\n\t\tuniform mat4 projectionMatrix;\n\n\t\tout vec2 vPosition;\n\t\tout vec4 vColor;\n\n\t\t${s.ShaderChunkLogDepth.VertexHead}\n\n\t\tvoid main() {\n\t\t\tfloat u = mod(params.z + time / totalTime, 1.0);\n\t\t\tfloat sinSpread = sin(spread);\n\t\t\tfloat uSpread = sinSpread > 0.0 ? u : (1.0 - u);\n\t\t\tfloat sizeAtU = size * max(0.1, uSpread);\n\t\t\tvec3 directionPerp2 = cross(direction, directionPerp);\n\t\t\tvec3 modelPosition = originOffset + (directionPerp * params.x * sinSpread * uSpread + directionPerp2 * params.y * sinSpread * uSpread + direction * u) * length;\n\t\t\tvec4 viewPosition = vec4(position.x * sizeAtU, 0, position.y * sizeAtU, 1) + modelViewMatrix * vec4(modelPosition, 1.0);\n\t\t\tgl_Position = projectionMatrix * viewPosition;\n\t\t\tgl_Position.w = viewPosition.y;\n\n\t\t\t// Set the varying variables.\n\t\t\tvPosition = position.xy;\n\t\t\tvColor = color * (1.0 - u);\n\n\t\t\t${s.ShaderChunkLogDepth.Vertex}\n\t\t}`;
        static fragmentShader = `\n\t\tprecision highp float;\n\n\t\tuniform vec4 globalColor;\n\n\t\tin vec2 vPosition;\n\t\tin vec4 vColor;\n\n\t\t// The output color.\n\t\tout vec4 outColor;\n\n\t\t${s.ShaderChunkLogDepth.FragmentHead}\n\n\t\tvoid main(void) {\n\t\t\t// Set the color to be a circle tinted by the color and globalColor.\n\t\t\toutColor = globalColor * vColor * max(0.0, 1.0 - dot(vPosition, vPosition));\n\n\t\t\t${s.ShaderChunkLogDepth.Fragment}\n\t\t}`
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        RingsComponent: function() {
            return RingsComponent
        }
    });
    var s = i(6);
    class RingsComponent extends s.BaseComponent {
        constructor(t, e) {
            super(t, e),
            this._topTextureUrl = "",
            this._bottomTextureUrl = "",
            this._innerRadius = 0,
            this._outerRadius = 0,
            this._fadeDistance = 0,
            this._shadowEntities = [],
            this._spheroidComponentRef = new s.ComponentRef(this.getEntity().getScene(),s.SpheroidComponent,this.getEntity().getName()),
            this._spheroidComponentRef.setRefChangedCallback(this._spheroidRefChangedCallback.bind(this)),
            this._spheroidChangedCallback = this._spheroidChangedCallback.bind(this),
            this.__setUsesEntityOrientation(!0)
        }
        getTopTextureUrl() {
            return this._topTextureUrl
        }
        setTopTextureUrl(t) {
            if (this._topTextureUrl = t,
            "loaded" === this.getLoadState().state) {
                const t = this.getThreeJsMaterials()[0].uniforms.topTexture;
                s.ThreeJsHelper.loadTextureIntoUniform(this, t, this._topTextureUrl, !0)
            }
        }
        getBottomTextureUrl() {
            return this._bottomTextureUrl
        }
        setBottomTextureUrl(t) {
            if (this._bottomTextureUrl = t,
            "loaded" === this.getLoadState().state) {
                const t = this.getThreeJsMaterials()[0].uniforms.bottomTexture;
                s.ThreeJsHelper.loadTextureIntoUniform(this, t, this._bottomTextureUrl, !0)
            }
        }
        getInnerRadius() {
            return this._innerRadius
        }
        setInnerRadius(t) {
            this._innerRadius = t,
            s.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], "innerRadius", this._innerRadius)
        }
        getOuterRadius() {
            return this._outerRadius
        }
        setOuterRadius(t) {
            this._outerRadius = t,
            this.__setRadius(this._outerRadius),
            s.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], "outerRadius", this._outerRadius)
        }
        getTopTexture() {
            const t = this.getThreeJsMaterials()[0];
            if (void 0 !== t) {
                return t.uniforms.topTexture.value
            }
            return null
        }
        getFadeDistance() {
            return this._fadeDistance
        }
        setFadeDistance(t) {
            this._fadeDistance = t
        }
        getShadowEntity(t) {
            return this._shadowEntities[t]?.getName()
        }
        setShadowEntities(t) {
            this._shadowEntities = [];
            for (const e of t)
                this._shadowEntities.push(new s.EntityRef(this.getEntity().getScene(),e));
            const e = t.length > 0;
            for (let t = 0, i = this.getThreeJsMaterials().length; t < i; t++)
                s.ThreeJsHelper.setDefine(this.getThreeJsMaterials()[t], "shadowEntities", e)
        }
        __destroy() {
            const t = this._spheroidComponentRef.get();
            null !== t && t.removeChangedCallback(this._spheroidChangedCallback),
            super.__destroy()
        }
        __update() {
            this._spheroidComponentRef.update()
        }
        __prepareForRender(t) {
            if (this._fadeDistance > 0) {
                const e = s.Vector3.pool.get()
                  , i = s.Quaternion.pool.get()
                  , n = this.getThreeJsObjects()[0].quaternion;
                i.copyFromThreeJs(n),
                e.rotateInverse(this.getEntity().getOrientation(), this.getEntity().getCameraSpacePosition(t)),
                s.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], "alphaFadeMultiplier", s.MathUtils.lerp(0, 1, s.MathUtils.clamp01(2 * (Math.abs(e.z) / this._fadeDistance - 1) + 1))),
                s.Quaternion.pool.release(i),
                s.Vector3.pool.release(e)
            }
            s.MaterialUtils.setLightSourceUniforms(this.getThreeJsMaterials(), this.getEntity(), t),
            s.MaterialUtils.setUniforms(this.getThreeJsMaterials(), t, this.getEntity(), this._shadowEntities, null, !1),
            s.ThreeJsHelper.setOrientationToEntity(this.getThreeJsObjects()[0], this.getEntity()),
            s.ThreeJsHelper.setPositionToEntity(this.getThreeJsObjects()[0], this.getEntity(), t)
        }
        async __loadResources() {
            const t = s.ThreeJsHelper.loadTexture(this, this._topTextureUrl, !0)
              , e = s.ThreeJsHelper.loadTexture(this, this._bottomTextureUrl, !0)
              , [i,n] = await Promise.all([t, e]);
            if (this.isDestroyed())
                return s.ThreeJsHelper.destroyTexture(i),
                void s.ThreeJsHelper.destroyTexture(n);
            const o = new s.THREE.ShaderMaterial({
                uniforms: {
                    ambientLightColor: new s.THREE.Uniform(new s.THREE.Color),
                    lightPositions: new s.THREE.Uniform([new s.THREE.Vector3(1,0,0), new s.THREE.Vector3(1,0,0), new s.THREE.Vector3(1,0,0), new s.THREE.Vector3(1,0,0), new s.THREE.Vector3(1,0,0)]),
                    lightColors: new s.THREE.Uniform([new s.THREE.Vector3(0,0,0), new s.THREE.Vector3(0,0,0), new s.THREE.Vector3(0,0,0), new s.THREE.Vector3(0,0,0), new s.THREE.Vector3(0,0,0)]),
                    lightRadii: new s.THREE.Uniform([0, 0, 0, 0, 0]),
                    numLights: new s.THREE.Uniform(0),
                    entityPos: new s.THREE.Uniform(new s.THREE.Vector3),
                    innerRadius: new s.THREE.Uniform(this._innerRadius),
                    outerRadius: new s.THREE.Uniform(this._outerRadius),
                    topTexture: new s.THREE.Uniform(i),
                    bottomTexture: new s.THREE.Uniform(n),
                    alphaFadeMultiplier: new s.THREE.Uniform(1),
                    spheroidEquatorialRadius: new s.THREE.Uniform(0),
                    spheroidPolarRadius: new s.THREE.Uniform(0),
                    numShadowEntities: new s.THREE.Uniform(0),
                    shadowEntityPositions: new s.THREE.Uniform([new s.THREE.Vector3, new s.THREE.Vector3, new s.THREE.Vector3, new s.THREE.Vector3, new s.THREE.Vector3, new s.THREE.Vector3, new s.THREE.Vector3]),
                    shadowEntityRadii: new s.THREE.Uniform([0, 0, 0, 0, 0, 0, 0]),
                    shadowEntitySunsetIntensity: new s.THREE.Uniform([0, 0, 0, 0, 0, 0, 0]),
                    shadowEntitySunsetColors: new s.THREE.Uniform([new s.THREE.Vector3, new s.THREE.Vector3, new s.THREE.Vector3, new s.THREE.Vector3, new s.THREE.Vector3, new s.THREE.Vector3, new s.THREE.Vector3]),
                    ...s.ShaderChunkLogDepth.ThreeUniforms
                },
                vertexShader: RingsComponent.vertexShader,
                fragmentShader: RingsComponent.fragmentShader,
                transparent: !0,
                depthWrite: !1,
                blending: s.THREE.NormalBlending,
                side: s.THREE.DoubleSide
            });
            s.ThreeJsHelper.setDefine(o, "shadowEntities", this._shadowEntities.length > 0),
            this.getThreeJsMaterials().push(o);
            const a = s.ThreeJsHelper.createMeshObject(this, o, [{
                name: "position",
                dimensions: 3
            }, {
                name: "normal",
                dimensions: 3
            }], !1)
              , r = 10
              , l = new Float32Array(300)
              , c = new Float32Array(300)
              , h = new Uint16Array(486);
            for (let t = 0; t < r; t++)
                for (let e = 0; e < r; e++) {
                    const i = e + t * r;
                    l[3 * i + 0] = e / 9 * 2 - 1,
                    l[3 * i + 1] = t / 9 * 2 - 1,
                    l[3 * i + 2] = 0,
                    c[3 * i + 0] = 0,
                    c[3 * i + 1] = 0,
                    c[3 * i + 2] = 1,
                    e + 1 < r && t + 1 < r && (h[6 * (e + 9 * t) + 0] = e + 0 + (t + 0) * r,
                    h[6 * (e + 9 * t) + 1] = e + 0 + (t + 1) * r,
                    h[6 * (e + 9 * t) + 2] = e + 1 + (t + 0) * r,
                    h[6 * (e + 9 * t) + 3] = e + 1 + (t + 0) * r,
                    h[6 * (e + 9 * t) + 4] = e + 0 + (t + 1) * r,
                    h[6 * (e + 9 * t) + 5] = e + 1 + (t + 1) * r)
                }
            s.ThreeJsHelper.setVertices(a.geometry, "position", l),
            s.ThreeJsHelper.setVertices(a.geometry, "normal", c),
            s.ThreeJsHelper.setIndices(a.geometry, h),
            a.material = o,
            this.getThreeJsObjects().push(a),
            this._spheroidChangedCallback()
        }
        __unloadResources() {
            s.ThreeJsHelper.destroyAllObjectsAndMaterials(this)
        }
        _spheroidRefChangedCallback(t, e) {
            null !== t && t.removeChangedCallback(this._spheroidChangedCallback),
            null !== e && e.addChangedCallback(this._spheroidChangedCallback),
            this._spheroidChangedCallback()
        }
        _spheroidChangedCallback() {
            const t = this.getThreeJsMaterials()[0];
            if (null !== t) {
                const e = this._spheroidComponentRef.get();
                null !== e ? (s.ThreeJsHelper.setUniformNumber(t, "spheroidEquatorialRadius", e.getEquatorialRadius()),
                s.ThreeJsHelper.setUniformNumber(t, "spheroidPolarRadius", e.getPolarRadius())) : (s.ThreeJsHelper.setUniformNumber(t, "spheroidEquatorialRadius", 0),
                s.ThreeJsHelper.setUniformNumber(t, "spheroidPolarRadius", 0))
            }
        }
        static vertexShader = `\n\t\tuniform float outerRadius;\n\n\t\tout vec3 localPosition;\n\t\tout vec3 cameraSpacePosition;\n\t\tout vec3 modelNormal;\n\n\t\t${s.ShaderChunkLogDepth.VertexHead}\n\n\t\tvoid main() {\n\t\t\tlocalPosition = position * outerRadius;\n\t\t\tcameraSpacePosition = (modelMatrix * vec4(localPosition, 1.)).xyz;\n\t\t\tmodelNormal = (modelMatrix * vec4(normal, 0.)).xyz;\n\t\t\tvec4 viewPosition = viewMatrix * vec4(cameraSpacePosition, 1.);\n\t\t\tgl_Position = projectionMatrix * viewPosition;\n\n\t\t\t${s.ShaderChunkLogDepth.Vertex}\n\t\t}`;
        static fragmentShader = `\n\t\tprecision highp float;\n\n\t\t#ifndef saturate\n\t\t\t#define saturate(a) clamp(a, 0.0, 1.0)\n\t\t#endif\n\n\t\t// Lights\n\t\tuniform vec3 ambientLightColor;\n\t\tuniform vec3 lightPositions[5];\n\t\tuniform vec3 lightColors[5];\n\t\tuniform float lightRadii[5];\n\t\tuniform int numLights;\n\n\t\tuniform float innerRadius;\n\t\tuniform float outerRadius;\n\t\tuniform sampler2D topTexture;\n\t\tuniform sampler2D bottomTexture;\n\t\tuniform float alphaFadeMultiplier;\n\t\tuniform float spheroidEquatorialRadius;\n\t\tuniform float spheroidPolarRadius;\n\t\tuniform vec3 entityPos;\n\n\t\t// Shadow Entities.\n\t\t#ifdef shadowEntities\n\t\t\tuniform int numShadowEntities;\n\t\t\tuniform vec3 shadowEntityPositions[7];\n\t\t\tuniform float shadowEntityRadii[7];\n\t\t\tuniform float shadowEntitySunsetIntensity[7];\n\t\t\tuniform vec3 shadowEntitySunsetColors[7];\n\t\t#endif\n\n\t\t// The varying attributes.\n\t\tin vec3 localPosition;\n\t\tin vec3 cameraSpacePosition;\n\t\tin vec3 modelNormal;\n\n\t\t${s.ShaderChunkLogDepth.FragmentHead}\n\n\t\tfloat spheroidShadow(vec3 lightDir, float lightCosAngle, float spheroidScaling, vec3 normal, vec3 ringPos) {\n\t\t\tvec3 sunDirScaled = normalize(lightDir - (spheroidScaling - 1.0) * lightCosAngle * normal);\n\t\t\tfloat pDotLScaled = dot(ringPos, sunDirScaled);\n\t\t\tif(dot(ringPos, ringPos) - pDotLScaled * pDotLScaled < spheroidEquatorialRadius * spheroidEquatorialRadius && pDotLScaled > 0.0) {\n\t\t\t\treturn 0.0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn 1.0;\n\t\t\t}\n\t\t}\n\n\t\t#ifdef shadowEntities\n\t\t\tvec3 applyRayleighScattering(vec3 color, float amount) {\n\t\t\t\tfloat value = (color.r + color.g + color.b);\n\t\t\t\tif (value > 0.0) {\n\t\t\t\t\tfloat rFactor = 1.0; // 6.3^-4 / 6.3^-4\n\t\t\t\t\tfloat gFactor = 1.602; // 5.6^-4 / 6.3^-4\n\t\t\t\t\tfloat bFactor = 3.228; // 4.7^-4 / 6.3^-4\n\t\t\t\t\tcolor.r *= pow(rFactor, -amount);\n\t\t\t\t\tcolor.g *= pow(gFactor, -amount);\n\t\t\t\t\tcolor.b *= pow(bFactor, -amount);\n\t\t\t\t\tcolor = value * color / (color.r + color.g + color.b);\n\t\t\t\t}\n\t\t\t\treturn color;\n\t\t\t}\n\n\t\t\tvec3 getLightColorFromShadowEntities(vec3 lightColor, vec3 lightDir, vec3 lightPosition, float lightRadius, vec3 normal) {\n\t\t\t\tvec3 color = lightColor;\n\t\t\t\tfor (int i = 0; i < 7; i++) {\n\t\t\t\t\tif (i >= numShadowEntities) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tvec3 origin = cameraSpacePosition - shadowEntityPositions[i];\n\t\t\t\t\tvec3 axis = normalize(shadowEntityPositions[i] - lightPosition);\n\t\t\t\t\tfloat sd = dot(origin, axis);\n\t\t\t\t\tif (sd > 0.0) {\n\t\t\t\t\t\tfloat e = length(origin - sd * axis);\n\t\t\t\t\t\tfloat ld = dot(cameraSpacePosition - lightPosition, axis);\n\t\t\t\t\t\tfloat lr = lightRadius;\n\t\t\t\t\t\tfloat sr = shadowEntityRadii[i];\n\t\t\t\t\t\tfloat e0 = (ld * sr - sd * lr) / (ld - sd);\n\t\t\t\t\t\tfloat e1 = (ld * sr + sd * lr) / (ld - sd);\n\t\t\t\t\t\tfloat lightLevel = 0.0;\n\t\t\t\t\t\tif (e1 < 0.0 || sd < 0.0) { // light in front of shadow entity\n\t\t\t\t\t\t\tlightLevel = 1.0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (e0 < e1) {\n\t\t\t\t\t\t\te0 /= max(1.0, shadowEntitySunsetIntensity[i] * 2.0);\n\t\t\t\t\t\t\tlightLevel = (e - e0) / (e1 - e0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tlightLevel = e < e0 ? 0.0 : 1.0; // 0 radius light.\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcolor = saturate(lightLevel) * applyRayleighScattering(color, saturate(1.5 - lightLevel) * saturate(shadowEntitySunsetIntensity[i]));\n\t\t\t\t\t}\n\t}\n\t\t\t\treturn color;\n\t\t\t}\n\t\t#endif\n\n\t\tvoid main(void) {\n\t\t\tfloat spheroidScaling = spheroidEquatorialRadius / spheroidPolarRadius;\n\t\t\tvec3 positionDir = normalize(cameraSpacePosition);\n\t\t\tvec3 ringPos = cameraSpacePosition - entityPos;\n\t\t\tvec3 normal = normalize(modelNormal);\n\t\t\tfloat cameraCosAngle = -dot(positionDir, normal);\n\n\t\t\t// Calculate the UVs.\n\t\t\tvec2 uv;\n\t\t\tuv.x = (length(localPosition) - innerRadius) / (outerRadius - innerRadius);\n\t\t\tif (uv.x < 0.0 || uv.x > 1.0) {\n\t\t\t\tpc_fragColor = vec4(0, 0, 0, 0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tuv.y = 0.0;\n\n\t\t\t// Get the pixels at those uvs.\n\t\t\tvec4 topPixel = texture(topTexture, uv);\n\t\t\tvec4 bottomPixel = texture(bottomTexture, uv);\n\n\t\t\t// Get the initial diffuse light.\n\t\t\tvec3 diffuseLight = ambientLightColor;\n\t\t\t\n\t\t\t// For each light,\n\t\t\tfor (int i = 0; i < 5; i++) {\n\t\t\t\tif (i >= numLights) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tvec3 lightDir = normalize(cameraSpacePosition - lightPositions[i]);\n\t\t\t\tfloat lightCosAngle = -dot(lightDir, normal);\n\n\t\t\t\tvec3 incomingLight = lightColors[i];\n\n\t\t\t\t#ifdef shadowEntities\n\t\t\t\t\tincomingLight = getLightColorFromShadowEntities(incomingLight, lightDir, lightPositions[i], lightRadii[i], normal);\n\t\t\t\t#endif\n\n\t\t\t\tfloat cameraDirDotLight = dot(positionDir, lightDir);\n\t\t\t\tfloat bottomTopRatio = (1.0 + 0.2 * cameraDirDotLight) * sign(cameraCosAngle) * lightCosAngle;\n\t\t\t\tfloat shadow = spheroidShadow(lightDir, lightCosAngle, spheroidScaling, normal, ringPos);\n\t\t\t\tvec3 bottomColor = saturate(incomingLight * (1.0 - bottomTopRatio) * shadow);\n\t\t\t\tvec3 topColor = 2.0 * saturate(incomingLight * bottomTopRatio * shadow);\n\n\t\t\t\tvec3 color = mix(bottomPixel.rgb * bottomColor, topPixel.rgb * topColor, bottomTopRatio);\n\t\t\t\tpc_fragColor.rgb += color;\n\t\t\t}\n\n\t\t\tpc_fragColor.a = topPixel.a;\n\t\t\tpc_fragColor.a *= alphaFadeMultiplier;\n\n\t\t\t${s.ShaderChunkLogDepth.Fragment}\n\t\t}`
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        SkyboxComponent: function() {
            return SkyboxComponent
        }
    });
    var s = i(6);
    class SkyboxComponent extends s.BaseComponent {
        constructor(t, e) {
            super(t, e),
            this._numLatVerts = 20,
            this._textureUrl = "",
            this.__setRadius(1e24),
            this.__setUsesEntityOrientation(!0)
        }
        getTextureUrl() {
            return this._textureUrl
        }
        setTextureUrl(t) {
            this._textureUrl = t,
            this.resetResources()
        }
        __prepareForRender(t) {
            s.ThreeJsHelper.setOrientationToEntity(this.getThreeJsObjects()[0], this.getEntity()),
            s.ThreeJsHelper.setPositionToEntity(this.getThreeJsObjects()[0], this.getEntity(), t)
        }
        async __loadResources() {
            const t = await s.ThreeJsHelper.loadTexture(this, this._textureUrl, !1);
            if ("loading" !== this.getLoadState().state)
                return void s.ThreeJsHelper.destroyTexture(t);
            const e = s.MaterialUtils.get();
            this.getThreeJsMaterials().push(e),
            e.defines.colorMapEmissive = !0,
            e.needsUpdate = !0,
            e.uniforms.colorTexture.value = t;
            const i = s.ThreeJsHelper.createMeshObject(this, e, [{
                name: "position",
                dimensions: 3
            }, {
                name: "uv",
                dimensions: 2
            }], !1);
            this.getThreeJsObjects().push(i),
            s.ThreeJsHelper.useInDynEnvMap(i, !0);
            const n = s.MathUtils.pi / (this._numLatVerts - 1)
              , o = s.MathUtils.pi / this._numLatVerts
              , a = (2 * this._numLatVerts + 1) * this._numLatVerts
              , r = new Float32Array(3 * a)
              , l = new Float32Array(2 * a)
              , c = new Uint16Array(this._numLatVerts * (this._numLatVerts - 1) * 12)
              , h = s.Vector3.pool.get()
              , d = s.LatLonAlt.pool.get();
            for (let t = 0; t < this._numLatVerts; t++)
                for (let e = 0; e < 2 * this._numLatVerts + 1; e++) {
                    d.lat = t * n - s.MathUtils.halfPi,
                    d.lon = e * o - s.MathUtils.pi,
                    d.alt = 0,
                    h.x = 5e23 * Math.cos(d.lat) * Math.cos(d.lon),
                    h.y = 5e23 * Math.cos(d.lat) * Math.sin(d.lon),
                    h.z = 5e23 * Math.sin(d.lat);
                    const i = t * (2 * this._numLatVerts + 1) + e;
                    r[3 * i + 0] = h.x,
                    r[3 * i + 1] = h.y,
                    r[3 * i + 2] = h.z,
                    l[2 * i + 0] = .5 - d.lon / s.MathUtils.twoPi,
                    l[2 * i + 1] = .5 - d.lat / s.MathUtils.pi;
                    const a = t * this._numLatVerts * 2 + e;
                    t < this._numLatVerts - 1 && e < 2 * this._numLatVerts && (c[6 * a + 0] = (2 * this._numLatVerts + 1) * (t + 0) + (e + 0),
                    c[6 * a + 1] = (2 * this._numLatVerts + 1) * (t + 1) + (e + 0),
                    c[6 * a + 2] = (2 * this._numLatVerts + 1) * (t + 1) + (e + 1),
                    c[6 * a + 3] = (2 * this._numLatVerts + 1) * (t + 0) + (e + 0),
                    c[6 * a + 4] = (2 * this._numLatVerts + 1) * (t + 1) + (e + 1),
                    c[6 * a + 5] = (2 * this._numLatVerts + 1) * (t + 0) + (e + 1))
                }
            s.LatLonAlt.pool.release(d),
            s.Vector3.pool.release(h);
            const u = this.getThreeJsObjects()[0].geometry;
            s.ThreeJsHelper.setVertices(u, "position", r),
            s.ThreeJsHelper.setVertices(u, "uv", l),
            s.ThreeJsHelper.setIndices(u, c)
        }
        __unloadResources() {
            s.ThreeJsHelper.destroyAllObjectsAndMaterials(this)
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        SpheroidComponent: function() {
            return SpheroidComponent
        }
    });
    var s = i(6);
    class SpheroidComponent extends s.BaseComponent {
        constructor(t, e) {
            super(t, e),
            this._equatorialRadius = 1,
            this._polarRadius = 1,
            this._planetographic = !1,
            this._changed = !0,
            this._changedCallbacks = new s.FastSet,
            this.setIsGroundComponent(!0),
            this.__setRadius(Math.max(this._polarRadius, this._equatorialRadius))
        }
        getEquatorialRadius() {
            return this._equatorialRadius
        }
        setEquatorialRadius(t) {
            this._equatorialRadius = t,
            this.__setRadius(Math.max(this._polarRadius, this._equatorialRadius)),
            this._changed = !0
        }
        getPolarRadius() {
            return this._polarRadius
        }
        setPolarRadius(t) {
            this._polarRadius = t,
            this.__setRadius(Math.max(this._polarRadius, this._equatorialRadius)),
            this._changed = !0
        }
        isPlanetographic() {
            return this._planetographic
        }
        setPlanetographic(t) {
            this._planetographic = t,
            this._changed = !0
        }
        addChangedCallback(t) {
            this._changedCallbacks.add(t)
        }
        removeChangedCallback(t) {
            this._changedCallbacks.delete(t)
        }
        __update() {
            if (this._changed) {
                for (let t = 0; t < this._changedCallbacks.getSize(); t++)
                    this._changedCallbacks.getAt(t)();
                this._changed = !1
            }
        }
        xyzFromLLA(t, e) {
            const i = Math.cos(e.lat)
              , s = Math.sin(e.lat);
            if (this._planetographic) {
                const n = 1 - this._polarRadius * this._polarRadius / (this._equatorialRadius * this._equatorialRadius)
                  , o = this._equatorialRadius / Math.sqrt(1 - n * s * s);
                t.x = (o + e.alt) * i * Math.cos(e.lon),
                t.y = (o + e.alt) * i * Math.sin(e.lon),
                t.z = ((1 - n) * o + e.alt) * s
            } else {
                const n = this._equatorialRadius
                  , o = this._polarRadius
                  , a = n * o / Math.sqrt(o * o * i * i + n * n * s * s);
                t.x = (a + e.alt) * i * Math.cos(e.lon),
                t.y = (a + e.alt) * i * Math.sin(e.lon),
                t.z = (a + e.alt) * s
            }
        }
        radiusFromXYZ(t, e=5) {
            if (this._planetographic) {
                const i = t.magnitudeXY()
                  , s = 1 - this._polarRadius * this._polarRadius / (this._equatorialRadius * this._equatorialRadius);
                let n = Math.atan(t.z / ((1 - s) * i))
                  , o = 0;
                for (let a = 0; a < e; a++) {
                    const e = Math.sin(n);
                    o = this._equatorialRadius / Math.sqrt(1 - s * e * e),
                    n = Math.atan((t.z + o * s * e) / i)
                }
                return o
            }
            const i = t.z * t.z / (t.x * t.x + t.y * t.y)
              , s = 1 / (1 + i)
              , n = i * s
              , o = this._equatorialRadius
              , a = this._polarRadius;
            return o * a / Math.sqrt(a * a * s + o * o * n)
        }
        llaFromXYZ(t, e, i=5) {
            if (this._planetographic) {
                t.lon = Math.atan2(e.y, e.x);
                const s = e.magnitudeXY()
                  , n = 1 - this._polarRadius * this._polarRadius / (this._equatorialRadius * this._equatorialRadius);
                t.lat = Math.atan(e.z / ((1 - n) * s));
                let o = 0;
                for (let a = 0; a < i; a++) {
                    const i = Math.sin(t.lat);
                    o = 1 / Math.sqrt(1 - n * i * i),
                    t.lat = Math.atan((e.z + this._equatorialRadius * o * n * i) / s)
                }
                t.alt = s / Math.cos(t.lat) - this._equatorialRadius * o
            } else {
                const i = e.magnitudeXY();
                t.lon = Math.atan2(e.y, e.x),
                t.lat = Math.atan(e.z / i);
                const s = Math.cos(t.lat)
                  , n = Math.sin(t.lat)
                  , o = this._equatorialRadius
                  , a = this._polarRadius
                  , r = o * a / Math.sqrt(a * a * s * s + o * o * n * n);
                t.alt = e.magnitude() - r
            }
        }
        llaToggleGraphicCentric(t, e) {
            const i = s.Vector3.pool.get();
            this.xyzFromLLA(i, e),
            this._planetographic = !this._planetographic,
            this.llaFromXYZ(t, i),
            this._planetographic = !this._planetographic,
            s.Vector3.pool.release(i)
        }
        upFromLLA(t, e) {
            const i = s.LatLonAlt.pool.get();
            this._planetographic ? i.copy(e) : this.llaToggleGraphicCentric(i, e),
            t.x = Math.cos(i.lat) * Math.cos(i.lon),
            t.y = Math.cos(i.lat) * Math.sin(i.lon),
            t.z = Math.sin(i.lat),
            s.LatLonAlt.pool.release(i)
        }
        eastFromLLA(t, e) {
            t.x = -Math.sin(e.lon),
            t.y = Math.cos(e.lon),
            t.z = 0
        }
        northFromLLA(t, e) {
            const i = s.LatLonAlt.pool.get();
            this._planetographic ? i.copy(e) : this.llaToggleGraphicCentric(i, e),
            t.x = -Math.sin(i.lat) * Math.cos(i.lon),
            t.y = -Math.sin(i.lat) * Math.sin(i.lon),
            t.z = Math.cos(i.lat),
            s.LatLonAlt.pool.release(i)
        }
        orientationFromLLA(t, e) {
            const i = s.LatLonAlt.pool.get();
            this._planetographic ? i.copy(e) : this.llaToggleGraphicCentric(i, e);
            const n = Math.sin(i.lat)
              , o = Math.sin(i.lon)
              , a = Math.cos(i.lon);
            t.w = .5 * Math.sqrt((1 + n) * (1 - o)),
            t.x = .5 * Math.sqrt((1 - n) * (1 - o)),
            t.y = .5 * Math.sqrt((1 - n) * (1 + o)) * Math.sign(a),
            t.z = .5 * Math.sqrt((1 + n) * (1 + o)) * Math.sign(a),
            s.LatLonAlt.pool.release(i)
        }
        aerFromXYZRelToLLA(t, e, i) {
            const n = s.Vector3.pool.get();
            this.xyzFromLLA(n, i);
            const o = s.LatLonAlt.pool.get();
            this._planetographic ? o.copy(i) : this.llaFromXYZ(o, n),
            n.sub(e, n),
            t.range = n.magnitude(),
            n.mult(n, 1 / t.range);
            const a = s.Vector3.pool.get();
            this.upFromLLA(a, o);
            const r = n.dot(a);
            t.elevation = s.MathUtils.halfPi - Math.acos(r),
            n.addMult(n, a, -r),
            s.Vector3.pool.release(a);
            const l = s.Vector3.pool.get();
            this.northFromLLA(l, o);
            const c = s.Vector3.pool.get();
            this.eastFromLLA(c, o),
            t.azimuth = Math.atan2(n.dot(c), n.dot(l)),
            s.Vector3.pool.release(l),
            s.Vector3.pool.release(c),
            s.LatLonAlt.pool.release(o),
            s.Vector3.pool.release(n)
        }
        getRayIntersection(t, e, i) {
            const n = this._equatorialRadius / this._polarRadius
              , o = s.Vector3.pool.get()
              , a = s.Vector3.pool.get();
            o.set(e.x, e.y, e.z * n),
            a.set(i.x, i.y, i.z * n);
            const r = s.Geometry.getLineSphereIntersectionWithSphereAtOrigin(o, a, this._equatorialRadius);
            t.addMult(o, a, r),
            s.Vector3.pool.release(o),
            s.Vector3.pool.release(a),
            t.z /= n
        }
        getGroundPosition(t, e, i) {
            const n = s.LatLonAlt.pool.get();
            this.llaFromXYZ(n, i),
            n.alt = 0,
            this.xyzFromLLA(t, n);
            const o = s.Vector3.pool.get();
            e && this.upFromLLA(e, n),
            s.LatLonAlt.pool.release(n),
            s.Vector3.pool.release(o)
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        SpheroidLODComponent: function() {
            return SpheroidLODComponent
        }
    });
    var s = i(6);
    class SpheroidLODComponent extends s.BaseComponent {
        constructor(t, e) {
            super(t, e),
            this._textureInfos = new s.FastMap,
            this._mapping = "cylinder",
            this._longitudinalRotation = 0,
            this._numFaces = 1,
            this._lowerLeftBounds = new s.LatLonAlt(-s.MathUtils.halfPi,-s.MathUtils.pi,0),
            this._upperRightBounds = new s.LatLonAlt(+s.MathUtils.halfPi,s.MathUtils.pi,0),
            this._cubeMapFaceFrames = s.CubeMap.defaultCubeMapFaceFrames,
            this._shadowEntities = [],
            this._materialOptions = new Set,
            this._atmosphereComponentRef = new s.ComponentRef(this.getEntity().getScene(),s.AtmosphereComponent,this.getEntity().getName()),
            this._spheroidComponentRef = new s.ComponentRef(this.getEntity().getScene(),s.SpheroidComponent,this.getEntity().getName()),
            this._spheroidComponentRef.setRefChangedCallback(this._spheroidRefChangedCallback.bind(this)),
            this._spheroidChangedCallback = this._spheroidChangedCallback.bind(this),
            this.__setUsesEntityOrientation(!0)
        }
        getTextureNames() {
            const t = [];
            for (let e = 0; e < this._textureInfos.getSize(); e++)
                t.push(this._textureInfos.getAt(e).key);
            return t
        }
        getTextureUrl(t) {
            return this._textureInfos.get(t)?.url
        }
        getTextureSizes(t) {
            return this._textureInfos.get(t)?.sizes
        }
        setTexture(t, e, i=[4, 512, 4096]) {
            const n = SpheroidLODComponent._textureToMaterialOption.get(t);
            if (void 0 !== n) {
                const t = this.getThreeJsMaterials();
                for (let e = 0, i = t.length; e < i; e++)
                    t[e].defines[n] = !0,
                    t[e].needsUpdate = !0
            }
            let o = this._textureInfos.get(t);
            if (o)
                o.url = e,
                o.sizes = [...i];
            else {
                o = {
                    url: e,
                    sizes: [...i],
                    lods: []
                };
                const n = this.getThreeJsMaterials();
                for (let e = 0, i = this._numFaces; e < i; e++) {
                    const i = new s.TextureLOD(this)
                      , a = n[e]?.uniforms[`${t}Texture`];
                    void 0 !== a && i.setUniform(a),
                    o.lods.push(i)
                }
                this._textureInfos.set(t, o)
            }
            for (let t = 0, s = this._numFaces; t < s; t++) {
                const s = o.lods[t];
                s.setUrl(e.replace("$FACE", t.toString())),
                s.setSizes(i)
            }
            "normal" === t && this._updateMeshes()
        }
        forceTextureSize(t, e) {
            const i = this._textureInfos.get(t);
            if (void 0 === i)
                throw new Error(`No texture named "${t}" has been defined.`);
            for (let t = 0; t < i.lods.length; t++)
                i.lods[t].setForcedSize(e)
        }
        unsetTexture(t) {
            const e = SpheroidLODComponent._textureToMaterialOption.get(t);
            if (void 0 !== e) {
                const t = this.getThreeJsMaterials();
                for (let i = 0, s = t.length; i < s; i++)
                    delete t[i].defines[e],
                    t[i].needsUpdate = !0
            }
            this._textureInfos.delete(t);
            const i = this.getThreeJsMaterials();
            for (let e = 0, n = i.length; e < n; e++) {
                const n = i[e].uniforms[`${t}Texture`];
                n?.value instanceof s.THREE.Texture && (s.ThreeJsHelper.destroyTexture(n.value),
                n.value = null)
            }
            "normal" === t && this._updateMeshes()
        }
        getTextureCurrentSize(t, e) {
            const i = this._textureInfos.get(t);
            if (void 0 !== i?.lods[e])
                return i.lods[e].getCurrentSize()
        }
        isMaterialOptionEnabled(t) {
            return this._materialOptions.has(t)
        }
        setMaterialOption(t, e) {
            const i = this.getThreeJsMaterials();
            if (e && !this._materialOptions.has(t)) {
                this._materialOptions.add(t);
                for (let e = 0, s = i.length; e < s; e++) {
                    const s = i[e];
                    s.defines[t] = !0,
                    s.needsUpdate = !0
                }
            } else if (!e && this._materialOptions.has(t)) {
                this._materialOptions.delete(t);
                for (let e = 0, s = i.length; e < s; e++) {
                    const s = i[e];
                    delete s.defines[t],
                    s.needsUpdate = !0
                }
            }
        }
        getMapping() {
            return this._mapping
        }
        setMapping(t) {
            if (this._mapping !== t) {
                if ("cylinder" === t)
                    this._numFaces = 1;
                else {
                    if ("cube" !== t)
                        throw new Error("Invalid mapping type.");
                    this._numFaces = 6
                }
                for (let t = 0; t < this._textureInfos.getSize(); t++) {
                    const e = this._textureInfos.getAt(t).value;
                    for (let t = 0; t < e.lods.length; t++)
                        e.lods[t].setEnabled(!1);
                    e.lods = [];
                    for (let t = 0, i = this._numFaces; t < i; t++) {
                        const i = new s.TextureLOD(this);
                        i.setUrl(e.url.replace("$FACE", t.toString())),
                        i.setSizes(e.sizes),
                        e.lods.push(i)
                    }
                }
                this.resetResources(),
                this._mapping = t
            }
        }
        setBounds(t, e) {
            this._lowerLeftBounds.copy(t),
            this._upperRightBounds.copy(e),
            this._updateMeshes()
        }
        setCubeMapLayout(t) {
            this._cubeMapFaceFrames = [];
            for (let e = 0; e < 6; e++) {
                this._cubeMapFaceFrames.push([]);
                for (let i = 0; i < 3; i++) {
                    let n;
                    switch (t[e][i]) {
                    case "+x":
                        n = s.Vector3.XAxis;
                        break;
                    case "-x":
                        n = s.Vector3.XAxisNeg;
                        break;
                    case "+y":
                        n = s.Vector3.YAxis;
                        break;
                    case "-y":
                        n = s.Vector3.YAxisNeg;
                        break;
                    case "+z":
                        n = s.Vector3.ZAxis;
                        break;
                    case "-z":
                        n = s.Vector3.ZAxisNeg;
                        break;
                    default:
                        throw new Error("Invalid cubemap layout component.")
                    }
                    this._cubeMapFaceFrames[e][i] = n
                }
            }
            this._updateMeshes()
        }
        getNumShadowEntities() {
            return this._shadowEntities.length
        }
        getShadowEntity(t) {
            return this._shadowEntities[t]?.getName()
        }
        setShadowEntities(t) {
            this._shadowEntities = [];
            for (const e of t)
                this._shadowEntities.push(new s.EntityRef(this.getEntity().getScene(),e));
            const e = t.length > 0;
            for (let t = 0, i = this.getThreeJsMaterials().length; t < i; t++)
                s.ThreeJsHelper.setDefine(this.getThreeJsMaterials()[t], "shadowEntities", e)
        }
        getLongitudeRotation() {
            return this._longitudinalRotation
        }
        setLongitudeRotation(t) {
            this._longitudinalRotation = t
        }
        async getLoadedPromise(t=!1, e=5) {
            await super.getLoadedPromise(t, e),
            "loaded" === this.getLoadState().state && await this.getTexturesLoadedPromise(e)
        }
        async getTexturesLoadedPromise(t=5) {
            const e = [];
            for (let i = 0; i < this._textureInfos.getSize(); i++) {
                const s = this._textureInfos.getAt(i).value;
                for (let i = 0, n = s.lods.length; i < n; i++)
                    e.push(s.lods[i].getLoadedPromise(t))
            }
            const i = await Promise.allSettled(e);
            if (!i.every((t => "fulfilled" === t.status)))
                throw new Error(i.filter((t => "rejected" === t.status)).map((t => t.reason instanceof Error ? t.reason.message : "")).filter((t => "" !== t)).reduce(( (t, e) => `${t}\n${e}`), ""))
        }
        setSpheroidReference(t) {
            this._spheroidComponentRef.set(this.getEntity().getName(), t)
        }
        __destroy() {
            const t = this._spheroidComponentRef.get();
            null !== t && t.removeChangedCallback(this._spheroidChangedCallback),
            super.__destroy()
        }
        __update() {
            for (let t = 0; t < this._textureInfos.getSize(); t++) {
                const e = this._textureInfos.getAt(t).value;
                for (let t = 0, i = e.lods.length; t < i; t++)
                    e.lods[t].update()
            }
            this._spheroidComponentRef.update()
        }
        __prepareForRender(t) {
            const e = this.getThreeJsObjects()
              , i = s.Quaternion.pool.get();
            i.setFromAxisAngle(s.Vector3.ZAxis, this._longitudinalRotation);
            for (let n = 0; n < e.length; n++)
                s.ThreeJsHelper.setOrientationToEntity(e[n], this.getEntity(), i),
                s.ThreeJsHelper.setPositionToEntity(e[n], this.getEntity(), t);
            s.Quaternion.pool.release(i);
            const n = this._atmosphereComponentRef.get();
            s.MaterialUtils.setUniforms(this.getThreeJsMaterials(), t, this.getEntity(), this._shadowEntities, n, !0)
        }
        async __loadResources() {
            for (let t = 0; t < this._numFaces; t++) {
                const e = s.MaterialUtils.get();
                this.getThreeJsMaterials().push(e);
                for (const t of this._materialOptions)
                    e.defines[t] = !0,
                    e.needsUpdate = !0;
                e.defines.shadowEntities = this.getNumShadowEntities() > 0,
                e.defines.nightMapEmissive = this._textureInfos.has("night");
                const i = s.ThreeJsHelper.createMeshObject(this, e, [{
                    name: "position",
                    dimensions: 3
                }, {
                    name: "normal",
                    dimensions: 3
                }, {
                    name: "uv",
                    dimensions: 2
                }], !1);
                this.getThreeJsObjects().push(i),
                s.ThreeJsHelper.useInDynEnvMap(i, !0);
                for (let i = 0; i < this._textureInfos.getSize(); i++) {
                    const {key: s, value: n} = this._textureInfos.getAt(i)
                      , o = e.uniforms[`${s}Texture`];
                    if (void 0 !== o) {
                        const e = n.lods[t];
                        e.setEnabled(!0),
                        e.setUniform(o)
                    }
                    const a = SpheroidLODComponent._textureToMaterialOption.get(s);
                    void 0 !== a && (e.defines[a] = !0,
                    e.needsUpdate = !0)
                }
            }
            this._updateMeshes()
        }
        __unloadResources() {
            for (let t = 0; t < this.getThreeJsMaterials().length; t++) {
                const e = this.getThreeJsMaterials()[t];
                e.uniforms.shadowRingsTexture?.value && (e.uniforms.shadowRingsTexture.value = null)
            }
            s.ThreeJsHelper.destroyAllObjectsAndMaterials(this);
            for (let t = 0; t < this._textureInfos.getSize(); t++) {
                const e = this._textureInfos.getAt(t).value;
                for (let t = 0; t < this._numFaces; t++)
                    e.lods[t].setEnabled(!1),
                    e.lods[t].setUniform(null)
            }
        }
        _updateMeshes() {
            if (0 === this.getThreeJsObjects().length)
                return;
            const t = this._spheroidComponentRef.get();
            if (null !== t)
                if ("cylinder" === this._mapping) {
                    const e = this._upperRightBounds.lat - this._lowerLeftBounds.lat
                      , i = this._upperRightBounds.lon - this._lowerLeftBounds.lon
                      , n = Math.max(Math.ceil(100 * e / s.MathUtils.pi), 4)
                      , o = Math.max(Math.ceil(200 * i / s.MathUtils.twoPi), 4)
                      , a = e / (n - 1)
                      , r = i / (o - 1)
                      , l = o * n
                      , c = new Float32Array(3 * l)
                      , h = new Float32Array(3 * l)
                      , d = new Float32Array(2 * l)
                      , u = new Uint16Array((o - 1) * (n - 1) * 6)
                      , p = s.Vector3.pool.get()
                      , m = s.LatLonAlt.pool.get();
                    for (let e = 0; e < n; e++)
                        for (let i = 0; i < o; i++) {
                            m.lat = this._lowerLeftBounds.lat + e * a,
                            m.lon = this._lowerLeftBounds.lon + i * r,
                            m.alt = 0;
                            const s = e * o + i;
                            if (t.xyzFromLLA(p, m),
                            c[3 * s + 0] = p.x,
                            c[3 * s + 1] = p.y,
                            c[3 * s + 2] = p.z,
                            t.upFromLLA(p, m),
                            h[3 * s + 0] = p.x,
                            h[3 * s + 1] = p.y,
                            h[3 * s + 2] = p.z,
                            d[2 * s + 0] = i / (o - 1),
                            d[2 * s + 1] = 1 - e / (n - 1),
                            e + 1 < n && i + 1 < o) {
                                const t = e * (o - 1) + i;
                                u[6 * t + 0] = o * (e + 0) + (i + 0),
                                u[6 * t + 1] = o * (e + 1) + (i + 1),
                                u[6 * t + 2] = o * (e + 1) + (i + 0),
                                u[6 * t + 3] = o * (e + 0) + (i + 0),
                                u[6 * t + 4] = o * (e + 0) + (i + 1),
                                u[6 * t + 5] = o * (e + 1) + (i + 1)
                            }
                        }
                    s.LatLonAlt.pool.release(m),
                    s.Vector3.pool.release(p);
                    const _ = this.getThreeJsObjects()[0];
                    s.ThreeJsHelper.setVertices(_.geometry, "position", c),
                    s.ThreeJsHelper.setVertices(_.geometry, "normal", h),
                    s.ThreeJsHelper.setVertices(_.geometry, "uv", d),
                    s.ThreeJsHelper.setIndices(_.geometry, u),
                    this._textureInfos.has("normal") && s.ThreeJsHelper.computeTangents(_.geometry)
                } else if ("cube" === this._mapping) {
                    const e = 50
                      , i = s.Vector3.pool.get()
                      , n = s.LatLonAlt.pool.get();
                    for (let o = 0; o < 6; o++) {
                        const a = new Float32Array(e * e * 3)
                          , r = new Float32Array(e * e * 3)
                          , l = new Float32Array(e * e * 2)
                          , c = new Uint16Array((e - 1) * (e - 1) * 6);
                        let h = !1;
                        const d = s.Vector3.pool.get();
                        d.cross(this._cubeMapFaceFrames[o][0], this._cubeMapFaceFrames[o][1]),
                        d.x === this._cubeMapFaceFrames[o][2].x && d.y === this._cubeMapFaceFrames[o][2].y && d.z === this._cubeMapFaceFrames[o][2].z || (h = !0),
                        s.Vector3.pool.release(d);
                        let u = 0
                          , p = 0;
                        for (let d = 0; d < e; d++)
                            for (let m = 0; m < e; m++)
                                i.mult(this._cubeMapFaceFrames[o][0], 2 * m / (e - 1) - 1),
                                i.addMult(i, this._cubeMapFaceFrames[o][1], 2 * d / (e - 1) - 1),
                                i.addMult(i, this._cubeMapFaceFrames[o][2], 1),
                                i.normalize(i),
                                s.Geometry.getLLAFromXYZOnSphere(n, i, 0),
                                n.alt = 0,
                                t.xyzFromLLA(i, n),
                                a[3 * u + 0] = i.x,
                                a[3 * u + 1] = i.y,
                                a[3 * u + 2] = i.z,
                                t.upFromLLA(i, n),
                                r[3 * u + 0] = i.x,
                                r[3 * u + 1] = i.y,
                                r[3 * u + 2] = i.z,
                                l[2 * u + 0] = m / (e - 1),
                                l[2 * u + 1] = 1 - d / (e - 1),
                                m < e - 1 && d < e - 1 && (c[6 * p + 0] = (d + 0) * e + (m + 0),
                                c[6 * p + 3] = (d + 1) * e + (m + 1),
                                h ? (c[6 * p + 1] = (d + 1) * e + (m + 1),
                                c[6 * p + 2] = (d + 0) * e + (m + 1),
                                c[6 * p + 4] = (d + 0) * e + (m + 0),
                                c[6 * p + 5] = (d + 1) * e + (m + 0)) : (c[6 * p + 1] = (d + 0) * e + (m + 1),
                                c[6 * p + 2] = (d + 1) * e + (m + 1),
                                c[6 * p + 4] = (d + 1) * e + (m + 0),
                                c[6 * p + 5] = (d + 0) * e + (m + 0)),
                                p += 1),
                                u += 1;
                        const m = this.getThreeJsObjects()[o];
                        s.ThreeJsHelper.setVertices(m.geometry, "position", a),
                        s.ThreeJsHelper.setVertices(m.geometry, "normal", r),
                        s.ThreeJsHelper.setVertices(m.geometry, "uv", l),
                        s.ThreeJsHelper.setIndices(m.geometry, c),
                        this._textureInfos.has("normal") && s.ThreeJsHelper.computeTangents(m.geometry)
                    }
                    s.LatLonAlt.pool.release(n),
                    s.Vector3.pool.release(i)
                }
        }
        _spheroidRefChangedCallback(t, e) {
            null !== t && t.removeChangedCallback(this._spheroidChangedCallback),
            null !== e && e.addChangedCallback(this._spheroidChangedCallback),
            this._spheroidChangedCallback()
        }
        _spheroidChangedCallback() {
            const t = this._spheroidComponentRef.get();
            null !== t ? this.__setRadius(Math.max(t.getEquatorialRadius(), t.getPolarRadius())) : this.__setRadius(0),
            this.resetResources()
        }
        static _textureToMaterialOption = new Map([["normal", "normalMap"], ["night", "nightMap"], ["decal", "decalMap"], ["specular", "specularMap"]])
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        SpoutComponent: function() {
            return SpoutComponent
        }
    });
    var s = i(6);
    class SpoutComponent extends s.CameraComponent {
        constructor(t, e) {
            super(t, e),
            this._renderWidth = 2048,
            this._globeDistance = 1,
            this._threeJsFaceCameras = [],
            this._threeJsFaceRenderTargets = [],
            this._threeJsQuad = new s.THREE.Mesh,
            this._threeJsSpoutScene = new s.THREE.Scene,
            this._threeJsCubeCamera = new s.THREE.OrthographicCamera(-1,1,-1,1,-1,1),
            this._tagStart = new s.THREE.WebGLRenderTarget(2,3,{
                minFilter: s.THREE.LinearFilter,
                magFilter: s.THREE.NearestFilter
            }),
            this._tagEnd = new s.THREE.WebGLRenderTarget(3,2,{
                minFilter: s.THREE.LinearFilter,
                magFilter: s.THREE.NearestFilter
            }),
            this._tagSend = new s.THREE.WebGLRenderTarget(3,3,{
                minFilter: s.THREE.LinearFilter,
                magFilter: s.THREE.NearestFilter
            }),
            this._spoutTexture = new s.THREE.WebGLRenderTarget(this._renderWidth,this._renderWidth / 2,{
                minFilter: s.THREE.LinearFilter,
                magFilter: s.THREE.NearestFilter
            }),
            this._setupFaceCameras(),
            this._setupQuad()
        }
        getRenderWidth() {
            return this._renderWidth
        }
        setRenderWidth(t) {
            this._renderWidth = t,
            this._spoutTexture.width !== this._renderWidth && this._spoutTexture.setSize(this._renderWidth, this._renderWidth / 2);
            for (let t = 0; t < 6; t++)
                this._threeJsFaceRenderTargets[t].setSize(this._renderWidth / 4, this._renderWidth / 4)
        }
        getForGlobe() {
            return 1 === this.getInvertDepth()
        }
        setForGlobe(t, e) {
            this.setInvertDepth(t ? 1 : 0),
            this._globeDistance = e
        }
        __render() {
            if (this.getForGlobe()) {
                const t = this.getEntity().getParent();
                t && this.setNearDistance(Math.max(.1, .5 * t.getOcclusionRadius())),
                this.setMidDistance(this.getAutoNearDistance())
            }
            this._updateProjectionMatrices();
            const t = .7071067811865476
              , e = this.getEntity().getOrientation()
              , i = s.Quaternion.threeJsPool.get();
            i.set(e.x, e.y, e.z, e.w),
            this._threeJsFaceCameras[0].setRotationFromQuaternion(i),
            i.set(t * (e.x - e.y), t * (e.x + e.y), t * (-e.w + e.z), t * (e.w + e.z)),
            this._threeJsFaceCameras[1].setRotationFromQuaternion(i),
            i.set(e.y, -e.x, e.w, -e.z),
            this._threeJsFaceCameras[2].setRotationFromQuaternion(i),
            i.set(t * (e.x + e.y), t * (-e.x + e.y), t * (e.w + e.z), t * (e.w - e.z)),
            this._threeJsFaceCameras[3].setRotationFromQuaternion(i),
            i.set(t * (e.w + e.x), t * (e.y + e.z), t * (-e.y + e.z), t * (e.w - e.x)),
            this._threeJsFaceCameras[4].setRotationFromQuaternion(i),
            i.set(t * (-e.w + e.x), t * (e.y - e.z), t * (e.y + e.z), t * (e.w + e.x)),
            this._threeJsFaceCameras[5].setRotationFromQuaternion(i),
            s.Quaternion.threeJsPool.release(i),
            this.getForGlobe() && this._threeJsRenderer.state.setCullFace(s.THREE.CullFaceFront);
            for (let t = 0; t < 6; t++)
                this._threeJsRenderer.setRenderTarget(this._threeJsFaceRenderTargets[t]),
                this._threeJsRenderer.render(this.getEntity().getScene().getThreeJsScene(), this._threeJsFaceCameras[t]);
            this.getForGlobe() && this._threeJsRenderer.state.setCullFace(s.THREE.CullFaceBack),
            this._threeJsRenderer.setRenderTarget(this._tagStart),
            this._threeJsRenderer.clearColor(),
            this._threeJsRenderer.setRenderTarget(this._spoutTexture),
            this._threeJsRenderer.clearColor(),
            this._threeJsRenderer.setRenderTarget(this._tagEnd),
            this._threeJsRenderer.clearColor(),
            this._threeJsRenderer.setRenderTarget(this._spoutTexture),
            this._threeJsRenderer.render(this._threeJsSpoutScene, this._threeJsCubeCamera),
            this._threeJsRenderer.setRenderTarget(this._tagSend),
            this._threeJsRenderer.clearColor(),
            this._threeJsRenderer.setRenderTarget(null)
        }
        _setupFaceCameras() {
            for (let t = 0; t < 6; t++) {
                this._threeJsFaceCameras.push(new s.THREE.PerspectiveCamera(90,1,.1,1e3));
                const e = new s.THREE.Matrix4;
                e.set(1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0),
                this._threeJsFaceCameras[t].projectionMatrix = e,
                this._threeJsFaceCameras[t].projectionMatrixInverse.copy(e).invert();
                const i = new s.THREE.WebGLRenderTarget(this._renderWidth / 4,this._renderWidth / 4,{
                    minFilter: s.THREE.LinearFilter,
                    magFilter: s.THREE.LinearFilter
                });
                this._threeJsFaceRenderTargets.push(i)
            }
        }
        _updateProjectionMatrices() {
            const t = this.getAutoNearDistance();
            let e = Number.EPSILON - 1
              , i = t * (2 - Number.EPSILON);
            if (1 === this.getInvertDepth()) {
                const s = this._globeDistance;
                e = (t + s) * (1 - Number.EPSILON) / (t - s),
                i = -2 * t * s * (1 - Number.EPSILON) / (t - s)
            }
            for (let t = 0; t < 6; t++)
                this._threeJsFaceCameras[t].projectionMatrix.elements[6] = e,
                this._threeJsFaceCameras[t].projectionMatrix.elements[14] = i
        }
        _setupQuad() {
            const t = new s.THREE.BufferGeometry
              , e = new Float32Array([-1, -1, 0, 1, -1, 0, 1, 1, 0, -1, 1, 0])
              , i = new Uint16Array([0, 1, 2, 0, 2, 3]);
            t.setAttribute("position", new s.THREE.BufferAttribute(e,3)),
            t.setIndex(new s.THREE.BufferAttribute(i,1));
            const n = {
                textures: new s.THREE.Uniform([])
            };
            for (let t = 0; t < 6; t++)
                n.textures.value.push(this._threeJsFaceRenderTargets[t].texture);
            const o = new s.THREE.RawShaderMaterial({
                uniforms: n,
                vertexShader: "\n\t\t\t\tin vec3 position;\n\t\t\t\tout vec2 xy;\n\t\t\t\tvoid main() {\n\t\t\t\t\tgl_Position = vec4(position.x, position.y, 0.0, 1.0);\n\t\t\t\t\txy = position.xy;\n\t\t\t\t}",
                fragmentShader: "\n\t\t\t\tprecision highp float;\n\n\t\t\t\tuniform sampler2D textures[6];\n\n\t\t\t\tin vec2 xy;\n\n\t\t\t\t// The output color.\n\t\t\t\tout vec4 outColor;\n\n\t\t\t\tconst float PI = 3.1415926535897932384626433832795;\n\n\t\t\t\tvec3 xyToUvFace(vec2 xy) {\n\t\t\t\t\tvec3 xyz = vec3(\n\t\t\t\t\t\tcos(xy.y * PI / 2.0) * cos(xy.x * PI),\n\t\t\t\t\t\tcos(xy.y * PI / 2.0) * sin(xy.x * PI),\n\t\t\t\t\t\tsin(-xy.y * PI / 2.0));\n\n\t\t\t\t\tvec3 basis[3];\n\t\t\t\t\tfloat face;\n\t\t\t\t\tif (xyz.x * xyz.x >= xyz.y * xyz.y && xyz.x * xyz.x >= xyz.z * xyz.z) {\n\t\t\t\t\t\tif (xyz.x >= 0.0) {\n\t\t\t\t\t\t\tbasis[0] = vec3(0, 1, 0); basis[1] = vec3(0, 0, 1); basis[2] = vec3(1, 0, 0);\n\t\t\t\t\t\t\tface = 0.0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tbasis[0] = vec3(0, -1, 0); basis[1] = vec3(0, 0, 1); basis[2] = vec3(-1, 0, 0);\n\t\t\t\t\t\t\tface = 2.0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (xyz.y * xyz.y >= xyz.x * xyz.x && xyz.y * xyz.y >= xyz.z * xyz.z) {\n\t\t\t\t\t\tif (xyz.y >= 0.0) {\n\t\t\t\t\t\t\tbasis[0] = vec3(-1, 0, 0); basis[1] = vec3(0, 0, 1); basis[2] = vec3(0, 1, 0);\n\t\t\t\t\t\t\tface = 1.0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tbasis[0] = vec3(1, 0, 0); basis[1] = vec3(0, 0, 1); basis[2] = vec3(0, -1, 0);\n\t\t\t\t\t\t\tface = 3.0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (xyz.z >= 0.0) {\n\t\t\t\t\t\t\tbasis[0] = vec3(0, 1, 0); basis[1] = vec3(-1, 0, 0); basis[2] = vec3(0, 0, 1);\n\t\t\t\t\t\t\tface = 4.0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tbasis[0] = vec3(0, 1, 0); basis[1] = vec3(1, 0, 0); basis[2] = vec3(0, 0, -1);\n\t\t\t\t\t\t\tface = 5.0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tvec3 uv = vec3(\n\t\t\t\t\t\tbasis[0].x * xyz.x + basis[0].y * xyz.y + basis[0].z * xyz.z,\n\t\t\t\t\t\tbasis[1].x * xyz.x + basis[1].y * xyz.y + basis[1].z * xyz.z,\n\t\t\t\t\t\tbasis[2].x * xyz.x + basis[2].y * xyz.y + basis[2].z * xyz.z);\n\t\t\t\t\tuv.x /= uv.z;\n\t\t\t\t\tuv.y /= uv.z;\n\n\t\t\t\t\treturn vec3(0.5 * (uv.x + 1.0), 0.5 * (uv.y + 1.0), face);\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec3 uvFace = xyToUvFace(xy);\n\n\t\t\t\t\tvec4 pixel;\n\t\t\t\t\tint face = int(uvFace.z);\n\n\t\t\t\t\tif (face == 0) {\n\t\t\t\t\t\tpixel = texture(textures[0], vec2(uvFace.x, uvFace.y));\n\t\t\t\t\t}\n\t\t\t\t\telse if (face == 1) {\n\t\t\t\t\t\tpixel = texture(textures[1], vec2(uvFace.x, uvFace.y));\n\t\t\t\t\t}\n\t\t\t\t\telse if (face == 2) {\n\t\t\t\t\t\tpixel = texture(textures[2], vec2(uvFace.x, uvFace.y));\n\t\t\t\t\t}\n\t\t\t\t\telse if (face == 3) {\n\t\t\t\t\t\tpixel = texture(textures[3], vec2(uvFace.x, uvFace.y));\n\t\t\t\t\t}\n\t\t\t\t\telse if (face == 4) {\n\t\t\t\t\t\tpixel = texture(textures[4], vec2(uvFace.x, uvFace.y));\n\t\t\t\t\t}\n\t\t\t\t\telse if (face == 5) {\n\t\t\t\t\t\tpixel = texture(textures[5], vec2(uvFace.x, uvFace.y));\n\t\t\t\t\t}\n\n\t\t\t\t\toutColor = pixel;\n\t\t\t\t}",
                glslVersion: s.THREE.GLSL3,
                depthTest: !1,
                depthWrite: !1,
                side: s.THREE.DoubleSide
            });
            this._threeJsQuad = new s.THREE.Mesh(t,o),
            this._threeJsQuad.frustumCulled = !1,
            this._threeJsSpoutScene.add(this._threeJsQuad)
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        SpriteComponent: function() {
            return SpriteComponent
        }
    });
    var s = i(6);
    class SpriteComponent extends s.BaseComponent {
        constructor(t, e) {
            super(t, e),
            this._textureUrl = "",
            this._size = new s.Vector2(1,Number.NaN),
            this._size.freeze(),
            this._sizeUnits = "km",
            this._colorMultiplier = new s.Color(1,1,1,1),
            this._colorMultiplier.freeze(),
            this._alignment = new s.Vector2(.5,.5),
            this._alignment.freeze(),
            this._fadeDistance = 0,
            this._transparent = !1,
            this._blending = "normal",
            this._billboard = !1,
            this._renderOrder = 0
        }
        getTextureUrl() {
            return this._textureUrl
        }
        setTextureUrl(t) {
            this._textureUrl = t,
            this.resetResources()
        }
        getSize() {
            return this._size
        }
        setSize(t) {
            this._size.thaw(),
            this._size.copy(t),
            this._size.freeze(),
            this._updateSizeUniform()
        }
        getSizeUnits() {
            return this._sizeUnits
        }
        setSizeUnits(t) {
            this._sizeUnits = t,
            this._updateSizeUniform()
        }
        getColorMultiplier() {
            return this._colorMultiplier
        }
        setColorMultiplier(t) {
            this._colorMultiplier.thaw(),
            this._colorMultiplier.copy(t),
            this._colorMultiplier.freeze(),
            s.ThreeJsHelper.setUniformColorRGBA(this.getThreeJsMaterials()[0], "colorMultiplier", t)
        }
        getAlignment() {
            return this._alignment
        }
        setAlignment(t) {
            this._alignment.thaw(),
            this._alignment.copy(t),
            this._alignment.freeze(),
            s.ThreeJsHelper.setUniformVector2(this.getThreeJsMaterials()[0], "origin", this._alignment)
        }
        getFadeDistance() {
            return this._fadeDistance
        }
        setFadeDistance(t) {
            this._fadeDistance = t
        }
        isBillboard() {
            return this._billboard
        }
        setBillboard(t) {
            this._billboard = t
        }
        getTransparent() {
            return this._transparent
        }
        setTransparent(t) {
            this._transparent = t,
            s.ThreeJsHelper.setTransparent(this.getThreeJsMaterials()[0], this._transparent)
        }
        setBlending(t) {
            this._blending = t,
            s.ThreeJsHelper.setBlending(this.getThreeJsMaterials()[0], this._blending)
        }
        getRenderOrder() {
            return this._renderOrder
        }
        setRenderOrder(t) {
            this._renderOrder = t,
            s.ThreeJsHelper.setRenderOrder(this.getThreeJsObjects()[0], this._renderOrder)
        }
        __prepareForRender(t) {
            if ("pixels" === this._sizeUnits) {
                const e = s.Vector2.pool.get()
                  , i = this.getEntity().getExtentsRadius() / this.getEntity().getPixelSpaceExtentsRadius(t);
                e.mult(this._size, i),
                s.ThreeJsHelper.setUniformVector2(this.getThreeJsMaterials()[0], "size", e),
                s.Vector2.pool.release(e)
            }
            if (this.getThreeJsObjects().length > 0 && (this._billboard ? s.ThreeJsHelper.setOrientationToBillboard(this.getThreeJsObjects()[0], t) : s.ThreeJsHelper.setOrientationToEntity(this.getThreeJsObjects()[0], this.getEntity())),
            this._fadeDistance > 0) {
                const e = s.Vector3.pool.get()
                  , i = s.Quaternion.pool.get()
                  , n = this.getThreeJsObjects()[0].quaternion;
                i.copyFromThreeJs(n),
                e.rotateInverse(this.getEntity().getOrientation(), this.getEntity().getCameraSpacePosition(t)),
                s.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], "alphaFadeMultiplier", s.MathUtils.lerp(0, 1, s.MathUtils.clamp01(2 * (Math.abs(e.z) / this._fadeDistance - 1) + 1))),
                s.Quaternion.pool.release(i),
                s.Vector3.pool.release(e)
            }
            s.ThreeJsHelper.setPositionToEntity(this.getThreeJsObjects()[0], this.getEntity(), t)
        }
        async __loadResources() {
            const t = await s.ThreeJsHelper.loadTexture(this, this._textureUrl, !1);
            if ("loading" !== this.getLoadState().state)
                return void s.ThreeJsHelper.destroyTexture(t);
            SpriteComponent._threeJsGeometry || (SpriteComponent._threeJsGeometry = s.ThreeJsHelper.createGeometry([{
                name: "position",
                dimensions: 3
            }, {
                name: "uv",
                dimensions: 2
            }], !1),
            s.ThreeJsHelper.setVertices(SpriteComponent._threeJsGeometry, "position", new Float32Array([0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0])),
            s.ThreeJsHelper.setVertices(SpriteComponent._threeJsGeometry, "uv", new Float32Array([0, 1, 1, 1, 1, 0, 0, 0])),
            s.ThreeJsHelper.setIndices(SpriteComponent._threeJsGeometry, new Uint16Array([0, 1, 2, 2, 3, 0]))),
            SpriteComponent._threeJsMaterial || (SpriteComponent._threeJsMaterial = new s.THREE.ShaderMaterial({
                uniforms: {
                    colorMultiplier: new s.THREE.Uniform(new s.THREE.Vector4(1,1,1,1)),
                    alphaFadeMultiplier: new s.THREE.Uniform(1),
                    size: new s.THREE.Uniform(new s.THREE.Vector2(1,1)),
                    colorTexture: new s.THREE.Uniform(null),
                    origin: new s.THREE.Uniform(new s.THREE.Vector2(0,0)),
                    ...s.ShaderChunkLogDepth.ThreeUniforms
                },
                vertexShader: `\n\t\t\t\t\tuniform vec2 size;\n\t\t\t\t\tuniform vec2 origin;\n\t\t\t\t\tout vec2 fUV;\n\n\t\t\t\t\t${s.ShaderChunkLogDepth.VertexHead}\n\n\t\t\t\t\tvoid main() {\n\t\t\t\t\t\tvec4 viewPosition = modelViewMatrix * vec4((position.x - origin.x) * size.x, (position.y - origin.y) * size.y, 0.0, 1.0);\n\t\t\t\t\t\tgl_Position = projectionMatrix * viewPosition;\n\t\t\t\t\t\tfUV = uv;\n\n\t\t\t\t\t\t${s.ShaderChunkLogDepth.Vertex}\n\t\t\t\t\t}`,
                fragmentShader: `\n\t\t\t\t\tprecision highp float;\n\n\t\t\t\t\tuniform vec4 colorMultiplier;\n\t\t\t\t\tuniform float alphaFadeMultiplier;\n\t\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\t\tin vec2 fUV;\n\n\t\t\t\t\t${s.ShaderChunkLogDepth.FragmentHead}\n\n\t\t\t\t\tvoid main(void) {\n\t\t\t\t\t\tpc_fragColor = texture(colorTexture, fUV);\n\t\t\t\t\t\tpc_fragColor *= colorMultiplier;\n\t\t\t\t\t\tpc_fragColor.a *= alphaFadeMultiplier;\n\n\t\t\t\t\t\t${s.ShaderChunkLogDepth.Fragment}\n\t\t\t\t\t}`,
                side: s.THREE.DoubleSide
            })),
            SpriteComponent._useCount += 1;
            const e = SpriteComponent._threeJsMaterial.clone();
            this.getThreeJsMaterials().push(e),
            s.ThreeJsHelper.setTransparent(e, this._transparent),
            s.ThreeJsHelper.setBlending(e, this._blending),
            s.ThreeJsHelper.setUniformColorRGBA(e, "colorMultiplier", this._colorMultiplier),
            s.ThreeJsHelper.setUniformNumber(e, "alphaFadeMultiplier", 1),
            s.ThreeJsHelper.setUniformVector2(e, "origin", this._alignment),
            s.ThreeJsHelper.setUniformTexture(e, "colorTexture", t);
            const i = s.ThreeJsHelper.createMeshObjectGivenGeometry(this, e, SpriteComponent._threeJsGeometry);
            this.getThreeJsObjects().push(i),
            s.ThreeJsHelper.setRenderOrder(i, this._renderOrder),
            this._updateSizeUniform()
        }
        __unloadResources() {
            s.ThreeJsHelper.destroyMaterial(this.getThreeJsMaterials()[0], !0);
            const t = this.getThreeJsObjects()[0];
            null !== t.parent && t.parent.remove(t),
            SpriteComponent._useCount -= 1,
            0 === SpriteComponent._useCount && (SpriteComponent._threeJsGeometry && s.ThreeJsHelper.destroyGeometry(SpriteComponent._threeJsGeometry),
            SpriteComponent._threeJsMaterial && s.ThreeJsHelper.destroyMaterial(SpriteComponent._threeJsMaterial, !0))
        }
        _updateSizeUniform() {
            if (this.getThreeJsMaterials().length > 0) {
                const t = this.getThreeJsMaterials()[0].uniforms.colorTexture.value;
                if (null !== t) {
                    const e = t.image
                      , i = e.width / e.height
                      , n = s.Vector2.pool.get();
                    Number.isNaN(this._size.x) ? n.set(this._size.y * i, this._size.y) : Number.isNaN(this._size.y) ? n.set(this._size.x, this._size.x / i) : n.set(this._size.x, this._size.y),
                    s.ThreeJsHelper.setUniformVector2(this.getThreeJsMaterials()[0], "size", n),
                    "km" === this._sizeUnits ? this.__setRadius(Math.max(n.x, n.y)) : this.__setRadius(Number.POSITIVE_INFINITY),
                    s.Vector2.pool.release(n)
                }
            } else
                "km" === this._sizeUnits ? Number.isNaN(this._size.x) || Number.isNaN(this._size.y) ? this.__setRadius(this._size.y) : this.__setRadius(Math.max(this._size.x, this._size.y)) : this.__setRadius(Number.POSITIVE_INFINITY)
        }
        static _threeJsMaterial = null;
        static _threeJsGeometry = null;
        static _useCount = 0
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        StarfieldComponent: function() {
            return StarfieldComponent
        }
    });
    var s = i(6);
    class Star {
        constructor() {
            this.mag = 0,
            this.absMag = 0,
            this.color = new s.Color,
            this.position = new s.Vector3,
            this.particle = null
        }
    }
    class StarfieldComponent extends s.BaseComponent {
        constructor(t, e) {
            super(t, e),
            this._url = "",
            this._particleSize = 1,
            this.__setRadius(1e24)
        }
        getUrl() {
            return this._url
        }
        setUrl(t) {
            this._url = t,
            this.resetResources()
        }
        getParticleSize() {
            return this._particleSize
        }
        setParticleSize(t) {
            this._particleSize = t
        }
        __prepareForRender(t) {
            const e = s.Vector2.pool.get();
            if (t instanceof s.SpoutComponent)
                e.set(t.getRenderWidth(), .5 * t.getRenderWidth());
            else {
                const i = t.getViewport();
                if (!i)
                    return;
                e.copy(i.getBounds().size)
            }
            const i = Math.sqrt(Math.max(e.x, e.y) * window.devicePixelRatio) / 60;
            s.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], "particleSize", this._particleSize * i),
            s.Vector2.pool.release(e),
            s.ThreeJsHelper.setPositionToEntity(this.getThreeJsObjects()[0], this.getEntity(), t)
        }
        async __loadResources() {
            const t = await this._loadStars();
            if (this.isDestroyed())
                return;
            const e = new s.THREE.ShaderMaterial({
                vertexShader: StarfieldComponent.vertexShader,
                fragmentShader: StarfieldComponent.fragmentShader,
                transparent: !0,
                blending: s.THREE.AdditiveBlending,
                depthWrite: !1,
                uniforms: {
                    particleSize: new s.THREE.Uniform(1),
                    ...s.ShaderChunkLogDepth.ThreeUniforms
                }
            });
            this.getThreeJsMaterials().push(e);
            const i = new s.THREE.BufferGeometry;
            i.setAttribute("position", new s.THREE.BufferAttribute(new Float32Array(0),3)),
            i.setAttribute("color", new s.THREE.BufferAttribute(new Float32Array(0),4)),
            i.setIndex(new s.THREE.BufferAttribute(new Uint16Array(0),1));
            const n = new s.THREE.Points(i,e);
            s.ThreeJsHelper.setupObject(this, n),
            n.renderOrder = -2,
            this.getThreeJsObjects().push(n);
            const o = new Float32Array(3 * t.length)
              , a = new Float32Array(4 * t.length)
              , r = new Uint16Array(t.length);
            for (let e = 0; e < t.length; e++) {
                const i = t[e];
                o[3 * e + 0] = i.position.x,
                o[3 * e + 1] = i.position.y,
                o[3 * e + 2] = i.position.z,
                a[4 * e + 0] = i.color.r,
                a[4 * e + 1] = i.color.g,
                a[4 * e + 2] = i.color.b,
                a[4 * e + 3] = i.absMag,
                r[e] = e
            }
            s.ThreeJsHelper.setVertices(i, "position", o),
            s.ThreeJsHelper.setVertices(i, "color", a),
            s.ThreeJsHelper.setIndices(i, r)
        }
        __unloadResources() {
            s.ThreeJsHelper.destroyAllObjectsAndMaterials(this)
        }
        async _loadStars() {
            const t = await this.getEntity().getScene().getEngine().getDownloader().download(this._url, "binary", -this.getEntity().getLeastCameraDepth());
            if ("cancelled" === t.status)
                return Promise.resolve([]);
            if ("failed" === t.status)
                return Promise.reject(new Error(`Failed to load starfield component file "${t.url}": ${t.errorMessage}`));
            if (!(t.content instanceof ArrayBuffer))
                return Promise.reject(new Error(`Failed to load starfield component file "${t.url}": Not a binary file.`));
            const e = new s.Reader(t.content)
              , i = e.readInt32()
              , n = [];
            for (let t = 0; t < i; t++) {
                const t = new Star;
                t.mag = e.readFloat32(),
                t.absMag = e.readFloat32(),
                t.color.r = e.readByte() / 255,
                t.color.g = e.readByte() / 255,
                t.color.b = e.readByte() / 255,
                t.color.div(t.color, t.color.max()),
                t.position.y = -e.readFloat32(),
                t.position.z = e.readFloat32(),
                t.position.x = e.readFloat32(),
                t.position.rotate(StarfieldComponent.eclipJ2000ToJ2000Rotation, t.position),
                n.push(t)
            }
            return n
        }
        static eclipJ2000ToJ2000Rotation = new s.Quaternion(.9791532214288992,.2031230389823101,0,0,!0);
        static vertexShader = `\n\t\t#define PI 3.1415926538\n\n\t\tin vec4 color;\n\t\tout vec4 fColor;\n\n\t\tuniform float particleSize;\n\n\t\t${s.ShaderChunkLogDepth.VertexHead}\n\n\t\t// Returns the watts per km^2.\n\t\tfloat absoluteMagnitudeToFlux(float absoluteMagnitude, float distance) {\n\t\t\tfloat luminosityInWatts = 3.0128e28 * pow(10.0, absoluteMagnitude / -2.5);\n\t\t\treturn luminosityInWatts / (4.0 * PI * distance * distance);\n\t\t}\n\n\t\tvoid main() {\n\t\t\tvec4 viewPosition = modelViewMatrix * vec4(position, 1.0);\n\t\t\tgl_Position = projectionMatrix * viewPosition;\n\t\t\tgl_Position.w = viewPosition.y;\n\t\t\tfColor = color;\n\n\t\t\t// Get the flux and brightness of the star at the camera's point.\n\t\t\tfloat absMag = color.a;\n\t\t\tfloat distance = length(viewPosition);\n\t\t\tfloat flux = absoluteMagnitudeToFlux(absMag, distance);\n\t\t\tfloat brightness = 2.0 * log(1.0 + flux * 1e4);\n\n\t\t\t// Adjust the color and size so that it is visually pleasing.\n\t\t\tfColor.a = clamp(brightness * particleSize, 0.05, 1.0);\n\t\t\tgl_PointSize = clamp(brightness * 4.0 * particleSize, 5.0, 50.0);\n\n\t\t\t// If it is too close, fade the star.\n\t\t\tfColor.a = mix(0.0, fColor.a, clamp((distance - 1.0e12) / 9.0e12, 0.0, 1.0));\n\n\t\t\t${s.ShaderChunkLogDepth.Vertex}\n\t\t}`;
        static fragmentShader = `\n\t\tprecision highp float;\n\n\t\tin vec4 fColor;\n\n\t\t${s.ShaderChunkLogDepth.FragmentHead}\n\n\t\tvoid main(void) {\n\t\t\tfloat distanceFromEdge = clamp(1.0 - 2.0 * length(gl_PointCoord - vec2(0.5, 0.5)), 0.0, 1.0);\n\t\t\tfloat a = pow(distanceFromEdge, 5.0);\n\t\t\tpc_fragColor.rgb = fColor.rgb;\n\t\t\tpc_fragColor.a = fColor.a * a;\n\n\t\t\t${s.ShaderChunkLogDepth.Fragment}\n\t\t}`
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        TrailComponent: function() {
            return TrailComponent
        }
    });
    var s = i(6);
    class Point {
        constructor() {
            this.time = 0,
            this.position = new s.Vector3,
            this.velocity = new s.Vector3
        }
    }
    class TrailComponent extends s.BaseComponent {
        constructor(t, e) {
            super(t, e),
            this._color = new s.Color(1,1,1,1),
            this._color.freeze(),
            this._alphaFade = 0,
            this._widthMin = 0,
            this._widthMax = 2,
            this._ignoreDistance = !1,
            this._startTime = void 0,
            this._endTime = 0,
            this._relativeStartTime = !0,
            this._relativeEndTime = !0,
            this._startTimeMultiplier = 1,
            this._endTimeMultiplier = 1,
            this._relativeToEntity = new s.EntityRef(this.getEntity().getScene()),
            this._relativeToEntityOrientation = !1,
            this._angleCurveThreshold = .05235987755,
            this._initialTimeStep = void 0,
            this._points = [],
            this._pointsStart = 0,
            this._pointsCount = 0,
            this._currentRelativeToEntity = new s.EntityRef(this.getEntity().getScene()),
            this._dashLength = 1,
            this._dashGapLength = 0,
            this._glowWidth = 0,
            this._dashOffsetTime = 0,
            this._updatePointPositions = !1,
            this._updatePointPositionsLastIndex = 0,
            this.__setRadius(Number.POSITIVE_INFINITY)
        }
        getColor() {
            return this._color
        }
        setColor(t) {
            this._color.thaw(),
            this._color.copy(t),
            this._color.freeze(),
            s.ThreeJsHelper.setUniformColorRGBA(this.getThreeJsMaterials()[0], "color", this._color)
        }
        getAlphaFade() {
            return this._alphaFade
        }
        setWidths(t, e) {
            this._widthMin = t,
            this._widthMax = e,
            s.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], "widthMin", t),
            s.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], "widthMax", e)
        }
        setAlphaFade(t) {
            this._alphaFade = t,
            s.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], "alphaFade", t)
        }
        setDashLength(t, e) {
            this._dashLength = t,
            this._dashGapLength = e,
            s.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], "dashLength", t),
            s.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], "dashGapLength", e)
        }
        setGlowWidth(t) {
            this._glowWidth = t,
            s.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], "glowWidth", this._glowWidth)
        }
        getStartTime() {
            return this._startTime
        }
        setStartTime(t) {
            this._startTime = t
        }
        getEndTime() {
            return this._endTime
        }
        setEndTime(t) {
            this._endTime = t
        }
        isRelativeStartTime() {
            return this._relativeStartTime
        }
        setRelativeStartTime(t) {
            this._relativeStartTime = t,
            this.resetPoints()
        }
        isRelativeEndTime() {
            return this._relativeEndTime
        }
        setRelativeEndTime(t) {
            this._relativeEndTime = t,
            this.resetPoints()
        }
        getStartTimeMultiplier() {
            return this._startTimeMultiplier
        }
        setStartTimeMultiplier(t) {
            this._startTimeMultiplier = t
        }
        getEndTimeMultiplier() {
            return this._endTimeMultiplier
        }
        setEndTimeMultiplier(t) {
            this._endTimeMultiplier = t
        }
        getRelativeToEntity() {
            return this._relativeToEntity.getName()
        }
        setRelativeToEntity(t) {
            this._relativeToEntity.setName(t),
            this._currentRelativeToEntity.setName(t),
            this.resetPoints()
        }
        isRelativeToEntityOrientation() {
            return this._relativeToEntityOrientation
        }
        setRelativeToEntityOrientation(t) {
            this._relativeToEntityOrientation = t,
            t || s.ThreeJsHelper.setOrientation(this.getThreeJsObjects(), s.Quaternion.Identity),
            this.resetPoints()
        }
        getAngleCurveThreshold() {
            return this._angleCurveThreshold
        }
        setAngleCurveThreshold(t) {
            this._angleCurveThreshold = t,
            this.resetPoints()
        }
        getInitialTimeStep() {
            return this._initialTimeStep
        }
        setInitialTimeStep(t) {
            this._initialTimeStep = t,
            this.resetPoints()
        }
        setIgnoreDistance(t) {
            this._ignoreDistance = t
        }
        getUpdatePointPositions() {
            return this._updatePointPositions
        }
        setUpdatePointPositions(t) {
            this._updatePointPositions = t
        }
        resetPoints() {
            if (this._points = [],
            this._pointsCount = 0,
            this._pointsStart = 0,
            this.getThreeJsObjects().length > 0) {
                const t = this.getThreeJsObjects()[0].geometry
                  , e = new Float32Array(0)
                  , i = new s.THREE.InterleavedBuffer(e,TrailComponent.VERTEX_SIZE);
                t.setAttribute("position", new s.THREE.InterleavedBufferAttribute(i,3,0,!1)),
                t.setAttribute("positionPrev", new s.THREE.InterleavedBufferAttribute(i,3,3,!1)),
                t.setAttribute("positionNext", new s.THREE.InterleavedBufferAttribute(i,3,6,!1)),
                t.setAttribute("side", new s.THREE.InterleavedBufferAttribute(i,1,9,!1)),
                t.setAttribute("index", new s.THREE.InterleavedBufferAttribute(i,1,10,!1)),
                t.setAttribute("dashOffset", new s.THREE.InterleavedBufferAttribute(i,1,11,!1)),
                t.setIndex(new s.THREE.BufferAttribute(new Uint16Array(0),1))
            }
        }
        async __loadResources() {
            const t = this.getEntity().getScene().getEngine().getMaterialManager().getPreloaded("trail");
            this.getThreeJsMaterials().push(t),
            t.uniforms.dashLength.value = this._dashLength,
            t.uniforms.dashGapLength.value = this._dashGapLength,
            t.uniforms.indexStart.value = 0,
            t.uniforms.indexCount.value = 0,
            t.uniforms.indexLength.value = 0;
            t.uniforms.color.value.set(this._color.r, this._color.g, this._color.b, this._color.a),
            t.uniforms.widthMin.value = this._widthMin,
            t.uniforms.widthMax.value = this._widthMax,
            t.uniforms.glowWidth.value = this._glowWidth,
            t.uniforms.alphaFade.value = this._alphaFade;
            const e = s.ThreeJsHelper.createMeshObject(this, t, [{
                name: "position",
                dimensions: 3
            }, {
                name: "positionPrev",
                dimensions: 3
            }, {
                name: "positionNext",
                dimensions: 3
            }, {
                name: "side",
                dimensions: 1
            }, {
                name: "index",
                dimensions: 1
            }, {
                name: "dashOffset",
                dimensions: 1
            }], !0);
            this.getThreeJsObjects().push(e)
        }
        __unloadResources() {
            this.getEntity().getScene().getEngine().getMaterialManager().release(this.getThreeJsMaterials()[0]),
            s.ThreeJsHelper.destroyAllObjectsAndMaterials(this),
            this._points = [],
            this._pointsCount = 0,
            this._pointsStart = 0
        }
        __prepareForRender(t) {
            const e = this.getEntity().getParent();
            if ("" === this._relativeToEntity.getName() && null !== e && this._currentRelativeToEntity.get() !== this.getEntity().getParent() && (this._currentRelativeToEntity.setName(e.getName()),
            this.resetPoints()),
            null === this._currentRelativeToEntity)
                return;
            this._updatePoints();
            const i = this.getThreeJsMaterials()[0];
            i.uniforms.indexStart.value = this._pointsStart,
            i.uniforms.indexCount.value = this._pointsCount,
            i.uniforms.indexLength.value = this._points.length;
            let n = 1;
            if (!this._ignoreDistance) {
                n *= (.02 - this.getEntity().getNormalSpaceExtentsRadius(t)) / .02;
                const e = this.getEntity().getCameraSpacePosition(t).magnitude() / this.getEntity().getPosition().magnitude();
                n *= s.MathUtils.clamp01(1e3 * e)
            }
            s.ThreeJsHelper.setUniformNumber(i, "alphaMultiplier", n);
            const o = s.Vector2.pool.get();
            if (t instanceof s.SpoutComponent)
                o.set(.1 * t.getRenderWidth(), .5 * t.getRenderWidth() * .1);
            else {
                const e = t.getViewport();
                e && o.copy(e.getBounds().size)
            }
            s.ThreeJsHelper.setUniformVector2(i, "viewportSize", o),
            s.Vector2.pool.release(o);
            const a = this._currentRelativeToEntity.get();
            null !== a && (s.ThreeJsHelper.setPosition(this.getThreeJsObjects(), a.getCameraSpacePosition(t)),
            this._relativeToEntityOrientation && s.ThreeJsHelper.setOrientation(this.getThreeJsObjects(), a.getOrientation()))
        }
        _updatePoints() {
            const t = s.Interval.pool.get();
            if (this._getIntervalForUpdate(t),
            isNaN(t.min) || isNaN(t.max))
                return void s.Interval.pool.release(t);
            const e = this._initialTimeStep ?? t.length() * this._angleCurveThreshold / (2 * Math.PI)
              , i = s.Interval.pool.get();
            for (i.set(Number.POSITIVE_INFINITY, 0),
            this._relativeStartTime && this._pointsCount > 0 && this._points[this._pointsStart].time !== t.min && this._popFrontPoint(i); this._pointsCount > 0 && this._points[this._pointsStart].time < t.min; )
                this._popFrontPoint(i);
            let n = 0;
            for (; (0 === this._pointsCount || this._points[this._pointsStart].time > t.min) && !(this._pointsCount >= 16e3 && this._relativeStartTime); ) {
                this._pushFrontPoint(i);
                const s = this._points[this._pointsStart];
                let o = 1
                  , a = Number.POSITIVE_INFINITY
                  , r = e;
                this._pointsCount > 2 && (r = this._points[(this._pointsStart + 2) % this._points.length].time - this._points[(this._pointsStart + 1) % this._points.length].time);
                let l = 0;
                for (; l < 20; ) {
                    let i = t.max;
                    if (this._pointsCount > 1 && (i = this._points[(this._pointsStart + 1) % this._points.length].time - r),
                    i < t.min && (i = t.min),
                    s.time = i,
                    this._getPositionAndVelocity(s.position, s.velocity, s.time),
                    s.position.isNaN())
                        break;
                    let n = 0;
                    if (this._pointsCount >= 2 && (n = this._points[(this._pointsStart + 1) % this._points.length].position.distance(s.position) < .001 ? Number.NaN : this._points[(this._pointsStart + 1) % this._points.length].velocity.angle(s.velocity)),
                    n > this._angleCurveThreshold)
                        a = r,
                        r = (o + r) / 2;
                    else {
                        if (!(this._pointsCount > 1 && r < 10 * e && (isNaN(n) || n < this._angleCurveThreshold / 3) && i !== t.min))
                            break;
                        o = r,
                        a === Number.POSITIVE_INFINITY ? r *= 2 : r = (r + a) / 2
                    }
                    l++
                }
                if (s.position.isNaN()) {
                    this._popFrontPoint(i);
                    break
                }
                if (n++,
                n >= 4)
                    break
            }
            for (this._relativeEndTime && this._pointsCount > 0 && this._points[(this._pointsStart + this._pointsCount - 1) % this._points.length].time !== t.max && this._popBackPoint(i); this._pointsCount > 0 && this._points[(this._pointsStart + this._pointsCount - 1) % this._points.length].time > t.max; )
                this._popBackPoint(i);
            for (n = 0; (0 === this._pointsCount || this._points[(this._pointsStart + this._pointsCount - 1) % this._points.length].time < t.max) && !(this._pointsCount >= 16e3 && this._relativeEndTime); ) {
                this._pushBackPoint(i);
                const s = this._points[(this._pointsStart + this._pointsCount - 1) % this._points.length];
                let o = 1
                  , a = Number.POSITIVE_INFINITY
                  , r = e;
                this._pointsCount > 2 && (r = this._points[(this._pointsStart + this._pointsCount - 2) % this._points.length].time - this._points[(this._pointsStart + this._pointsCount - 3) % this._points.length].time);
                let l = 0;
                for (; l < 20; ) {
                    let i = t.min;
                    if (this._pointsCount > 1 && (i = this._points[(this._pointsStart + this._pointsCount - 2) % this._points.length].time + r),
                    i > t.max && (i = t.max),
                    s.time = i,
                    this._getPositionAndVelocity(s.position, s.velocity, s.time),
                    s.position.isNaN())
                        break;
                    let n = 0;
                    if (this._pointsCount >= 2 && (n = this._points[(this._pointsStart + this._pointsCount - 2) % this._points.length].position.distance(s.position) < .001 ? Number.NaN : this._points[(this._pointsStart + this._pointsCount - 2) % this._points.length].velocity.angle(s.velocity)),
                    n > this._angleCurveThreshold)
                        a = r,
                        r = (o + r) / 2;
                    else {
                        if (!(this._pointsCount > 1 && r < 10 * e && (isNaN(n) || n < this._angleCurveThreshold / 3) && i !== t.max))
                            break;
                        o = r,
                        a === Number.POSITIVE_INFINITY ? r *= 2 : r = (r + a) / 2
                    }
                    l++
                }
                if (s.position.isNaN()) {
                    this._popBackPoint(i);
                    break
                }
                if (n++,
                n >= 4)
                    break
            }
            if (s.Interval.pool.release(t),
            this._updatePointPositions && this._pointsCount > 0)
                for (let t = 0, e = Math.min(this._pointsCount, 5); t < e; t++) {
                    this._updatePointPositionsLastIndex = (this._updatePointPositionsLastIndex + 1) % this._pointsCount;
                    const t = (this._pointsStart + this._updatePointPositionsLastIndex) % this._points.length
                      , e = this._points[t]
                      , n = s.Vector3.pool.get()
                      , o = s.Vector3.pool.get();
                    this._getPositionAndVelocity(n, o, e.time),
                    n.isNaN() || e.position.copy(n),
                    o.isNaN() || e.velocity.copy(o),
                    s.Vector3.pool.release(n),
                    s.Vector3.pool.release(o),
                    i.expandTo(t)
                }
            const o = this.getThreeJsObjects()[0].geometry.attributes.positionCurr.data
              , a = o.array;
            for (let t = i.min, e = Math.min(this._points.length - 1, i.max); t <= e; t++) {
                const e = this._points[t].position
                  , i = isNaN(this._points[(t + this._points.length - 1) % this._points.length].position.x) ? e : this._points[(t + this._points.length - 1) % this._points.length].position
                  , s = isNaN(this._points[(t + 1) % this._points.length].position.x) ? e : this._points[(t + 1) % this._points.length].position;
                a[2 * t * TrailComponent.VERTEX_SIZE + 0] = e.x,
                a[2 * t * TrailComponent.VERTEX_SIZE + 1] = e.y,
                a[2 * t * TrailComponent.VERTEX_SIZE + 2] = e.z,
                a[(2 * t + 1) * TrailComponent.VERTEX_SIZE + 0] = e.x,
                a[(2 * t + 1) * TrailComponent.VERTEX_SIZE + 1] = e.y,
                a[(2 * t + 1) * TrailComponent.VERTEX_SIZE + 2] = e.z,
                a[2 * t * TrailComponent.VERTEX_SIZE + 3] = i.x,
                a[2 * t * TrailComponent.VERTEX_SIZE + 4] = i.y,
                a[2 * t * TrailComponent.VERTEX_SIZE + 5] = i.z,
                a[(2 * t + 1) * TrailComponent.VERTEX_SIZE + 3] = i.x,
                a[(2 * t + 1) * TrailComponent.VERTEX_SIZE + 4] = i.y,
                a[(2 * t + 1) * TrailComponent.VERTEX_SIZE + 5] = i.z,
                a[2 * t * TrailComponent.VERTEX_SIZE + 6] = s.x,
                a[2 * t * TrailComponent.VERTEX_SIZE + 7] = s.y,
                a[2 * t * TrailComponent.VERTEX_SIZE + 8] = s.z,
                a[(2 * t + 1) * TrailComponent.VERTEX_SIZE + 6] = s.x,
                a[(2 * t + 1) * TrailComponent.VERTEX_SIZE + 7] = s.y,
                a[(2 * t + 1) * TrailComponent.VERTEX_SIZE + 8] = s.z,
                a[2 * t * TrailComponent.VERTEX_SIZE + 9] = 1,
                a[(2 * t + 1) * TrailComponent.VERTEX_SIZE + 9] = -1,
                a[2 * t * TrailComponent.VERTEX_SIZE + 10] = t,
                a[(2 * t + 1) * TrailComponent.VERTEX_SIZE + 10] = t,
                a[2 * t * TrailComponent.VERTEX_SIZE + 11] = this._points[t].time - this._dashOffsetTime,
                a[(2 * t + 1) * TrailComponent.VERTEX_SIZE + 11] = this._points[t].time - this._dashOffsetTime
            }
            o.needsUpdate = !0,
            o.clearUpdateRanges(),
            i.min <= i.max && o.addUpdateRange(2 * i.min * TrailComponent.VERTEX_SIZE, 2 * (i.length() + 1) * TrailComponent.VERTEX_SIZE),
            s.Interval.pool.release(i)
        }
        _getIntervalForUpdate(t) {
            const e = this._relativeStartTime || this._relativeEndTime ? this.getEntity().getScene().getEngine().getTime() : void 0;
            this._relativeStartTime && void 0 !== e ? void 0 !== this._startTime ? t.min = e - this._startTimeMultiplier * this._startTime : t.min = e - this._startTimeMultiplier * this._getAutoLength(e) : t.min = this._startTime ?? NaN,
            this._relativeEndTime && void 0 !== e ? void 0 !== this._endTime ? t.max = e + this._endTimeMultiplier * this._endTime : t.max = e + this._endTimeMultiplier * this._getAutoLength(e) : t.max = this._endTime ?? NaN,
            t.intersection(t, this.getEntity().getPositionCoverage())
        }
        _popFrontPoint(t) {
            this._pointsCount > 0 && (this._resize(this._pointsCount - 1, t),
            t.expandTo(this._pointsStart),
            this._pointsCount > 1 && t.expandTo((this._pointsStart + 1) % this._points.length),
            this._points[this._pointsStart].position.x = NaN,
            this._pointsStart = (this._pointsStart + 1) % this._points.length,
            this._pointsCount -= 1)
        }
        _popBackPoint(t) {
            this._pointsCount > 0 && (this._resize(this._pointsCount - 1, t),
            this._pointsCount -= 1,
            t.expandTo((this._pointsStart + this._pointsCount) % this._points.length),
            this._pointsCount > 0 && t.expandTo((this._pointsStart + this._pointsCount - 1) % this._points.length),
            this._points[(this._pointsStart + this._pointsCount) % this._points.length].position.x = NaN)
        }
        _pushFrontPoint(t) {
            this._resize(this._pointsCount + 1, t),
            this._pointsStart = (this._pointsStart + this._points.length - 1) % this._points.length,
            t.expandTo(this._pointsStart),
            this._pointsCount > 0 && t.expandTo((this._pointsStart + 1) % this._points.length),
            this._pointsCount += 1
        }
        _pushBackPoint(t) {
            this._resize(this._pointsCount + 1, t),
            this._pointsCount += 1,
            t.expandTo((this._pointsStart + this._pointsCount - 1) % this._points.length),
            this._pointsCount > 1 && t.expandTo((this._pointsStart + this._pointsCount - 2) % this._points.length)
        }
        _resize(t, e) {
            let i = !1;
            if ((t + 1 > this._points.length || t <= this._points.length / 4 && t >= 8) && (i = !0),
            i) {
                const i = Math.max(8, s.MathUtils.ceilPow2(t + 1))
                  , n = [];
                for (let t = 0, e = this._pointsCount; t < e; t++)
                    n.push(this._points[(this._pointsStart + t) % this._points.length]);
                this._pointsStart = 0;
                for (let t = this._pointsCount, e = i; t < e; t++) {
                    const t = new Point;
                    t.position.x = Number.NaN,
                    n.push(t)
                }
                this._points = n;
                const o = this.getThreeJsObjects()[0].geometry
                  , a = new Float32Array(2 * this._points.length * TrailComponent.VERTEX_SIZE)
                  , r = new s.THREE.InterleavedBuffer(a,TrailComponent.VERTEX_SIZE);
                o.setAttribute("positionCurr", new s.THREE.InterleavedBufferAttribute(r,3,0,!1)),
                o.setAttribute("positionPrev", new s.THREE.InterleavedBufferAttribute(r,3,3,!1)),
                o.setAttribute("positionNext", new s.THREE.InterleavedBufferAttribute(r,3,6,!1)),
                o.setAttribute("side", new s.THREE.InterleavedBufferAttribute(r,1,9,!1)),
                o.setAttribute("index", new s.THREE.InterleavedBufferAttribute(r,1,10,!1)),
                o.setAttribute("dashOffset", new s.THREE.InterleavedBufferAttribute(r,1,11,!1));
                const l = new Uint16Array(6 * this._points.length);
                for (let t = 0; t < this._points.length; t++)
                    l[6 * t + 0] = (2 * t + 0) % (2 * this._points.length),
                    l[6 * t + 1] = (2 * t + 2) % (2 * this._points.length),
                    l[6 * t + 2] = (2 * t + 3) % (2 * this._points.length),
                    l[6 * t + 3] = (2 * t + 3) % (2 * this._points.length),
                    l[6 * t + 4] = (2 * t + 1) % (2 * this._points.length),
                    l[6 * t + 5] = (2 * t + 0) % (2 * this._points.length);
                o.setIndex(new s.THREE.BufferAttribute(l,1)),
                this._dashOffsetTime = this._points[this._pointsStart].time,
                e.min = 0,
                e.max = i
            }
        }
        _getAutoLength(t) {
            let e = null;
            for (let i = 0; ; i++) {
                const n = this.getEntity().getController(s.DynamoController, i);
                if (null === n)
                    break;
                "orb" === n.getPointType() && n.getCoverage().contains(t) && (e = n)
            }
            const i = s.Vector3.pool.get()
              , n = s.Vector3.pool.get();
            let o;
            if (this.getEntity().getPositionAtTime(i, t),
            this.getEntity().getVelocityAtTime(n, t),
            i.cross(i, n),
            null !== e) {
                const s = e.getEccentricity(t)
                  , n = e.getHeaderValue("gravitationalParameter1") + e.getHeaderValue("gravitationalParameter2")
                  , a = n * n / i.magnitudeSqr() * -.5 * (1 - s * s);
                o = 2 * Math.PI * n / Math.sqrt(8 * Math.abs(Math.min(1, a * a * a)))
            } else
                o = 2 * Math.PI * i.magnitude() / n.magnitudeSqr();
            return s.Vector3.pool.release(i),
            s.Vector3.pool.release(n),
            o
        }
        _getPositionAndVelocity(t, e, i) {
            const n = "" !== this._relativeToEntity.getName() ? this._relativeToEntity.get() : this.getEntity().getParent();
            if ("" === this._relativeToEntity.getName()) {
                this.getEntity().getPositionAtTime(t, i),
                this.getEntity().getVelocityAtTime(e, i);
                const n = this.getEntity().getParentAtTime(i)
                  , o = this._currentRelativeToEntity.get();
                if (null !== o && "" !== n && n !== o.getName()) {
                    const a = this.getEntity().getScene().getEntity(n);
                    null !== a ? (a.getPositionRelativeToEntity(t, t, o, i),
                    a.getVelocityRelativeToEntity(e, e, o, i)) : (t.copy(s.Vector3.NaN),
                    e.copy(s.Vector3.NaN))
                }
            } else
                null !== n ? (this.getEntity().getPositionRelativeToEntity(t, s.Vector3.Zero, n, i),
                this.getEntity().getVelocityRelativeToEntity(e, s.Vector3.Zero, n, i)) : (t.copy(s.Vector3.NaN),
                e.copy(s.Vector3.NaN));
            if (this._relativeToEntityOrientation && null !== n) {
                const o = s.Quaternion.pool.get();
                n.getOrientationAtTime(o, i),
                t.rotateInverse(o, t),
                e.rotateInverse(o, e),
                s.Quaternion.pool.release(o)
            }
        }
        static VERTEX_SIZE = 12
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        BaseController: function() {
            return BaseController
        }
    });
    var s = i(6);
    class BaseController extends s.EntityItem {
        constructor(t, e) {
            super(t, e),
            this._coverage = new s.Interval(Number.NEGATIVE_INFINITY,Number.POSITIVE_INFINITY),
            this._coverage.freeze(),
            this._modifiedStates = new Set,
            this._dependentStates = new Set,
            this.getEntity().getScene().getControllerDependencyGraph().addItem(this)
        }
        __destroy() {
            this.getEntity().getScene().getControllerDependencyGraph().removeItem(this),
            super.__destroy()
        }
        addModifiedState(t) {
            this._modifiedStates.has(t) || (this._modifiedStates.add(t),
            this.getEntity().getScene().getControllerDependencyGraph().needsSorting(),
            "position" !== t && "orientation" !== t || this.getEntity().__updateCoverage())
        }
        removeModifiedState(t) {
            this._modifiedStates.delete(t) && (this.getEntity().getScene().getControllerDependencyGraph().needsSorting(),
            "position" !== t && "orientation" !== t || this.getEntity().__updateCoverage())
        }
        hasModifiedState(t) {
            return this._modifiedStates.has(t)
        }
        addDependentState(t, e) {
            this._dependentStates.has(`${t}.${e}`) || (this._dependentStates.add(`${t}.${e}`),
            this.getEntity().getScene().getControllerDependencyGraph().needsSorting())
        }
        removeDependentState(t, e) {
            this._dependentStates.delete(`${t}.${e}`) && this.getEntity().getScene().getControllerDependencyGraph().needsSorting()
        }
        hasDependentState(t, e) {
            return this._dependentStates.has(`${t}.${e}`)
        }
        __getModifiedStates() {
            return this._modifiedStates
        }
        getCoverage() {
            return this._coverage
        }
        setCoverage(t) {
            this._coverage.thaw(),
            this._coverage.copy(t),
            this._coverage.freeze(),
            this.getEntity().__updateCoverage()
        }
        __updatePositionAtTime(t, e) {}
        __updateVelocityAtTime(t, e) {}
        __updateOrientationAtTime(t, e) {}
        toString() {
            let t = 0;
            for (let e = 0, i = this.getEntity().getNumControllers(); e < i; e++) {
                const i = this.getEntity().getControllerAt(e);
                if (this === i)
                    break;
                this.constructor === i.constructor && (t += 1)
            }
            return `${this.getEntity().getName()}.${this.constructor.name}.${t}`
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        AlignController: function() {
            return AlignController
        }
    });
    var s = i(6);
    class AlignController extends s.BaseController {
        constructor(t, e) {
            super(t, e),
            this._primaryAlignType = "none",
            this._primaryAxis = new s.Vector3(1,0,0),
            this._primaryAxis.freeze(),
            this._primaryTargetEntity = new s.EntityRef(this.getEntity().getScene()),
            this._primaryTargetEntity.setRefChangedCallback(( (t, e) => {
                t && this._removeDependentStates(t, this._primaryAlignType),
                e && this._addDependentStates(e, this._primaryAlignType)
            }
            )),
            this._primaryTargetAxis = new s.Vector3(1,0,0),
            this._primaryTargetAxis.freeze(),
            this._secondaryAlignType = "none",
            this._secondaryAxis = new s.Vector3(0,1,0),
            this._secondaryAxis.freeze(),
            this._secondaryTargetEntity = new s.EntityRef(this.getEntity().getScene()),
            this._secondaryTargetEntity.setRefChangedCallback(( (t, e) => {
                t && this._removeDependentStates(t, this._secondaryAlignType),
                e && this._addDependentStates(e, this._secondaryAlignType)
            }
            )),
            this._secondaryTargetAxis = new s.Vector3(0,1,0),
            this._secondaryTargetAxis.freeze(),
            this._joint = "",
            this._jointObject = null,
            this._model = null,
            this._modelRootId = 0,
            this.addModifiedState("orientation")
        }
        getPrimaryAlignType() {
            return this._primaryAlignType
        }
        setPrimaryAlignType(t) {
            if (this._primaryAlignType === t)
                return;
            const e = this._primaryTargetEntity.get();
            e && this._removeDependentStates(e, this._primaryAlignType),
            this._primaryAlignType = t,
            e && this._addDependentStates(e, this._primaryAlignType)
        }
        getPrimaryAxis() {
            return this._primaryAxis
        }
        setPrimaryAxis(t) {
            this._primaryAxis.thaw(),
            this._primaryAxis.copy(t),
            this._primaryAxis.freeze()
        }
        getPrimaryTargetEntity() {
            return this._primaryTargetEntity.getName()
        }
        setPrimaryTargetEntity(t) {
            this._primaryTargetEntity.setName(t)
        }
        getPrimaryTargetAxis() {
            return this._primaryTargetAxis
        }
        setPrimaryTargetAxis(t) {
            this._primaryTargetAxis.thaw(),
            this._primaryTargetAxis.copy(t),
            this._primaryTargetAxis.freeze()
        }
        getSecondaryAlignType() {
            return this._secondaryAlignType
        }
        setSecondaryAlignType(t) {
            if (this._secondaryAlignType === t)
                return;
            const e = this._secondaryTargetEntity.get();
            e && this._removeDependentStates(e, this._secondaryAlignType),
            this._secondaryAlignType = t,
            e && this._addDependentStates(e, this._secondaryAlignType)
        }
        getSecondaryAxis() {
            return this._secondaryAxis
        }
        setSecondaryAxis(t) {
            this._secondaryAxis.thaw(),
            this._secondaryAxis.copy(t),
            this._secondaryAxis.freeze()
        }
        getSecondaryTargetEntity() {
            return this._secondaryTargetEntity.getName()
        }
        setSecondaryTargetEntity(t) {
            this._secondaryTargetEntity.setName(t)
        }
        getSecondaryTargetAxis() {
            return this._secondaryTargetAxis
        }
        setSecondaryTargetAxis(t) {
            this._secondaryTargetAxis.thaw(),
            this._secondaryTargetAxis.copy(t),
            this._secondaryTargetAxis.freeze()
        }
        setJoint(t, e) {
            if (this._joint = t,
            e)
                this._model = e;
            else {
                const t = this.getEntity().getComponent(s.ModelComponent);
                null !== t && (this._model = t)
            }
            "" !== this._joint ? (this.addDependentState(this.getEntity().getName(), "orientation"),
            this.removeModifiedState("orientation")) : (this.removeDependentState(this.getEntity().getName(), "orientation"),
            this.addModifiedState("orientation"))
        }
        __updateOrientationAtTime(t, e) {
            "" === this._joint && this._getOrientation(t, e)
        }
        __update() {
            const t = s.Quaternion.pool.get();
            t.copy(this.getEntity().getOrientation()),
            this._getOrientation(t),
            t.isNaN() || (null !== this._jointObject ? this._jointObject.quaternion.set(t.x, t.y, t.z, t.w) : this.getEntity().setOrientation(t)),
            s.Quaternion.pool.release(t)
        }
        _getOrientation(t, e) {
            if ("" !== this._joint && null !== this._model) {
                const t = this._model.getThreeJsObjects()[0];
                if (void 0 !== t && (null === this._jointObject || this._jointObject.name !== this._joint || t.id !== this._modelRootId)) {
                    const e = this._model.getThreeJsObjectByName(this._joint);
                    null !== e && (this._jointObject = e,
                    this._modelRootId = t.id)
                }
                if (null === this._jointObject)
                    return
            }
            const i = s.Vector3.pool.get()
              , n = s.Quaternion.pool.get();
            if (null !== this._jointObject && null !== this._model) {
                let e = this._jointObject;
                const i = s.Quaternion.threeJsPool.get();
                for (i.set(0, 0, 0, 1); null !== e.parent && e.parent !== this._model.getThreeJsObjects()[0]; )
                    e = e.parent,
                    i.multiplyQuaternions(e.quaternion, i);
                n.copyFromThreeJs(i),
                s.Quaternion.threeJsPool.release(i),
                n.mult(this._model.getRotation(), n),
                n.mult(t, n)
            } else
                n.copy(t);
            n.isNaN() && n.copy(s.Quaternion.Identity),
            i.rotate(n, this._primaryAxis);
            const o = s.Vector3.pool.get();
            if (this._getAxis(o, this._primaryAlignType, this._primaryTargetEntity, this._primaryTargetAxis, i, e),
            o.isNaN())
                return t.copy(s.Quaternion.NaN),
                s.Vector3.pool.release(o),
                s.Vector3.pool.release(i),
                void s.Quaternion.pool.release(n);
            const a = s.Quaternion.pool.get();
            if (a.setFromVectorFromTo(i, o),
            t.mult(a, n),
            t.isNaN() && t.copy(s.Quaternion.Identity),
            s.Quaternion.pool.release(a),
            "none" !== this._secondaryAlignType && null !== this._secondaryTargetEntity) {
                if (this._getAxis(o, this._secondaryAlignType, this._secondaryTargetEntity, this._secondaryTargetAxis, i, e),
                o.isNaN())
                    return t.copy(s.Quaternion.NaN),
                    s.Vector3.pool.release(o),
                    s.Vector3.pool.release(i),
                    void s.Quaternion.pool.release(n);
                const a = s.Quaternion.pool.get()
                  , r = s.Vector3.pool.get()
                  , l = s.Vector3.pool.get();
                r.rotate(t, this._primaryAxis),
                l.rotate(t, this._secondaryAxis);
                const c = l.angleAroundAxis(o, r);
                a.setFromAxisAngle(r, c),
                t.mult(a, t),
                s.Quaternion.pool.release(a),
                s.Vector3.pool.release(r),
                s.Vector3.pool.release(l)
            }
            t.normalize(t),
            null !== this._jointObject && t.multInverseL(n, t),
            s.Quaternion.pool.release(n),
            s.Vector3.pool.release(i),
            s.Vector3.pool.release(o)
        }
        _getAxis(t, e, i, n, o, a) {
            const r = i.get();
            if ("align" === e) {
                if (null === r)
                    return void t.copy(s.Vector3.NaN);
                const e = s.Quaternion.pool.get();
                r.getOrientationAtTime(e, a),
                t.rotate(e, n),
                s.Quaternion.pool.release(e)
            } else if ("velocity" === e) {
                if (null === r)
                    return void t.copy(s.Vector3.NaN);
                r.getVelocityAtTime(t, a),
                t.normalize(t)
            } else if ("point" === e) {
                if (null === r)
                    return void t.copy(s.Vector3.NaN);
                r.getPositionRelativeToEntity(t, s.Vector3.Zero, this.getEntity(), a),
                t.normalize(t)
            } else if ("position" === e) {
                if (null === r)
                    return void t.copy(s.Vector3.NaN);
                t.normalize(r.getPosition())
            } else
                t.copy(o)
        }
        _removeDependentStates(t, e) {
            "align" === e ? this.removeDependentState(t.getName(), "orientation") : "velocity" === e ? this.removeDependentState(t.getName(), "velocity") : "point" === e ? (this.removeDependentState(this.getEntity().getName(), "position"),
            this.removeDependentState(t.getName(), "position")) : "position" === e && this.removeDependentState(t.getName(), "position")
        }
        _addDependentStates(t, e) {
            "align" === e ? this.addDependentState(t.getName(), "orientation") : "velocity" === e ? this.addDependentState(t.getName(), "velocity") : "point" === e ? (this.addDependentState(this.getEntity().getName(), "position"),
            this.addDependentState(t.getName(), "position")) : "position" === e && this.addDependentState(t.getName(), "position")
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        AnimdataController: function() {
            return AnimdataController
        }
    });
    var s = i(6);
    class State {
        read(t) {}
        interpolate(t, e, i, s) {}
        static eclipJ2000ToJ200Rotation = new s.Quaternion(.9791532214288992,.2031230389823101,0,0)
    }
    class PosState extends State {
        constructor() {
            super(),
            this.position = new s.Vector3,
            this.velocity = new s.Vector3
        }
        read(t) {
            this.position.y = -t.readFloat64(),
            this.position.z = t.readFloat64(),
            this.position.x = t.readFloat64(),
            this.velocity.y = -t.readFloat64(),
            this.velocity.z = t.readFloat64(),
            this.velocity.x = t.readFloat64(),
            this.position.rotate(State.eclipJ2000ToJ200Rotation, this.position),
            this.velocity.rotate(State.eclipJ2000ToJ200Rotation, this.velocity)
        }
        interpolate(t, e, i, s) {
            const n = 1 - s
              , o = n * n
              , a = s * s
              , r = (1 + 2 * s) * o
              , l = s * o
              , c = a * (3 - 2 * s)
              , h = a * -n;
            this.position.mult(t.position, r),
            this.position.addMult(this.position, t.velocity, i * l),
            this.position.addMult(this.position, e.position, c),
            this.position.addMult(this.position, e.velocity, i * h);
            const d = 6 * (a - s)
              , u = d
              , p = 3 * a - 4 * s + 1
              , m = -d
              , _ = 3 * a - 2 * s;
            this.velocity.mult(t.position, u / i),
            this.velocity.addMult(this.velocity, t.velocity, p),
            this.velocity.addMult(this.velocity, e.position, m / i),
            this.velocity.addMult(this.velocity, e.velocity, _)
        }
    }
    class OriState extends State {
        constructor() {
            super(),
            this.orientation = new s.Quaternion
        }
        read(t) {
            this.orientation.y = t.readFloat32(),
            this.orientation.z = -t.readFloat32(),
            this.orientation.x = -t.readFloat32(),
            this.orientation.w = t.readFloat32(),
            this.orientation.mult(State.eclipJ2000ToJ200Rotation, this.orientation)
        }
        interpolate(t, e, i, s) {
            this.orientation.slerp(t.orientation, e.orientation, s)
        }
    }
    class DataPoint {
        constructor(t) {
            this.interval = new s.Interval,
            this.state = t.__getNewState()
        }
        read(t) {
            this.interval.min = t.readFloat64(),
            this.interval.max = t.readFloat64(),
            this.state.read(t)
        }
    }
    class AnimdataFile {
        constructor(t, e, i) {
            this.interval = new s.Interval,
            this.dataPoints = [];
            const n = `${t.getUrl()}/${t.getStateType()}_data/${`00${e}`.slice(-3)}.${`000${i + 1}`.slice(-4)}.animdata`;
            this.promise = t.getEntity().getScene().getEngine().getDownloader().download(n, "binary", -t.getEntity().getLeastCameraDepth()).then((async e => {
                if ("cancelled" === e.status)
                    return Promise.resolve();
                if ("failed" === e.status)
                    return Promise.reject(new Error(`Failed to load animdata controller file "${e.url}": ${e.errorMessage}`));
                if (!(e.content instanceof ArrayBuffer))
                    return Promise.reject(new Error(`Failed to load animdata controller file "${e.url}": Not a binary file.`));
                const i = new s.Reader(e.content);
                this.interval.min = i.readFloat64(),
                this.interval.max = i.readFloat64();
                const n = i.readInt32();
                for (let e = 0; e < n; e++) {
                    const e = new DataPoint(t);
                    e.read(i),
                    this.dataPoints.push(e)
                }
                return Promise.resolve()
            }
            ))
        }
    }
    class FileOverlap {
        constructor() {
            this.fileIndex = 0,
            this.interval = new s.Interval
        }
    }
    class BucketOverlap {
        constructor() {
            this.fileIndex = 0,
            this.dataPointIndices = []
        }
    }
    class Bucket {
        constructor() {
            this.bucketOverlaps = []
        }
    }
    class AniminfoFile {
        constructor(t, e, i) {
            this.fileOverlaps = new Map,
            this.buckets = [];
            const n = `${t.getUrl()}/${t.getStateType()}_info/${`00${e}`.slice(-3)}.${`000${i}`.slice(-4)}.animinfo`;
            this.promise = t.getEntity().getScene().getEngine().getDownloader().download(n, "binary", -t.getEntity().getLeastCameraDepth()).then((async t => {
                if ("cancelled" === t.status)
                    return Promise.resolve();
                if ("failed" === t.status)
                    return Promise.reject(new Error(`Failed to load animdata controller file "${t.url}": ${t.errorMessage}`));
                if (!(t.content instanceof ArrayBuffer))
                    return Promise.reject(new Error(`Failed to load animdata controller file "${t.url}": Not a binary file.`));
                const e = new s.Reader(t.content)
                  , i = e.readInt16();
                for (let t = 0; t < i; t++) {
                    const t = new FileOverlap;
                    t.fileIndex = e.readInt16(),
                    t.interval.min = e.readFloat64(),
                    t.interval.max = e.readFloat64(),
                    this.fileOverlaps.set(t.fileIndex, t)
                }
                const n = e.readInt16();
                for (let t = 0; t < n; t++) {
                    const t = new Bucket
                      , i = e.readInt16();
                    for (let s = 0; s < i; s++) {
                        const i = new BucketOverlap;
                        i.fileIndex = e.readInt16();
                        const s = e.readInt16();
                        for (let t = 0; t < s; t++)
                            i.dataPointIndices.push(e.readInt16());
                        t.bucketOverlaps.push(i)
                    }
                    this.buckets.push(t)
                }
                return Promise.resolve()
            }
            ))
        }
    }
    class Coverage {
        constructor() {
            this.interval = new s.Interval,
            this.numDataFiles = 0,
            this.numBuckets = 0,
            this.bucketStepSize = 0,
            this.numBucketsPerAniminfoFile = 0,
            this.animinfos = new Map,
            this.animdatas = new Map
        }
    }
    class AnimdefFile {
        constructor(t) {
            this.coverages = [];
            const e = `${t.getUrl()}/${t.getStateType()}.animdef`;
            this.promise = t.getEntity().getScene().getEngine().getDownloader().download(e, "binary", -t.getEntity().getLeastCameraDepth()).then((async e => {
                if ("cancelled" === e.status)
                    return Promise.resolve();
                if ("failed" === e.status)
                    return Promise.reject(new Error(`Failed to load animdata controller file "${e.url}": ${e.errorMessage}`));
                if (!(e.content instanceof ArrayBuffer))
                    return Promise.reject(new Error(`Failed to load animdata controller file "${e.url}": Not a binary file.`));
                const i = new s.Reader(e.content)
                  , n = i.readInt16();
                for (let t = 0; t < n; t++) {
                    const t = new Coverage;
                    t.interval.min = i.readFloat64(),
                    t.interval.max = i.readFloat64(),
                    t.numDataFiles = i.readInt16(),
                    t.numBuckets = i.readInt32(),
                    t.bucketStepSize = i.readFloat64(),
                    t.numBucketsPerAniminfoFile = i.readInt16(),
                    this.coverages.push(t)
                }
                return t.__updateCoverage(),
                Promise.resolve()
            }
            ))
        }
    }
    class AnimdataController extends s.BaseController {
        constructor(t, e) {
            super(t, e),
            this._baseUrl = "",
            this._stateType = "pos",
            this._animdef = null,
            this._currentDataPoint = null,
            this._tempDataPoint = new DataPoint(this),
            this._engine = this.getEntity().getScene().getEngine(),
            this._forcedCoverage = new s.Interval(Number.NEGATIVE_INFINITY,Number.POSITIVE_INFINITY),
            super.setCoverage(new s.Interval(NaN,NaN))
        }
        getUrl() {
            return this._baseUrl
        }
        getStateType() {
            return this._stateType
        }
        setBaseUrlAndStateType(t, e) {
            this._baseUrl = t,
            this._stateType = e,
            this._currentDataPoint = new DataPoint(this),
            this._tempDataPoint = new DataPoint(this),
            this._animdef = new AnimdefFile(this),
            "pos" === this._stateType ? (this.addModifiedState("position"),
            this.addModifiedState("velocity")) : "ori" === this._stateType && this.addModifiedState("orientation")
        }
        setCoverage(t) {
            this._forcedCoverage.copy(t),
            this.__updateCoverage()
        }
        __updateCoverage() {
            const t = s.Interval.pool.get();
            if (null !== this._animdef && this._animdef.coverages.length > 0) {
                t.copy(this._animdef.coverages[0].interval);
                for (let e = 1; e < this._animdef.coverages.length; e++)
                    t.union(t, this._animdef.coverages[e].interval);
                t.intersection(t, this._forcedCoverage)
            } else
                t.set(NaN, NaN);
            super.setCoverage(t),
            s.Interval.pool.release(t)
        }
        __updatePositionAtTime(t, e) {
            if ("pos" === this._stateType) {
                const i = this._tempDataPoint.state;
                this._tempDataPoint.interval.min !== e ? this._getDataPointAtTime(this._tempDataPoint, e) && t.copy(i.position) : t.copy(i.position)
            }
        }
        __updateVelocityAtTime(t, e) {
            if ("pos" === this._stateType) {
                const i = this._tempDataPoint.state;
                this._tempDataPoint.interval.min !== e ? this._getDataPointAtTime(this._tempDataPoint, e) && t.copy(i.velocity) : t.copy(i.velocity)
            }
        }
        __updateOrientationAtTime(t, e) {
            if ("ori" === this._stateType) {
                const i = this._tempDataPoint.state;
                this._getDataPointAtTime(this._tempDataPoint, e) && t.copy(i.orientation)
            }
        }
        async downloadDataForInterval(t) {
            if (null === this._animdef)
                return;
            if (await this._animdef.promise,
            null === this._animdef)
                return;
            const e = [];
            for (let i = 0; i < this._animdef.coverages.length; i++) {
                const s = this._animdef.coverages[i];
                if (s.interval.intersects(t)) {
                    const n = Math.floor((Math.max(t.min, s.interval.min) - s.interval.min) / s.bucketStepSize / s.numBucketsPerAniminfoFile)
                      , o = Math.floor((Math.min(t.max, s.interval.max) - 1e-4 - s.interval.min) / s.bucketStepSize / s.numBucketsPerAniminfoFile);
                    for (let a = n; a <= o; a++) {
                        s.animinfos.has(a) || s.animinfos.set(a, new AniminfoFile(this,i,a));
                        const n = s.animinfos.get(a);
                        n && e.push(n.promise.then((async () => {
                            const e = [];
                            for (const o of n.fileOverlaps.values())
                                if (o.interval.intersects(t)) {
                                    const t = o.fileIndex;
                                    s.animdatas.has(t) || s.animdatas.set(t, new AnimdataFile(this,i,t));
                                    const n = s.animdatas.get(t);
                                    if (!n)
                                        continue;
                                    e.push(n.promise)
                                }
                            await Promise.all(e)
                        }
                        )))
                    }
                    break
                }
            }
            await Promise.allSettled(e)
        }
        __getNewState() {
            return "pos" === this._stateType ? new PosState : new OriState
        }
        __update() {
            if (null !== this._currentDataPoint && this._getDataPointAtTime(this._currentDataPoint, this._engine.getTime())) {
                if ("pos" === this._stateType) {
                    const t = this._currentDataPoint.state;
                    this.getEntity().setPosition(t.position),
                    this.getEntity().setVelocity(t.velocity)
                }
                if ("ori" === this._stateType) {
                    const t = this._currentDataPoint.state;
                    this.getEntity().setOrientation(t.orientation)
                }
            }
        }
        _getDataPointAtTime(t, e) {
            if (!this._animdef)
                return !1;
            for (let i = 0; i < this._animdef.coverages.length; i++) {
                const s = this._animdef.coverages[i];
                if (s.interval.contains(e)) {
                    const n = Math.floor((e - s.interval.min) / s.bucketStepSize / s.numBucketsPerAniminfoFile);
                    if (s.animinfos.has(n)) {
                        const o = s.animinfos.get(n);
                        if (!o)
                            return !1;
                        const a = Math.floor((e - s.interval.min) / s.bucketStepSize) - n * s.numBucketsPerAniminfoFile
                          , r = o.buckets[a];
                        if (void 0 === r)
                            return !1;
                        for (let n = 0; n < r.bucketOverlaps.length; n++) {
                            const a = r.bucketOverlaps[n]
                              , l = a.fileIndex
                              , c = o.fileOverlaps.get(l);
                            if (c && c.interval.contains(e)) {
                                if (s.animdatas.has(l)) {
                                    const i = s.animdatas.get(l);
                                    if (!i)
                                        return !1;
                                    for (let s = 0; s < a.dataPointIndices.length; s++) {
                                        const n = a.dataPointIndices[s]
                                          , o = i.dataPoints[n];
                                        if (void 0 === o)
                                            return !1;
                                        if (o.interval.contains(e)) {
                                            const s = (e - o.interval.min) / o.interval.length();
                                            return t.interval.min = e,
                                            t.interval.max = e,
                                            t.state.interpolate(o.state, i.dataPoints[n + 1].state, o.interval.length(), s),
                                            !0
                                        }
                                    }
                                    return !1
                                }
                                return s.animdatas.set(l, new AnimdataFile(this,i,l)),
                                !1
                            }
                        }
                        return !1
                    }
                    return s.animinfos.set(n, new AniminfoFile(this,i,n)),
                    !1
                }
            }
            return !1
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        CoverageController: function() {
            return CoverageController
        }
    });
    var s = i(6);
    class CoverageController extends s.BaseController {
        constructor(t, e) {
            super(t, e),
            this.coverage = new s.Interval,
            this.enterFunction = void 0,
            this.exitFunction = void 0,
            this.updateFunction = void 0,
            this.active = !1,
            this.lastUpdateTime = Number.NEGATIVE_INFINITY,
            this.updateInterval = 0
        }
        setCoverage(t) {
            this.coverage.copy(t)
        }
        setEnterFunction(t) {
            this.enterFunction = t
        }
        setExitFunction(t) {
            this.exitFunction = t
        }
        setUpdateFunction(t) {
            this.updateFunction = t
        }
        setUpdateInterval(t) {
            this.updateInterval = 1e3 * t
        }
        __update() {
            const t = this.getEntity().getScene().getEngine().getTime();
            if (0 === this.getClassIndex())
                for (let e = 0; ; e++) {
                    const i = this.getEntity().getController(CoverageController, e);
                    if (null === i)
                        break;
                    const s = i.coverage.contains(t);
                    i.active && !s && i.exitFunction && i.exitFunction(this.getEntity())
                }
            const e = this.coverage.contains(t);
            if (!this.active && e && this.enterFunction && this.enterFunction(this.getEntity()),
            e && this.updateFunction) {
                const t = Date.now();
                t - this.lastUpdateTime >= this.updateInterval && (this.lastUpdateTime = t,
                this.updateFunction(this.getEntity()))
            }
            this.active = e
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        DynamoController: function() {
            return DynamoController
        }
    });
    var s = i(6);
    class Point {
        constructor() {
            this.time = NaN
        }
        load(t) {
            this.time = t.readFloat64()
        }
        calculate(t, e, i, s) {}
        apply(t) {}
        setNaN(t) {}
        static readHeader(t) {
            return {}
        }
    }
    class PosPoint extends Point {
        constructor() {
            super(),
            this.position = new s.Vector3,
            this.velocity = new s.Vector3
        }
        load(t) {
            super.load(t),
            this.position = new s.Vector3(t.readFloat64(),t.readFloat64(),t.readFloat64()),
            this.velocity = new s.Vector3(t.readFloat64(),t.readFloat64(),t.readFloat64())
        }
        calculate(t, e, i, s) {
            this.time = e;
            const n = t[1].time - t[0].time
              , o = (e - t[0].time) / n
              , a = 1 - o
              , r = a * a
              , l = o * o
              , c = (1 + 2 * o) * r
              , h = o * r
              , d = l * (3 - 2 * o)
              , u = l * -a;
            this.position.mult(t[0].position, c),
            this.position.addMult(this.position, t[0].velocity, n * h),
            this.position.addMult(this.position, t[1].position, d),
            this.position.addMult(this.position, t[1].velocity, n * u);
            const p = 6 * (l - o)
              , m = p
              , _ = 3 * l - 4 * o + 1
              , g = -p
              , y = 3 * l - 2 * o;
            this.velocity.mult(t[0].position, m / n),
            this.velocity.addMult(this.velocity, t[0].velocity, _),
            this.velocity.addMult(this.velocity, t[1].position, g / n),
            this.velocity.addMult(this.velocity, t[1].velocity, y)
        }
        apply(t) {
            t.setPosition(this.position),
            t.setVelocity(this.velocity)
        }
        setNaN(t) {
            t.setPosition(s.Vector3.NaN),
            t.setVelocity(s.Vector3.NaN)
        }
        static readHeader(t) {
            return {}
        }
    }
    class LinPoint extends Point {
        constructor() {
            super(),
            this.position = new s.Vector3,
            this.velocity = new s.Vector3
        }
        load(t) {
            super.load(t),
            this.position.set(t.readFloat64(), t.readFloat64(), t.readFloat64()),
            this.velocity.copy(s.Vector3.Zero)
        }
        calculate(t, e, i, n) {
            if (this.time = e,
            t[1].time > t[0].time) {
                const i = s.MathUtils.clamp01((e - t[0].time) / (t[1].time - t[0].time));
                this.position.lerp(t[0].position, t[1].position, i),
                this.velocity.sub(t[1].position, t[0].position),
                this.velocity.div(this.velocity, t[1].time - t[0].time)
            } else
                this.position.copy(t[1].position),
                this.velocity.copy(s.Vector3.Zero)
        }
        apply(t) {
            t.setPosition(this.position),
            t.setVelocity(this.velocity)
        }
        setNaN(t) {
            t.setPosition(s.Vector3.NaN),
            t.setVelocity(s.Vector3.NaN)
        }
        static readHeader(t) {
            return {}
        }
    }
    class OriPoint extends Point {
        constructor() {
            super(),
            this.orientation = new s.Quaternion,
            this.angularVelocity = new s.Vector3
        }
        load(t) {
            super.load(t),
            this.orientation = new s.Quaternion(t.readFloat64(),t.readFloat64(),t.readFloat64(),t.readFloat64()),
            this.angularVelocity = new s.Vector3(t.readFloat64(),t.readFloat64(),t.readFloat64())
        }
        calculate(t, e, i, n) {
            this.time = e;
            const o = s.Quaternion.pool.get()
              , a = s.Quaternion.pool.get()
              , r = (e - t[0].time) / (t[1].time - t[0].time);
            t[0]._project(o, e, n),
            t[1]._project(a, e, n),
            this.orientation.slerp(o, a, r),
            s.Quaternion.pool.release(o),
            s.Quaternion.pool.release(a),
            this.angularVelocity.slerp(t[0].angularVelocity, t[1].angularVelocity, r),
            this.angularVelocity.neg(this.angularVelocity),
            this.angularVelocity.rotate(this.orientation, this.angularVelocity)
        }
        apply(t) {
            t.setOrientation(this.orientation),
            t.setAngularVelocity(this.angularVelocity)
        }
        _project(t, e, i) {
            const n = s.Vector3.pool.get()
              , o = s.Quaternion.pool.get();
            n.normalize(this.angularVelocity),
            o.setFromAxisAngle(n, this.angularVelocity.magnitude() * (e - this.time)),
            s.Vector3.pool.release(n),
            i ? (o.multInverseR(this.orientation, o),
            t.mult(t, o)) : t.multInverseR(this.orientation, o),
            s.Quaternion.pool.release(o)
        }
        setNaN(t) {
            t.setOrientation(s.Quaternion.NaN),
            t.setAngularVelocity(s.Vector3.NaN)
        }
        static readHeader(t) {
            return {}
        }
    }
    class QuatPoint extends Point {
        constructor() {
            super(),
            this.orientation = new s.Quaternion,
            this.angularVelocity = new s.Vector3
        }
        load(t) {
            super.load(t),
            this.orientation = new s.Quaternion(t.readFloat64(),t.readFloat64(),t.readFloat64(),t.readFloat64())
        }
        calculate(t, e, i, n) {
            this.time = e;
            const o = s.MathUtils.clamp01((e - t[0].time) / (t[1].time - t[0].time));
            this.orientation.slerp(t[0].orientation, t[1].orientation, o)
        }
        apply(t) {
            t.setOrientation(this.orientation),
            t.setAngularVelocity(s.Vector3.Zero)
        }
        setNaN(t) {
            t.setOrientation(s.Quaternion.NaN),
            t.setAngularVelocity(s.Vector3.NaN)
        }
        static readHeader(t) {
            return {}
        }
    }
    class OrbPoint extends Point {
        constructor() {
            super(),
            this.oe = new s.OrbitalElements,
            this.oe.orbitOrientation.freeze(),
            this.position = new s.Vector3,
            this.velocity = new s.Vector3
        }
        load(t) {
            super.load(t),
            this.oe.epoch = this.time,
            this.oe.semiMajorAxis = t.readFloat64(),
            this.oe.eccentricity = t.readFloat64(),
            this.oe.meanAngularMotion = t.readFloat64(),
            this.oe.meanAnomalyAtEpoch = t.readFloat64(),
            this.oe.orbitOrientation.thaw(),
            this.oe.orbitOrientation.set(t.readFloat64(), t.readFloat64(), t.readFloat64(), t.readFloat64()),
            this.oe.orbitOrientation.freeze()
        }
        calculate(t, e, i, n) {
            this.time = e,
            this.oe.epoch = e;
            const o = s.Vector3.pool.get()
              , a = s.Vector3.pool.get()
              , r = s.Vector3.pool.get()
              , l = s.Vector3.pool.get()
              , c = s.MathUtils.clamp01((e - t[0].time) / (t[1].time - t[0].time));
            t[0]._project(o, r, e, i, n),
            t[1]._project(a, l, e, i, n),
            this.position.lerp(o, a, c),
            this.velocity.lerp(r, l, c),
            s.Vector3.pool.release(o),
            s.Vector3.pool.release(a),
            s.Vector3.pool.release(r),
            s.Vector3.pool.release(l)
        }
        apply(t) {
            t.setPosition(this.position),
            t.setVelocity(this.velocity)
        }
        _project(t, e, i, n, o) {
            const a = s.Vector3.pool.get()
              , r = s.Vector3.pool.get();
            this.oe.project(a, r, i);
            let l = 1;
            1 === n.body ? l = n.gravitationalParameter2 / (n.gravitationalParameter1 + n.gravitationalParameter2) : 2 === n.body && (l = -n.gravitationalParameter1 / (n.gravitationalParameter1 + n.gravitationalParameter2)),
            a.mult(a, l),
            r.mult(r, l),
            o ? t.add(a, t) : t.copy(a),
            e.copy(r),
            s.Vector3.pool.release(a),
            s.Vector3.pool.release(r)
        }
        setNaN(t) {
            t.setPosition(s.Vector3.NaN),
            t.setVelocity(s.Vector3.NaN)
        }
        static readHeader(t) {
            return {
                gravitationalParameter1: t.readFloat64(),
                gravitationalParameter2: t.readFloat64()
            }
        }
    }
    class PointSet {
        constructor(t, e, i, n) {
            this._PointClass = t,
            this._version = e,
            this._numberOfDigits = i,
            this._name = n,
            this._pointSets = [],
            this._points = [],
            this._hintIndex = 0,
            this._interval = new s.Interval(Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY),
            this._loadedState = PointSet.State.NOT_LOADED,
            this._accessedTime = Number.POSITIVE_INFINITY
        }
        getName() {
            return this._name
        }
        getLoadedState() {
            return this._loadedState
        }
        getLoadedTime() {
            return this._accessedTime
        }
        hasPointSets() {
            return 0 !== this._pointSets.length
        }
        hasPoints() {
            return 0 !== this._points.length
        }
        load(t) {
            let e = !0;
            if ((2 === this._version || 1 === this._version && "def" === this._name) && (e = 1 === t.readByte()),
            e) {
                const e = t.readInt32();
                for (let i = 0; i < e; i++) {
                    const e = new this._PointClass;
                    e.load(t),
                    this._points.push(e)
                }
                this._points.length > 0 && (this._interval.min = this._points[0].time,
                this._interval.max = this._points[this._points.length - 1].time)
            } else {
                const e = t.readInt32();
                1 === this._version && (this._numberOfDigits = Math.ceil(Math.log10(e)));
                for (let i = 0; i < e; i++) {
                    let e;
                    e = "def" === this._name ? `${i}`.padStart(this._numberOfDigits, "0") : `${this._name}_${`${i}`.padStart(this._numberOfDigits, "0")}`;
                    const s = new PointSet(this._PointClass,this._version,this._numberOfDigits,e);
                    s._interval.min = t.readFloat64(),
                    1 === this._version ? s._interval.max = t.readFloat64() : i > 0 && (this._pointSets[i - 1]._interval.max = s._interval.min),
                    this._pointSets.push(s)
                }
                2 === this._version && this._pointSets.splice(this._pointSets.length - 1, 1),
                this._pointSets.length > 0 && (this._interval.min = this._pointSets[0]._interval.min,
                this._interval.max = this._pointSets[this._pointSets.length - 1]._interval.max)
            }
            this._loadedState = PointSet.State.LOADED,
            this._accessedTime = Date.now()
        }
        loadFromUrl(t, e, i) {
            this._loadedState = PointSet.State.LOADING,
            t.download(`${e}/${this._name}.dyn`, "binary", i).then((async t => {
                if ("cancelled" === t.status)
                    return;
                if ("failed" === t.status)
                    return void (this._loadedState = PointSet.State.FAILED);
                if (!(t.content instanceof ArrayBuffer))
                    throw new Error(`Failed to load dynamo controller file "${t.url}": Not a binary file.`);
                const e = new s.Reader(t.content);
                this.load(e)
            }
            ))
        }
        unloadOldPointSet() {
            for (let t = 0, e = this._pointSets.length; t < e; t++) {
                const e = this._pointSets[t];
                if (e._loadedState === PointSet.State.LOADED) {
                    if (Date.now() - e._accessedTime > 15e3)
                        return e.unload(),
                        !0;
                    if (e.unloadOldPointSet())
                        return !0
                }
            }
            return !1
        }
        unload() {
            this._loadedState = PointSet.State.NOT_LOADED,
            this._accessedTime = Number.POSITIVE_INFINITY,
            this._pointSets = [],
            this._points = []
        }
        getPointSet(t) {
            if (this._accessedTime = Date.now(),
            0 === this._pointSets.length)
                return null;
            if (this._pointSets[this._hintIndex]._interval.contains(t))
                ;
            else if (this._hintIndex - 1 >= 0 && this._pointSets[this._hintIndex - 1]._interval.contains(t))
                this._hintIndex -= 1;
            else if (this._hintIndex + 1 < this._pointSets.length && this._pointSets[this._hintIndex + 1]._interval.contains(t))
                this._hintIndex += 1;
            else {
                let e, i = 0, s = this._pointSets.length - 1;
                for (; i !== s; )
                    e = Math.ceil((i + s) / 2),
                    t < this._pointSets[e]._interval.min ? s = e - 1 : i = e;
                this._hintIndex = i
            }
            return this._pointSets[this._hintIndex]
        }
        getPoints(t, e) {
            if (this._accessedTime = Date.now(),
            0 === this._points.length)
                return t[0] = null,
                void (t[1] = null);
            if (this._hintIndex + 1 < this._points.length && this._points[this._hintIndex].time <= e && e < this._points[this._hintIndex + 1].time)
                ;
            else if (this._hintIndex - 1 >= 0 && this._points[this._hintIndex - 1].time <= e && e < this._points[this._hintIndex].time)
                this._hintIndex -= 1;
            else if (this._hintIndex + 2 < this._points.length && this._points[this._hintIndex + 1].time <= e && e < this._points[this._hintIndex + 2].time)
                this._hintIndex += 1;
            else {
                let t, i = 0, s = this._points.length - 2;
                for (; i !== s; )
                    t = Math.ceil((i + s) / 2),
                    e < this._points[t].time ? s = t - 1 : i = t;
                this._hintIndex = i
            }
            t[0] = this._points[this._hintIndex],
            t[1] = this._points[this._hintIndex + 1]
        }
        static State = {
            NOT_LOADED: 0,
            LOADING: 1,
            LOADED: 2,
            FAILED: 3
        }
    }
    class DynamoController extends s.BaseController {
        constructor(t, e) {
            super(t, e),
            this._baseUrl = "",
            this._dataLoadedAtCurrentTime = !1,
            this._timeOffset = 0,
            this._version = 0,
            this._pointType = "",
            this._PointClass = Point,
            this._numberOfDigits = 0,
            this._header = {
                body: 0
            },
            this._incremental = !1,
            this._pointSet = null,
            this._downloader = e.getScene().getEngine().getDownloader(),
            this._points = [null, null],
            this._lastPoints = [null, null],
            this._lastTime = Number.NaN,
            this._pCalc = new Point,
            this._userCoverage = new s.Interval(Number.NEGATIVE_INFINITY,Number.POSITIVE_INFINITY),
            this._userCoverage.freeze(),
            super.setCoverage(new s.Interval(NaN,NaN))
        }
        getPointType() {
            return this._pointType
        }
        getHeaderValue(t) {
            return this._header[t]
        }
        setHeaderValue(t, e) {
            this._header[t] = e
        }
        isIncremental() {
            return this._incremental
        }
        setIncremental(t) {
            this._incremental = t
        }
        getBaseUrl() {
            return this._baseUrl
        }
        setBaseUrl(t) {
            "" !== this._baseUrl && (this._downloader.cancel(`${this._baseUrl}/def.dyn`),
            this._pointSet = null,
            this._PointClass = Point,
            super.setCoverage(new s.Interval(NaN,NaN)),
            this.removeModifiedState("position"),
            this.removeModifiedState("velocity"),
            this.removeModifiedState("orientation"),
            this.removeModifiedState("angularVelocity"),
            this._dataLoadedAtCurrentTime = !1),
            this._baseUrl = t,
            this._baseUrl.endsWith("/") && (this._baseUrl = this._baseUrl.slice(0, -1)),
            this._loadDef()
        }
        getTimeOffset() {
            return this._timeOffset
        }
        setTimeOffset(t) {
            const e = this._timeOffset;
            this._timeOffset = t;
            const i = new s.Interval;
            i.copy(this.getCoverage()),
            i.min += this._timeOffset - e,
            i.max += this._timeOffset - e,
            super.setCoverage(i)
        }
        setCoverage(t) {
            this._userCoverage.thaw(),
            this._userCoverage.copy(t),
            this._userCoverage.freeze();
            const e = s.Interval.pool.get();
            null !== this._pointSet ? e.intersection(this._userCoverage, this._pointSet._interval) : e.copy(new s.Interval(NaN,NaN)),
            e.min += this._timeOffset,
            e.max += this._timeOffset,
            super.setCoverage(e),
            s.Interval.pool.release(e)
        }
        getOrbitalElements(t, e) {
            if (this._PointClass === OrbPoint && null !== this._pointSet && (this._getPointsAtTime(this._points, e),
            null !== this._points[0] && (this._lastPoints[0] = this._points[0],
            this._lastPoints[1] = this._points[1]),
            null !== this._lastPoints[0] && null !== this._lastPoints[1])) {
                const i = this._lastPoints[0].oe
                  , n = this._lastPoints[1].oe
                  , o = s.MathUtils.clamp01((e - this._lastPoints[0].time) / (this._lastPoints[1].time - this._lastPoints[0].time));
                t.eccentricity = s.MathUtils.lerp(i.eccentricity, n.eccentricity, o),
                t.semiMajorAxis = s.MathUtils.lerp(i.semiMajorAxis, n.semiMajorAxis, o),
                t.epoch = s.MathUtils.lerp(i.epoch, n.epoch, o),
                t.meanAngularMotion = s.MathUtils.lerp(i.meanAngularMotion, n.meanAngularMotion, o),
                t.meanAnomalyAtEpoch = s.MathUtils.lerpAngle(i.meanAnomalyAtEpoch, n.meanAnomalyAtEpoch, o),
                t.orbitOrientation.slerp(i.orbitOrientation, n.orbitOrientation, o)
            }
        }
        getEccentricity(t) {
            if (this._PointClass === OrbPoint && null !== this._pointSet && (this._getPointsAtTime(this._points, t),
            null !== this._points[0] && (this._lastPoints[0] = this._points[0],
            this._lastPoints[1] = this._points[1]),
            null !== this._lastPoints[0] && null !== this._lastPoints[1])) {
                const e = s.MathUtils.clamp01((t - this._lastPoints[0].time) / (this._lastPoints[1].time - this._lastPoints[0].time));
                return s.MathUtils.lerp(this._lastPoints[0].oe.eccentricity, this._lastPoints[1].oe.eccentricity, e)
            }
            return Number.NaN
        }
        getSemiMajorAxis(t) {
            if (this._PointClass === OrbPoint && null !== this._pointSet && (this._getPointsAtTime(this._points, t),
            null !== this._points[0] && (this._lastPoints[0] = this._points[0],
            this._lastPoints[1] = this._points[1]),
            null !== this._lastPoints[0] && null !== this._lastPoints[1])) {
                const e = s.MathUtils.clamp01((t - this._lastPoints[0].time) / (this._lastPoints[1].time - this._lastPoints[0].time));
                return s.MathUtils.lerp(this._lastPoints[0].oe.semiMajorAxis, this._lastPoints[1].oe.semiMajorAxis, e)
            }
            return Number.NaN
        }
        getOrbitOrientation(t, e) {
            if (this._PointClass === OrbPoint && null !== this._pointSet && (this._getPointsAtTime(this._points, e),
            null !== this._points[0] && (this._lastPoints[0] = this._points[0],
            this._lastPoints[1] = this._points[1]),
            null !== this._lastPoints[0] && null !== this._lastPoints[1])) {
                const i = s.MathUtils.clamp01((e - this._lastPoints[0].time) / (this._lastPoints[1].time - this._lastPoints[0].time));
                t.slerp(this._lastPoints[0].oe.orbitOrientation, this._lastPoints[1].oe.orbitOrientation, i)
            }
        }
        __destroy() {
            "" !== this._baseUrl && this._downloader.cancel(`${this._baseUrl}/def.dyn`),
            super.__destroy()
        }
        __updatePositionAtTime(t, e) {
            if (null !== this._pointSet) {
                if (void 0 !== this._pCalc.position && this.getCoverage().contains(e)) {
                    if (this._pCalc.time !== e) {
                        if (this._getPointsAtTime(this._points, e),
                        null === this._points[0])
                            return void t.copy(s.Vector3.NaN);
                        this._pCalc.calculate(this._points, e - this._timeOffset, this._header, this._incremental)
                    }
                    t.copy(this._pCalc.position)
                }
            } else
                t.copy(s.Vector3.NaN)
        }
        __updateVelocityAtTime(t, e) {
            if (null !== this._pointSet) {
                if (void 0 !== this._pCalc.velocity && this.getCoverage().contains(e)) {
                    if (this._pCalc.time !== e) {
                        if (this._getPointsAtTime(this._points, e),
                        null === this._points[0])
                            return void t.copy(s.Vector3.NaN);
                        this._pCalc.calculate(this._points, e - this._timeOffset, this._header, this._incremental)
                    }
                    t.copy(this._pCalc.velocity)
                }
            } else
                t.copy(s.Vector3.NaN)
        }
        __updateOrientationAtTime(t, e) {
            if (null !== this._pointSet) {
                if (void 0 !== this._pCalc.orientation && this.getCoverage().contains(e)) {
                    if (this._pCalc.time !== e) {
                        if (this._getPointsAtTime(this._points, e),
                        null === this._points[0])
                            return void t.copy(s.Quaternion.NaN);
                        this._pCalc.calculate(this._points, e - this._timeOffset, this._header, this._incremental)
                    }
                    t.copy(this._pCalc.orientation)
                }
            } else
                t.copy(s.Quaternion.NaN)
        }
        __update() {
            const t = this.getEntity()
              , e = t.getScene().getEngine().getTime();
            null !== this._pointSet ? (this._pointSet.unloadOldPointSet(),
            this._getPointsAtTime(this._points, e),
            null !== this._points[0] ? (this._pCalc.calculate(this._points, e - this._timeOffset, this._header, this._incremental),
            this._pCalc.apply(t),
            this._lastPoints[0] = this._points[0],
            this._lastPoints[1] = this._points[1],
            this._dataLoadedAtCurrentTime = !0) : (null !== this._lastPoints[0] && null !== this._lastPoints[1] && (this._pCalc.calculate(this._lastPoints, e - this._timeOffset, this._header, this._incremental),
            this._pCalc.apply(t)),
            this._dataLoadedAtCurrentTime = !1)) : (this.getEntity().setPosition(s.Vector3.NaN),
            this.getEntity().setVelocity(s.Vector3.NaN),
            this.getEntity().setOrientation(s.Quaternion.NaN),
            this.getEntity().setAngularVelocity(s.Vector3.NaN),
            this._dataLoadedAtCurrentTime = !1),
            this._lastTime = e
        }
        async _loadDef() {
            const t = await this._downloader.download(`${this._baseUrl}/def.dyn`, "binary", -this.getEntity().getLeastCameraDepth());
            if ("cancelled" === t.status)
                return;
            if ("failed" === t.status)
                throw new Error(`Failed to load dynamo controller file "${t.url}": ${t.errorMessage}`);
            if (!(t.content instanceof ArrayBuffer))
                throw new Error(`Failed to load dynamo controller file "${t.url}": Not a binary file.`);
            const e = new s.Reader(t.content);
            if (this._version = e.readInt16(),
            1 !== this._version && 2 !== this._version)
                throw new Error(`${t.url} is not Dynamo version 1 or 2`);
            this._pointType = e.readString(),
            "pos" === this._pointType ? this._PointClass = PosPoint : "lin" === this._pointType ? this._PointClass = LinPoint : "ori" === this._pointType ? this._PointClass = OriPoint : "quat" === this._pointType ? this._PointClass = QuatPoint : "orb" === this._pointType && (this._PointClass = OrbPoint),
            this._pCalc = new this._PointClass,
            this._PointClass === PosPoint || this._PointClass === LinPoint || this._PointClass === OrbPoint ? (this.addModifiedState("position"),
            this.addModifiedState("velocity"),
            this.removeModifiedState("orientation"),
            this.removeModifiedState("angularVelocity")) : this._PointClass !== OriPoint && this._PointClass !== QuatPoint || (this.addModifiedState("orientation"),
            this.addModifiedState("angularVelocity"),
            this.removeModifiedState("position"),
            this.removeModifiedState("velocity")),
            2 === this._version && (this._numberOfDigits = e.readByte()),
            this._header = Object.assign(this._header, this._PointClass.readHeader(e)),
            this._pointSet = new PointSet(this._PointClass,this._version,this._numberOfDigits,"def"),
            this._pointSet.load(e);
            const i = s.Interval.pool.get();
            i.intersection(this._userCoverage, this._pointSet._interval),
            i.min += this._timeOffset,
            i.max += this._timeOffset,
            super.setCoverage(i),
            s.Interval.pool.release(i)
        }
        _getPointsAtTime(t, e) {
            let i = this._pointSet;
            for (; null !== i; ) {
                if (i.hasPoints())
                    return void i.getPoints(t, e - this._timeOffset);
                if (i.getLoadedState() !== PointSet.State.LOADED) {
                    if (i.getLoadedState() === PointSet.State.NOT_LOADED) {
                        i.loadFromUrl(this._downloader, this._baseUrl, -this.getEntity().getLeastCameraDepth());
                        break
                    }
                    if (i.getLoadedState() === PointSet.State.FAILED) {
                        this.setBaseUrl(this._baseUrl);
                        break
                    }
                    break
                }
                i = i.getPointSet(e - this._timeOffset)
            }
            t[0] = null,
            t[1] = null
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        FixedController: function() {
            return FixedController
        }
    });
    var s = i(6);
    class FixedController extends s.BaseController {
        constructor(t, e) {
            super(t, e),
            this._position = null,
            this._orientation = null
        }
        getPosition() {
            return this._position
        }
        setPosition(t) {
            null !== t ? (null === this._position && (this._position = new s.Vector3),
            this._position.thaw(),
            this._position.copy(t),
            this._position.freeze()) : this._position = null,
            null !== t ? (this.addModifiedState("position"),
            this.addModifiedState("velocity")) : (this.removeModifiedState("position"),
            this.removeModifiedState("velocity"))
        }
        getOrientation() {
            return this._orientation
        }
        setOrientation(t) {
            null !== t ? (null === this._orientation && (this._orientation = new s.Quaternion),
            this._orientation.thaw(),
            this._orientation.copy(t),
            this._orientation.freeze()) : this._orientation = null,
            null !== t ? this.addModifiedState("orientation") : this.removeModifiedState("orientation")
        }
        __updatePositionAtTime(t, e) {
            null !== this._position && t.copy(this._position)
        }
        __updateVelocityAtTime(t, e) {
            null !== this._position && t.set(0, 0, 0)
        }
        __updateOrientationAtTime(t, e) {
            null !== this._orientation && t.copy(this._orientation)
        }
        __update() {
            null !== this._position && (this.getEntity().setPosition(this._position),
            this.getEntity().setVelocity(s.Vector3.Zero)),
            null !== this._orientation && this.getEntity().setOrientation(this._orientation)
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        FixedToParentController: function() {
            return FixedToParentController
        }
    });
    var s = i(6);
    class FixedToParentController extends s.BaseController {
        constructor(t, e) {
            super(t, e),
            this._lastParent = null,
            this._lastParentOrientation = new s.Quaternion,
            this._lastParent = this.getEntity().getParent(),
            this._lastParent && this._lastParentOrientation.copy(this._lastParent.getOrientation()),
            this.addModifiedState("position"),
            this.addModifiedState("orientation"),
            this.addDependentState("parent", "orientation")
        }
        __update() {
            const t = this.getEntity().getParent();
            if (null === t || null === this._lastParent)
                return void (this._lastParent = t);
            const e = s.Quaternion.pool.get();
            if (e.inverse(this._lastParentOrientation),
            e.mult(this._lastParent.getOrientation(), e),
            !e.isNaN()) {
                const i = s.Vector3.pool.get()
                  , n = s.Quaternion.pool.get();
                i.copy(this.getEntity().getPosition()),
                t !== this._lastParent && t.getPositionRelativeToEntity(i, i, this._lastParent),
                i.rotate(e, i),
                t !== this._lastParent && this._lastParent.getPositionRelativeToEntity(i, i, t),
                this.getEntity().setPosition(i),
                n.mult(e, this.getEntity().getOrientation()),
                this.getEntity().setOrientation(n),
                s.Quaternion.pool.release(n),
                s.Vector3.pool.release(i)
            }
            s.Quaternion.pool.release(e),
            this._lastParent = t,
            this._lastParentOrientation.copy(t.getOrientation())
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        FreeFlyController: function() {
            return FreeFlyController
        }
    });
    var s = i(6);
    class FreeFlyController extends s.BaseController {
        constructor(t, e) {
            super(t, e),
            this._dragSensitivity = .05,
            this._dragSmoothness = .8,
            this._moveSmoothedValue = new s.Vector3(0,0,0),
            this._changeParentToNearestEntity = !0,
            this._nearestEntity = null,
            this._nearestEntityDistance = Number.POSITIVE_INFINITY,
            this._nearestEntityCheckIndex = 0,
            this._forcedMoving = new s.Vector3,
            this._isMoving = !1,
            this.addModifiedState("position"),
            this.addDependentState("parent", "orientation"),
            this.addDependentState("parent", "radius")
        }
        getDragSensitivity() {
            return this._dragSensitivity
        }
        setDragSensitivity(t) {
            this._dragSensitivity = t
        }
        getDragSmoothness() {
            return this._dragSmoothness
        }
        setDragSmoothness(t) {
            this._dragSmoothness = t
        }
        getChangeParentToNearestEntity() {
            return this._changeParentToNearestEntity
        }
        setChangeParentToNearestEntity(t) {
            this._changeParentToNearestEntity = t
        }
        getForcedMoving() {
            return this._forcedMoving
        }
        setForcedMoving(t) {
            this._forcedMoving = t
        }
        __update() {
            if (null === this.getEntity().getParent())
                return;
            this._nearestEntity && (this._nearestEntityDistance = this.getEntity().getDistanceTo(this._nearestEntity, !0));
            const t = this.getEntity().getScene()
              , e = t.getNumEntities()
              , i = Math.min(20, e);
            for (let s = 0; s < i; s++) {
                const i = t.getEntityAt((this._nearestEntityCheckIndex + s) % e);
                if (i === this.getEntity())
                    continue;
                const n = this.getEntity().getDistanceTo(i, !0);
                n >= 0 && this._nearestEntityDistance > n && (this._nearestEntityDistance = n,
                this._nearestEntity = i)
            }
            this._nearestEntityCheckIndex = (this._nearestEntityCheckIndex + i) % e,
            this._changeParentToNearestEntity && this._nearestEntity && this._nearestEntity !== this.getEntity().getParent() && this.getEntity().setParent(this._nearestEntity),
            this.getEntity().getOrientation().isNaN() && this.getEntity().setOrientation(s.Quaternion.Identity),
            this.getEntity().getPosition().isNaN() && this.getEntity().setPosition(new s.Vector3(0,-1,0));
            const n = s.Vector3.pool.get();
            n.set(0, 0, 0);
            const o = this.getEntity().getScene().getEngine().getInput()
              , a = o.getActiveViewport();
            if (null !== a) {
                const t = a.getCamera();
                if (null !== t && t.getEntity() === this.getEntity()) {
                    let t = 1;
                    o.isKeyPressed("x") && (t = .05),
                    o.isShiftPressed() && (t = 5);
                    const e = o.getZoomedOffset();
                    0 !== e && (n.y += -e * this._dragSensitivity * t),
                    o.isKeyPressed("w") && (n.y += this._dragSensitivity * t),
                    o.isKeyPressed("s") && (n.y -= this._dragSensitivity * t),
                    o.isKeyPressed("d") && (n.x += this._dragSensitivity * t),
                    o.isKeyPressed("a") && (n.x -= this._dragSensitivity * t),
                    o.isKeyPressed("e") && (n.z += this._dragSensitivity * t),
                    o.isKeyPressed("q") && (n.z -= this._dragSensitivity * t)
                }
            }
            n.add(n, this._forcedMoving),
            this._isMoving = n.magnitudeSqr() > 0,
            this._moveSmoothedValue.lerp(n, this._moveSmoothedValue, this._dragSmoothness),
            !this._isMoving && this._moveSmoothedValue.magnitudeSqr() < 1e-7 && this._moveSmoothedValue.set(0, 0, 0),
            s.Vector3.pool.release(n);
            const r = this.getEntity().getPosition()
              , l = s.Vector3.pool.get()
              , c = s.Vector3.pool.get();
            c.rotate(this.getEntity().getOrientation(), this._moveSmoothedValue),
            l.addMult(r, c, Math.max(1e-4, this._nearestEntityDistance)),
            this.getEntity().setPosition(l),
            s.Vector3.pool.release(c),
            s.Vector3.pool.release(l)
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        GroundClampController: function() {
            return GroundClampController
        }
    });
    var s = i(6);
    class GroundClampController extends s.BaseController {
        constructor(t, e) {
            super(t, e),
            this._groundEntityRef = new s.EntityRef(this.getEntity().getScene()),
            this._distanceFromGround = 0,
            this._up = new s.Vector3(0,0,1),
            this._up.freeze(),
            this._clampOnlyIfBelow = !1,
            this.addModifiedState("position")
        }
        setGroundEntityRef(t) {
            this.removeDependentState(this._groundEntityRef.getName(), "orientation"),
            this._groundEntityRef.setName(t),
            this.addDependentState(t, "orientation")
        }
        getDistanceFromGround() {
            return this._distanceFromGround
        }
        setDistanceFromGround(t) {
            this._distanceFromGround = t
        }
        getUp() {
            return this._up
        }
        setUp(t) {
            this._up.thaw(),
            this._up.copy(t),
            this._up.freeze()
        }
        getClampOnlyIfBelow() {
            return this._clampOnlyIfBelow
        }
        setClampOnlyIfBelow(t) {
            this._clampOnlyIfBelow = t
        }
        __updatePositionAtTime(t, e) {
            const i = this.getEntity().getParentAtTime(e)
              , n = this.getEntity().getScene().getEntity(i);
            if (null === n)
                return;
            let o = this._groundEntityRef.get();
            for (; o && !o.getGroundComponent(); )
                o = o.getParent();
            if (!o)
                return;
            const a = o.getGroundComponent()
              , r = s.Vector3.pool.get()
              , l = s.Vector3.pool.get()
              , c = s.Vector3.pool.get()
              , h = s.Quaternion.pool.get();
            if (o.getOrientationAtTime(h, e),
            n.getPositionRelativeToEntity(r, t, o, e),
            r.rotateInverse(h, r),
            l.copy(s.Vector3.NaN),
            a.getGroundPosition(l, c, r),
            !l.isNaN()) {
                const i = s.Vector3.pool.get()
                  , a = s.Quaternion.pool.get();
                this.getEntity().getOrientationAtTime(a, e),
                i.rotate(a, this._up),
                s.Quaternion.pool.release(a),
                i.rotateInverse(h, i);
                const d = Math.abs(i.dot(c));
                s.Vector3.pool.release(i);
                const u = Math.min(this._distanceFromGround / d, this._distanceFromGround + this.getEntity().getExtentsRadius());
                l.addMult(l, c, u),
                (!this._clampOnlyIfBelow || r.dot(c) - l.dot(c) < 0) && (r.rotate(h, l),
                o.getPositionRelativeToEntity(t, r, n, e))
            }
            s.Vector3.pool.release(r),
            s.Vector3.pool.release(l),
            s.Vector3.pool.release(c),
            s.Quaternion.pool.release(h)
        }
        __update() {
            if (null === this.getEntity().getParent())
                return;
            let t = this._groundEntityRef.get();
            for (; t && !t.getGroundComponent(); )
                t = t.getParent();
            if (!t)
                return;
            const e = t.getGroundComponent()
              , i = s.Vector3.pool.get()
              , n = s.Vector3.pool.get()
              , o = s.Vector3.pool.get();
            if (this.getEntity().getPositionRelativeToEntity(i, s.Vector3.Zero, t),
            i.rotateInverse(t.getOrientation(), i),
            n.copy(s.Vector3.NaN),
            e.getGroundPosition(n, o, i),
            !n.isNaN()) {
                const e = s.Vector3.pool.get();
                e.rotate(this.getEntity().getOrientation(), this._up),
                e.rotateInverse(t.getOrientation(), e);
                const a = Math.abs(e.dot(o));
                s.Vector3.pool.release(e);
                const r = Math.min(this._distanceFromGround / a, this._distanceFromGround + this.getEntity().getExtentsRadius());
                n.addMult(n, o, r);
                const l = this.getEntity().getParent();
                (!this._clampOnlyIfBelow || i.dot(o) - n.dot(o) < 0) && l && (i.rotate(t.getOrientation(), n),
                t.getPositionRelativeToEntity(i, i, l),
                this.getEntity().setPosition(i))
            }
            s.Vector3.pool.release(i),
            s.Vector3.pool.release(n),
            s.Vector3.pool.release(o)
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        KeyframeController: function() {
            return KeyframeController
        }
    });
    var s = i(6);
    class KeyframeController extends s.BaseController {
        constructor(t, e) {
            super(t, e),
            this._positionKeyframes = [],
            this._orientationKeyframes = [],
            this._timesAreRealTime = !1,
            this._timeOfFirstUpdate = NaN,
            this.setCoverage(new s.Interval(Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY)),
            this._position0 = new s.Vector3,
            this._position1 = new s.Vector3,
            this._orientation0 = new s.Quaternion,
            this._orientation1 = new s.Quaternion,
            this._newPosition = new s.Vector3,
            this._newVelocity = new s.Vector3,
            this._newOrientation = new s.Quaternion,
            this._tangent0 = new s.Vector3,
            this._tangent1 = new s.Vector3,
            this._tempA = new s.Vector3,
            this._tempB = new s.Vector3
        }
        addPositionKeyframe(t, e, i, n, o, a) {
            const r = [t, {
                position: e,
                relativeToEntityPosition: void 0 !== i ? new s.EntityRef(this.getEntity().getScene(),i) : void 0,
                relativeToEntityPositionTime: n,
                relativeToEntityOrientation: void 0 !== o ? new s.EntityRef(this.getEntity().getScene(),o) : void 0,
                relativeToEntityOrientationTime: a
            }];
            s.Sort.add(r, this._positionKeyframes, KeyframeController.isLessAdd),
            1 === this._positionKeyframes.length && (this.addModifiedState("position"),
            this.addModifiedState("velocity")),
            this._updateCoverage()
        }
        removePositionKeyframe(t) {
            const e = s.Sort.remove(t, this._positionKeyframes, KeyframeController.isLess, KeyframeController.isEqual);
            return e && (0 === this._positionKeyframes.length && (this.removeModifiedState("position"),
            this.removeModifiedState("velocity")),
            this._updateCoverage()),
            e
        }
        addOrientationKeyframe(t, e, i, n) {
            const o = [t, {
                orientation: e,
                relativeToEntityOrientation: void 0 !== i ? new s.EntityRef(this.getEntity().getScene(),i) : void 0,
                relativeToEntityOrientationTime: n
            }];
            s.Sort.add(o, this._orientationKeyframes, KeyframeController.isLessAdd),
            1 === this._orientationKeyframes.length && this.addModifiedState("orientation"),
            this._updateCoverage()
        }
        removeOrientationKeyframe(t) {
            const e = s.Sort.remove(t, this._orientationKeyframes, KeyframeController.isLess, KeyframeController.isEqual);
            return e && (0 === this._orientationKeyframes.length && this.removeModifiedState("orientation"),
            this._updateCoverage()),
            e
        }
        areTimesRealTime() {
            return this._timesAreRealTime
        }
        setTimesAreRealTime(t) {
            this._timesAreRealTime = t,
            this._updateCoverage()
        }
        __updatePositionAtTime(t, e) {
            this._getPositionAtTime(t, e)
        }
        __updateVelocityAtTime(t, e) {
            this._getVelocityAtTime(t, e)
        }
        __updateOrientationAtTime(t, e) {
            this._getOrientationAtTime(t, e)
        }
        __update() {
            const t = this.getEntity().getScene().getEngine();
            let e = 0;
            this._timesAreRealTime ? isNaN(this._timeOfFirstUpdate) ? this._timeOfFirstUpdate = Date.now() / 1e3 : e = Date.now() / 1e3 - this._timeOfFirstUpdate : e = t.getTime(),
            this._getPositionAtTime(this._newPosition, e) && this.getEntity().setPosition(this._newPosition),
            this._getVelocityAtTime(this._newVelocity, e) && this.getEntity().setVelocity(this._newVelocity),
            this._getOrientationAtTime(this._newOrientation, e) && this.getEntity().setOrientation(this._newOrientation)
        }
        _getPositionAtTime(t, e) {
            const i = s.Sort.getIndex(e, this._positionKeyframes, KeyframeController.isLess);
            if (i < this._positionKeyframes.length) {
                if (0 !== i) {
                    const s = i - 1
                      , n = i
                      , o = this._positionKeyframes[s][0]
                      , a = this._positionKeyframes[n][0];
                    if (this._getPositionOfKeyframe(this._position0, this._positionKeyframes[s]),
                    this._getPositionOfKeyframe(this._position1, this._positionKeyframes[n]),
                    s > 0) {
                        const t = this._positionKeyframes[s - 1][0];
                        this._getPositionOfKeyframe(this._tempA, this._positionKeyframes[s - 1]),
                        this._tempA.sub(this._position0, this._tempA),
                        this._tempB.sub(this._position1, this._position0),
                        this._tempB.mult(this._tempB, .5),
                        this._tangent0.addMult(this._tempB, this._tempA, .5 * (a - o) / (o - t))
                    } else
                        this._tangent0.sub(this._position1, this._position0);
                    if (n < this._positionKeyframes.length - 1) {
                        const t = this._positionKeyframes[n + 1][0];
                        this._getPositionOfKeyframe(this._tempB, this._positionKeyframes[n + 1]),
                        this._tempA.sub(this._position1, this._position0),
                        this._tempB.sub(this._tempB, this._position1),
                        this._tempA.mult(this._tempA, .5),
                        this._tangent1.addMult(this._tempA, this._tempB, .5 * (a - o) / (t - a))
                    } else
                        this._tangent1.sub(this._position1, this._position0);
                    const r = (e - o) / (a - o);
                    return this._cubicHermiteSpline(t, this._position0, this._position1, this._tangent0, this._tangent1, r),
                    !0
                }
                if (this._positionKeyframes[0][0] === e)
                    return this._getPositionOfKeyframe(t, this._positionKeyframes[0]),
                    !0
            }
            return !1
        }
        _getVelocityAtTime(t, e) {
            const i = s.Sort.getIndex(e, this._positionKeyframes, KeyframeController.isLess);
            if (i < this._positionKeyframes.length) {
                if (0 !== i) {
                    const s = i - 1
                      , n = i
                      , o = this._positionKeyframes[s][0]
                      , a = this._positionKeyframes[n][0];
                    if (this._getPositionOfKeyframe(this._position0, this._positionKeyframes[s]),
                    this._getPositionOfKeyframe(this._position1, this._positionKeyframes[n]),
                    s > 0) {
                        const t = this._positionKeyframes[s - 1][0];
                        this._getPositionOfKeyframe(this._tempA, this._positionKeyframes[s - 1]),
                        this._tempA.sub(this._position0, this._tempA),
                        this._tempB.sub(this._position1, this._position0),
                        this._tempB.mult(this._tempB, .5),
                        this._tangent0.addMult(this._tempB, this._tempA, .5 * (a - o) / (o - t))
                    } else
                        this._tangent0.sub(this._position1, this._position0);
                    if (n < this._positionKeyframes.length - 1) {
                        const t = this._positionKeyframes[n + 1][0];
                        this._getPositionOfKeyframe(this._tempB, this._positionKeyframes[n + 1]),
                        this._tempA.sub(this._position1, this._position0),
                        this._tempB.sub(this._tempB, this._position1),
                        this._tempA.mult(this._tempA, .5),
                        this._tangent1.addMult(this._tempA, this._tempB, .5 * (a - o) / (t - a))
                    } else
                        this._tangent1.sub(this._position1, this._position0);
                    const r = (e - o) / (a - o);
                    return this._cubicHermiteSplineDerivative(t, this._position0, this._position1, this._tangent0, this._tangent1, r),
                    t.div(t, a - o),
                    !0
                }
                if (this._positionKeyframes[0][0] === e) {
                    if (this._positionKeyframes.length > 1) {
                        const e = this._positionKeyframes[0][0]
                          , i = this._positionKeyframes[1][0];
                        this._getPositionOfKeyframe(this._position0, this._positionKeyframes[0]),
                        this._getPositionOfKeyframe(this._position1, this._positionKeyframes[1]),
                        t.sub(this._position1, this._position0),
                        t.div(t, i - e)
                    } else
                        t.set(0, 0, 0);
                    return !0
                }
            }
            return !1
        }
        _getOrientationAtTime(t, e) {
            const i = s.Sort.getIndex(e, this._orientationKeyframes, KeyframeController.isLess);
            if (i < this._orientationKeyframes.length) {
                if (0 !== i) {
                    const s = i - 1
                      , n = i
                      , o = this._orientationKeyframes[s][0];
                    this._getOrientationOfKeyframe(this._orientation0, this._orientationKeyframes[s]);
                    const a = this._orientationKeyframes[n][0];
                    return this._getOrientationOfKeyframe(this._orientation1, this._orientationKeyframes[n]),
                    t.slerp(this._orientation0, this._orientation1, (e - o) / (a - o)),
                    !0
                }
                if (this._orientationKeyframes[0][0] === e)
                    return this._getOrientationOfKeyframe(t, this._orientationKeyframes[0]),
                    !0
            }
            return !1
        }
        _getPositionOfKeyframe(t, e) {
            const i = e[1];
            if (t.copy(i.position),
            void 0 !== i.relativeToEntityOrientation) {
                const n = e[1].relativeToEntityOrientationTime ?? e[0]
                  , o = i.relativeToEntityOrientation.get();
                if (null !== o) {
                    const e = s.Quaternion.pool.get();
                    o.getOrientationAtTime(e, n),
                    t.rotate(e, t),
                    s.Quaternion.pool.release(e)
                } else
                    t.copy(s.Vector3.NaN)
            }
            if (void 0 !== i.relativeToEntityPosition) {
                const n = e[1].relativeToEntityPositionTime ?? e[0]
                  , o = i.relativeToEntityPosition.get()
                  , a = this.getEntity().getParent();
                if (null !== o && a) {
                    const e = s.Vector3.pool.get();
                    o.getPositionRelativeToEntity(e, s.Vector3.Zero, a, n),
                    t.add(e, t),
                    s.Vector3.pool.release(e)
                } else
                    t.copy(s.Vector3.NaN)
            }
        }
        _getOrientationOfKeyframe(t, e) {
            const i = e[1];
            if (void 0 !== i.relativeToEntityOrientation) {
                const n = e[1].relativeToEntityOrientationTime ?? e[0]
                  , o = i.relativeToEntityOrientation.get();
                null !== o ? (o.getOrientationAtTime(t, n),
                t.mult(t, i.orientation)) : t.copy(s.Quaternion.NaN)
            } else
                t.copy(i.orientation)
        }
        _updateCoverage() {
            if (this._timesAreRealTime)
                this.setCoverage(s.Interval.Infinite);
            else {
                const t = new s.Interval(Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY);
                this._positionKeyframes.length > 0 && (t.min = Math.min(t.min, this._positionKeyframes[0][0]),
                t.max = Math.max(t.max, this._positionKeyframes[this._positionKeyframes.length - 1][0])),
                this._orientationKeyframes.length > 0 && (t.min = Math.min(t.min, this._orientationKeyframes[0][0]),
                t.max = Math.max(t.max, this._orientationKeyframes[this._orientationKeyframes.length - 1][0])),
                this.setCoverage(t)
            }
        }
        _cubicHermiteSpline(t, e, i, s, n, o) {
            const a = o * o
              , r = o * a
              , l = 2 * r - 3 * a + 1
              , c = r - 2 * a + o
              , h = -2 * r + 3 * a
              , d = r - a;
            t.x = l * e.x + c * s.x + h * i.x + d * n.x,
            t.y = l * e.y + c * s.y + h * i.y + d * n.y,
            t.z = l * e.z + c * s.z + h * i.z + d * n.z
        }
        _cubicHermiteSplineDerivative(t, e, i, s, n, o) {
            const a = o * o
              , r = 6 * a - 6 * o
              , l = 3 * a - 4 * o + 1
              , c = -6 * a + 6 * o
              , h = 3 * a - 2 * o;
            t.x = r * e.x + l * s.x + c * i.x + h * n.x,
            t.y = r * e.y + l * s.y + c * i.y + h * n.y,
            t.z = r * e.z + l * s.z + c * i.z + h * n.z
        }
        static isLessAdd = (t, e) => t[0] < e[0];
        static isLess = (t, e) => t[0] < e;
        static isEqual = (t, e) => t[0] === e
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        LookController: function() {
            return LookController
        }
    });
    var s = i(6);
    class LookController extends s.BaseController {
        constructor(t, e) {
            super(t, e),
            this._dragSensitivity = .01,
            this._dragSmoothness = .8,
            this._yawAngleSmoothedValue = 0,
            this._pitchAngleSmoothedValue = 0,
            this._yawAxisType = "none",
            this._yawAxisEntity = null,
            this.addModifiedState("orientation")
        }
        getDragSensitivity() {
            return this._dragSensitivity
        }
        setDragSensitivity(t) {
            this._dragSensitivity = t
        }
        getDragSmoothness() {
            return this._dragSmoothness
        }
        setDragSmoothness(t) {
            this._dragSmoothness = t
        }
        getYawAxisType() {
            return this._yawAxisType
        }
        setYawAxisType(t) {
            this._yawAxisType !== t && (null !== this._yawAxisEntity && (["x-axis", "y-axis", "z-axis"].includes(this._yawAxisType) ? this.removeDependentState(this._yawAxisEntity.getName(), "orientation") : "position" === this._yawAxisType && this.removeDependentState(this._yawAxisEntity.getName(), "position")),
            this._yawAxisType = t,
            null !== this._yawAxisEntity && (["x-axis", "y-axis", "z-axis"].includes(this._yawAxisType) ? this.addDependentState(this._yawAxisEntity.getName(), "orientation") : "position" === this._yawAxisType && this.addDependentState(this._yawAxisEntity.getName(), "position")))
        }
        getYawAxisEntity() {
            return this._yawAxisEntity
        }
        setYawAxisEntity(t) {
            this._yawAxisEntity !== t && (null !== this._yawAxisEntity && (["x-axis", "y-axis", "z-axis"].includes(this._yawAxisType) ? this.removeDependentState(this._yawAxisEntity.getName(), "orientation") : "position" === this._yawAxisType && this.removeDependentState(this._yawAxisEntity.getName(), "position")),
            this._yawAxisEntity = t,
            null !== this._yawAxisEntity && (["x-axis", "y-axis", "z-axis"].includes(this._yawAxisType) ? this.addDependentState(this._yawAxisEntity.getName(), "orientation") : "position" === this._yawAxisType && this.addDependentState(this._yawAxisEntity.getName(), "position")))
        }
        __update() {
            null === this._yawAxisEntity && (this._yawAxisEntity = this.getEntity().getParent(),
            null !== this._yawAxisEntity && (["x-axis", "y-axis", "z-axis"].includes(this._yawAxisType) ? this.addDependentState(this._yawAxisEntity.getName(), "orientation") : "position" === this._yawAxisType && this.addDependentState(this._yawAxisEntity.getName(), "position"))),
            this.getEntity().getOrientation().isNaN() && this.getEntity().setOrientation(s.Quaternion.Identity);
            const t = this.getEntity().getScene().getEngine().getInput();
            let e = 1;
            t.isKeyPressed("x") && (e = .05);
            const i = this.getEntity().getComponent(s.CameraComponent);
            null !== i && (e *= Math.min(1, i.getFieldOfView()));
            let n = 0
              , o = 0;
            const a = t.getActiveViewport();
            if (null !== a) {
                const i = a.getCamera();
                if (null !== i && i.getEntity() === this.getEntity()) {
                    const i = t.getDraggedOffset();
                    n = -i.x * this._dragSensitivity * e,
                    o = -i.y * this._dragSensitivity * e
                }
            }
            this._yawAngleSmoothedValue = s.MathUtils.lerp(n, this._yawAngleSmoothedValue, this._dragSmoothness),
            this._pitchAngleSmoothedValue = s.MathUtils.lerp(o, this._pitchAngleSmoothedValue, this._dragSmoothness),
            Math.abs(this._yawAngleSmoothedValue) < 1e-4 * e && (this._yawAngleSmoothedValue = 0),
            Math.abs(this._pitchAngleSmoothedValue) < 1e-4 * e && (this._pitchAngleSmoothedValue = 0);
            const r = s.Vector3.pool.get();
            "x-axis" === this._yawAxisType && null !== this._yawAxisEntity ? this._yawAxisEntity.getOrientation().getAxis(r, 0) : "y-axis" === this._yawAxisType && null !== this._yawAxisEntity ? this._yawAxisEntity.getOrientation().getAxis(r, 1) : "z-axis" === this._yawAxisType && null !== this._yawAxisEntity ? this._yawAxisEntity.getOrientation().getAxis(r, 2) : "position" === this._yawAxisType && null !== this._yawAxisEntity ? r.normalize(this._yawAxisEntity.getPosition()) : this.getEntity().getOrientation().getAxis(r, 2),
            r.isNaN() && this.getEntity().getOrientation().getAxis(r, 2);
            const l = s.Quaternion.pool.get();
            l.copy(this.getEntity().getOrientation());
            const c = s.Quaternion.pool.get()
              , h = s.Vector3.pool.get()
              , d = s.Vector3.pool.get();
            this.getEntity().getOrientation().getAxis(d, 1),
            this.getEntity().getOrientation().getAxis(h, 2);
            const u = h.angleAroundAxis(r, d);
            c.setFromAxisAngle(d, u),
            c.normalize(c),
            l.mult(c, l),
            s.Vector3.pool.release(h),
            s.Vector3.pool.release(d);
            const p = s.Vector3.pool.get();
            l.getAxis(p, 0),
            c.setFromAxisAngle(p, this._pitchAngleSmoothedValue),
            l.mult(c, l),
            s.Vector3.pool.release(p),
            c.setFromAxisAngle(r, this._yawAngleSmoothedValue),
            l.mult(c, l),
            s.Vector3.pool.release(r),
            s.Quaternion.pool.release(c),
            this.getEntity().setOrientation(l),
            s.Quaternion.pool.release(l)
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        ModelAnimateController: function() {
            return ModelAnimateController
        }
    });
    var s = i(6);
    class ModelAnimateController extends s.BaseController {
        constructor(t, e) {
            super(t, e),
            this._animations = []
        }
        setAnimation(t, e, i, s) {
            if (null === t)
                throw new Error("Null model specified.");
            this._animations.push({
                model: t,
                jointName: e,
                animationName: i,
                interval: s,
                animationClip: null,
                rootObject: null,
                jointObject: null,
                animationMixer: null
            })
        }
        __update() {
            const t = this.getEntity().getScene().getEngine().getTime();
            for (let e = 0, i = this._animations.length; e < i; e++) {
                const i = this._animations[e];
                if (i.model.isDestroyed())
                    this._animations.splice(e, 1),
                    e--;
                else if (null !== i.model.getThreeJsObjects()[0]) {
                    if (i.rootObject !== i.model.getThreeJsObjects()[0] && (i.rootObject = i.model.getThreeJsObjects()[0],
                    i.animationClip = null,
                    i.jointObject = null,
                    i.animationMixer = null),
                    null === i.animationClip && (i.animationClip = i.model.getAnimationClip(i.animationName)),
                    null === i.jointObject) {
                        const t = i.model.getThreeJsObjectByName(i.jointName);
                        null !== t && (i.jointObject = t)
                    }
                    if (null === i.animationMixer && null !== i.animationClip && null !== i.jointObject && (i.animationMixer = new s.THREE.AnimationMixer(i.jointObject),
                    i.animationMixer.clipAction(i.animationClip).play()),
                    i.animationMixer && i.animationClip) {
                        const e = s.MathUtils.clamp01((t - i.interval.min) / (i.interval.max - i.interval.min))
                          , n = i.animationClip.duration * e * (i.animationClip.tracks[0].times.length - 1) / i.animationClip.tracks[0].times.length;
                        i.animationMixer.setTime(n),
                        i.animationMixer.update(0)
                    }
                } else
                    i.rootObject = null
            }
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        OrbitController: function() {
            return OrbitController
        }
    });
    var s = i(6);
    class OrbitController extends s.BaseController {
        constructor(t, e) {
            super(t, e),
            this._dragSensitivity = .01,
            this._dragSmoothness = .8,
            this._yawChangeSmoothedValue = 0,
            this._pitchChangeSmoothedValue = 0,
            this._yawAxisType = "none",
            this._yawAxisEntity = null,
            this._pitchAxisType = "none",
            this._pitchAxisEntity = null,
            this._slowWhenCloseToParent = !1,
            this._yawAngleLimits = new s.Interval(Number.NEGATIVE_INFINITY,Number.POSITIVE_INFINITY),
            this._yawAngleLimits.freeze(),
            this._pitchAngleLimits = new s.Interval(Number.NEGATIVE_INFINITY,Number.POSITIVE_INFINITY),
            this._pitchAngleLimits.freeze(),
            this.addModifiedState("position"),
            this.addModifiedState("orientation")
        }
        getDragSensitivity() {
            return this._dragSensitivity
        }
        setDragSensitivity(t) {
            this._dragSensitivity = t
        }
        getDragSmoothness() {
            return this._dragSmoothness
        }
        setDragSmoothness(t) {
            this._dragSmoothness = t
        }
        getYawAxisType() {
            return this._yawAxisType
        }
        setYawAxisType(t) {
            this._yawAxisType !== t && (null !== this._yawAxisEntity && (["x-axis", "y-axis", "z-axis"].includes(this._yawAxisType) ? this.removeDependentState(this._yawAxisEntity.getName(), "orientation") : "position" === this._yawAxisType && this.removeDependentState(this._yawAxisEntity.getName(), "position")),
            this._yawAxisType = t,
            null !== this._yawAxisEntity && (["x-axis", "y-axis", "z-axis"].includes(this._yawAxisType) ? this.addDependentState(this._yawAxisEntity.getName(), "orientation") : "position" === this._yawAxisType && this.addDependentState(this._yawAxisEntity.getName(), "position")))
        }
        getPitchAxisType() {
            return this._pitchAxisType
        }
        setPitchAxisType(t) {
            this._pitchAxisType !== t && (null !== this._pitchAxisEntity && (["x-axis", "y-axis", "z-axis"].includes(this._pitchAxisType) ? this.removeDependentState(this._pitchAxisEntity.getName(), "orientation") : "position" === this._pitchAxisType && this.removeDependentState(this._pitchAxisEntity.getName(), "position")),
            this._pitchAxisType = t,
            null !== this._pitchAxisEntity && (["x-axis", "y-axis", "z-axis"].includes(this._pitchAxisType) ? this.addDependentState(this._pitchAxisEntity.getName(), "orientation") : "position" === this._pitchAxisType && this.addDependentState(this._pitchAxisEntity.getName(), "position")))
        }
        getYawAxisEntity() {
            return this._yawAxisEntity
        }
        setYawAxisEntity(t) {
            this._yawAxisEntity !== t && (null !== this._yawAxisEntity && (["x-axis", "y-axis", "z-axis"].includes(this._yawAxisType) ? this.removeDependentState(this._yawAxisEntity.getName(), "orientation") : "position" === this._yawAxisType && this.removeDependentState(this._yawAxisEntity.getName(), "position")),
            this._yawAxisEntity = t,
            null !== this._yawAxisEntity && (["x-axis", "y-axis", "z-axis"].includes(this._yawAxisType) ? this.addDependentState(this._yawAxisEntity.getName(), "orientation") : "position" === this._yawAxisType && this.addDependentState(this._yawAxisEntity.getName(), "position")))
        }
        getPitchAxisEntity() {
            return this._pitchAxisEntity
        }
        setPitchAxisEntity(t) {
            this._pitchAxisEntity !== t && (null !== this._pitchAxisEntity && (["x-axis", "y-axis", "z-axis"].includes(this._pitchAxisType) ? this.removeDependentState(this._pitchAxisEntity.getName(), "orientation") : "position" === this._pitchAxisType && this.removeDependentState(this._pitchAxisEntity.getName(), "position")),
            this._pitchAxisEntity = t,
            null !== this._pitchAxisEntity && (["x-axis", "y-axis", "z-axis"].includes(this._pitchAxisType) ? this.addDependentState(this._pitchAxisEntity.getName(), "orientation") : "position" === this._pitchAxisType && this.addDependentState(this._pitchAxisEntity.getName(), "position")))
        }
        getYawAngleLimits() {
            return this._yawAngleLimits
        }
        setYawAngleLimits(t) {
            this._yawAngleLimits.thaw(),
            this._yawAngleLimits.copy(t),
            this._yawAngleLimits.freeze()
        }
        getPitchAngleLimits() {
            return this._pitchAngleLimits
        }
        setPitchAngleLimits(t) {
            this._pitchAngleLimits.thaw(),
            this._pitchAngleLimits.copy(t),
            this._pitchAngleLimits.freeze()
        }
        isSlowWhenCloseToParent() {
            return this._slowWhenCloseToParent
        }
        slowWhenCloseToParent(t) {
            this._slowWhenCloseToParent = t
        }
        __update() {
            if (null === this.getEntity().getParent())
                return;
            this.getEntity().getOrientation().isNaN() && this.getEntity().setOrientation(s.Quaternion.Identity),
            this.getEntity().getPosition().isNaN() && this.getEntity().setPosition(new s.Vector3(0,-1,0));
            const t = this.getEntity().getScene().getEngine().getInput();
            let e = 1;
            t.isKeyPressed("x") && (e = .05),
            t.isShiftPressed() && (e = 5);
            const i = this.getEntity().getComponent(s.CameraComponent);
            null !== i && (e *= Math.min(1, i.getFieldOfView()));
            let n = 0
              , o = 0;
            const a = t.getActiveViewport();
            if (null !== a) {
                const i = a.getCamera();
                if (null !== i && i.getEntity() === this.getEntity()) {
                    const i = t.getDraggedOffset();
                    n = -i.x * this._dragSensitivity * e,
                    o = i.y * this._dragSensitivity * e,
                    t.isKeyPressed("d") && (n += this._dragSensitivity * e),
                    t.isKeyPressed("a") && (n -= this._dragSensitivity * e),
                    t.isKeyPressed("e") && (o -= this._dragSensitivity * e),
                    t.isKeyPressed("q") && (o += this._dragSensitivity * e)
                }
            }
            this._yawChangeSmoothedValue = s.MathUtils.lerp(n, this._yawChangeSmoothedValue, this._dragSmoothness),
            this._pitchChangeSmoothedValue = s.MathUtils.lerp(o, this._pitchChangeSmoothedValue, this._dragSmoothness),
            Math.abs(this._yawChangeSmoothedValue) < 1e-4 * e && (this._yawChangeSmoothedValue = 0),
            Math.abs(this._pitchChangeSmoothedValue) < 1e-4 * e && (this._pitchChangeSmoothedValue = 0);
            const r = s.Vector3.pool.get();
            null === this._yawAxisEntity && (this._yawAxisEntity = this.getEntity().getParent()),
            "x-axis" === this._yawAxisType && null !== this._yawAxisEntity ? this._yawAxisEntity.getOrientation().getAxis(r, 0) : "y-axis" === this._yawAxisType && null !== this._yawAxisEntity ? this._yawAxisEntity.getOrientation().getAxis(r, 1) : "z-axis" === this._yawAxisType && null !== this._yawAxisEntity ? this._yawAxisEntity.getOrientation().getAxis(r, 2) : "position" === this._yawAxisType && null !== this._yawAxisEntity ? r.normalize(this._yawAxisEntity.getPosition()) : this.getEntity().getOrientation().getAxis(r, 2),
            (r.isNaN() || r.isZero()) && this.getEntity().getOrientation().getAxis(r, 2);
            const l = s.Vector3.pool.get();
            null === this._pitchAxisEntity && (this._pitchAxisEntity = this.getEntity().getParent()),
            "x-axis" === this._pitchAxisType && null !== this._pitchAxisEntity ? this._pitchAxisEntity.getOrientation().getAxis(l, 0) : "y-axis" === this._pitchAxisType && null !== this._pitchAxisEntity ? this._pitchAxisEntity.getOrientation().getAxis(l, 1) : "z-axis" === this._pitchAxisType && null !== this._pitchAxisEntity ? this._pitchAxisEntity.getOrientation().getAxis(l, 2) : "position" === this._pitchAxisType && null !== this._pitchAxisEntity ? l.normalize(this._pitchAxisEntity.getPosition()) : this.getEntity().getOrientation().getAxis(l, 0),
            (l.isNaN() || l.isZero()) && this.getEntity().getOrientation().getAxis(l, 0),
            l.setNormalTo(r, l);
            const c = s.Quaternion.pool.get();
            c.setFromAxes(l, void 0, r),
            s.Vector3.pool.release(l),
            s.Vector3.pool.release(r);
            const h = s.Vector3.pool.get();
            h.rotateInverse(c, this.getEntity().getPosition());
            let d = 1;
            const u = this.getEntity().getParent();
            if (this._slowWhenCloseToParent && u) {
                const t = u.getOcclusionRadius();
                d = s.MathUtils.clamp((h.magnitude() - t) / t, .001, 1)
            }
            const p = s.LatLonAlt.pool.get();
            s.Geometry.getLLAFromXYZOnSphere(p, h, 0),
            p.lat += this._pitchChangeSmoothedValue * d,
            p.lon += this._yawChangeSmoothedValue * d,
            p.lat < 1e-4 - s.MathUtils.halfPi && (p.lat = 1e-4 - s.MathUtils.halfPi),
            p.lat > s.MathUtils.halfPi - 1e-4 && (p.lat = s.MathUtils.halfPi - 1e-4),
            p.lat < this._pitchAngleLimits.min && (p.lat = this._pitchAngleLimits.min),
            p.lat > this._pitchAngleLimits.max && (p.lat = this._pitchAngleLimits.max),
            p.lon < this._yawAngleLimits.min && (p.lon = this._yawAngleLimits.min),
            p.lon > this._yawAngleLimits.max && (p.lon = this._yawAngleLimits.max),
            s.Geometry.getXYZFromLLAOnSphere(h, p, 0),
            s.LatLonAlt.pool.release(p),
            h.rotate(c, h),
            s.Quaternion.pool.release(c),
            this.getEntity().setPosition(h),
            s.Vector3.pool.release(h)
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        OrbitKeyframeController: function() {
            return OrbitKeyframeController
        }
    });
    var s = i(6);
    class OrbitKeyframeController extends s.BaseController {
        constructor(t, e) {
            super(t, e),
            this._positionKeyframes = [],
            this._focusKeyframes = [],
            this._upKeyframes = [],
            this._timeOfFirstUpdate = NaN,
            this._directionOfFirstUpdate = new s.Vector3,
            this._resolvePromise = () => {}
            ,
            this._rejectPromise = null,
            this._endPromise = new Promise(( (t, e) => {
                this._resolvePromise = t,
                this._rejectPromise = e
            }
            )),
            this.addModifiedState("position"),
            this.addModifiedState("velocity"),
            this.addModifiedState("orientation"),
            this.addModifiedState("angularVelocity")
        }
        setPositionKeyframe(t, e, i) {
            if (void 0 !== e) {
                const n = new PositionKeyframe(this.getEntity().getScene());
                n.time = t,
                n.position.copy(e),
                n.relativeTo.setName(i),
                s.Sort.add(n, this._positionKeyframes, OrbitKeyframeController.isLess)
            } else {
                const e = s.Sort.getIndex(t, this._positionKeyframes, OrbitKeyframeController.isLessThanTime);
                e < this._positionKeyframes.length && t === this._positionKeyframes[e].time && this._positionKeyframes.splice(e, 1)
            }
        }
        setFocusKeyframe(t, e) {
            if (void 0 !== e) {
                const i = new FocusKeyframe(this.getEntity().getScene());
                i.time = t,
                i.focus.setName(e),
                s.Sort.add(i, this._focusKeyframes, OrbitKeyframeController.isLess)
            } else {
                const e = s.Sort.getIndex(t, this._focusKeyframes, OrbitKeyframeController.isLessThanTime);
                e < this._focusKeyframes.length && t === this._focusKeyframes[e].time && this._focusKeyframes.splice(e, 1)
            }
        }
        setUpKeyframe(t, e) {
            if (void 0 !== e) {
                const i = new UpKeyframe;
                i.time = t,
                i.up.copy(e),
                s.Sort.add(i, this._upKeyframes, OrbitKeyframeController.isLess)
            } else {
                const e = s.Sort.getIndex(t, this._upKeyframes, OrbitKeyframeController.isLessThanTime);
                e < this._upKeyframes.length && t === this._upKeyframes[e].time && this._upKeyframes.splice(e, 1)
            }
        }
        async getEndPromise() {
            await this._endPromise
        }
        __destroy() {
            super.__destroy(),
            null !== this._rejectPromise && this._rejectPromise(new Error(`Could not complete keyframes because ${this} was destroyed.`))
        }
        __update() {
            const t = this.getEntity();
            let e = 0;
            if (isNaN(this._timeOfFirstUpdate)) {
                const e = t.getParent();
                if (null === e)
                    return;
                this._timeOfFirstUpdate = Date.now() / 1e3,
                t.getOrientation().getAxis(this._directionOfFirstUpdate, 1);
                const i = new PositionKeyframe(t.getScene());
                i.time = 0,
                i.position.copy(t.getPosition()),
                i.relativeTo.setName(e.getName()),
                s.Sort.add(i, this._positionKeyframes, OrbitKeyframeController.isLess);
                const n = new FocusKeyframe(t.getScene());
                n.time = 0,
                n.focus.setName(""),
                s.Sort.add(n, this._focusKeyframes, OrbitKeyframeController.isLess);
                const o = new UpKeyframe;
                o.time = 0,
                t.getOrientation().getAxis(o.up, 2),
                s.Sort.add(o, this._upKeyframes, OrbitKeyframeController.isLess)
            } else
                e = Date.now() / 1e3 - this._timeOfFirstUpdate;
            let i = !1;
            const n = s.Sort.getIndex(e, this._positionKeyframes, OrbitKeyframeController.isLessThanTime);
            if (n > 0 && n < this._positionKeyframes.length) {
                const i = this._positionKeyframes[n - 1]
                  , o = this._positionKeyframes[n]
                  , a = i.relativeTo.get()
                  , r = o.relativeTo.get();
                if (null !== a && null !== r) {
                    let n = (e - i.time) / (o.time - i.time)
                      , l = a;
                    n >= .5 && (l = r),
                    t.getParent() !== l && t.setParent(l);
                    const c = s.Vector3.pool.get()
                      , h = s.Vector3.pool.get();
                    a.getPositionRelativeToEntity(c, i.position, r),
                    r.getPositionRelativeToEntity(h, o.position, a);
                    let d = Math.max(0, i.position.magnitude() - a.getOcclusionRadius())
                      , u = Math.max(0, h.magnitude() - a.getOcclusionRadius())
                      , p = Math.max(0, c.magnitude() - r.getOcclusionRadius())
                      , m = Math.max(0, o.position.magnitude() - r.getOcclusionRadius());
                    if (d = Math.max(d, u / 1e4),
                    u = Math.max(u, d / 1e4),
                    p = Math.max(p, m / 1e4),
                    m = Math.max(m, u / 1e4),
                    d !== u && p !== m) {
                        const t = (u ** n * d ** (1 - n) - d) / (u - d)
                          , e = (m ** n * p ** (1 - n) - p) / (m - p);
                        n = s.MathUtils.lerp(t, e, n)
                    }
                    const _ = n * n;
                    n = _ / (2 * (_ - n) + 1),
                    a.getPositionRelativeToEntity(c, i.position, l),
                    r.getPositionRelativeToEntity(h, o.position, l);
                    const g = s.Vector3.pool.get();
                    a === r ? g.slerp(c, h, n) : g.lerp(c, h, n),
                    t.setPosition(g),
                    s.Vector3.pool.release(g),
                    s.Vector3.pool.release(c),
                    s.Vector3.pool.release(h)
                }
            } else if (n === this._positionKeyframes.length) {
                const e = this._positionKeyframes[this._positionKeyframes.length - 1]
                  , s = e.relativeTo.get();
                t.getParent() !== s && t.setParent(s),
                t.setPosition(e.position),
                i = !0
            }
            const o = s.Vector3.pool.get();
            o.setMagnitude(t.getPosition(), -1);
            const a = s.Vector3.pool.get();
            t.getOrientation().getAxis(a, 2);
            let r = !1;
            const l = s.Sort.getIndex(e, this._focusKeyframes, OrbitKeyframeController.isLessThanTime);
            if (l > 0 && l < this._focusKeyframes.length) {
                const i = this._focusKeyframes[l - 1]
                  , n = this._focusKeyframes[l]
                  , a = i.focus.get()
                  , r = n.focus.get()
                  , c = t.getParent();
                if (!("" !== i.focus.getName() && null === a || "" !== n.focus.getName() && null === r || null === c)) {
                    let l = (e - i.time) / (n.time - i.time);
                    const h = l * l;
                    l = h / (2 * (h - l) + 1);
                    const d = s.Vector3.pool.get()
                      , u = s.Vector3.pool.get();
                    a ? (c.getPositionRelativeToEntity(d, t.getPosition(), a),
                    d.setMagnitude(d, -1)) : d.copy(this._directionOfFirstUpdate),
                    r ? (c.getPositionRelativeToEntity(u, t.getPosition(), r),
                    u.setMagnitude(u, -1)) : u.copy(this._directionOfFirstUpdate),
                    o.slerp(d, u, l),
                    s.Vector3.pool.release(d),
                    s.Vector3.pool.release(u)
                }
            } else if (l === this._focusKeyframes.length) {
                const e = this._focusKeyframes[this._focusKeyframes.length - 1].focus.get()
                  , i = t.getParent();
                null !== e && null !== i && (i.getPositionRelativeToEntity(o, t.getPosition(), e),
                o.setMagnitude(o, -1)),
                r = !0
            } else {
                const e = this._focusKeyframes[0]
                  , i = e.focus.get()
                  , s = t.getParent();
                "" !== e.focus.getName() && null === i || null === s || (i ? (s.getPositionRelativeToEntity(o, t.getPosition(), i),
                o.setMagnitude(o, -1)) : o.copy(this._directionOfFirstUpdate))
            }
            let c = !1;
            const h = s.Sort.getIndex(e, this._upKeyframes, OrbitKeyframeController.isLessThanTime);
            if (h > 0 && h < this._upKeyframes.length) {
                const t = this._upKeyframes[h - 1]
                  , i = this._upKeyframes[h];
                let s = (e - t.time) / (i.time - t.time);
                const n = s * s;
                s = n / (2 * (n - s) + 1),
                a.slerp(t.up, i.up, s)
            } else if (h === this._upKeyframes.length) {
                const t = this._upKeyframes[this._upKeyframes.length - 1];
                a.copy(t.up),
                c = !0
            }
            const d = s.Quaternion.pool.get();
            a.setNormalTo(o, a),
            d.setFromAxes(void 0, o, a),
            t.setOrientation(d),
            s.Quaternion.pool.release(d),
            s.Vector3.pool.release(o),
            i && r && c && (this._rejectPromise = null,
            this._resolvePromise())
        }
        static isLess = (t, e) => t.time < e.time;
        static isLessThanTime = (t, e) => t.time < e
    }
    class Keyframe {
        constructor() {
            this.time = NaN
        }
    }
    class PositionKeyframe extends Keyframe {
        constructor(t) {
            super(),
            this.position = new s.Vector3,
            this.relativeTo = new s.EntityRef(t)
        }
    }
    class FocusKeyframe extends Keyframe {
        constructor(t) {
            super(),
            this.focus = new s.EntityRef(t)
        }
    }
    class UpKeyframe extends Keyframe {
        constructor() {
            super(),
            this.up = new s.Vector3
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        OrbitalElementsController: function() {
            return OrbitalElementsController
        },
        OrbitalElementsKeyFrame: function() {
            return OrbitalElementsKeyFrame
        }
    });
    var s = i(6);
    class OrbitalElementsController extends s.BaseController {
        constructor(t, e) {
            super(t, e),
            this._orbitalElementsKeyFrames = [],
            this.setCoverage(new s.Interval(Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY)),
            this.addModifiedState("position"),
            this.addModifiedState("velocity")
        }
        getNumOrbitalElements() {
            return this._orbitalElementsKeyFrames.length
        }
        getOrbitalElements(t) {
            return this._orbitalElementsKeyFrames[t]
        }
        addOrbitalElements(t, e) {
            s.Sort.add({
                time: t,
                oe: e
            }, this._orbitalElementsKeyFrames, OrbitalElementsController.isLessAdd, OrbitalElementsController.isEqualAdd),
            this._updateCoverage()
        }
        removeOrbitalElements(t) {
            if (t < 0 || this._orbitalElementsKeyFrames.length <= t)
                throw new Error(`Invalid index for ${this}.removeOrbitalElements`);
            this._orbitalElementsKeyFrames.splice(t, 1),
            this._updateCoverage()
        }
        __updatePositionAtTime(t, e) {
            this._getPositionAtTime(t, e)
        }
        __updateVelocityAtTime(t, e) {
            this._getVelocityAtTime(t, e)
        }
        __update() {
            const t = this.getEntity().getScene().getEngine().getTime();
            this._getPositionAtTime(OrbitalElementsController._tempPosition, t) && this.getEntity().setPosition(OrbitalElementsController._tempPosition),
            this._getVelocityAtTime(OrbitalElementsController._tempVelocity, t) && this.getEntity().setVelocity(OrbitalElementsController._tempVelocity)
        }
        _getPositionAtTime(t, e) {
            const i = s.Sort.getIndex(e, this._orbitalElementsKeyFrames, OrbitalElementsController.isLess)
              , n = this._orbitalElementsKeyFrames[Math.max(i - 1, 0)]
              , o = this._orbitalElementsKeyFrames[Math.min(i, this._orbitalElementsKeyFrames.length - 1)]
              , a = s.Vector3.pool.get()
              , r = s.Vector3.pool.get();
            n.oe.project(a, OrbitalElementsController._tempVelocity, e),
            o.oe.project(r, OrbitalElementsController._tempVelocity, e);
            const l = s.MathUtils.clamp01(o.time !== n.time ? (e - n.time) / (o.time - n.time) : 0);
            return t.slerp(a, r, l),
            s.Vector3.pool.release(a),
            s.Vector3.pool.release(r),
            !0
        }
        _getVelocityAtTime(t, e) {
            const i = s.Sort.getIndex(e, this._orbitalElementsKeyFrames, OrbitalElementsController.isLess)
              , n = this._orbitalElementsKeyFrames[Math.max(i - 1, 0)]
              , o = this._orbitalElementsKeyFrames[Math.min(i, this._orbitalElementsKeyFrames.length - 1)]
              , a = s.Vector3.pool.get()
              , r = s.Vector3.pool.get();
            n.oe.project(OrbitalElementsController._tempPosition, a, e),
            o.oe.project(OrbitalElementsController._tempPosition, r, e);
            const l = s.MathUtils.clamp01(o.time !== n.time ? (e - n.time) / (o.time - n.time) : 0);
            return t.slerp(a, r, l),
            s.Vector3.pool.release(a),
            s.Vector3.pool.release(r),
            !0
        }
        _updateCoverage() {
            const t = new s.Interval(Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY);
            this._orbitalElementsKeyFrames.length > 1 && (t.min = Math.min(t.min, this._orbitalElementsKeyFrames[0].time),
            t.max = Math.max(t.max, this._orbitalElementsKeyFrames[this._orbitalElementsKeyFrames.length - 1].time)),
            this.setCoverage(t)
        }
        static isLessAdd = (t, e) => t.time < e.time;
        static isLess = (t, e) => t.time < e;
        static isEqualAdd = (t, e) => t.time === e.time;
        static _tempPosition = new s.Vector3;
        static _tempVelocity = new s.Vector3
    }
    class OrbitalElementsKeyFrame {
        constructor() {
            this.time = 0,
            this.oe = new s.OrbitalElements
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        PickController: function() {
            return PickController
        }
    });
    var s = i(6);
    class PickController extends s.BaseController {
        constructor(t, e) {
            super(t, e),
            this._pickedEntity = null,
            this._callback = null,
            this._triggerOnHover = !1,
            this._pickedPosition = new s.Vector3,
            this._pickedPosition.freeze()
        }
        getPickedEntity() {
            return this._pickedEntity
        }
        setPickedEntity(t) {
            this._pickedEntity = t
        }
        getCallback() {
            return this._callback
        }
        setCallback(t) {
            this._callback = t
        }
        getTriggerOnHover() {
            return this._triggerOnHover
        }
        setTriggerOnHover(t) {
            this._triggerOnHover = t
        }
        getPickedPosition() {
            return this._pickedPosition
        }
        __update() {
            const t = this.getEntity().getScene().getEngine().getInput();
            if ((t.isSelected() || this._triggerOnHover) && null !== this._callback && null !== this._pickedEntity) {
                const e = t.getActiveViewport();
                if (null !== e) {
                    const i = e.getCamera();
                    if (null !== i && i.getEntity() === this.getEntity()) {
                        const n = s.Vector3.pool.get();
                        e.getNormalSpacePositionFromPixelSpacePosition(n, t.getCursorPosition()),
                        i.getCameraSpacePositionFromNormalSpacePosition(n, n),
                        n.normalize(n);
                        const o = s.Interval.pool.get()
                          , a = this.getEntity().getParent()?.getComponent(s.SpheroidComponent);
                        if (a) {
                            const t = a.getEquatorialRadius() / a.getPolarRadius();
                            n.rotateInverse(this._pickedEntity.getOrientation(), n),
                            n.z *= t;
                            const e = s.Vector3.pool.get();
                            e.copy(this._pickedEntity.getCameraSpacePosition(i)),
                            e.rotateInverse(this._pickedEntity.getOrientation(), e),
                            e.z *= t,
                            s.Geometry.getLineSphereIntersectionWithLineStartAtOrigin(o, n, e, a.getEquatorialRadius()),
                            n.z /= t,
                            n.rotate(this._pickedEntity.getOrientation(), n),
                            s.Vector3.pool.release(e)
                        } else {
                            const t = this._pickedEntity.getCameraSpacePosition(i);
                            s.Geometry.getLineSphereIntersectionWithLineStartAtOrigin(o, n, t, this._pickedEntity.getOcclusionRadius())
                        }
                        Number.isNaN(o.min) || (this._pickedPosition.thaw(),
                        this._pickedPosition.mult(n, o.min),
                        i.getEntity().getPositionRelativeToEntity(this._pickedPosition, this._pickedPosition, this._pickedEntity),
                        this._pickedPosition.freeze(),
                        this.getEntity().getScene().getEngine().addCallback(this._callback.bind(void 0, this._pickedPosition), !1)),
                        s.Interval.pool.release(o),
                        s.Vector3.pool.release(n)
                    }
                }
            }
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        RollController: function() {
            return RollController
        }
    });
    var s = i(6);
    class RollController extends s.BaseController {
        constructor(t, e) {
            super(t, e),
            this._rollSensitivity = .01,
            this._rollSmoothness = .8,
            this._rollAngleSmoothedValue = 0,
            this.addModifiedState("orientation")
        }
        getRollSensitivity() {
            return this._rollSensitivity
        }
        setRollSensitivity(t) {
            this._rollSensitivity = t
        }
        getRollSmoothness() {
            return this._rollSmoothness
        }
        setRollSmoothness(t) {
            this._rollSmoothness = t
        }
        __update() {
            this.getEntity().getOrientation().isNaN() && this.getEntity().setOrientation(s.Quaternion.Identity);
            let t = 0;
            const e = this.getEntity().getScene().getEngine().getInput()
              , i = e.getActiveViewport();
            if (null !== i) {
                const n = i.getCamera();
                if (null !== n && n.getEntity() === this.getEntity()) {
                    let i = 1;
                    e.isKeyPressed("x") && (i = .05),
                    e.isShiftPressed() && (i = 5);
                    const n = e.getRotatedOffset();
                    0 !== n && (t += s.MathUtils.clamp(n * this._rollSensitivity * i, -.1, .1)),
                    e.isKeyPressed("c") && (t += this._rollSensitivity * i),
                    e.isKeyPressed("z") && (t -= this._rollSensitivity * i)
                }
            }
            if (this._rollAngleSmoothedValue = s.MathUtils.lerp(t, this._rollAngleSmoothedValue, this._rollSmoothness),
            Math.abs(this._rollAngleSmoothedValue) < 1e-4 && (this._rollAngleSmoothedValue = 0),
            0 !== this._rollAngleSmoothedValue) {
                const t = s.Quaternion.pool.get()
                  , e = s.Quaternion.pool.get();
                e.setFromAxisAngle(s.Vector3.YAxis, this._rollAngleSmoothedValue),
                t.mult(this.getEntity().getOrientation(), e),
                this.getEntity().setOrientation(t),
                s.Quaternion.pool.release(t),
                s.Quaternion.pool.release(e)
            }
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        RotateController: function() {
            return RotateController
        }
    });
    var s = i(6);
    class RotateController extends s.BaseController {
        constructor(t, e) {
            super(t, e),
            this._rotation = new s.Quaternion,
            this._rotation.freeze(),
            this._rotatingPosition = !0,
            this._rotatingOrientation = !0,
            this._joint = "",
            this._jointObject = null,
            this._jointObjectIndex = 0,
            this._model = null,
            this.addModifiedState("position"),
            this.addModifiedState("velocity"),
            this.addModifiedState("orientation"),
            this.addModifiedState("angularVelocity")
        }
        getRotation() {
            return this._rotation
        }
        setRotation(t) {
            this._rotation.thaw(),
            this._rotation.copy(t),
            this._rotation.freeze()
        }
        isRotatingPosition() {
            return this._rotatingPosition
        }
        setRotatingPosition(t) {
            this._rotatingPosition = t,
            this._updateModifiedStates()
        }
        isRotatingOrientation() {
            return this._rotatingOrientation
        }
        setRotatingOrientation(t) {
            this._rotatingOrientation = t,
            this._updateModifiedStates()
        }
        setJoint(t, e) {
            if (this._joint = t,
            e)
                this._model = e;
            else {
                const t = this.getEntity().getComponent(s.ModelComponent);
                null !== t && (this._model = t)
            }
            this._updateModifiedStates()
        }
        __updatePositionAtTime(t, e) {
            this._rotatingPosition && "" === this._joint && t.rotate(this._rotation, t)
        }
        __updateVelocityAtTime(t, e) {
            this._rotatingPosition && "" === this._joint && t.rotate(this._rotation, t)
        }
        __updateOrientationAtTime(t, e) {
            this._rotatingOrientation && "" === this._joint && t.mult(this._rotation, t)
        }
        __update() {
            if ("" === this._joint) {
                if (this._rotatingPosition) {
                    const t = s.Vector3.pool.get();
                    t.rotate(this._rotation, this.getEntity().getPosition()),
                    this.getEntity().setPosition(t),
                    s.Vector3.pool.release(t);
                    const e = s.Vector3.pool.get();
                    e.rotate(this._rotation, this.getEntity().getVelocity()),
                    this.getEntity().setVelocity(e),
                    s.Vector3.pool.release(e)
                }
                if (this._rotatingOrientation) {
                    const t = s.Quaternion.pool.get();
                    t.mult(this._rotation, this.getEntity().getOrientation()),
                    this.getEntity().setOrientation(t),
                    s.Quaternion.pool.release(t);
                    const e = s.Vector3.pool.get();
                    e.rotate(this._rotation, this.getEntity().getAngularVelocity()),
                    this.getEntity().setAngularVelocity(e),
                    s.Vector3.pool.release(e)
                }
            } else {
                if (null !== this._jointObject && this._model?.getThreeJsObjects()[this._jointObjectIndex] !== this._jointObject && (this._jointObject = null),
                "" !== this._joint && (null === this._jointObject || this._jointObject.name !== this._joint) && null !== this._model) {
                    const t = this._model.getThreeJsObjectByName(this._joint);
                    null !== t && (this._jointObject = t,
                    this._jointObjectIndex = this._model.getThreeJsObjects().indexOf(this._jointObject))
                }
                this._jointObject && s.ThreeJsHelper.setOrientation(this._jointObject, this._rotation)
            }
        }
        _updateModifiedStates() {
            "" === this._joint && this._rotatingOrientation ? (this.addModifiedState("orientation"),
            this.addModifiedState("angularVelocity")) : (this.removeModifiedState("orientation"),
            this.removeModifiedState("angularVelocity")),
            "" === this._joint && this._rotatingPosition ? (this.addModifiedState("position"),
            this.addModifiedState("velocity")) : (this.removeModifiedState("position"),
            this.removeModifiedState("velocity"))
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        RotateByEntityOrientationController: function() {
            return RotateByEntityOrientationController
        }
    });
    var s = i(6);
    class RotateByEntityOrientationController extends s.BaseController {
        constructor(t, e) {
            super(t, e),
            this._entityRef = new s.EntityRef(this.getEntity().getScene()),
            this._rotatingPosition = !0,
            this._rotatingOrientation = !0,
            this.addModifiedState("position"),
            this.addModifiedState("velocity"),
            this.addModifiedState("orientation"),
            this.addModifiedState("angularVelocity")
        }
        setEntityForOrientation(t) {
            "" !== this._entityRef.getName() && this.addDependentState(this._entityRef.getName(), "orientation"),
            this._entityRef.setName(t),
            this.addDependentState(t, "orientation")
        }
        isRotatingPosition() {
            return this._rotatingPosition
        }
        setRotatingPosition(t) {
            this._rotatingPosition = t,
            t ? (this.addModifiedState("position"),
            this.addModifiedState("velocity")) : (this.removeModifiedState("position"),
            this.removeModifiedState("velocity"))
        }
        isRotatingOrientation() {
            return this._rotatingOrientation
        }
        setRotatingOrientation(t) {
            this._rotatingOrientation = t,
            t ? (this.addModifiedState("orientation"),
            this.addModifiedState("angularVelocity")) : (this.removeModifiedState("orientation"),
            this.removeModifiedState("angularVelocity"))
        }
        __updatePositionAtTime(t, e) {
            if (this._rotatingPosition) {
                const i = "" !== this._entityRef.getName() ? this._entityRef.get() : this.getEntity().getScene().getEntity(this.getEntity().getParentAtTime(e));
                if (null !== i) {
                    const n = s.Quaternion.pool.get();
                    i.getOrientationAtTime(n, e),
                    t.rotate(n, t),
                    s.Quaternion.pool.release(n)
                }
            }
        }
        __updateVelocityAtTime(t, e) {
            if (this._rotatingPosition) {
                const i = "" !== this._entityRef.getName() ? this._entityRef.get() : this.getEntity().getScene().getEntity(this.getEntity().getParentAtTime(e));
                if (null !== i) {
                    const n = s.Quaternion.pool.get();
                    i.getOrientationAtTime(n, e),
                    t.rotate(n, t),
                    s.Quaternion.pool.release(n)
                }
            }
        }
        __updateOrientationAtTime(t, e) {
            if (this._rotatingOrientation) {
                const i = "" !== this._entityRef.getName() ? this._entityRef.get() : this.getEntity().getScene().getEntity(this.getEntity().getParentAtTime(e));
                if (null !== i) {
                    const n = s.Quaternion.pool.get();
                    i.getOrientationAtTime(n, e),
                    t.mult(n, t),
                    s.Quaternion.pool.release(n)
                }
            }
        }
        __update() {
            const t = "" !== this._entityRef.getName() ? this._entityRef.get() : this.getEntity().getParent();
            if (null !== t) {
                if (this._rotatingPosition) {
                    const e = s.Vector3.pool.get();
                    e.rotate(t.getOrientation(), this.getEntity().getPosition()),
                    this.getEntity().setPosition(e),
                    s.Vector3.pool.release(e);
                    const i = s.Vector3.pool.get();
                    i.rotate(t.getOrientation(), this.getEntity().getVelocity()),
                    this.getEntity().setVelocity(i),
                    s.Vector3.pool.release(i)
                }
                if (this._rotatingOrientation) {
                    const e = s.Quaternion.pool.get();
                    e.mult(t.getOrientation(), this.getEntity().getOrientation()),
                    this.getEntity().setOrientation(e),
                    s.Quaternion.pool.release(e);
                    const i = s.Vector3.pool.get();
                    i.rotate(t.getOrientation(), this.getEntity().getAngularVelocity()),
                    this.getEntity().setAngularVelocity(i),
                    s.Vector3.pool.release(i)
                }
            }
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        ScaleController: function() {
            return ScaleController
        }
    });
    var s = i(6);
    class ScaleController extends s.BaseController {
        constructor(t, e) {
            super(t, e),
            this._scale = 1,
            this.addModifiedState("position")
        }
        getScale() {
            return this._scale
        }
        setScale(t) {
            this._scale = t
        }
        __updatePositionAtTime(t, e) {
            t.mult(t, this._scale)
        }
        __updateVelocityAtTime(t, e) {
            t.mult(t, this._scale)
        }
        __update() {
            const t = s.Vector3.pool.get();
            t.mult(this.getEntity().getPosition(), this._scale),
            this.getEntity().setPosition(t),
            s.Vector3.pool.release(t)
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        SelectController: function() {
            return SelectController
        }
    });
    var s = i(6);
    class SelectController extends s.BaseController {
        constructor(t, e) {
            super(t, e),
            this._callback = null
        }
        getCallback() {
            return this._callback
        }
        setCallback(t) {
            this._callback = t
        }
        __update() {
            const t = this.getEntity().getScene().getEngine().getInput();
            if (t.isSelected() && null !== this._callback) {
                const e = t.getActiveViewport();
                if (null !== e) {
                    const i = e.getCamera();
                    if (null !== i && i.getEntity() === this.getEntity()) {
                        const n = s.Vector3.pool.get();
                        e.getNormalSpacePositionFromPixelSpacePosition(n, t.getSelectedPosition());
                        let o = null
                          , a = 0;
                        const r = s.Vector2.pool.get();
                        r.set(n.x, n.y);
                        const l = this.getEntity().getScene().getNumEntities();
                        for (let t = 0; t < l; t++) {
                            const e = this.getEntity().getScene().getEntityAt(t);
                            if (e.isEnabled()) {
                                const t = e.getComponent(s.LabelComponent);
                                if (null !== t && "loaded" === t.getLoadState().state) {
                                    const s = t.getNormalSpaceBounds(i);
                                    if (void 0 !== s && s.contains(r)) {
                                        const t = e.getCameraSpacePosition(i).magnitude();
                                        (null === o || a > t) && (o = e,
                                        a = t)
                                    }
                                }
                            }
                        }
                        s.Vector2.pool.release(r),
                        null === o && (i.getCameraSpacePositionFromNormalSpacePosition(n, n),
                        n.mult(n, 1 / n.magnitude()),
                        o = i.getNearestIntersectingEntity(n)),
                        s.Vector3.pool.release(n),
                        this.getEntity().getScene().getEngine().addCallback(this._callback.bind(void 0, o), !1)
                    }
                }
            }
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        SetParentController: function() {
            return SetParentController
        }
    });
    var s = i(6);
    class SetParentController extends s.BaseController {
        constructor(t, e) {
            super(t, e),
            this._parent = new s.EntityRef(this.getEntity().getScene())
        }
        getParent() {
            return this._parent.getName()
        }
        setParent(t) {
            "" !== this._parent.getName() && this.removeDependentState(this._parent.getName(), "position"),
            this._parent.setName(t),
            "" !== this._parent.getName() && this.addDependentState(this._parent.getName(), "position")
        }
        __update() {
            const t = this._parent.get();
            this.getEntity().setParent(t)
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        SpinController: function() {
            return SpinController
        }
    });
    var s = i(6);
    class SpinController extends s.BaseController {
        constructor(t, e) {
            super(t, e),
            this._axis = new s.Vector3(0,0,1),
            this._axis.freeze(),
            this._axisRelativeToEntity = !0,
            this._rate = 0,
            this._referenceAngle = 0,
            this._referenceTime = void 0,
            this._clampedToRealTime = !1,
            this._usingRealTime = !1,
            this._rotatingPosition = !1,
            this._joint = "",
            this._jointObject = null,
            this._jointObjectIndex = 0,
            this._model = null,
            this._lastTime = e.getScene().getEngine().getTime(),
            this.addModifiedState("orientation")
        }
        getAxis() {
            return this._axis
        }
        isAxisRelativeToEntity() {
            return this._axisRelativeToEntity
        }
        setAxis(t, e) {
            this._axis.thaw(),
            this._axis.copy(t),
            this._axis.freeze(),
            this._axisRelativeToEntity = e
        }
        getRate() {
            return this._rate
        }
        setRate(t) {
            this._rate = t
        }
        getReferenceAngle() {
            return this._referenceAngle
        }
        setReferenceAngle(t) {
            this._referenceAngle = t
        }
        getReferenceTime() {
            return this._referenceTime
        }
        setReferenceTime(t) {
            this._referenceTime = t
        }
        isClampedToRealTime() {
            return this._clampedToRealTime
        }
        setClampedToRealTime(t) {
            this._clampedToRealTime = t
        }
        isUsingRealTime() {
            return this._usingRealTime
        }
        setUsingRealTime(t) {
            this._usingRealTime = t
        }
        isRotatingPosition() {
            return this._rotatingPosition
        }
        setRotatingPosition(t) {
            this._rotatingPosition = t,
            t ? this.addModifiedState("position") : this.removeModifiedState("position")
        }
        setJoint(t, e) {
            if (this._joint = t,
            e)
                this._model = e;
            else {
                const t = this.getEntity().getComponent(s.ModelComponent);
                null !== t && (this._model = t)
            }
            "" !== this._joint ? (this.removeModifiedState("orientation"),
            this.removeModifiedState("position")) : (this.addModifiedState("orientation"),
            this._rotatingPosition && this.addModifiedState("position"))
        }
        __updatePositionAtTime(t, e) {
            if (this._rotatingPosition) {
                let i = 0;
                this._usingRealTime || void 0 !== this._referenceTime && (i = e - this._referenceTime,
                i -= this._referenceAngle / this._rate);
                const n = s.Quaternion.pool.get();
                if (n.setFromAxisAngle(this._axis, this._rate * i),
                null === this._jointObject) {
                    if (this._axisRelativeToEntity) {
                        const t = s.Quaternion.pool.get();
                        this.getEntity().getOrientationAtTime(t, e),
                        n.mult(t, n),
                        n.multInverseR(n, t),
                        s.Quaternion.pool.release(t)
                    }
                    t.rotate(n, t)
                }
                s.Quaternion.pool.release(n)
            }
        }
        __updateOrientationAtTime(t, e) {
            t.isNaN() && t.copy(s.Quaternion.Identity);
            let i = 0;
            this._usingRealTime || void 0 !== this._referenceTime && (i = e - this._referenceTime,
            i -= this._referenceAngle / this._rate);
            const n = s.Quaternion.pool.get();
            n.setFromAxisAngle(this._axis, this._rate * i),
            null === this._jointObject && (this._axisRelativeToEntity && (n.mult(t, n),
            n.multInverseR(n, t)),
            t.mult(n, t),
            t.normalize(t)),
            s.Quaternion.pool.release(n)
        }
        __update() {
            this.getEntity().getOrientation().isNaN() && this.getEntity().setOrientation(s.Quaternion.Identity);
            const t = this.getEntity().getScene().getEngine();
            let e;
            if (this._usingRealTime)
                e = t.getDeltaTime();
            else if (void 0 !== this._referenceTime)
                e = t.getTime() - this._referenceTime,
                e -= this._referenceAngle / this._rate;
            else if (e = t.getTime() - this._lastTime,
            this._clampedToRealTime) {
                const i = t.getDeltaTime();
                e = s.MathUtils.clamp(e, -i, i)
            }
            const i = s.Quaternion.pool.get();
            if (i.setFromAxisAngle(this._axis, this._rate * e),
            null !== this._jointObject && this._model?.getThreeJsObjects()[this._jointObjectIndex] !== this._jointObject && (this._jointObject = null),
            "" !== this._joint && (null === this._jointObject || this._jointObject.name !== this._joint) && null !== this._model) {
                const t = this._model.getThreeJsObjectByName(this._joint);
                null !== t && (this._jointObject = t,
                this._jointObjectIndex = this._model.getThreeJsObjects().indexOf(this._jointObject))
            }
            const n = this.getEntity().getOrientation();
            if (null !== this._jointObject) {
                this._axisRelativeToEntity || (i.multInverseL(n, i),
                i.mult(i, n));
                const t = s.Quaternion.threeJsPool.get();
                t.set(i.x, i.y, i.z, i.w),
                this._jointObject.quaternion.multiplyQuaternions(t, this._jointObject.quaternion),
                this._rotatingPosition && this._jointObject.position.applyQuaternion(t),
                s.Quaternion.threeJsPool.release(t)
            } else {
                const t = s.Quaternion.pool.get();
                this._axisRelativeToEntity && (i.mult(n, i),
                i.multInverseR(i, n)),
                t.mult(i, n),
                t.normalize(t);
                const e = s.Vector3.pool.get();
                if (e.mult(this._axis, this._rate),
                this._axisRelativeToEntity && e.rotate(t, e),
                this.getEntity().setOrientation(t),
                this.getEntity().setAngularVelocity(e),
                s.Vector3.pool.release(e),
                s.Quaternion.pool.release(t),
                this._rotatingPosition) {
                    const t = s.Vector3.pool.get();
                    t.rotate(i, this.getEntity().getPosition()),
                    this.getEntity().setPosition(t),
                    s.Vector3.pool.release(t)
                }
            }
            s.Quaternion.pool.release(i),
            this._lastTime = t.getTime()
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        TapController: function() {
            return TapController
        }
    });
    var s = i(6);
    class TapController extends s.BaseController {
        constructor(t, e) {
            super(t, e),
            this._tapCallback = null
        }
        getTapCallback() {
            return this._tapCallback
        }
        setTapCallback(t) {
            this._tapCallback = t
        }
        __update() {
            const t = this.getEntity().getScene().getEngine().getInput();
            !t.isSelected() && t.getDraggedOffset().isZero() || null !== this._tapCallback && this._tapCallback()
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        TransitionController: function() {
            return TransitionController
        }
    });
    var s = i(6);
    class TransitionController extends s.BaseController {
        constructor(t, e) {
            super(t, e),
            this._initialPosition = new s.Vector3,
            this._initialPosition.copy(e.getPosition()),
            this._initialOrientation = new s.Quaternion,
            this._initialOrientation.copy(e.getOrientation()),
            this._initialParent = new s.EntityRef(this.getEntity().getScene()),
            this._transitionStart = Number.NaN,
            this._transitionTime = 1,
            this._transitionFunction = this._lerpTransitionFunction,
            this._resolvePromise = () => {}
            ,
            this._rejectPromise = () => {}
            ,
            this._endPromise = new Promise(( (t, e) => {
                this._resolvePromise = t,
                this._rejectPromise = e
            }
            ));
            const i = this.getEntity().getParent();
            null !== i && this._initialParent.setName(i.getName());
            const n = this.getEntity().getController(TransitionController);
            null !== n && this.getEntity().removeController(n);
            const o = this.getEntity().addController(s.SetParentController, "transitionSetParent", this.getEntity().getControllerAt(0));
            null !== i && o.setParent(i.getName())
        }
        getTransitionTime() {
            return this._transitionTime
        }
        setTransitionTime(t) {
            this._transitionTime = t
        }
        setTransitionFunction(t) {
            this._transitionFunction = t
        }
        getParent() {
            const t = this.getEntity().getController(s.SetParentController, "transitionSetParent");
            if (null !== t)
                return t.getName();
            const e = this.getEntity().getParent();
            return null !== e ? e.getName() : ""
        }
        setParent(t) {
            const e = this.getEntity().getController(s.SetParentController, "transitionSetParent");
            null !== e && e.setParent(t)
        }
        async getEndPromise() {
            await this._endPromise
        }
        __destroy() {
            super.__destroy();
            const t = this.getEntity().getController(s.SetParentController, "transitionSetParent");
            null !== t && this.getEntity().removeController(t),
            0 !== this._transitionTime && this._rejectPromise(new Error("Transition controller was destroyed before completing."))
        }
        __update() {
            const t = this._initialParent.get()
              , e = this.getEntity().getParent();
            null === e && (this._transitionTime = 0,
            this.getEntity().removeController(this),
            this._rejectPromise(new Error("The final parent was destroyed or disabled before the transition could complete."))),
            Number.isNaN(this._transitionStart) && (this._transitionStart = Date.now() / 1e3);
            const i = this.getEntity().getController(s.SetParentController, "transitionSetParent");
            if (null !== i) {
                if (null === t)
                    return void this.getEntity().getScene().getEngine().addCallback(( () => {
                        this._transitionTime = 0,
                        this.getEntity().removeController(this),
                        "" !== this._initialParent.getName() ? this._rejectPromise(new Error(`The initial parent "${this._initialParent.getName()}" was destroyed or disabled before the first half of the transition could complete.`)) : this._resolvePromise()
                    }
                    ), !1);
                Date.now() / 1e3 - this._transitionStart >= this._transitionTime / 2 || t === e ? (this.getEntity().removeController(i),
                t !== e && null !== t && null !== e && t.getPositionRelativeToEntity(this._initialPosition, this._initialPosition, e)) : this.getEntity().setParent(t)
            }
            const n = this.getEntity().getPosition()
              , o = this.getEntity().getOrientation();
            let a = s.MathUtils.clamp01((Date.now() / 1e3 - this._transitionStart) / this._transitionTime);
            Number.isNaN(a) && (a = 1),
            this._transitionFunction(this.getEntity(), this._initialPosition, n, this._initialOrientation, o, a),
            Date.now() / 1e3 - this._transitionStart >= this._transitionTime && this.getEntity().getScene().getEngine().addCallback(( () => {
                this._transitionTime = 0,
                this.getEntity().removeController(this),
                this._resolvePromise()
            }
            ), !1)
        }
        _lerpTransitionFunction(t, e, i, n, o, a) {
            const r = s.Vector3.pool.get()
              , l = s.Quaternion.pool.get();
            r.lerp(e, i, a),
            l.slerp(n, o, a),
            t.setPosition(r),
            t.setOrientation(l),
            s.Vector3.pool.release(r),
            s.Quaternion.pool.release(l)
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        TranslateController: function() {
            return TranslateController
        }
    });
    var s = i(6);
    class TranslateController extends s.BaseController {
        constructor(t, e) {
            super(t, e),
            this._translation = new s.Vector3(0,0,0),
            this._translation.freeze(),
            this._relativeToOrientation = !1,
            this.addModifiedState("position")
        }
        getTranslation() {
            return this._translation
        }
        setTranslation(t) {
            this._translation.thaw(),
            this._translation.copy(t),
            this._translation.freeze()
        }
        setRelativeToOrientation(t) {
            this._relativeToOrientation = t
        }
        __updatePositionAtTime(t, e) {
            const i = s.Vector3.pool.get();
            if (this._relativeToOrientation) {
                const t = s.Quaternion.pool.get();
                this.getEntity().getOrientationAtTime(t, e),
                i.rotate(t, this._translation),
                s.Quaternion.pool.release(t)
            } else
                i.copy(this._translation);
            t.add(i, t),
            s.Vector3.pool.release(i)
        }
        __update() {
            const t = s.Vector3.pool.get();
            this._relativeToOrientation ? t.rotate(this.getEntity().getOrientation(), this._translation) : t.copy(this._translation),
            t.add(t, this.getEntity().getPosition()),
            this.getEntity().setPosition(t),
            s.Vector3.pool.release(t)
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        ZoomController: function() {
            return ZoomController
        }
    });
    var s = i(6);
    class ZoomController extends s.BaseController {
        constructor(t, e) {
            super(t, e),
            this._zoomSensitivity = .05,
            this._zoomSmoothness = .8,
            this._zoomSmoothedValue = 1,
            this._distanceClamp = new s.Interval(.001,Number.POSITIVE_INFINITY),
            this._distanceClamp.freeze(),
            this._useSpheroidRadiusForDistance = !1,
            this.addModifiedState("position")
        }
        getZoomSensitivity() {
            return this._zoomSensitivity
        }
        setZoomSensitivity(t) {
            this._zoomSensitivity = t
        }
        getZoomSmoothness() {
            return this._zoomSmoothness
        }
        setZoomSmoothness(t) {
            this._zoomSmoothness = t
        }
        getDistanceClamp() {
            return this._distanceClamp
        }
        setDistanceClamp(t) {
            this._distanceClamp.thaw(),
            this._distanceClamp.copy(t),
            this._distanceClamp.freeze()
        }
        getUseSpheroidRadiusForDistance() {
            return this._useSpheroidRadiusForDistance
        }
        setUseSpheroidRadiusForDistance(t) {
            this._useSpheroidRadiusForDistance = t
        }
        __update() {
            const t = this.getEntity().getScene().getEngine().getInput();
            let e = 1;
            const i = t.getActiveViewport();
            if (null !== i) {
                const s = i.getCamera();
                if (null !== s && s.getEntity() === this.getEntity()) {
                    let i = 1;
                    t.isKeyPressed("x") && (i = .05),
                    t.isShiftPressed() && (i = 5);
                    const s = t.getZoomedOffset();
                    0 !== s && (e *= 2 ** (s * this._zoomSensitivity * i)),
                    t.isKeyPressed("w") && (e /= 2 ** (this._zoomSensitivity * i)),
                    t.isKeyPressed("s") && (e *= 2 ** (this._zoomSensitivity * i))
                }
            }
            let n;
            this._zoomSmoothedValue = s.MathUtils.clamp(s.MathUtils.lerp(e, this._zoomSmoothedValue, this._zoomSmoothness), .8, 1.25),
            Math.abs(1 - this._zoomSmoothedValue) < 1e-7 && (this._zoomSmoothedValue = 1);
            const o = s.LatLonAlt.pool.get()
              , a = this.getEntity().getParent();
            if (this._useSpheroidRadiusForDistance && null !== a) {
                const t = a.getComponent(s.SpheroidComponent);
                if (null !== t) {
                    const e = s.Vector3.pool.get();
                    e.rotateInverse(a.getOrientation(), this.getEntity().getPosition()),
                    t.llaFromXYZ(o, e),
                    n = o.alt,
                    s.Vector3.pool.release(e)
                } else
                    n = this.getEntity().getPosition().magnitude() - a.getOcclusionRadius()
            } else
                n = this.getEntity().getPosition().magnitude();
            Number.isNaN(n) && (n = 1),
            n *= this._zoomSmoothedValue,
            n < this._distanceClamp.min && (n = this._distanceClamp.min,
            this._zoomSmoothedValue = 1),
            n > this._distanceClamp.max && (n = this._distanceClamp.max,
            this._zoomSmoothedValue = 1);
            const r = s.Vector3.pool.get();
            let l = n;
            if (this._useSpheroidRadiusForDistance && null !== a) {
                const t = a.getComponent(s.SpheroidComponent);
                null !== t ? (o.alt = n,
                t.xyzFromLLA(r, o),
                l = r.magnitude()) : l = n + a.getOcclusionRadius()
            }
            r.normalize(this.getEntity().getPosition()),
            r.mult(r, l),
            this.getEntity().setPosition(r),
            s.Vector3.pool.release(r),
            s.LatLonAlt.pool.release(o)
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        DistanceLineComponent: function() {
            return DistanceLineComponent
        }
    });
    var s = i(5);
    class DistanceLineComponent extends s.BaseComponent {
        constructor(t, e) {
            super(t, e),
            this._targetEntity = null,
            this._color = new s.Color(.48,.56,.66),
            this._distance = null,
            this._sourceRelRadius = null,
            this._targetRelRadius = null,
            this._sourceMpIsSurface = !1,
            this._targetMpIsSurface = !1,
            this._switchStartPos = null,
            this._depthTest = !1,
            this._animation = {
                isAnimating: !1,
                duration: 300,
                sourceStartTime: null,
                targetStartTime: null
            },
            this._width = 2,
            this._lineMesh = null,
            this.__setRadius(Number.POSITIVE_INFINITY)
        }
        setTargetEntity(t) {
            this._targetEntity = t
        }
        setSourceMeasurePoint(t) {
            const e = "surface" === t;
            this._sourceMpIsSurface !== e && (this._sourceMpIsSurface = e,
            this._animation.isAnimating = !0,
            this._animation.sourceStartTime = Date.now())
        }
        setTargetMeasurePoint(t) {
            const e = "surface" === t;
            this._targetMpIsSurface !== e && (this._targetMpIsSurface = e,
            this._animation.isAnimating = !0,
            this._animation.targetStartTime = Date.now())
        }
        setColor(t) {
            this._color = t
        }
        setWidth(t) {
            this._width = t
        }
        setDistanceProps({distance: t, sourceRadius: e, targetRadius: i}) {
            this._distance = t,
            this._sourceRelRadius = Math.max(Math.min(e / this._distance, 1), 0),
            this._targetRelRadius = Math.max(Math.min(i / this._distance, 1), 0)
        }
        _applyEasing(t) {
            const e = 2 * t;
            return (e <= 1 ? Math.pow(e, 4) : 2 - Math.pow(2 - e, 4)) / 2
        }
        _updateAnimation(t, e, i, s, n, o) {
            if (!this._animation.isAnimating)
                return;
            const {sourceStartTime: a, targetStartTime: r, duration: l} = this._animation;
            if (a) {
                const r = Date.now() - a
                  , c = r > l ? 1 : r / l;
                if (1 !== c) {
                    const a = this._applyEasing(c);
                    this._sourceMpIsSurface ? this._switchStartPos ? e.lerp(n, o, a) : t.lerp(i, s, a) : this._switchStartPos ? e.lerp(o, n, a) : t.lerp(s, i, a)
                } else
                    this._animation.isAnimating = !1,
                    this._animation.sourceStartTime = null
            }
            if (r) {
                const a = Date.now() - r
                  , c = a > l ? 1 : a / l;
                if (1 !== c) {
                    const a = this._applyEasing(c);
                    this._targetMpIsSurface ? this._switchStartPos ? t.lerp(i, s, a) : e.lerp(n, o, a) : this._switchStartPos ? t.lerp(s, i, a) : e.lerp(o, n, a)
                } else
                    this._animation.isAnimating = !1,
                    this._animation.targetStartTime = null
            }
        }
        __loadResources() {
            return this._lineMesh = new s.LineMesh(this),
            this._lineMesh.setColors([this._color, this._color]),
            this._lineMesh.setWidths([this._width, this._width]),
            this.setOpacity(1),
            Promise.resolve()
        }
        setOpacity(t) {
            this._lineMesh.setAlphaMultiplier(t)
        }
        setDepthTest(t) {
            this._depthTest = t
        }
        __unloadResources() {
            s.ThreeJsHelper.destroyAllObjectsAndMaterials(this),
            this._lineMesh = null
        }
        __prepareForRender(t) {
            const [e] = this.getThreeJsObjects();
            if (null === this._targetEntity)
                return void (e && (e.visible = !1));
            e?.material && (e.material.depthTest = this._depthTest),
            this._calcStartPos(t),
            this._updatePoints(t);
            const i = this._switchStartPos ? this._targetEntity : this.getEntity();
            s.ThreeJsHelper.setPositionToEntity(e, i, t),
            this._lineMesh.prepareForRender(t)
        }
        _calcStartPos(t) {
            const e = s.Vector3.pool.get();
            t.getEntity().getPositionRelativeToEntity(e, s.Vector3.Zero, this._targetEntity);
            const i = e.magnitude() / this._distance < .001;
            this._switchStartPos !== i && (this._switchStartPos = i),
            s.Vector3.pool.release(e)
        }
        _updatePoints(t) {
            if (null === this._targetEntity)
                return;
            const e = s.Vector3.pool.get()
              , i = s.Vector3.pool.get()
              , n = s.Vector3.pool.get()
              , o = s.Vector3.pool.get();
            e.copy(s.Vector3.Zero),
            o.sub(this._targetEntity.getCameraSpacePosition(t), this.getEntity().getCameraSpacePosition(t)),
            this._switchStartPos && o.neg(o);
            const a = this._switchStartPos ? this._targetRelRadius : this._sourceRelRadius
              , r = 1 - (this._switchStartPos ? this._sourceRelRadius : this._targetRelRadius);
            i.lerp(e, o, a),
            n.lerp(e, o, r);
            const l = (this._switchStartPos ? this._targetMpIsSurface : this._sourceMpIsSurface) ? i : e
              , c = (this._switchStartPos ? this._sourceMpIsSurface : this._targetMpIsSurface) ? n : o;
            this._updateAnimation(l, c, e, i, o, n);
            const h = [l, c];
            this._lineMesh.setPositions(h),
            s.Vector3.pool.release(e),
            s.Vector3.pool.release(i),
            s.Vector3.pool.release(n),
            s.Vector3.pool.release(o)
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        CancelToken: function() {
            return CancelToken
        }
    });
    class CancelToken {
        constructor() {
            this._isCanceled = !1
        }
        cancel() {
            this._isCanceled = !0
        }
        get isCanceled() {
            return this._isCanceled
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        AppUtils: function() {
            return AppUtils
        }
    });
    var s = i(135)
      , n = i.n(s)
      , o = i(136)
      , a = i.n(o)
      , r = i(137)
      , l = i.n(r)
      , c = i(138)
      , h = i.n(c)
      , d = (i(139),
    i(140));
    class AppUtils {
        static conversionTable = {
            kmToMi: .621371,
            kmToFt: 3280.84,
            miToFt: 5280,
            kmToM: 1e3,
            auToKm: 149597871,
            ldToKm: 384398
        };
        static constants = {
            speedOfLight: 299792.458,
            minDate: -8e15,
            maxDate: 8e15
        };
        static isEmptyObject(t) {
            return t.constructor === Object && 0 === Object.keys(t).length
        }
        static addStartToPath(t, e="/") {
            return t.startsWith(e) ? t : e + t
        }
        static cleanPathDuplicate(t, e="/", i="/") {
            const s = new RegExp(`${e}+`,"g");
            return t.replace(s, i)
        }
        static addEndToPath(t, e="/") {
            return t.endsWith(e) ? t : t + e
        }
        static isElement(t) {
            return t instanceof Element || t instanceof Document
        }
        static isHTML(t) {
            return "string" == typeof t && (null !== t.match(/<[^/>]+>/gm) && null !== t.match(/<\/[^>]+>/gm))
        }
        static hasHTML(t) {
            if ("string" != typeof t)
                return !1;
            const e = (new DOMParser).parseFromString(t, "text/html");
            return Array.from(e.body.childNodes).some((t => 1 === t.nodeType))
        }
        static async loadJSON(t) {
            t = AppUtils.addEndToPath(t, ".json");
            const e = await fetch(t);
            if (200 === e.status)
                return e.json();
            {
                const i = new Error(e.status + " (" + e.statusText + ') when trying to fetch "' + t + '"');
                throw i.name = "NotFound",
                i
            }
        }
        static msToTime(t=0) {
            const e = t % 1e3
              , i = (t = (t - e) / 1e3) % 60
              , s = (t = (t - i) / 60) % 60;
            return {
                hour: (t - s) / 60,
                minute: s,
                second: i,
                millisecond: e
            }
        }
        static formatCountdownTime(t, e) {
            const i = this.msToTime(e);
            return i.hour = i.hour.toString().padStart(2, "0"),
            i.minute = i.minute.toString().padStart(2, "0"),
            i.second = i.second.toString().padStart(2, "0"),
            `${t >= 36e5 ? i.hour + ":" : ""}${i.minute || "00"}:${i.second}`
        }
        static minToSec(t) {
            return 60 * t
        }
        static minToMS(t) {
            return 6e4 * t
        }
        static isFutureMission(t) {
            const e = new Date;
            return new Date(t) > e
        }
        static deepCopy(t) {
            return JSON.parse(JSON.stringify(t))
        }
        static deepClone(t) {
            const e = Array.isArray(t) ? [] : {};
            for (const i in t) {
                const s = t[i];
                e[i] = "object" == typeof s && null !== s ? AppUtils.deepClone(s) : s
            }
            return e
        }
        static deepMerge(t, e) {
            const i = {
                isMergeableObject: t => (!t || !t._isAMomentObject) && (Boolean(t) && "object" == typeof t)
            };
            return n()(t, e, i)
        }
        static deepEqual(t, e) {
            if (!t || !e)
                return !1;
            const i = Object.keys(t)
              , s = Object.keys(e);
            if (i.length !== s.length)
                return !1;
            for (const s of i) {
                const i = t[s]
                  , n = e[s]
                  , o = AppUtils.isObject(i) && AppUtils.isObject(n);
                if (o && !AppUtils.deepEqual(i, n))
                    return !1;
                if (!o && i !== n)
                    return !1
            }
            return !0
        }
        static isObject(t) {
            return null !== t && "object" == typeof t
        }
        static filterObject(t, e) {
            return Object.fromEntries(Object.entries(t).filter(( ([t,i]) => e(i, t))))
        }
        static debounce() {
            return a()(...arguments)
        }
        static throttle() {
            return l()(...arguments)
        }
        static waitFor(t) {
            return new Promise((e => {
                setTimeout(( () => {
                    e()
                }
                ), t)
            }
            ))
        }
        static isPortrait() {
            return window.matchMedia("(orientation: portrait)").matches
        }
        static isLandscape() {
            return window.matchMedia("(orientation: landscape)").matches
        }
        static isMobileLandscape() {
            return window.matchMedia("(min-width: 320px) and (max-width: 915px) and (orientation: landscape)").matches
        }
        static isMobilePortrait() {
            return window.matchMedia("(min-width: 320px) and (max-width: 640px) and (orientation: portrait)").matches
        }
        static isMobile() {
            return AppUtils.isMobileLandscape() || AppUtils.isMobilePortrait()
        }
        static isAppleDevice() {
            return !0 === AppUtils.isiPhone() || !0 === AppUtils.isiPad()
        }
        static isiPhone() {
            return "iPhone" === (window.navigator?.userAgentData?.platform || window.navigator?.platform || "unknown")
        }
        static isiPad() {
            const t = window.navigator?.userAgentData?.platform || window.navigator?.platform || "unknown"
              , e = window.navigator.maxTouchPoints > 1;
            return "MacIntel" === t && e
        }
        static isTabletPortrait() {
            return window.matchMedia("(min-width: 641px) and (max-width: 1024px) and (orientation: portrait)").matches
        }
        static isTabletLandscape() {
            return window.matchMedia("(min-width: 916px) and (max-width: 1024px) and (orientation: landscape)").matches
        }
        static isTablet() {
            return AppUtils.isTabletLandscape() || AppUtils.isTabletPortrait()
        }
        static isMobileMode() {
            return AppUtils.isMobilePortrait() || AppUtils.isMobileLandscape() || AppUtils.isTabletLandscape() || AppUtils.isTabletPortrait() || AppUtils.isPanorama()
        }
        static isDesktop() {
            return window.matchMedia("(min-width: 1025px) and (min-height: 600px)").matches
        }
        static isPanorama() {
            return window.matchMedia("(min-width: 1025px) and (max-height: 599px) and (orientation: landscape)").matches
        }
        static is2K() {
            return window.matchMedia("(min-width: 2880px) and (min-height: 1620px)").matches
        }
        static is4K() {
            return window.matchMedia("(min-width: 3200px) and (min-height: 1800px)").matches
        }
        static isTouch() {
            return "ontouchstart"in window || window.navigator.maxTouchPoints > 0
        }
        static isPrimaryTouch() {
            return window.matchMedia("(pointer: coarse)").matches
        }
        static canHover() {
            return !matchMedia("(hover: none)").matches
        }
        static htmlToElement(t) {
            const e = document.createElement("template");
            return e.innerHTML = t.replace(/[\t\n]+/g, "").trim(),
            e.content.firstElementChild
        }
        static htmlToElements(t) {
            const e = document.createElement("template");
            return e.innerHTML = t.replace(/[\t\n]+/g, "").trim(),
            e.content.cloneNode(!0).childNodes
        }
        static insertParamsToHTML(t, e={}) {
            t = t.replace(/[\t\n]+/g, "").trim();
            const i = Object.keys(e);
            for (let s = i.length - 1; s >= 0; s--) {
                const n = i[s]
                  , o = `{$${n}}`;
                t = t.replaceAll(o, e[n])
            }
            return t = t.replaceAll(/{\$([A-Z])\w+}/gi, "")
        }
        static htmlWithParamsToElement(t, e={}) {
            return t = AppUtils.insertParamsToHTML(t, e),
            AppUtils.htmlToElement(t)
        }
        static onAttachElement(t, e, {interval: i=100, timeout: s=5e3}={}) {
            const n = setInterval(( () => {
                ("string" == typeof t ? null !== document.querySelector(t) : document.body.contains(t)) && (clearInterval(n),
                clearTimeout(o),
                e())
            }
            ), i)
              , o = setTimeout(( () => {
                clearInterval(n),
                console.error(`[AppUtils.onAttachElement] Timeout exceeded for "${t}".`)
            }
            ), s)
        }
        static appendWithCallback(t, e, i, s) {
            new Promise((t => {
                if (document.querySelector(i))
                    return t(document.querySelector(i));
                const e = new MutationObserver(( () => {
                    document.querySelector(i) && (t(document.querySelector(i)),
                    e.disconnect())
                }
                ));
                e.observe(document.body, {
                    childList: !0,
                    subtree: !0
                })
            }
            )).then(s),
            t.appendChild(e)
        }
        static elementReady(t, e=1e3) {
            return new Promise(( (i, s) => {
                const n = document.querySelector(t);
                if (n)
                    return void i(n);
                const o = new MutationObserver(( () => {
                    const e = document.querySelector(t);
                    e && (o.disconnect(),
                    clearTimeout(a),
                    i(e))
                }
                ));
                o.observe(document.body, {
                    childList: !0,
                    subtree: !0
                });
                const a = setTimeout(( () => {
                    o.disconnect(),
                    s(console.warn(`${t} not found in DOM`))
                }
                ), e)
            }
            ))
        }
        static addScrollbar(t, e={}) {
            const i = {
                className: "os-theme-dark",
                resize: "none",
                clipAlways: !1,
                normalizeRTL: !1,
                paddingAbsolute: !0,
                autoUpdate: !1,
                sizeAutoCapable: !1,
                overflowBehavior: {
                    x: "hidden",
                    y: "scroll"
                },
                scrollbars: {
                    clickScrolling: !0,
                    autoHide: "move"
                },
                ...e
            };
            return h()(t, i)
        }
        static formatNumber(t, e=3, i) {
            return t.toLocaleString(void 0, {
                maximumFractionDigits: e,
                minimumFractionDigits: i
            })
        }
        static formatDate(t, e={}) {
            return t.toLocaleString(void 0, {
                year: "numeric",
                month: "long",
                day: "numeric",
                ...e
            })
        }
        static tween(t, e, {onUpdate: i, onComplete: s, duration: n=2e3}={}) {
            let o = 0;
            const a = new d.Tween(t).to(e, n).onUpdate((t => {
                void 0 !== i && i(t)
            }
            )).onComplete(( () => {
                "function" == typeof s && s(),
                cancelAnimationFrame(o)
            }
            )).start()
              , r = t => {
                o = requestAnimationFrame(r),
                (0,
                d.update)(t)
            }
            ;
            return r(),
            a
        }
        static convertObjType(t) {
            return Object.entries(t).forEach(( ([e,i]) => {
                let s;
                switch (i.trim()) {
                case "undefined":
                    s = void 0;
                    break;
                case "null":
                    s = null;
                    break;
                case "true":
                    s = !0;
                    break;
                case "false":
                    s = !1;
                    break;
                case "NaN":
                    s = NaN;
                    break;
                case "":
                    break;
                default:
                    s = isNaN(i) ? i : parseFloat(i)
                }
                t[e] = s
            }
            )),
            t
        }
    }
}
, , , , , , , function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        AnimationUtils: function() {
            return AnimationUtils
        }
    });
    class AnimationUtils {
    }
    AnimationUtils.createAnimation = (t, e, i) => {
        const s = new KeyframeEffect(t,e,i);
        return new Animation(s,t.ownerDocument.timeline)
    }
    ,
    AnimationUtils.directionalFade = (t, {direction: e="up", fade: i="in", yOffset: s=0, xOffset: n=0, timings: o=AnimationUtils.defaultTimings}) => {
        const a = {
            x: {
                ori: 0,
                dest: 0
            },
            y: {
                ori: 0,
                dest: 0
            },
            opacity: {
                ori: 1,
                dest: 0
            }
        };
        "up" === e || "down" === e ? (a.y.ori = "in" === i ? 100 : 0,
        a.y.dest = 100 - a.y.ori,
        "up" === e && (a.y.ori *= -1,
        a.y.dest *= -1)) : (a.x.ori = "in" === i ? 100 : 0,
        a.x.dest = 100 - a.x.ori,
        "left" === e && (a.x.ori *= -1,
        a.x.dest *= -1)),
        "in" === i && (a.opacity.ori = 0,
        a.opacity.dest = 1),
        a.x.ori += n,
        a.x.dest += n,
        a.y.ori += s,
        a.y.dest += s;
        const r = [{
            transform: "translate(" + a.x.ori + "%, " + a.y.ori + "%)",
            opacity: a.opacity.ori
        }, {
            transform: "translate(" + a.x.dest + "%, " + a.y.dest + "%)",
            opacity: a.opacity.dest
        }];
        return AnimationUtils.createAnimation(t, r, o)
    }
    ,
    AnimationUtils.defaultTimings = {
        duration: 1e3,
        iteration: 1,
        fill: "forwards",
        easing: "ease"
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        BaseComponent: function() {
            return BaseComponent
        }
    });
    var s = i(2);
    class BaseComponent {
        constructor(t, e, i={
            parent: null,
            config: {},
            params: {},
            isVisible: !0
        }) {
            this._element = e,
            this._app = t,
            this._config = i.config || {},
            delete i.config,
            "hiddenMode"in this._config || (this._config.hiddenMode = "hidden"),
            this._params = i.params || {},
            delete i.params,
            "isVisible"in i || (i.isVisible = !1),
            this._class = {
                isVisible: {
                    true: "active",
                    false: "hidden" === this._config.hiddenMode ? "hidden" : "invisible"
                },
                fontSize: {
                    small: "small",
                    default: "",
                    large: ""
                }
            },
            this._state = {
                ...i,
                isVisibleClass: this._class.isVisible[i.isVisible ? "true" : "false"],
                fontSizeClass: this._class.fontSize.default
            },
            this._oldState = {},
            this._children = {},
            this._components = [],
            this._vars = {},
            this._parent = this._element ? this._element.parentElement : i.parent || null,
            this._enabled = !1,
            this._eventNames = ["statuschange", "visiblechange"],
            this._callbacks = {},
            this._initCallbacks(),
            this._callbackRegistry = [],
            this._resizeTimeout = null,
            this._resizeTimeoutAmount = 0,
            this.bindFunctions(["resize", "isEnabled", "setEnabled", "show", "hide", "toggle", "loadHTML", "getState", "setState"])
        }
        get components() {
            return this._components
        }
        get app() {
            return this._app
        }
        resize() {
            this._updateFontSize()
        }
        _updateFontSize() {
            let t = this._class.fontSize.default;
            s.AppUtils.isMobile() ? t = this._class.fontSize.small : s.AppUtils.isTablet() || s.AppUtils.isPanorama() ? t = this._class.fontSize.default : (s.AppUtils.is2K() || s.AppUtils.is4K()) && (t = this._class.fontSize.large),
            this.setState({
                fontSizeClass: t
            })
        }
        get element() {
            return this._element
        }
        getParent() {
            return this._parent
        }
        setParent(t, e=null) {
            this._parent = t,
            e && this._parent.removeChild(e),
            this._enabled && this._parent.appendChild(this._element)
        }
        async init(t={}) {
            Object.assign(this._params, t);
            const e = this.constructor;
            void 0 !== e.html ? (this._element = s.AppUtils.htmlWithParamsToElement(e.html, this._params),
            this._element.classList.add("{{fontSizeClass}}"),
            this._setVariables(this._element),
            this._setEventHandlersFromAttributes(this._element)) : (this._element.classList.add("{{fontSizeClass}}"),
            this._setVariables(this._element)),
            this._updateFontSize()
        }
        getConfig() {
            return this._config
        }
        setConfig(t) {
            Object.assign(this._config, t)
        }
        bindFunctions(t=[]) {
            const e = this;
            for (let i = 0; i < t.length; i++) {
                const s = t[i];
                e[s] = e[s].bind(this)
            }
        }
        isEnabled() {
            return this._enabled
        }
        setEnabled(t) {
            const e = this._enabled;
            t && !e ? this.__enable() : !t && e && this.__disable(),
            this._enabled = t,
            this._components.forEach((e => {
                ("string" == typeof e ? this._app.getComponent(e) : e).setEnabled(t)
            }
            ))
        }
        destroy() {
            this.__destroy()
        }
        show() {
            this.setState({
                isVisible: !0,
                isVisibleClass: this._class.isVisible.true
            }, ( () => this.triggerCallbacks("visiblechange", [!0])))
        }
        hide() {
            this.setState({
                isVisible: !1,
                isVisibleClass: this._class.isVisible.false
            }, ( () => this.triggerCallbacks("visiblechange", [!1])))
        }
        toggle() {
            this._state.isVisible ? this.hide() : this.show()
        }
        async loadHTML(t, e=null) {
            const i = await fetch(t);
            if (i.ok) {
                const t = await i.text();
                this._parseHTML(t, e)
            } else
                console.error(i.status + ": " + i.statusText)
        }
        getState(t) {
            return t in this._state ? this._state[t] : null
        }
        addState(t, e, i) {
            this._state[t] = e,
            i && this._setVariables(i)
        }
        setState(t, e) {
            if (s.AppUtils.isEmptyObject(t))
                return;
            let i = !1;
            for (const e in t)
                if (t[e] !== this._state[e]) {
                    i = !0;
                    break
                }
            i && (this._oldState = {
                ...this._state
            },
            this._state = {
                ...this._state,
                ...t
            },
            this._render(t),
            void 0 !== e && e())
        }
        _parseHTML(t, e=null) {
            if (!t)
                return;
            const i = e || this._element;
            this._roots = [...s.AppUtils.htmlToElements(t)];
            const n = document.createDocumentFragment();
            for (let t = 0; t < this._roots.length; t++) {
                const e = this._roots[t];
                e instanceof HTMLElement && (this._setVariables(e),
                this._setEventHandlersFromAttributes(e),
                n.appendChild(e))
            }
            i.appendChild(n)
        }
        _containVar(t) {
            return t && "function" == typeof t.includes && t.includes("{{") && t.includes("}}")
        }
        _splitNonEmpty(t) {
            return t.split(/\s+/g).filter((t => "" !== t))
        }
        _setVariables(t, e=!0) {
            let i;
            if (t instanceof Element)
                for (let e = t.attributes.length - 1; e >= 0; e--) {
                    const i = t.attributes[e];
                    if ("key" === i.name) {
                        this._children[i.value] = t;
                        break
                    }
                }
            const n = [];
            if (t.nodeType === Node.TEXT_NODE)
                this._containVar(t.nodeValue) && n.push({
                    field: "nodeValue",
                    elementVar: t.nodeValue
                });
            else if (t instanceof Element) {
                let e = t.className;
                for (; this._containVar(e); ) {
                    const t = e.indexOf("}}") + 2;
                    n.push({
                        field: "classList",
                        elementVar: e.substring(e.indexOf("{{"), t)
                    }),
                    e = e.substring(t)
                }
            }
            for (let e = 0; e < n.length; e++) {
                let {field: o, elementVar: a} = n[e];
                if (o && a.startsWith("{{") && a.endsWith("}}")) {
                    const e = a.replace("{{", "").replace("}}", "");
                    if ("classList" === o && t instanceof Element) {
                        t.classList.remove(a);
                        const i = this._state[e];
                        if (void 0 !== i) {
                            const e = this._splitNonEmpty(i);
                            t.classList.add(...e)
                        }
                    } else if (s.AppUtils.isHTML(this._state[e])) {
                        const n = s.AppUtils.htmlToElement(this._state[e]);
                        t.parentNode.replaceChild(n, t),
                        i = n
                    } else if (s.AppUtils.hasHTML(this._state[e]))
                        if (t.nodeType === Node.TEXT_NODE) {
                            const s = document.createElement("span");
                            s.innerHTML = this._state[e];
                            (t.parentElement || t.parentNode).replaceChild(s, t),
                            i = s,
                            o = "innerHTML"
                        } else
                            t.innerHTML = this._state[e];
                    else {
                        t[o] = this._state[e]
                    }
                    void 0 === this._vars[e] && (this._vars[e] = []),
                    this._vars[e].push({
                        element: i || t,
                        field: o
                    })
                }
            }
            if (e)
                for (let e = t.childNodes.length - 1; e >= 0; e--)
                    this._setVariables(t.childNodes[e])
        }
        _setEventHandlersFromAttributes(t) {
            const e = [];
            for (let i = t.attributes.length - 1; i >= 0; i--) {
                const s = t.attributes[i];
                if (s.name.startsWith("on")) {
                    const i = s.name.substring(2).toLowerCase()
                      , n = this[s.value];
                    if (void 0 === n || !(n instanceof Function))
                        throw new Error("Could not find valid " + i + " handler " + s.value + " for element with id " + t.id);
                    const o = n.bind(this);
                    e.push(s.name),
                    t.addEventListener(i, o)
                }
            }
            for (let i = e.length - 1; i >= 0; i--)
                t.removeAttribute(e[i]);
            for (let e = t.children.length - 1; e >= 0; e--)
                this._setEventHandlersFromAttributes(t.children[e])
        }
        _render(t) {
            const e = Object.keys(t);
            for (let i = e.length - 1; i >= 0; i--) {
                const n = e[i];
                if (n in this._vars && t[n] !== this._oldState[n]) {
                    const e = this._vars[n];
                    for (let i = 0; i < e.length; i++) {
                        const {field: o, element: a} = e[i];
                        if ("classList" === o) {
                            let e = this._splitNonEmpty(this._oldState[n]);
                            const i = a;
                            i[o].remove(...e),
                            e = this._splitNonEmpty(t[n]),
                            i[o].add(...e)
                        } else if (s.AppUtils.isHTML(t[n])) {
                            const e = s.AppUtils.htmlToElement(t[n]);
                            a.parentNode.replaceChild(e, a),
                            this._vars[n][i].element = e
                        } else if (s.AppUtils.hasHTML(t[n]))
                            if (a.nodeType === Node.TEXT_NODE) {
                                const e = document.createElement("span");
                                e.innerHTML = t[n];
                                (a.parentElement || a.parentNode).replaceChild(e, a),
                                this._vars[n][i].element = e,
                                this._vars[n][i].field = "innerHTML"
                            } else
                                a.innerHTML = t[n];
                        else {
                            a[o] = t[n]
                        }
                    }
                }
            }
        }
        __enable() {
            window.addEventListener("resize", ( () => {
                clearTimeout(this._resizeTimeout),
                this._resizeTimeout = setTimeout(this.resize, this._resizeTimeoutAmount)
            }
            ), !1),
            this.registerCallbacks(),
            this._parent && (this._parent.appendChild(this._element),
            this.triggerCallbacks("statuschange", [!0, this]))
        }
        __disable() {
            clearTimeout(this._resizeTimeout),
            this._parent && this._parent.contains(this._element) && (this.triggerCallbacks("statuschange", [!1, this]),
            this._element = this._parent.removeChild(this._element)),
            window.removeEventListener("resize", this.resize),
            this.removeCallbacks()
        }
        __destroy() {
            this.__disable(),
            this._element = null,
            this._parent = null
        }
        _initCallbacks() {
            for (let t = 0; t < this._eventNames.length; t++)
                this._callbacks[this._eventNames[t]] = []
        }
        registerCallback(t, e) {
            "function" != typeof e || this._eventNames.indexOf(t) < 0 || this._callbacks[t].includes(e) || this._callbacks[t].push(e)
        }
        removeCallback(t, e) {
            if ("function" != typeof e || this._eventNames.indexOf(t) < 0)
                return;
            const i = this._callbacks[t].indexOf(e);
            i > -1 && this._callbacks[t].splice(i, 1)
        }
        triggerCallbacks(t, e=[]) {
            for (let i = this._callbacks[t].length - 1; i >= 0; i--) {
                (0,
                this._callbacks[t][i])(...e)
            }
        }
        registerCallbacks() {
            for (let t = 0; t < this._callbackRegistry.length; t++) {
                const {emitter: e, event: i, callback: s} = this._callbackRegistry[t];
                e.registerCallback(i, s)
            }
        }
        removeCallbacks() {
            for (let t = 0; t < this._callbackRegistry.length; t++) {
                const {emitter: e, event: i, callback: s} = this._callbackRegistry[t];
                e.removeCallback(i, s)
            }
        }
    }
    BaseComponent.create = async (t, e, i, s=!0, n=[], o={}) => {
        const a = s ? await t.addComponentWithPlaceholder({
            type: i,
            name: e,
            args: n,
            options: o
        }) : await t.addComponent(e, i, ...n, o);
        return i.postCreationFunction && i.postCreationFunction(t, a),
        a
    }
    ,
    BaseComponent.html = void 0,
    BaseComponent.postCreationFunction = void 0
}
, function(t, e, i) {
    "use strict";
    i.r(e);
    var s = i(144);
    i(204),
    i(205);
    e.default = s.default
}
, function(t, e, i) {
    "use strict";
    i.r(e);
    var s = i(145)
      , n = i(147)
      , o = (i(5),
    i(2))
      , a = i(146)
      , r = i.n(a);
    class Settings extends o.BaseComponent {
        constructor(t, e={}) {
            const i = {
                isCollapsible: !0,
                allowToggleUnit: !1,
                allowLayers: !0,
                allowZoom: !0,
                allowFullscreen: s.default.isEnabled,
                allowPhotoMode: !1,
                allowInfoPanel: !0,
                allowLighting: !0,
                showLightOptions: !1,
                allowGuidedCamera: !1,
                zoomIn: t.getManager("camera").zoomIn,
                zoomOut: t.getManager("camera").zoomOut,
                ...e.config
            };
            delete e.config,
            i.orientation = {
                bigPortrait: {
                    check: i.orientation?.bigPortrait?.check || ( () => o.AppUtils.isPortrait() && !o.AppUtils.isMobilePortrait() && !o.AppUtils.isTabletPortrait()),
                    ori: i.orientation?.bigPortrait?.ori || "vertical"
                },
                tabletPortrait: {
                    check: i.orientation?.tabletPortrait?.check || ( () => o.AppUtils.isTabletPortrait()),
                    ori: i.orientation?.tabletPortrait?.ori || "vertical"
                },
                smallPortrait: {
                    check: i.orientation?.smallPortrait?.check || ( () => o.AppUtils.isMobilePortrait()),
                    ori: i.orientation?.smallPortrait?.ori || "vertical"
                },
                bigLandscape: {
                    check: i.orientation?.bigLandscape?.check || ( () => o.AppUtils.isLandscape() && !o.AppUtils.isMobileLandscape() && !o.AppUtils.isTabletLandscape()),
                    ori: i.orientation?.bigLandscape?.ori || "vertical"
                },
                tabletLandscape: {
                    check: i.orientation?.tabletPortrait?.check || ( () => o.AppUtils.isTabletLandscape() || o.AppUtils.isPanorama()),
                    ori: i.orientation?.tabletPortrait?.ori || "vertical"
                },
                smallLandscape: {
                    check: i.orientation?.smallLandscape?.check || ( () => o.AppUtils.isMobileLandscape()),
                    ori: i.orientation?.smallLandscape?.ori || "horizontal"
                }
            },
            super(t, null, {
                isMetric: !1,
                isVisible: !0,
                isFullscreen: !1,
                isPhotoMode: !1,
                isGuidedCamera: !0,
                showOrbitLines: !0,
                showLabels: !0,
                lightType: "shadow",
                config: i,
                ...e
            }),
            this._ori = "",
            this._isMobileMode = o.AppUtils.isMobileMode(),
            this._isHorizontal = null,
            Object.assign(this._class, {
                container: {
                    collapse: "hidden",
                    expand: "active"
                },
                isItemVisible: {
                    true: "",
                    false: "hidden"
                },
                icon: {
                    imperial: "icon-mi",
                    metric: "icon-km",
                    info: "icon-info"
                },
                fullscreen: {
                    true: "fullscreen",
                    false: "window"
                },
                photo: {
                    true: "active",
                    false: ""
                },
                light: {
                    natural: "icon-natural-light",
                    shadow: "icon-shadow-light",
                    flood: "icon-flood-light"
                },
                camera: {
                    true: "icon-free-cam",
                    false: "icon-auto-cam"
                },
                isHorizontal: {
                    true: "horizontal",
                    false: "vertical"
                }
            });
            const a = !this._isMobileMode
              , r = this._isMobileMode
              , l = this.isHorizontal()
              , c = this.app.getManager("camera");
            this._fullLightColor = c.getFullLightColor(),
            this._shadowLightColor = c.getShadowLightColor(),
            Object.assign(this._state, {
                isVisible: a,
                isCollapsed: r,
                isVisibleClass: this._class.isVisible[a],
                containerClass: r ? this._class.container.collapse : this._class.container.expand,
                isCollapsibleClass: this._class.isItemVisible[this._config.isCollapsible],
                allowInfoPanelClass: this._class.isItemVisible[this._config.allowInfoPanel],
                allowToggleUnitClass: this._class.isItemVisible[this._config.allowToggleUnit],
                allowPhotoModeClass: this._class.isItemVisible[this._config.allowPhotoMode],
                allowZoomClass: this._class.isItemVisible[this._config.allowZoom],
                allowLightingClass: this._class.isItemVisible[this._config.allowLighting],
                showLightingOptionsClass: this._class.isItemVisible[this._config.showLightOptions],
                allowGuidedCameraClass: this._class.isItemVisible[this._config.allowGuidedCamera],
                allowFullscreenClass: this._class.isItemVisible[this._config.allowFullscreen],
                allowLayersClass: this._class.isItemVisible[this._config.allowLayers],
                unitButton: this._state.isMetric ? this._class.icon.imperial : this._class.icon.metric,
                infoButton: this._class.icon.info,
                fullscreenClass: this._class.fullscreen[this._state.isFullscreen],
                photoModeClass: this._class.photo[this._state.isPhotoMode],
                lightClass: this._class.light[this._state.lightType],
                guidedClass: this._class.camera[this._state.isGuidedCamera],
                isHorizontal: l,
                orientationClass: this._class.isHorizontal[l]
            }),
            this._eventNames.push("unitchange", "photomodechange", "guidedcamerachange", "expandtoggle"),
            this._initCallbacks(),
            this._isMouseHold = !1,
            this._isContinuousZoom = !1,
            this._zoomInterval = null,
            this._zoomTimeout = null,
            this._tooltips = [],
            n.default.setDefaultProps({
                theme: "default",
                touch: ["hold", 2e3],
                delay: [600, null],
                plugins: [n.followCursor]
            }),
            this.bindFunctions(["toggleCollapse", "toggleUnit", "toggleLayers", "toggleFullscreen", "togglePhotoMode", "hideLightingOptions", "toggleLightOptions", "toggleLight", "toggleGuidedCamera", "toggleInfoPanel", "startGuidedCamera", "stopGuidedCamera", "_zoomIn", "_zoomOut", "_stopZooming", "_updateSize"])
        }
        init() {
            super.init();
            const {isCollapsible: t, allowToggleUnit: e, allowLayers: i, allowZoom: n, allowFullscreen: o, allowPhotoMode: a, allowInfoPanel: r, allowLighting: l, allowGuidedCamera: c} = this._config
              , h = {};
            t && (h.isCollapsibleClass = this._class.isItemVisible[t]),
            r && (h.allowInfoPanelClass = this._class.isItemVisible[r]),
            e && (h.allowToggleUnitClass = this._class.isItemVisible[e]),
            a && (h.allowPhotoModeClass = this._class.isItemVisible[a]),
            n && (h.allowZoomClass = this._class.isItemVisible[n],
            this._children.zoomInButton.addEventListener("mousedown", ( () => {
                this._stopZooming(),
                this._zoomIn(!0)
            }
            )),
            this._children.zoomInButton.addEventListener("mouseleave", this._stopZooming),
            this._children.zoomInButton.addEventListener("mouseup", ( () => {
                this._isContinuousZoom || this._zoomIn(),
                this._stopZooming()
            }
            )),
            this._children.zoomInButton.addEventListener("touchstart", (t => {
                t.preventDefault(),
                this._stopZooming(),
                this._zoomIn(!0)
            }
            )),
            this._children.zoomInButton.addEventListener("touchmove", (t => {
                t.preventDefault();
                "zoomInButton" !== document.elementFromPoint(t.changedTouches[0].clientX, t.changedTouches[0].clientY).getAttribute("key") && this._stopZooming()
            }
            )),
            this._children.zoomInButton.addEventListener("touchend", (t => {
                t.preventDefault(),
                this._isContinuousZoom || this._zoomIn(),
                this._stopZooming()
            }
            )),
            this._children.zoomOutButton.addEventListener("mousedown", ( () => {
                this._stopZooming(),
                this._zoomOut(!0)
            }
            )),
            this._children.zoomOutButton.addEventListener("mouseleave", this._stopZooming),
            this._children.zoomOutButton.addEventListener("mouseup", ( () => {
                this._isContinuousZoom || this._zoomOut(),
                this._stopZooming()
            }
            )),
            this._children.zoomOutButton.addEventListener("touchstart", (t => {
                t.preventDefault(),
                this._stopZooming(),
                this._zoomOut(!0)
            }
            )),
            this._children.zoomOutButton.addEventListener("touchmove", (t => {
                t.preventDefault();
                "zoomOutButton" !== document.elementFromPoint(t.changedTouches[0].clientX, t.changedTouches[0].clientY).getAttribute("key") && this._stopZooming()
            }
            )),
            this._children.zoomOutButton.addEventListener("touchend", (t => {
                t.preventDefault(),
                this._isContinuousZoom || this._zoomOut(),
                this._stopZooming()
            }
            ))),
            l && (h.allowLightingClass = this._class.isItemVisible[l],
            this._children.flood.onclick = this.toggleLightOptions.bind(this._children.flood, "flood"),
            this._children.shadow.onclick = this.toggleLightOptions.bind(this._children.shadow, "shadow"),
            this._children.natural.onclick = this.toggleLightOptions.bind(this._children.natural, "natural"),
            this._children.shadow.classList.add("selected-lighting"),
            this.toggleLightOptions("shadow")),
            c && (h.allowGuidedCameraClass = this._class.isItemVisible[c]),
            o && s.default.isEnabled && (h.allowFullscreenClass = this._class.isItemVisible[o],
            s.default.on("change", ( () => {
                const t = s.default.isFullscreen;
                this.setState({
                    isFullscreen: t,
                    fullscreenClass: this._class.fullscreen[t]
                })
            }
            ))),
            i && (h.allowLayersClass = this._class.isItemVisible[i]),
            this.setState(h);
            const d = this._element.querySelectorAll('.settings button:not(.zoom), span[key="zoomInButton"], span[key="zoomOutButton"]');
            this.addTooltips(d, {
                update: function(t) {
                    this.setProps({
                        placement: t ? "top" : "left"
                    })
                }
            }),
            this._updateSize(),
            this._callbackRegistry.push({
                emitter: this._app.getManager("time"),
                event: "ratechange",
                callback: this.onRateChange
            })
        }
        addTooltips(t, e) {
            const i = e.props || {}
              , s = (0,
            n.default)(t, i);
            if ("function" == typeof e.update)
                for (const t of s)
                    t.update = e.update;
            if ("function" == typeof e.onclick)
                for (const t of s)
                    t.popper.onclick = e.onclick;
            return this._tooltips.push(...s),
            1 === s.length ? s[0] : s
        }
        updateTooltips(t) {
            for (const e of this._tooltips)
                "function" == typeof e.update && e.update(t)
        }
        setConfig(t) {
            const {collapseSettingsOptions: e, hideFullScreenToggle: i, lighting: n} = this.app.getManager("router").configs;
            if (t.allowFullscreen && !0 !== i && (t.allowFullscreen = s.default.isEnabled),
            t.orientation) {
                const e = this._config.orientation
                  , i = ["bigPortrait", "tabletPortrait", "smallPortrait", "bigLandscape", "tabletLandscape", "smallLandscape"];
                for (let s = 0; s < i.length; s++) {
                    const n = i[s];
                    t.orientation[n] ? (t.orientation[n].check ??= e[n].check,
                    t.orientation[n].ori ??= e[n].ori) : t.orientation[n] = e[n]
                }
            }
            super.setConfig(t);
            const o = {};
            for (const e in t)
                if ("orientation" === e) {
                    const t = this.isHorizontal();
                    o.isHorizontal = t,
                    o[`${e}Class`] = this._class.isHorizontal[t]
                } else
                    o[`${e}Class`] = this._class.isItemVisible[t[e]];
            this.setState(o),
            !0 === e && this.collapse(),
            !0 === i && this.hideFullScreenOption(),
            "flood" !== n && "natural" !== n || this.toggleLightOptions(n),
            this._updateSize(!0)
        }
        getOrientation() {
            return this._ori
        }
        setOrientation(t="") {
            this._ori = t
        }
        isHorizontal() {
            if ("" !== this._ori)
                return "horizontal" === this._ori;
            for (const t in this._config.orientation) {
                const e = this._config.orientation[t];
                if (e.check())
                    return "horizontal" === e.ori
            }
            return !1
        }
        _updateSize(t=!1) {
            const e = this.isHorizontal();
            if (!t && this._isHorizontal === e)
                return;
            this._isHorizontal = e;
            let i = 1;
            const s = Array.from(this._children.content.querySelectorAll(":scope > button"));
            for (let t = 0; t < s.length; t++)
                s[t].classList.contains("hidden") || i++;
            this._config.allowZoom && i++,
            this._isHorizontal ? (this._element.style.width = `calc(${i} * 30px + ${i} * 2px)`,
            this._element.style.height = "30px") : (this._element.style.width = "30px",
            this._element.style.height = `calc(${i} * 30px + ${i} * 2px)`),
            this.updateTooltips(e)
        }
        _zoomContinuously(t) {
            this._isMouseHold = !0,
            null !== this._zoomTimeout && clearTimeout(this._zoomTimeout),
            this._zoomTimeout = setTimeout(( () => {
                this._isMouseHold && (this._isContinuousZoom = !0,
                null !== this._zoomInterval && clearInterval(this._zoomInterval),
                this._zoomInterval = setInterval(( () => {
                    this._isMouseHold ? t(!0) : clearInterval(this._zoomInterval)
                }
                ), 30))
            }
            ), 200)
        }
        _zoomIn(t=!1) {
            t ? this._zoomContinuously(this._config.zoomIn) : this._config.zoomIn()
        }
        _zoomOut(t=!1) {
            t ? this._zoomContinuously(this._config.zoomOut) : this._config.zoomOut()
        }
        _stopZooming() {
            clearInterval(this._zoomInterval),
            this._isMouseHold = !1,
            this._isContinuousZoom = !1
        }
        show() {
            this.setState({
                isVisible: !0,
                isVisibleClass: this._class.isVisible.true
            })
        }
        hide() {
            this.setState({
                isVisible: !1,
                isVisibleClass: this._class.isVisible.false,
                showLightingOptionsClass: this._class.isVisible.false
            })
        }
        isVisible() {
            return this._state.isVisible
        }
        expand() {
            this.setState({
                isCollapsed: !1,
                containerClass: this._class.container.expand
            })
        }
        collapse() {
            this.setState({
                isCollapsed: !0,
                showLightingOptionsClass: this._class.isVisible.false,
                containerClass: this._class.container.collapse
            })
        }
        toggleCollapse() {
            this._state.isCollapsed ? this.expand() : this.collapse(),
            this.triggerCallbacks("expandtoggle", [!this._state.isCollapsed, this._state.isPhotoMode])
        }
        toggleUnit() {
            const t = !this._state.isMetric;
            this.setState({
                isMetric: t,
                unitButton: t ? this._class.icon.imperial : this._class.icon.metric
            }, ( () => {
                this.triggerCallbacks("unitchange", [this._state.isMetric])
            }
            ))
        }
        toggleFullscreen() {
            s.default.isEnabled && s.default.toggle()
        }
        toggleLayers() {
            !this._app.getComponent("layerPanel").getState("isVisible") ? (this._app.getComponent("layerPanel").show(),
            this.collapse()) : this._app.getComponent("layerPanel").hide()
        }
        togglePhotoMode() {
            const t = !this._state.isPhotoMode;
            this.setState({
                isPhotoMode: t,
                photoModeClass: this._class.photo[t]
            }, ( () => {
                this._state.isPhotoMode ? this.collapse() : this.expand(),
                this.triggerCallbacks("photomodechange", [this._state.isPhotoMode])
            }
            ))
        }
        hideLightingOptions(t) {
            [this._children.lightToggle, this._children.lightOptions, this._children.flood, this._children.natural, this._children.shadow].includes(t.target) || this.setState({
                showLightingOptionsClass: this._class.isVisible.false
            }),
            window.removeEventListener("mousedown", this.hideLightingOptions),
            window.removeEventListener("touchstart", this.hideLightingOptions)
        }
        hideFullScreenOption() {
            const t = {};
            t.allowFullscreenClass = this._class.isItemVisible[!1],
            this.setState(t)
        }
        toggleLightOptions(t) {
            this.setState({
                lightType: t,
                lightClass: this._class.light[t],
                showLightingOptionsClass: this._class.isVisible.false
            }, ( () => {
                "flood" === t ? (this._app.getManager("camera")?.toggleCameraLight(!0, this._fullLightColor),
                this._app.getManager("comparison")?.setCameraLight(!0, this._fullLightColor)) : "natural" === t ? (this._app.getManager("camera")?.toggleCameraLight(!1),
                this._app.getManager("comparison")?.setCameraLight(!1)) : "shadow" === t && (this._app.getManager("camera")?.toggleCameraLight(!0, this._shadowLightColor),
                this._app.getManager("comparison")?.setCameraLight(!0, this._shadowLightColor));
                for (const e in this._children)
                    e === t || "flood" !== e && "natural" !== e && "shadow" !== e || this._children[e].classList.remove("selected-lighting");
                this._children[`${t}`].classList.add("selected-lighting")
            }
            ))
        }
        toggleLight() {
            this.setState({
                showLightingOptionsClass: this.getState("showLightingOptionsClass") === this._class.isVisible.true ? this._class.isVisible.false : this._class.isVisible.true
            }),
            this.getState("showLightingOptionsClass") === this._class.isVisible.true ? (window.addEventListener("mousedown", this.hideLightingOptions),
            window.addEventListener("touchstart", this.hideLightingOptions)) : (window.removeEventListener("mousedown", this.hideLightingOptions),
            window.removeEventListener("touchstart", this.hideLightingOptions))
        }
        startGuidedCamera() {
            this.setState({
                isGuidedCamera: !0,
                guidedClass: this._class.camera.true
            }, ( () => this.triggerCallbacks("guidedcamerachange", [this._state.isGuidedCamera])))
        }
        stopGuidedCamera() {
            this.setState({
                isGuidedCamera: !1,
                guidedClass: this._class.camera.false
            }, ( () => this.triggerCallbacks("guidedcamerachange", [this._state.isGuidedCamera])))
        }
        toggleGuidedCamera() {
            this._state.isGuidedCamera ? this.stopGuidedCamera() : this.startGuidedCamera()
        }
        toggleInfoPanel() {
            null !== this._app.getComponent("infoPanel") && this._app.getComponent("infoPanel").openPanel()
        }
        resize() {
            super.resize();
            const t = this.isHorizontal();
            this._isHorizontal !== t && this.setState({
                isHorizontal: t,
                orientationClass: this._class.isHorizontal[t]
            }),
            this._updateSize()
        }
    }
    Settings.html = r(),
    e.default = Settings
}
, , function(t) {
    t.exports = '<div class="settings {{isVisibleClass}} {{orientationClass}}">\n\t<div key="container" class="container {{containerClass}}">\n\t\t<div key="content" class="content">\n\t\t\t<button class="clickable icon icon-box {{allowInfoPanelClass}}" onclick="toggleInfoPanel" data-tippy-content="Show info panel" aria-label="show info panel">\n\t\t\t\t<span class="icon {{infoButton}}"></span>\n\t\t\t</button>\n\t\t\t<button class="clickable icon icon-layers {{allowLayersClass}}" onclick="toggleLayers" data-tippy-content="Toggle layers" aria-label="toggle layers"></button>\n\t\t\t<button class="clickable icon {{unitButton}} {{allowToggleUnitClass}}" onclick="toggleUnit" data-tippy-content="Toggle between metric and imperial units" aria-label="toggle between metric and imperial units"></button>\n\t\t\t<button class="clickable icon icon-hide {{photoModeClass}} {{allowPhotoModeClass}}" onclick="togglePhotoMode" data-tippy-content="Show or hide UI" aria-label="show or hide UI"></button>\n\t\t\t<button class="clickable icon-bg zoom {{allowZoomClass}}">\n\t\t\t\t<span key="zoomInButton" class="icon icon-plus" data-tippy-content="Zoom in" aria-label="zoom in" role="button"></span>\n\t\t\t\t<div class="horizontal-line"></div>\n\t\t\t\t<span key="zoomOutButton" class="icon icon-minus" data-tippy-content="Zoom out" aria-label="zoom out" role="button"></span>\n\t\t\t</button>\n\t\t\t<button key="lightToggle" class="light-toggle clickable icon icon-box {{allowLightingClass}}" onclick="toggleLight" data-tippy-content="Toggle light modes" aria-label="toggle light modes">\n\t\t\t\t<span class="icon {{lightClass}}"></span>\n\t\t\t</button>\n\t\t\t<button class="clickable icon {{guidedClass}} {{allowGuidedCameraClass}}" onclick="toggleGuidedCamera" data-tippy-content="Toggle auto camera" aria-label="toggle auto camera"></button>\n\t\t\t<div key="lightOptions" class="lighting-option-container small {{showLightingOptionsClass}}">\n\t\t\t\t<button key="flood" class="button lighting-option clickable">\n\t\t\t\t\t<span class="lighting-icon icon icon-flood-light"></span>\n\t\t\t\t\t<span class="title">Flood Lighting</span>\n\t\t\t\t</button>\n\t\t\t\t<button key="shadow" class="button lighting-option clickable" value="shadow">\n\t\t\t\t\t<span class="lighting-icon icon icon-shadow-light"></span>\n\t\t\t\t\t<span class="title">Shadow Lighting</span>\n\t\t\t\t</button>\n\t\t\t\t<button key="natural" class="button lighting-option clickable" value="natural">\n\t\t\t\t\t<span class="lighting-icon icon icon-natural-light"></span>\n\t\t\t\t\t<span class="title">Natural Lighting</span>\n\t\t\t\t</button>\n\t\t\t</div>\n\t\t\t<button class="clickable icon icon-fullscreen {{fullscreenClass}} {{allowFullscreenClass}}" onclick="toggleFullscreen" data-tippy-content="Toggle fullscreen" aria-label="toggle fullscreen"></button>\n\t\t</div>\n\t</div>\n\t<button class="toggle clickable icon icon-controls {{isCollapsibleClass}}" onclick="toggleCollapse" data-tippy-content="Show or hide settings" aria-label="show or hide settings"></button>\n</div>\n'
}
, , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t, e, i) {
    "use strict";
    i.r(e);
    var s = i(207);
    i(209);
    e.default = s.default
}
, function(t, e, i) {
    "use strict";
    i.r(e);
    var s = i(2)
      , n = i(208)
      , o = i.n(n);
    class LoadIcon extends s.BaseComponent {
        init() {
            super.init(),
            this._callbackRegistry.push({
                emitter: this._app.getManager("scene"),
                event: "loading",
                callback: this.show
            }, {
                emitter: this._app.getManager("scene"),
                event: "loaded",
                callback: this.hide
            }),
            this.hide()
        }
    }
    LoadIcon.html = o(),
    e.default = LoadIcon
}
, function(t) {
    t.exports = '<div class="load-icon {{isVisibleClass}}">\n\t<div class="bg face"></div>\n\t<div class="front face"></div>\n\t<div class="left face"></div>\n\t<div class="top face"></div>\n\t<div class="right face"></div>\n\t<div class="bottom face"></div>\n\t<div class="text">Loading</div>\n</div>\n'
}
, function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t, e, i) {
    "use strict";
    i.r(e);
    var s = i(211);
    i(213);
    e.default = s.default
}
, function(t, e, i) {
    "use strict";
    i.r(e);
    i(138);
    var s = i(2)
      , n = i(212)
      , o = i.n(n);
    class Overlay extends s.BaseComponent {
        constructor(t, e={}) {
            super(t, null, {
                isVisible: !1,
                isOpenButtonVisible: !0,
                content: null,
                ...e
            }),
            this._class.isOpenButtonVisibleClass = {
                true: "",
                false: "hidden"
            },
            Object.assign(this._state, {
                isOpenButtonVisibleClass: this._class.isOpenButtonVisibleClass[this._state.isOpenButtonVisible]
            }),
            this._scrollbar = null
        }
        init() {
            super.init(),
            null !== this._state.content && this._children.overlayContent.appendChild(this._state.content),
            this._element.addEventListener("click", this.hide),
            this._element.addEventListener("animationend", ( () => {
                this._children.overlay.classList.contains("hidden") && (this._children.overlay.style.display = "none")
            }
            ))
        }
        setContent(t) {
            null === this._state.content ? this._children.overlayContent.appendChild(t) : this._children.overlayContent.replaceChild(t, this._state.content),
            this._state.content = t
        }
        show() {
            this._element.classList.add("initialized"),
            this._children.overlay.style.display = "",
            super.show()
        }
        __enable() {
            super.__enable(),
            null === this._scrollbar ? s.AppUtils.onAttachElement(this._children.overlay, ( () => {
                this._scrollbar = s.AppUtils.addScrollbar(this._children.overlay)
            }
            )) : this._scrollbar.scroll(0)
        }
    }
    Overlay.html = o(),
    e.default = Overlay
}
, function(t) {
    t.exports = '<div class="overlay-container">\n\t<button class="open-button icon icon-info clickable {{isOpenButtonVisibleClass}}" onclick="show"></button>\n\t<div key="overlay" class="overlay {{isVisibleClass}}">\n\t\t<div key="overlayContent" class="container"></div>\n\t\t<button class="close-button icon icon-close clickable" onclick="hide"></button>\n\t</div>\n</div>\n'
}
, function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t, e, i) {
    "use strict";
    i.r(e);
    var s = i(215);
    i(217);
    e.default = s.default
}
, function(t, e, i) {
    "use strict";
    i.r(e);
    var s = i(2)
      , n = i(216)
      , o = i.n(n);
    class Search extends s.BaseComponent {
        constructor(t, e={
            config: {}
        }) {
            e.config = {
                initialOpen: !1,
                allowFeatured: !1,
                allowDetail: !0,
                allowInfo: !1,
                stopOnExactMatch: !1,
                infoText: {
                    default: "most popular",
                    results: "result",
                    suggestions: "suggestion",
                    nomatches: "no matches"
                },
                maxSuggestions: 1,
                placeholderText: "Search...",
                nameSearch: ["iauName", "displayName"],
                nameDisplay: ["displayName", "iauName"],
                ...e.config
            },
            super(t, null, {
                text: "",
                searchInfo: e.config?.infoText?.default || "",
                alwaysOpen: !1,
                magClass: "mag-open",
                searchClass: "search-close",
                focusedClass: "",
                isFeaturedVisible: !1,
                ...e
            }),
            this._class.isItemVisible = {
                true: "",
                false: "hidden"
            },
            Object.assign(this._state, {
                allowFeaturedClass: this._class.isItemVisible[this._config.allowFeatured],
                isFeaturedVisibleClass: this._class.isItemVisible[this._config.allowFeatured && this._state.isFeaturedVisible],
                allowInfoClass: this._class.isItemVisible[this._config.allowInfo]
            }),
            this._eventNames.push("resultselected"),
            this._initCallbacks(),
            this._resultsScrollbar = null,
            this._featuredScrollbar = null,
            this.onResize = null,
            this.results = [],
            this._excludeResults = [],
            this._suggestionsThreshold = .05,
            this.index = -1,
            this.bindFunctions(["_find", "renderResults", "open", "close", "eraseInput", "onIconClick", "reset", "keydown", "onInputFocus", "_getDetails", "_handleClick"]),
            window.addEventListener("setupSearch", this.resize)
        }
        init() {
            super.init();
            const t = .9 * this._children.input.getAttribute("placeholder").length;
            this._children.input.style.minWidth = `${t}ch`,
            this._children.input.onkeyup = t => {
                const e = 0 === this._children.input.value.length;
                this._config.allowFeatured && e !== this._state.isFeaturedVisible && (this._featuredScrollbar?.scroll(0),
                this.setState({
                    isFeaturedVisible: e,
                    isFeaturedVisibleClass: this._class.isItemVisible[e],
                    ...e && {
                        searchInfo: this._config.infoText.default
                    }
                }))
            }
            ,
            this.resize(),
            this.registerManager(this._app.getManager("search"))
        }
        onIconClick() {
            "search-close" === this._state.searchClass ? (this._scrollbar?.scroll(0),
            this.open(),
            this._children.input.focus()) : "" === this._children.input.value ? this.reset() : this._children.results.querySelector(".active")?.firstChild.click()
        }
        resize() {
            super.resize(),
            "function" == typeof this.onResize && this.onResize()
        }
        reset() {
            this.eraseInput(),
            this._config.initialOpen || this.close()
        }
        keydown(t) {
            const e = t.key;
            "Escape" === e && (this.eraseInput(),
            this.close());
            const i = this.results.length;
            i && ("ArrowDown" === e ? (this.index = (this.index + 1) % i,
            t.preventDefault()) : "ArrowUp" === e ? (this.index -= 1,
            this.index < 0 && (this.index = i - 1),
            t.preventDefault()) : "Enter" === e && (this._handleClick(this.results[this.index]?.link || this.results[0]?.link, this._searchString),
            t.preventDefault()),
            this.setSelected(this.index))
        }
        setSelected(t) {
            this.index = t;
            for (let t = 0; t < this.results.length; t++) {
                const e = this.results[t].element;
                e && (t === this.index ? e.classList.add("active") : e.classList.remove("active"))
            }
        }
        onInputFocus() {
            this.setState({
                focusedClass: "input-focused"
            })
        }
        eraseInput() {
            this._resultsScrollbar?.destroy(),
            this._resultsScrollbar = null,
            this._children.input.value = "",
            this._children.results.innerHTML = ""
        }
        registerManager(t) {
            this._searchManager = t
        }
        _find(t, e) {
            this._searchTimeout && clearTimeout(this._searchTimeout),
            t && t.target && t.target.value && (e = t.target.value);
            const {maxEntries: i} = this._config;
            this._searchTimeout = setTimeout((async () => {
                if (this._searchManager) {
                    const t = this._searchManager.find(e, i)
                      , s = t?.length && this._excludeResults?.length ? t.filter(( ({item: t}) => !this._excludeResults.includes(t.id))) : t;
                    await this.renderResults(s, e)
                }
            }
            ), 100)
        }
        async renderResults(t, e) {
            if (this.index = -1,
            this.results = [],
            this._searchString = e,
            this._resultsScrollbar?.destroy(),
            this._resultsScrollbar = null,
            this._children.results.innerHTML = "",
            this._children.results.classList.remove("no-results"),
            !t || !Array.isArray(t))
                return;
            const i = []
              , s = [];
            for (let n = 0; n < t.length; n++) {
                const o = t[n]
                  , {nameSearch: a} = this._config
                  , r = o.item[a.find((t => void 0 !== o.item[t]))];
                if (this._config.stopOnExactMatch && e.toLowerCase() === r.toLowerCase()) {
                    s.length = 0,
                    i.length = 0,
                    s.push(o);
                    break
                }
                o.score < this._suggestionsThreshold ? s.push(o) : i.push(o)
            }
            1 === s.length ? this._config.allowDetail ? await this._renderResultCard(s[0], e) : this._renderResultList(s, e) : 0 === s.length ? this._renderSuggestions(i, e) : this._renderResultList(s, e),
            s.length > 3 && (this._resultsScrollbar ??= this._createScrollbar(this._children.results));
            const {allowInfo: n, infoText: o, maxSuggestions: a} = this._config;
            if (n) {
                let t = o.nomatches;
                s.length ? t = `${s.length} ${o.results}${s.length > 1 ? "s" : ""}` : i.length && (t = `${Math.min(i.length, a)} ${o.suggestions}${i.length > 1 ? "s" : ""}`),
                this.setState({
                    searchInfo: t
                })
            }
            this.setSelected(0)
        }
        async _renderResultCard(t, e) {
            try {
                let i = await this._getDetails(t);
                if (!i && t && t.item) {
                    const {nameDisplay: e} = this._config;
                    i = {
                        title: t.item[e.find((e => void 0 !== t.item[e]))]
                    }
                }
                const n = document.createElement("div");
                n.className = "card-title result-div";
                const o = document.createElement("h4");
                o.className = "semi clickable";
                let a = i.title;
                if ("string" == typeof a) {
                    const t = a.toUpperCase().indexOf(e.toUpperCase());
                    if (t > -1) {
                        const i = a.substring(t, t + e.length)
                          , s = a.split(i);
                        s && 2 === s.length && (a = "",
                        s[0].length > 0 && (a += `<span class='unmatch'>${s[0]}</span>`),
                        a += i,
                        s[1].length > 0 && (a += `<span class='unmatch'>${s[1]}</span>`))
                    }
                } else
                    a = "";
                o.innerHTML = a;
                const r = s.AppUtils.addStartToPath(t.item.id);
                o.addEventListener("mouseover", ( () => {
                    this.setSelected(0)
                }
                ), !1),
                o.addEventListener("click", (i => {
                    t.item && this._handleClick(t.item.id, e),
                    i?.stopPropagation?.()
                }
                ), !1),
                n.appendChild(o),
                this.results.push({
                    link: r,
                    element: n
                }),
                this._children.results.innerHTML = "",
                this._children.results.appendChild(n),
                i.cards && this._createStoryBlock(i.cards),
                i.featuredEvents && i.featuredEvents.initial && this._createEventsBlock(i.featuredEvents.initial, t.item.id),
                i.exploration && i.exploration.initial && this._createExplorationBlock(i.exploration.initial),
                i.featuredMoons && this._createMoonsBlock(i.featuredMoons, t.item.id)
            } catch (i) {
                void 0 !== i.status && 404 === i.status ? this._renderResultList([t], e) : i && console.error(i)
            }
        }
        _createEventsBlock(t, e) {
            if (!Array.isArray(t) || 0 === t.length)
                return;
            const i = this._app.getManager("content").getEntityInfo(e);
            if (null === i || !i.hasEvents)
                return;
            const n = this._createBlockContainer();
            n.classList.add("events");
            this._createHeaderBlock("Featured Events", n);
            for (let i = 0; i < t.length; i++) {
                const o = t[i]
                  , a = o.title
                  , r = s.AppUtils.addStartToPath(e + "/events/" + o.eventId)
                  , l = this._createSingleResult(a, r, n);
                this.results.push({
                    link: r,
                    element: l
                })
            }
        }
        _createMoonsBlock(t) {
            if (!Array.isArray(t) || 0 === t.length)
                return;
            const e = this._createBlockContainer();
            e.classList.add("moons");
            this._createHeaderBlock("Featured Moons", e);
            for (let i = 0; i < t.length; i++) {
                const s = t[i]
                  , n = t[i]
                  , o = this._createSingleResult(s, n, e);
                this.results.push({
                    link: n,
                    element: o
                })
            }
        }
        _createExplorationBlock(t) {
            if (!Array.isArray(t) || 0 === t.length)
                return;
            const e = this._createBlockContainer();
            e.classList.add("exploration");
            this._createHeaderBlock("Exploration", e);
            for (let i = 0; i < t.length; i++) {
                const s = t[i];
                let n = s.title;
                null !== s.info && void 0 !== s.info && (n += " (" + s.info + ")");
                const o = s.url
                  , a = this._createSingleResult(n, o, e);
                this.results.push({
                    link: o,
                    element: a
                })
            }
        }
        _createStoryBlock(t) {
            if (!Array.isArray(t) || 0 === t.length)
                return;
            const e = this._createBlockContainer();
            e.classList.add("stories");
            let i = !1;
            for (let s = 0; s < t.length; s++) {
                const n = t[s];
                if (void 0 !== n.storyId) {
                    const t = this._app.getManager("content").getStoryList().stories[n.storyId];
                    if (void 0 !== t) {
                        i || (this._createHeaderBlock("Stories", e),
                        i = !0);
                        const s = t.title
                          , o = "/story/" + n.storyId
                          , a = this._createSingleResult(s, o, e);
                        this.results.push({
                            link: o,
                            element: a
                        })
                    }
                }
            }
        }
        _createBlockContainer() {
            const t = document.createElement("div");
            return t.className = "block-container",
            this._children.results.appendChild(t),
            t
        }
        _createHeaderBlock(t, e) {
            const i = document.createElement("div");
            i.className = "header";
            const s = document.createElement("span");
            s.className = "title small semi",
            s.innerHTML = t,
            i.appendChild(s),
            e.appendChild(i)
        }
        _createSingleResult(t, e, i) {
            const s = document.createElement("div");
            s.className = "result-div";
            const n = document.createElement("button");
            n.className = "small clickable capitalize",
            n.innerHTML = t;
            const o = this.results.length - 1 + 1;
            return s.addEventListener("click", (t => {
                this._handleClick(e, this._searchString),
                t?.stopPropagation?.()
            }
            ), !1),
            s.addEventListener("mouseover", ( () => {
                this.setSelected(o)
            }
            ), !1),
            s.appendChild(n),
            i.appendChild(s),
            s
        }
        _renderResultList(t, e) {
            for (let i = 0; i < t.length; i++) {
                const n = t[i].item
                  , {nameSearch: o} = this._config
                  , a = n[o.find((t => void 0 !== n[t]))];
                if (!a)
                    continue;
                const r = document.createElement("button");
                r.className = "entries clickable thin small";
                const l = n.url || n.id;
                let c = a;
                const h = a.toUpperCase().indexOf(e.toUpperCase());
                if (h > -1) {
                    const t = c.substring(h, h + e.length);
                    c = c.replace(t, `<span class='semi'>${t}</span>`)
                }
                r.innerHTML = c;
                const d = s.AppUtils.addStartToPath(l)
                  , u = document.createElement("div");
                u.className = "result-div",
                u.appendChild(r),
                u.addEventListener("mouseover", ( () => {
                    this.setSelected(i)
                }
                ), !1),
                u.addEventListener("click", (t => {
                    this._handleClick(l, e),
                    t?.stopPropagation?.()
                }
                ), !1),
                this.results.push({
                    link: d,
                    element: u
                }),
                this._children.results.appendChild(u)
            }
        }
        _renderSuggestions(t, e) {
            const i = document.createElement("div");
            if (i.className = "suggestion",
            t.length > 0) {
                const n = document.createElement("label");
                n.className = "title small semi",
                n.innerHTML = "Did you mean...?",
                i.appendChild(n);
                for (let n = 0; n < Math.min(this._config.maxSuggestions, t.length); n++) {
                    const o = document.createElement("button");
                    o.className = "entries clickable";
                    const a = t[n].item
                      , {nameSearch: r} = this._config
                      , l = a[r.find((t => void 0 !== a[t]))];
                    if (l) {
                        const t = a.url || a.id;
                        o.innerHTML = l;
                        const r = s.AppUtils.addStartToPath(t);
                        o.addEventListener("mouseover", ( () => {
                            this.setSelected(n)
                        }
                        ), !1),
                        o.addEventListener("click", (i => {
                            this._handleClick(t, e),
                            i?.stopPropagation?.()
                        }
                        ), !1);
                        const c = document.createElement("div");
                        c.className = "result-div small",
                        c.appendChild(o),
                        i.appendChild(c),
                        this.results.push({
                            link: r,
                            element: c
                        })
                    }
                }
            } else if (!this._config.allowInfo) {
                const t = document.createElement("label");
                t.className = "title no-match small",
                t.innerHTML = "No matches.",
                i.appendChild(t),
                this._children.results.classList.add("no-results")
            }
            this._children.results.appendChild(i)
        }
        open() {
            this.setState({
                magClass: "mag-close",
                searchClass: "search-open",
                isFeaturedVisible: this._config.allowFeatured,
                isFeaturedVisibleClass: this._class.isItemVisible[this._config.allowFeatured],
                ...this._config.allowFeatured && {
                    searchInfo: this._config.infoText.default
                }
            }),
            this.app.isSearching = !0
        }
        close() {
            this.getState("alwaysOpen") ? this.setState({
                magClass: "mag-close",
                searchClass: "search-open",
                focusedClass: "",
                isFeaturedVisible: !1,
                isFeaturedVisibleClass: this._class.isItemVisible.false
            }) : this.setState({
                magClass: "mag-open",
                searchClass: "search-close",
                focusedClass: "",
                isFeaturedVisible: !1,
                isFeaturedVisibleClass: this._class.isItemVisible.false
            }),
            this._children.input?.blur(),
            this.app.isSearching = !1
        }
        setupFeaturedSuggestion(t=[]) {
            this._children.featured.innerHTML = "";
            for (let e = 0; e < t.length; e++) {
                const {text: i, url: s} = t[e]
                  , n = document.createElement("li");
                n.innerHTML = i,
                n.className = "clickable thin",
                n.addEventListener("click", (t => {
                    this._handleClick(s, this._searchString),
                    t?.stopPropagation?.()
                }
                )),
                this._children.featured.appendChild(n)
            }
        }
        _createScrollbar(t) {
            return s.AppUtils.addScrollbar(t, {
                sizeAutoCapable: !0
            })
        }
        _getLink(t) {
            return t
        }
        _handleClick(t, e) {
            if (!t)
                return;
            this.reset(),
            this.triggerCallbacks("resultselected");
            const i = this._app.getManager("router")
              , s = this._getLink(t)
              , n = "string" == typeof s ? s : s.path ?? "";
            if (n.includes("events"))
                i.navigate({}, n, {
                    __remove: "all"
                });
            else {
                const {options: t={
                    keepTime: !0
                }, query: e={}} = "object" == typeof s && s;
                i.navigate(e, n, t)
            }
        }
        simulate(t) {
            const {input: e} = this._children;
            this.onIconClick(),
            e.value = t,
            this._find({}, t),
            e.onkeyup()
        }
        async _getDetails(t) {
            return this._app.getManager("content").getEntityDesc(t.item.id)
        }
        setExcludeResults(t) {
            this._excludeResults = t
        }
        __enable() {
            super.__enable();
            const {allowFeatured: t} = this._config;
            if (t) {
                const {parentElement: t} = this._children.featured || {};
                document.body.contains(t) && (this._featuredScrollbar ??= this._createScrollbar(t))
            }
        }
    }
    Search.html = o(),
    e.default = Search
}
, function(t) {
    t.exports = '<div class="search {{isVisibleClass}}">\n\t<span class="icon icon-search clickable {{magClass}}" onclick="onIconClick"></span>\n\t<div class="{{searchClass}} {{focusedClass}}">\n\t\t<div class="cover" onclick="reset"></div>\n\t\t<div key="container" class="bar">\n\t\t\t<span class="icon icon-search clickable"></span>\n\t\t\t<input key="input" type="text" placeholder="{$placeholderText}" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" oninput="_find" onfocus="onInputFocus" onkeydown="keydown"></input>\n\t\t\t<span class="close icon icon-close clickable search-close-icon" onclick="reset"></span>\n\t\t\t<div class="results-container">\n\t\t\t\t<div key="results" class="scrollable results gradient"></div>\n\t\t\t</div>\n\t\t\t<span class="search-info tiny {{allowInfoClass}}">{{searchInfo}}</span>\n\t\t\t<div class="featured gradient scrollable {{allowFeaturedClass}} {{isFeaturedVisibleClass}}">\n\t\t\t\t<ul key="featured"></ul>\n\t\t\t</div>\n\t\t</div>\n\t</div>\n</div>\n'
}
, function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t, e, i) {
    "use strict";
    i.r(e);
    var s = i(219);
    i(361);
    e.default = s.default
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        Clock: function() {
            return Clock
        }
    });
    var s = i(2)
      , n = (i(220),
    i(360))
      , o = i.n(n);
    class Clock extends s.BaseComponent {
        constructor(t, e={}) {
            super(t, null, {
                isVisible: !1,
                isDateVisible: !0,
                isTimeVisible: !0,
                isMeridiemVisible: !0,
                allowEdit: !0,
                date: "Date",
                time: "Time",
                meridiem: "",
                alert: "",
                isKioskSessionTimer: !1,
                ...e
            }),
            Object.assign(this._state, {
                isDateVisibleClass: this._class.isVisible[this._state.isDateVisible],
                isTimeVisibleClass: this._class.isVisible[this._state.isTimeVisible],
                isMeridiemVisibleClass: this._class.isVisible[this._state.isMeridiemVisible]
            }),
            this.bindFunctions(["update", "onDateTimeClick"])
        }
        init() {
            super.init();
            const {allowEdit: t, isKioskSessionTimer: e} = this._state;
            this._app.getManager("time").setDateFormats({
                utc: {
                    date: "MMM DD, YYYY",
                    time: "HH[:]mm[:]ss"
                },
                local: {
                    date: "MMM DD, YYYY",
                    time: "hh[:]mm[:]ss",
                    meridiem: "a",
                    parse: ["MMM D, YYYY h:m:s a", "MMM D, YYYY h:m a", "MMM D, YYYY h a", "MMM D, YYYY"]
                }
            }),
            this._app.getManager("time").setDisplayUTC(!1);
            const {displayContainer: i, timeInput: s, timeForm: n} = this._children;
            t && (i.classList.add("editable"),
            s.addEventListener("keyup", (t => {
                t.stopPropagation()
            }
            )),
            s.addEventListener("keydown", (t => {
                t.stopPropagation()
            }
            )),
            n.classList.add("editable"),
            n.addEventListener("submit", (t => {
                s.blur(),
                this._parseTime(s.value),
                t.preventDefault()
            }
            )),
            s.addEventListener("blur", (t => {
                n.classList.add("hidden"),
                i.classList.remove("hidden")
            }
            ))),
            this._setVariables(this._element),
            this._children.date.classList.add("semi"),
            this._children.time.classList.add("semi"),
            this._children.meridiem.classList.add("semi"),
            this._children.timeInput.classList.add("semi"),
            this._children.timeForm.classList.add("semi"),
            e || this._callbackRegistry.push({
                emitter: this._app.getManager("time"),
                event: "update",
                callback: this.update
            })
        }
        onDateTimeClick() {
            const {displayContainer: t, timeInput: e, timeForm: i, date: s, time: n, meridiem: o} = this._children
              , a = this._app.getManager("router").currentRoute.url.includes("story");
            if (!this._state.allowEdit || a)
                return;
            const r = this._state.meridiem ? ` ${o.innerHTML}` : "";
            e.value = `${s.innerHTML} ${n.innerHTML}${r}`,
            t.classList.add("hidden"),
            i.classList.remove("hidden"),
            e.focus()
        }
        isERT() {
            return this._isERT
        }
        toggle(t, e) {
            switch (t) {
            case "date":
                this.setState({
                    isDateVisible: e,
                    isDateVisibleClass: this._class.isVisible[e]
                });
                break;
            case "time":
                this.setState({
                    isTimeVisible: e,
                    isTimeVisibleClass: this._class.isVisible[e]
                });
                break;
            case "meridiem":
                this.setState({
                    isMeridiemVisible: e,
                    isMeridiemVisibleClass: this._class.isVisible[e]
                })
            }
        }
        _parseTime(t) {
            const e = this._app.getManager("router")
              , i = this._app.getManager("time").parseTime(t, "parse");
            if (i.isValid()) {
                this._app.getManager("time").setDisplayUTC(i.isUTC());
                const t = this._app.getManager("time").getTimeUrl(i);
                e.navigate({
                    time: t
                }, e.currentRoute.url)
            } else
                console.error("Invalid input: " + t),
                e.navigate({
                    __remove: ["time"]
                }, e.currentRoute.url)
        }
        update(t, e=!1) {
            this._state.isVisible && (e ? this.setState({
                time: t
            }) : this.setState({
                date: t.format(this._app.getManager("time").getDateFormat("date")),
                time: t.format(this._app.getManager("time").getDateFormat("time")),
                meridiem: this._app.getManager("time").isUTC() ? "" : t.format(this._app.getManager("time").getDateFormat("meridiem")),
                alert: this._app.getManager("time").forcedPause ? "alert" : ""
            }))
        }
        backToLive() {
            const t = this._app.getManager("router")
              , e = this._app.getManager("time");
            if (!e.isNow()) {
                const i = e.getTimeUrl(e.getNow())
                  , s = t.query.time;
                t.navigate({
                    __remove: ["time", "rate"]
                }, t.currentRoute.url),
                s !== i && (e.setTimeRate(1),
                e.setToNow())
            }
        }
        setLimitMessage(t, e) {
            let i;
            if (e)
                i = `"${e}"`;
            else {
                const {currentView: e} = this._app.getManager("router")
                  , {_isSpacecraft: s} = this._app.getView(e);
                let n = "time " + (1 === t ? "maximum" : "minimum");
                "event" === e ? n = "event " + (1 === t ? "end" : "start") : s && (n = "mission " + (1 === t ? "end" : "start")),
                i = 1 === t ? `"cannot exceed ${n}"` : `"cannot preceed ${n}"`
            }
            this._children.displayContainer?.style.setProperty("--limit-message", i),
            this._displayLimitMessage(!0),
            this.limitMessageTimeout = setTimeout(( () => {
                this._displayLimitMessage(!1)
            }
            ), 3e3)
        }
        _displayLimitMessage(t) {
            this._children.displayContainer?.classList.toggle("limit", t)
        }
        __disable() {
            this._displayLimitMessage(!1),
            clearTimeout(this.limitMessageTimeout),
            super.__disable()
        }
    }
    Clock.html = o(),
    e.default = Clock
}
, , , , function(t, e, i) {
    var s = {
        "./af": 224,
        "./af.js": 224,
        "./ar": 225,
        "./ar-dz": 226,
        "./ar-dz.js": 226,
        "./ar-kw": 227,
        "./ar-kw.js": 227,
        "./ar-ly": 228,
        "./ar-ly.js": 228,
        "./ar-ma": 229,
        "./ar-ma.js": 229,
        "./ar-sa": 230,
        "./ar-sa.js": 230,
        "./ar-tn": 231,
        "./ar-tn.js": 231,
        "./ar.js": 225,
        "./az": 232,
        "./az.js": 232,
        "./be": 233,
        "./be.js": 233,
        "./bg": 234,
        "./bg.js": 234,
        "./bm": 235,
        "./bm.js": 235,
        "./bn": 236,
        "./bn-bd": 237,
        "./bn-bd.js": 237,
        "./bn.js": 236,
        "./bo": 238,
        "./bo.js": 238,
        "./br": 239,
        "./br.js": 239,
        "./bs": 240,
        "./bs.js": 240,
        "./ca": 241,
        "./ca.js": 241,
        "./cs": 242,
        "./cs.js": 242,
        "./cv": 243,
        "./cv.js": 243,
        "./cy": 244,
        "./cy.js": 244,
        "./da": 245,
        "./da.js": 245,
        "./de": 246,
        "./de-at": 247,
        "./de-at.js": 247,
        "./de-ch": 248,
        "./de-ch.js": 248,
        "./de.js": 246,
        "./dv": 249,
        "./dv.js": 249,
        "./el": 250,
        "./el.js": 250,
        "./en-au": 251,
        "./en-au.js": 251,
        "./en-ca": 252,
        "./en-ca.js": 252,
        "./en-gb": 253,
        "./en-gb.js": 253,
        "./en-ie": 254,
        "./en-ie.js": 254,
        "./en-il": 255,
        "./en-il.js": 255,
        "./en-in": 256,
        "./en-in.js": 256,
        "./en-nz": 257,
        "./en-nz.js": 257,
        "./en-sg": 258,
        "./en-sg.js": 258,
        "./eo": 259,
        "./eo.js": 259,
        "./es": 260,
        "./es-do": 261,
        "./es-do.js": 261,
        "./es-mx": 262,
        "./es-mx.js": 262,
        "./es-us": 263,
        "./es-us.js": 263,
        "./es.js": 260,
        "./et": 264,
        "./et.js": 264,
        "./eu": 265,
        "./eu.js": 265,
        "./fa": 266,
        "./fa.js": 266,
        "./fi": 267,
        "./fi.js": 267,
        "./fil": 268,
        "./fil.js": 268,
        "./fo": 269,
        "./fo.js": 269,
        "./fr": 270,
        "./fr-ca": 271,
        "./fr-ca.js": 271,
        "./fr-ch": 272,
        "./fr-ch.js": 272,
        "./fr.js": 270,
        "./fy": 273,
        "./fy.js": 273,
        "./ga": 274,
        "./ga.js": 274,
        "./gd": 275,
        "./gd.js": 275,
        "./gl": 276,
        "./gl.js": 276,
        "./gom-deva": 277,
        "./gom-deva.js": 277,
        "./gom-latn": 278,
        "./gom-latn.js": 278,
        "./gu": 279,
        "./gu.js": 279,
        "./he": 280,
        "./he.js": 280,
        "./hi": 281,
        "./hi.js": 281,
        "./hr": 282,
        "./hr.js": 282,
        "./hu": 283,
        "./hu.js": 283,
        "./hy-am": 284,
        "./hy-am.js": 284,
        "./id": 285,
        "./id.js": 285,
        "./is": 286,
        "./is.js": 286,
        "./it": 287,
        "./it-ch": 288,
        "./it-ch.js": 288,
        "./it.js": 287,
        "./ja": 289,
        "./ja.js": 289,
        "./jv": 290,
        "./jv.js": 290,
        "./ka": 291,
        "./ka.js": 291,
        "./kk": 292,
        "./kk.js": 292,
        "./km": 293,
        "./km.js": 293,
        "./kn": 294,
        "./kn.js": 294,
        "./ko": 295,
        "./ko.js": 295,
        "./ku": 296,
        "./ku.js": 296,
        "./ky": 297,
        "./ky.js": 297,
        "./lb": 298,
        "./lb.js": 298,
        "./lo": 299,
        "./lo.js": 299,
        "./lt": 300,
        "./lt.js": 300,
        "./lv": 301,
        "./lv.js": 301,
        "./me": 302,
        "./me.js": 302,
        "./mi": 303,
        "./mi.js": 303,
        "./mk": 304,
        "./mk.js": 304,
        "./ml": 305,
        "./ml.js": 305,
        "./mn": 306,
        "./mn.js": 306,
        "./mr": 307,
        "./mr.js": 307,
        "./ms": 308,
        "./ms-my": 309,
        "./ms-my.js": 309,
        "./ms.js": 308,
        "./mt": 310,
        "./mt.js": 310,
        "./my": 311,
        "./my.js": 311,
        "./nb": 312,
        "./nb.js": 312,
        "./ne": 313,
        "./ne.js": 313,
        "./nl": 314,
        "./nl-be": 315,
        "./nl-be.js": 315,
        "./nl.js": 314,
        "./nn": 316,
        "./nn.js": 316,
        "./oc-lnc": 317,
        "./oc-lnc.js": 317,
        "./pa-in": 318,
        "./pa-in.js": 318,
        "./pl": 319,
        "./pl.js": 319,
        "./pt": 320,
        "./pt-br": 321,
        "./pt-br.js": 321,
        "./pt.js": 320,
        "./ro": 322,
        "./ro.js": 322,
        "./ru": 323,
        "./ru.js": 323,
        "./sd": 324,
        "./sd.js": 324,
        "./se": 325,
        "./se.js": 325,
        "./si": 326,
        "./si.js": 326,
        "./sk": 327,
        "./sk.js": 327,
        "./sl": 328,
        "./sl.js": 328,
        "./sq": 329,
        "./sq.js": 329,
        "./sr": 330,
        "./sr-cyrl": 331,
        "./sr-cyrl.js": 331,
        "./sr.js": 330,
        "./ss": 332,
        "./ss.js": 332,
        "./sv": 333,
        "./sv.js": 333,
        "./sw": 334,
        "./sw.js": 334,
        "./ta": 335,
        "./ta.js": 335,
        "./te": 336,
        "./te.js": 336,
        "./tet": 337,
        "./tet.js": 337,
        "./tg": 338,
        "./tg.js": 338,
        "./th": 339,
        "./th.js": 339,
        "./tk": 340,
        "./tk.js": 340,
        "./tl-ph": 341,
        "./tl-ph.js": 341,
        "./tlh": 342,
        "./tlh.js": 342,
        "./tr": 343,
        "./tr.js": 343,
        "./tzl": 344,
        "./tzl.js": 344,
        "./tzm": 345,
        "./tzm-latn": 346,
        "./tzm-latn.js": 346,
        "./tzm.js": 345,
        "./ug-cn": 347,
        "./ug-cn.js": 347,
        "./uk": 348,
        "./uk.js": 348,
        "./ur": 349,
        "./ur.js": 349,
        "./uz": 350,
        "./uz-latn": 351,
        "./uz-latn.js": 351,
        "./uz.js": 350,
        "./vi": 352,
        "./vi.js": 352,
        "./x-pseudo": 353,
        "./x-pseudo.js": 353,
        "./yo": 354,
        "./yo.js": 354,
        "./zh-cn": 355,
        "./zh-cn.js": 355,
        "./zh-hk": 356,
        "./zh-hk.js": 356,
        "./zh-mo": 357,
        "./zh-mo.js": 357,
        "./zh-tw": 358,
        "./zh-tw.js": 358
    };
    function n(t) {
        var e = o(t);
        return i(e)
    }
    function o(t) {
        if (!i.o(s, t)) {
            var e = new Error("Cannot find module '" + t + "'");
            throw e.code = "MODULE_NOT_FOUND",
            e
        }
        return s[t]
    }
    n.keys = function() {
        return Object.keys(s)
    }
    ,
    n.resolve = o,
    t.exports = n,
    n.id = 223
}
, , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , function(t) {
    t.exports = '<time class="clock {{isVisibleClass}}">\n\t<div class="datetime-container {{alert}}">\n\t\t<div key="displayContainer" class="display-container">\n\t\t\t<div key="date" class="date {{isDateVisibleClass}} monospace" onclick="onDateTimeClick">{{date}}</div>\n\t\t\t<div key="time" class="time {{isTimeVisibleClass}} monospace" onclick="onDateTimeClick">{{time}}</div>\n\t\t\t<div key="meridiem" class="meridiem {{isMeridiemVisibleClass}} monospace" onclick="onDateTimeClick">{{meridiem}}</div>\n\t\t</div>\n\t\t<form key="timeForm" class="hidden" method="post" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">\n\t\t\t<input key="timeInput" type="text" name="hour" class="hour-input" placeholder="hour" autocorrect="off" autocapitalize="off" spellcheck="false" size="25"></input>\n\t\t</form>\n\t</div>\n</time>\n'
}
, function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t, e, i) {
    "use strict";
    i.r(e);
    var s = i(363);
    i(204),
    i(365);
    e.default = s.default
}
, function(t, e, i) {
    "use strict";
    i.r(e);
    var s = i(147)
      , n = (i(220),
    i(2))
      , o = i(364)
      , a = i.n(o);
    class ClockShortcut extends n.BaseComponent {
        constructor(t) {
            super(t, null, {
                hasHover: !1,
                liveContainerClass: "hidden",
                liveClass: "live",
                liveText: "live",
                liveIcon: "icon-live",
                replayClass: "container",
                replayIcon: "icon-replay"
            }),
            this._state.replayClass = "hidden",
            this._class.fontSize.small = "x-small",
            this._liveCallback = null,
            this.bindFunctions(["_replay", "backToLive", "update"])
        }
        init() {
            super.init();
            const {canHover: t, isTouch: e} = this._app;
            t && !e && (this._children.liveContainer.addEventListener("mouseenter", ( () => {
                this.setState({
                    hasHover: !0,
                    liveIcon: "icon-live"
                })
            }
            )),
            this._children.liveContainer.addEventListener("mouseleave", ( () => {
                this.setState({
                    hasHover: !1,
                    liveIcon: "icon-back-to-live"
                })
            }
            ))),
            s.default.setDefaultProps({
                theme: "default",
                touch: ["hold", 2e3],
                delay: [600, null],
                plugins: [s.followCursor]
            }),
            (0,
            s.default)(this._children.liveContainer, {
                content: "Reset time to live.",
                placement: "top"
            }),
            this._children.live.classList.add("semi", "color"),
            this._children.replay.classList.add("semi", "color"),
            this._element.removeChild(this._children.replayContainer),
            this._callbackRegistry.push({
                emitter: this._app.getManager("time"),
                event: "update",
                callback: this.update
            })
        }
        setCallback(t) {
            this._liveCallback = "function" == typeof t ? t : null
        }
        backToLive() {
            if ("function" == typeof this._liveCallback)
                this._liveCallback();
            else {
                const t = this._app.getManager("router")
                  , e = this._app.getManager("time");
                if (!e.isNow()) {
                    const i = e.getTimeUrl(e.getNow())
                      , s = t.query.time;
                    t.navigate({
                        __remove: ["time", "rate"]
                    }, t.currentRoute.url),
                    s !== i && (e.setTimeRate(1),
                    e.setToNow())
                }
            }
        }
        _replay() {
            this._app.getManager("router").navigate({
                __remove: ["time", "rate"]
            }) || (this._app.getManager("time").setTimeRate(1),
            this._app.getManager("time").setToStart())
        }
        update(t) {
            if (!this._state.isVisible)
                return;
            const e = this._app.getManager("time").isNow()
              , i = this._app.getManager("time").getNow()
              , s = {
                liveContainerClass: 0 === this._app.getManager("time").isWithinLimits(i) ? e ? "active" : "clickable" : "hidden",
                liveClass: e ? "live" : "",
                replayClass: n.AppUtils.isMobileMode() ? "icon icon-box" : "container"
            };
            this._state.hasHover || (s.liveIcon = e ? "icon-live" : "icon-back-to-live"),
            this.setState(s)
        }
    }
    ClockShortcut.html = a(),
    e.default = ClockShortcut
}
, function(t) {
    t.exports = '<nav class="clock-shortcut shortcut {{isVisibleClass}}">\n\t<div class="{{replayClass}} replay-container clickable" onclick="_replay" key="replayContainer">\n\t\t<span class="icon {{replayIcon}}" key="iconReplay"></span>\n\t\t<div class="replay text semi" key="replay">Replay</div>\n\t</div>\n\t<div class="{{liveContainerClass}} live-container container" onclick="backToLive" key="liveContainer" data-tippy-content="Reset time to live.">\n\t\t<span class="icon {{liveIcon}}" key="iconLive"></span>\n\t\t<div class="{{liveClass}} text" key="live">{{liveText}}</div>\n\t</div>\n</nav>\n'
}
, function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t, e, i) {
    "use strict";
    i.r(e);
    var s = i(367);
    i(204),
    i(370);
    e.default = s.default
}
, function(t, e, i) {
    "use strict";
    i.r(e);
    var s = i(147)
      , n = i(2)
      , o = i(368)
      , a = i.n(o)
      , r = i(369)
      , l = i.n(r);
    class Carousel extends n.BaseComponent {
        constructor(t, e, i={}) {
            const s = n.AppUtils.isPrimaryTouch() ? "Swipe/Tap" : "Scroll/Click";
            i.config = {
                infinite: !1,
                initialSlideIndex: 0,
                vertical: !0,
                timeout: 1e3,
                navigationButtons: {
                    prev: {
                        text: "Prev",
                        icon: "icon-greater up"
                    },
                    next: {
                        text: "Next",
                        icon: "icon-greater down"
                    },
                    replay: {
                        text: "Back To Start",
                        icon: "icon-replay"
                    }
                },
                hintText: {
                    default: `${s} arrows to continue`,
                    first: `${s} arrow to continue`,
                    last: `${s} arrow for previous`
                },
                ...i.config
            },
            super(t, e, {
                slideType: "",
                previousIndex: -1,
                currentIndex: i.config.initialSlideIndex || 0,
                isScrolling: !1,
                isScrollingClass: "",
                isTimeout: !1,
                collapseClass: "expand",
                isCollapsed: !1,
                collapseButtonClass: "icon-collapse",
                isCloseButtonVisible: !1,
                closeButtonText: "Exit",
                isControlsVisible: !1,
                ...i
            }),
            Object.assign(this._state, {
                isCloseButtonVisibleClass: this._class.isVisible[this._state.isCloseButtonVisible],
                isControlsVisibleClass: this._class.isVisible[this._state.isControlsVisible]
            }),
            this._children = {
                track: null,
                slides: []
            },
            this._progressTooltip = null,
            this._onEnter = {},
            this._onLeave = {},
            this._slideTypes = ["panel", "overlay"],
            this._currentInfo = null,
            this._onSlideChange = this.goToSlide,
            this._toggleControls = null,
            this._eventNames.push("slidechange", "expandtoggle"),
            this._initCallbacks(),
            this.bindFunctions(["_setSlideTrackDimensions", "_updateCarousel", "_onScroll", "_toggleCollapse", "_onControlsToggle", "goToPrevSlide", "goToNextSlide", "close"])
        }
        get currentInfo() {
            return this._currentInfo
        }
        _onControlsToggle() {
            this._toggleControls()
        }
        setOnControlsToggle(t) {
            this._toggleControls = t
        }
        init() {
            super.init(),
            this._children.carousel.classList.add(this._config.vertical ? "vertical" : "horizontal"),
            this._createSlideTrack(),
            this._updateCarousel(),
            this._children.carousel.classList.add("initialized"),
            window.addEventListener("keydown", (t => {
                "Tab" === t.key && this._state.isScrolling && t.preventDefault()
            }
            )),
            this._children.carousel.addEventListener("transitionstart", (t => {
                t.target === this._children.track && "transform" === t.propertyName && (this.setState({
                    isScrolling: !0,
                    isScrollingClass: "scrolling"
                }),
                this._children.carousel.style.pointerEvents = "all")
            }
            ), !0),
            this._children.carousel.addEventListener("transitionend", (t => {
                t.target === this._children.track && "transform" === t.propertyName && (this.setState({
                    isScrolling: !1,
                    isScrollingClass: "scrolling-done"
                }),
                this._children.carousel.style.pointerEvents = "none")
            }
            ), !0),
            this._children.progress.addEventListener("wheel", this._onScroll, {
                passive: !1
            }),
            this._children.progress.addEventListener("touchstart", (t => {
                const e = t.changedTouches[0];
                this._touchStartY = e.pageY
            }
            )),
            this._children.progress.addEventListener("touchmove", (t => {
                const e = t.changedTouches[0];
                t.deltaY = e.pageY - this._touchStartY,
                this._onScroll(t, "touch")
            }
            ), {
                passive: !1
            }),
            this._children.progress.addEventListener("touchend", (t => {
                const e = t.changedTouches[0];
                t.deltaY = e.pageY - this._touchStartY,
                this._onScroll(t, "touch")
            }
            ), {
                passive: !1
            })
        }
        resize() {
            super.resize(),
            setTimeout(this._setSlideTrackDimensions, 100),
            this._updateTooltipsProps()
        }
        _updateTooltipsProps() {
            const {slideType: t} = this._state;
            this._progressTooltip.setProps({
                offset: "overlay" === t ? [0, -30] : [0, 10]
            })
        }
        _createSlideTrack() {
            this._children.slides.forEach((t => {
                this._children.track.appendChild(t)
            }
            )),
            this._setSlideTrackDimensions()
        }
        _setSlideTrackDimensions() {
            const {track: t, slides: e} = this._children
              , {vertical: i} = this._config;
            if (e.forEach((t => {
                t.style.transition = "none"
            }
            )),
            t.style.transition = "none",
            i) {
                const i = [...e].reduce(( (t, e) => t + e.getBoundingClientRect().height), 0);
                t.style.height = i + "px"
            } else {
                const i = [...e].reduce(( (t, e) => t + e.getBoundingClientRect().width), 0);
                t.style.width = i + "px"
            }
            t.style.transition = "",
            e.forEach((t => {
                t.style.transition = ""
            }
            )),
            this._updateTrackPosition()
        }
        _updateTrackPosition() {
            const {currentIndex: t} = this._state;
            let e = 0;
            for (let i = 0; i < t; i++)
                e += this._children.slides[i].getBoundingClientRect().height;
            const i = this._config.vertical ? `translateY(-${e}px)` : `translateX(-${e}px)`;
            this._children.track.style.transform = i
        }
        _updateSlides() {
            const {previousIndex: t, currentIndex: e} = this._state
              , i = this._children.slides[t];
            i && (i.classList.remove("active"),
            i.classList.add("hidden"));
            const s = this._children.slides[e];
            s && (s.classList.remove("hidden"),
            s.classList.add("active"))
        }
        _updateCarousel() {
            this._updateTrackPosition(),
            this._updateSlides()
        }
        _onScroll(t, e="mouse") {
            if (this._state.isCollapsed && !this._state.isTimeout)
                this.expand();
            else if (!this._state.isScrolling && !this._state.isTimeout) {
                const i = t.currentTarget.querySelector(".os-viewport") || t.currentTarget
                  , s = i.scrollTop
                  , n = 0 === s
                  , o = Math.ceil(i.getBoundingClientRect().height + s) >= i.scrollHeight;
                t.deltaY < 0 ? "mouse" === e ? t.deltaY < -4 && n && this.goToPrevSlide() : t.deltaY < -5 && o && this.goToNextSlide() : t.deltaY > 0 && ("mouse" === e ? t.deltaY > 4 && o && this.goToNextSlide() : t.deltaY > 5 && n && this.goToPrevSlide())
            }
            this.setState({
                isTimeout: !0
            }, ( () => setTimeout(( () => this.setState({
                isTimeout: !1
            })), this._config.timeout))),
            ["wheel", "touchmove"].includes(t.type) && t.stopPropagation()
        }
        addSlide(t, {isLast: e=!1, isFirst: i=!1}={}) {
            const o = t.html || l()
              , {type: a, content: r} = t;
            this._slideTypes.includes(a) || console.warn(`addSlide: Unknown slide type "${a}". Supported types: ${this._slideTypes}`);
            const c = n.AppUtils.htmlWithParamsToElement(o, {
                prevButtonText: this._config.navigationButtons.prev.text,
                prevButtonIcon: this._config.navigationButtons.prev.icon,
                nextButtonText: this._config.navigationButtons.next.text,
                nextButtonIcon: this._config.navigationButtons.next.icon,
                replayButtonText: this._config.navigationButtons.replay.text,
                replayButtonIcon: this._config.navigationButtons.replay.icon,
                hintText: () => e ? this._config.hintText.last : i ? this._config.hintText.first : this._config.hintText.default,
                type: a
            });
            c.querySelector(".content").appendChild(r),
            e && c.classList.add("last"),
            i && c.classList.add("first"),
            t.classList && c.classList.add(...t.classList),
            t.id && (c.dataset.id = t.id),
            c.dataset.type = t.type || "",
            this._children.track.appendChild(c),
            this._children.slides.push(c);
            const h = c.firstChild;
            h.addEventListener("wheel", this._onScroll, {
                passive: !1
            }),
            h.addEventListener("touchstart", (t => {
                const e = t.changedTouches[0];
                this._touchStartY = e.pageY
            }
            )),
            h.addEventListener("touchmove", (t => {
                const e = t.changedTouches[0];
                t.deltaY = e.pageY - this._touchStartY,
                this._onScroll(t, "touch")
            }
            ), {
                passive: !1
            }),
            h.addEventListener("touchend", (t => {
                const e = t.changedTouches[0];
                t.deltaY = e.pageY - this._touchStartY,
                this._onScroll(t, "touch")
            }
            ), {
                passive: !1
            }),
            this._setVariables(c),
            this._setEventHandlersFromAttributes(c),
            this._setSlideTrackDimensions(),
            this._updateCarousel(),
            n.AppUtils.addScrollbar(h),
            null === this._progressTooltip && (this._progressTooltip = (0,
            s.default)(this._children.progress.parentElement, {
                theme: "default",
                onShow(t) {
                    clearTimeout(t.timeout),
                    t.timeout = setTimeout(( () => {
                        t.hide()
                    }
                    ), 2e3)
                }
            }))
        }
        addSlides(t) {
            for (let e = 0; e < t.length; e++)
                this.addSlide(t[e])
        }
        async onEnter(t) {
            const e = this._onEnter[t];
            for (let t = 0; t < e?.length; t++)
                "function" == typeof e[t] && await e[t]()
        }
        async onLeave(t) {
            "number" != typeof t && (t = this._state.currentIndex);
            const e = this._onLeave[t];
            for (let t = 0; t < e?.length; t++)
                "function" == typeof e[t] && await e[t]()
        }
        async goToSlide(t) {
            const {spout: e, spoutFontSize: i} = this.app.getManager("router").configs
              , s = this._state.currentIndex;
            t !== s && await this.onLeave(s);
            const n = this._children.slides[t]?.dataset.type;
            n && this.setState({
                currentIndex: t,
                previousIndex: s,
                slideType: n
            }, ( () => {
                this._updateCarousel(),
                this._children.progress.style.top = `calc(${100 * t / (this._children.slides.length - 1)}% - ${this._children.progress.offsetHeight / 2}px)`;
                const e = this._children.slides[t].querySelector(".os-viewport");
                e && (e.scrollTop = 0),
                this.triggerCallbacks("slidechange", [this._currentInfo]),
                this._progressTooltip.setContent(`${t + 1} of ${this._children.slides.length}`),
                this._updateTooltipsProps(),
                this._state.isVisible && this._progressTooltip.show()
            }
            )),
            await this.onEnter(t),
            !0 === e && await this.app.getManager("spout").setUpSpoutLabels(i)
        }
        goToPrevSlide() {
            const {currentIndex: t} = this._state
              , e = this._children.slides.length - 1
              , i = t - 1;
            i < 0 ? this._config.infinite && this._onSlideChange(e) : this._onSlideChange(i)
        }
        goToNextSlide() {
            const {currentIndex: t} = this._state
              , e = t + 1;
            e > this._children.slides.length - 1 ? this._config.infinite && this._onSlideChange(0) : this._onSlideChange(e)
        }
        goToFirstSlide() {
            this._onSlideChange(0)
        }
        isVisible() {
            return this._state.isVisible
        }
        collapse() {
            this.setState({
                isCollapsed: !0,
                collapseClass: "collapse",
                collapseButtonClass: "icon-expand"
            }),
            this.triggerCallbacks("expandtoggle", [!1])
        }
        expand() {
            this.setState({
                isCollapsed: !1,
                collapseClass: "expand",
                collapseButtonClass: "icon-collapse"
            }),
            this.triggerCallbacks("expandtoggle", [!0])
        }
        close() {}
        show() {
            super.show(),
            this._updateCarousel(),
            null !== this._progressTooltip && this._children.slides.length > 1 && this._progressTooltip.show()
        }
        clear() {
            this._children.track.innerHTML = "",
            this._children.slides = [],
            this._onEnter = {},
            this._onLeave = {},
            this._currentInfo = null,
            this._state.previousIndex = 1,
            this._state.currentIndex = this._config.initialSlideIndex || 0
        }
        _toggleCollapse() {
            this._state.isCollapsed ? this.expand() : this.collapse()
        }
    }
    Carousel.html = a(),
    e.default = Carousel
}
, function(t) {
    t.exports = '<div class="carousel-container {{isVisibleClass}} {{slideType}}">\n\t<button class="close-button clickable {{isCloseButtonVisibleClass}}" onclick="close">\n\t\t<span class="text">{{closeButtonText}}</span>\n\t\t<span class="icon icon-close"></span>\n\t</button>\n\t<div class="progress {{slideType}}">\n\t\t<span key="progress" class="icon icon-triangle"></span>\n\t</div>\n\t<div key="carousel" class="carousel {{collapseClass}} {{isScrollingClass}} {{slideType}}">\n\t\t<div class="track" key="track"></div>\n\t</div>\n</div>\n'
}
, function(t) {
    t.exports = '<div class="slide hidden {$type}">\n\t<div class="container {{collapseClass}}">\n\t\t<div class="container-wrapper">\n\t\t\t<div class="mobile-hint small">\n\t\t\t\t<span class="icon icon-greater up clickable" onclick="goToPrevSlide"></span>\n\t\t\t\t<span class="hint-text">{$hintText}</span>\n\t\t\t\t<span class="icon icon-greater down clickable" onclick="goToNextSlide"></span>\n\t\t\t</div>\n\t\t\t<div class="content-container">\n\t\t\t\t<div class="content-wrapper">\n\t\t\t\t\t<div class="content"></div>\n\t\t\t\t\t<div class="controls {{isControlsVisibleClass}}">\n\t\t\t\t\t\t<button class="icon icon-clock clickable" onclick="_onControlsToggle"></button>\n\t\t\t\t\t\t<button class="icon collapse-button clickable {{collapseButtonClass}}" onclick="_toggleCollapse"></button>\n\t\t\t\t\t</div>\n\t\t\t\t\t<button class="navigation-button replay mobile clickable" onclick="goToFirstSlide">\n\t\t\t\t\t\t<span class="icon {$replayButtonIcon}"></span>\n\t\t\t\t\t\t{$replayButtonText}\n\t\t\t\t\t</button>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t<button class="navigation-button next clickable" onclick="goToNextSlide">\n\t\t\t\t{$nextButtonText}\n\t\t\t\t<span class="icon {$nextButtonIcon}"></span>\n\t\t\t</button>\n\t\t\t<button class="navigation-button replay clickable" onclick="goToFirstSlide">\n\t\t\t\t<span class="icon {$replayButtonIcon}"></span>\n\t\t\t\t{$replayButtonText}\n\t\t\t</button>\n\t\t</div>\n\t</div>\n\t<div class="collapse-container {{collapseClass}}">\n\t\t<button class="mobile-collapse icon clickable {{collapseButtonClass}}" onclick="_toggleCollapse"></button>\n\t</div>\n</div>\n'
}
, function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t, e, i) {
    "use strict";
    i.r(e);
    var s = i(372);
    i(480);
    e.default = s.default
}
, function(t, e, i) {
    "use strict";
    i.r(e);
    var s = i(373)
      , n = (i(475),
    i(476),
    i(477),
    i(478),
    i(2))
      , o = i(479)
      , a = i.n(o);
    s.default.use([s.Navigation, s.Keyboard, s.Mousewheel]);
    const r = "OK, got it. Thanks!"
      , l = "OK, let's go!";
    class TutorialOverlay extends n.BaseComponent {
        constructor(t, e={}) {
            e.config = {
                direction: "horizontal",
                speed: 600,
                slidesPerView: 1,
                spaceBetween: 100,
                keyboard: {
                    enabled: !0
                },
                mousewheel: {
                    forceToAxis: !0,
                    thresholdDelta: 100
                },
                navigation: {
                    prevEl: ".tutorial-carousel-prev",
                    nextEl: ".tutorial-carousel-next"
                },
                ...e.config
            },
            super(t, null, {
                isVisible: !1,
                carouselClass: "tutorial-carousel",
                slideClass: "",
                dismissText: r,
                ...e
            }),
            this._swiper = null,
            this._allTutorials = null,
            this._elementMeasures = null,
            this._currIndex = null,
            this._slideViewedTimeout = null,
            this._initTimeout = null,
            this._bulletClass = "swiper-pagination-bullet",
            this._activeBulletClass = "swiper-pagination-bullet-active",
            this._swiperSlideClass = "swiper-slide",
            this._storageName = "EoA_Tutorials"
        }
        setTutorials(t) {
            this._allTutorials = t,
            this._createSlides()
        }
        hideTutorialSlide(t) {
            const {tutorials: e} = this.app;
            return e.filter(( ({id: e}) => e !== t))
        }
        _addEvents() {
            this._swiper.on("slideChange", ( ({realIndex: t}) => {
                this._setHighlightedElement(t),
                this._setActiveBullet(t),
                this._currIndex !== t && this.navigateToTutorial(t);
                const {id: e} = this._allTutorials[t] || {}
                  , i = t === this._allTutorials.length - 1
                  , s = e ? `tutorial-slide-${e}` : "";
                this.setState({
                    dismissText: i ? l : r,
                    slideClass: s
                })
            }
            )),
            this._children.swiperSlides.addEventListener("click", (t => {
                const e = t?.target?.dataset?.def;
                e && this._app.getComponent("definitionOverlay").navigateToDefinition(e)
            }
            ))
        }
        _createSlides() {
            const {isTouch: t} = this._app;
            this._allTutorials.forEach(( ({id: e, title: i, description: s, extra: n}) => {
                const o = [];
                if (i) {
                    const t = document.createElement("h2");
                    t.innerHTML = i,
                    o.push(t)
                }
                if (s) {
                    const e = "object" == typeof s ? t ? s.touch : s.desktop : s;
                    if ("string" == typeof e) {
                        const t = document.createElement("p");
                        t.innerHTML = e,
                        o.push(t)
                    }
                }
                if (n) {
                    const e = "object" == typeof n ? t ? n.touch : n.desktop : n;
                    if ("string" == typeof e) {
                        const t = document.createElement("div");
                        t.className = "tutorial-extra",
                        t.innerHTML = e,
                        o.push(t)
                    }
                }
                const a = `${this._swiperSlideClass} tutorial-slide-${e}`;
                o.length && this._addSlide(o, a)
            }
            ))
        }
        _addSlide(t=[], e) {
            const i = document.createElement("div");
            i.className = e,
            i.replaceChildren(...t),
            this._children.swiperSlides.append(i)
        }
        _createBullets() {
            const {bullets: t} = this._children
              , {slides: e} = this._swiper
              , i = [...e].map(( (t, e) => {
                const i = document.createElement("span");
                return i.classList.add(this._bulletClass),
                i.addEventListener("click", (t => this._swiper.slideTo(e))),
                i
            }
            ));
            t.replaceChildren(...i)
        }
        _setActiveBullet(t=this._currIndex) {
            const {bullets: e} = this._children;
            e.childNodes.forEach(( (e, i) => {
                e.classList.remove(this._activeBulletClass),
                i === t && e.classList.add(this._activeBulletClass)
            }
            ))
        }
        _setHighlightedElement(t=this._currIndex, e=!1) {
            (!this._elementMeasures || e) && (this._elementMeasures = this._calcElementMeasures());
            const i = this._elementMeasures[t]
              , {mask: s} = this._allTutorials[t];
            if (i) {
                const {xPos: t, yPos: e, relWidth: n, relHeight: o} = i
                  , {xSizeMult: a=1, ySizeMult: r=1} = s || {}
                  , l = 15
                  , c = (200 + n * l * 100) * a
                  , h = (200 + o * l * 100) * r
                  , d = Math.max(200, c)
                  , u = Math.max(200, h)
                  , p = 100 / (d - 100)
                  , m = 100 / (u - 100)
                  , _ = .5 - .5 * m + e * m
                  , g = (100 * (.5 - .5 * p + t * p)).toFixed(2)
                  , y = (100 * _).toFixed(2);
                this._element.style.setProperty("--tutorial-mask-grad", "radial-gradient(transparent, black 5%)"),
                this._element.style.setProperty("--tutorial-mask-pos", `${g}% ${y}%`),
                this._element.style.setProperty("--tutorial-mask-size", `${d}% ${u}%`)
            } else
                this._element.style.setProperty("--tutorial-mask-grad", null),
                this._element.style.setProperty("--tutorial-mask-pos", null),
                this._element.style.setProperty("--tutorial-mask-size", null)
        }
        onQueryChange({cancelToken: t, tutorial: e}={}) {
            clearTimeout(this._slideViewedTimeout);
            const {currentRoute: i, homeRoute: s} = this.app.getManager("router");
            if (i.url !== s || t?.isCanceled)
                return;
            const n = this._getIndexByTutorialId(e);
            n !== this._currIndex && (this._currIndex = n,
            this._currIndex > -1 ? (this._state.isVisible ? this._swiper.slideTo(this._currIndex) : this.show(),
            this._setSlideViewedTimeout(n)) : this.hide())
        }
        _initSwiper() {
            const {carouselClass: t} = this._state
              , e = `.${t} .swiper-wrapper > div`;
            n.AppUtils.elementReady(e).then(( () => {
                this._initTimeout = setTimeout(( () => {
                    this._swiper ? (this._swiper.update(),
                    this._swiper.slideTo(this._currIndex)) : (this._swiper = new s.default(`.${t}`,this._config),
                    this._postSwiperInitFunction(this._swiper)),
                    0 === this._currIndex && (this._setActiveBullet(),
                    this._setHighlightedElement()),
                    super.show()
                }
                ), 500)
            }
            ))
        }
        _postSwiperInitFunction() {
            this._addEvents(),
            this._createBullets(),
            this._swiper.slideTo(this._currIndex)
        }
        _getIndexByTutorialId(t) {
            return this._allTutorials?.findIndex(( ({id: e}) => e === t))
        }
        _setSlideViewedTimeout(t) {
            this._slideViewedTimeout = setTimeout(( () => {
                const e = localStorage?.getItem(this._storageName)?.split(",") || [];
                e.includes(t.toString()) || (e.push(t),
                e.sort(),
                localStorage?.setItem(this._storageName, e))
            }
            ), 3e3)
        }
        _calcElementMeasures() {
            const {clientWidth: t, clientHeight: e} = document.body;
            return this._allTutorials.map(( ({targetSelector: i}) => {
                const s = [...document.body.querySelectorAll(i)].filter((t => null !== t.offsetParent));
                if (!s.length)
                    return !1;
                const {left: n, width: o, top: a, height: r} = s[0].getBoundingClientRect();
                return {
                    xPos: 1 - (n + .5 * o) / t,
                    yPos: 1 - (a + .5 * r) / e,
                    relWidth: o / t,
                    relHeight: r / e
                }
            }
            ))
        }
        show() {
            const t = this._app.getManager("layer");
            t.getLayer("ui").visible || t.toggleLayer("ui");
            const e = this._children.swiperSlides?.childNodes?.length;
            e && this._initSwiper();
            if (!0 === this._app.getManager("router").configs.hideExternalLinks) {
                const t = document.getElementsByClassName("tutorial-smallprint")[0].innerHTML;
                document.getElementsByClassName("tutorial-smallprint")[0].innerHTML = this._app.getManager("content").hideExternalLinksInText(t)
            }
        }
        hide() {
            clearTimeout(this._initTimeout),
            this._currIndex = null,
            super.hide()
        }
        calcPriorityIndex() {
            const t = localStorage?.getItem(this._storageName)?.split(",") || []
              , e = this._allTutorials.filter(( (e, i) => !t.includes(i.toString())));
            return e.length ? this._getIndexByTutorialId(e[0].id) : null
        }
        navigateToTutorial(t, e=!1) {
            const {homeRoute: i, currentRoute: s, navigate: n} = this.app.getManager("router")
              , o = e ? i : s.url ?? "";
            if ("number" == typeof t && t > -1 && t < this._allTutorials.length) {
                const {id: e} = this._allTutorials[t];
                n({
                    tutorial: e
                }, o)
            }
        }
        close() {
            this.app.getManager("router").navigate({
                __remove: ["tutorial"]
            })
        }
        resize() {
            this._state.isVisible && null !== this._currIndex && this._setHighlightedElement(this._currIndex, !0)
        }
    }
    TutorialOverlay.html = a(),
    e.default = TutorialOverlay
}
, , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , function(t) {
    t.exports = '<div id="tutorial-overlay" class="{{isVisibleClass}} {{slideClass}}">\n\n\t<div class="swiper {{carouselClass}}">\n\t\t<div key="swiperSlides" class="swiper-wrapper"></div>\n\n\t\t<div class="swiper-button-prev icon prev-arrow tutorial-carousel-prev"></div>\n\t\t<div class="swiper-button-next icon next-arrow tutorial-carousel-next"></div>\n\n\t\t<div key="bullets" class="bullet-container"></div>\n\n\t</div>\n\n\t<div class="dismiss-container">\n\t\t<button class="dismiss-button clickable" onclick="close">{{dismissText}}</button>\n\t</div>\n\n\n\t<footer>\n\t\t<p class=\'tutorial-smallprint\'>The data used to generate this visualization is from the <a href=\'https://cneos.jpl.nasa.gov\' target=\'_blank\'>Center for Near-Earth Object Studies</a> and JPL\'s <a href=\'https://ssd.jpl.nasa.gov\' target=\'_blank\'>Solar System Dynamics</a> website. Visit the <a href=\'https://www.nasa.gov/planetarydefense/overview\' target=\'_blank\'>Planetary Defense Coordination Office</a> for more information on how NASA monitors for potentially hazardous asteroids and comets.</p>\n\t</footer>\n</div>\n'
}
, function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t, e, i) {
    "use strict";
    i.r(e);
    var s = i(482);
    i(475),
    i(476),
    i(484),
    i(477),
    i(478),
    i(485);
    e.default = s.default
}
, function(t, e, i) {
    "use strict";
    i.r(e);
    var s = i(373)
      , n = i(2)
      , o = i(483)
      , a = i.n(o);
    s.default.use([s.Navigation, s.Pagination, s.Keyboard, s.Mousewheel]);
    class CarouselPanel extends n.BaseComponent {
        constructor(t, e={}) {
            const {paginationClass: i, prevButtonClass: s, nextButtonClass: n} = e;
            e.config = {
                direction: "horizontal",
                speed: 600,
                grabCursor: !0,
                touchStartPreventDefault: !1,
                slidesPerView: 1,
                spaceBetween: 100,
                keyboard: {
                    enabled: !0
                },
                mousewheel: {
                    forceToAxis: !0,
                    thresholdDelta: 100
                },
                navigation: {
                    prevEl: `.${s}`,
                    nextEl: `.${n}`
                },
                ...i && {
                    pagination: {
                        el: `.${i}`,
                        type: "custom",
                        renderCustom: (t, e, i) => `${e} of ${i}`
                    }
                },
                ...e.config
            },
            super(t, null, {
                isVisible: !1,
                preTitle: "viewing",
                title: "Panel Title",
                caption: "This is the panel subtitle",
                carouselClass: "",
                paginationClass: "",
                prevButtonClass: "",
                nextButtonClass: "",
                isExpandedClass: "collapsed",
                tabsVisibleClass: "hidden",
                tabNumClass: "",
                ...e
            }),
            this._swiper = null,
            this._tabIndices = null,
            this._activeTabIndex = null,
            this._tabElements = null,
            this._bulletClass = "swiper-pagination-bullet",
            this._activeBulletClass = "swiper-pagination-bullet-active",
            this._swiperSlideClass = "swiper-slide",
            this._onSlideChange = null,
            this._expandOnShow = !1,
            this._orientation = null,
            this._resizeTimeout = null,
            this._isInitialized = null,
            this._eventNames.push("expandtoggle"),
            this._initCallbacks(),
            this.bindFunctions(["_onTabClick"])
        }
        _addEvents() {
            this._swiper.on("slideChange", (t => {
                const {realIndex: e, previousIndex: i} = t;
                let s = e;
                "function" == typeof this._onSlideChange && this._onSlideChange(t);
                const n = this._children.swiperSlides.childNodes[i];
                if (n?._scrollInstance && (n._isMousedown = !1,
                n._scrollInstance.scroll(0)),
                this._tabElements) {
                    const t = this._tabIndices.findIndex(( ({start: t, end: i}) => e >= t && e <= i))
                      , {start: i} = this._tabIndices[t];
                    if (s -= i,
                    t > -1 && t !== this._activeTabIndex)
                        return this._tabElements.forEach(( (e, i) => {
                            e.classList.toggle("active", i === t)
                        }
                        )),
                        this._activeTabIndex = t,
                        void this._createBullets(s)
                }
                this._setActiveBullet(s)
            }
            )),
            this._children.swiperSlides.addEventListener("click", (t => {
                const e = t?.target?.dataset?.def;
                e && this._app.getComponent("definitionOverlay").navigateToDefinition(e)
            }
            ))
        }
        _hasOrientationChanged() {
            const t = n.AppUtils.isPortrait() ? "portrait" : "landscape"
              , e = this._orientation !== t;
            return this._orientation = t,
            e
        }
        _addScrollbars() {
            const t = this._hasOrientationChanged();
            this._children?.swiperSlides?.childNodes?.forEach((e => {
                const {clientHeight: i, scrollHeight: s, cHeight: o, sHeight: a} = e;
                if (o && o === i && a && a === s && !t)
                    return;
                e._scrollInstance?.destroy();
                const {clientHeight: r, scrollHeight: l} = e;
                if (e.sHeight = r,
                e.cHeight = l,
                l > r) {
                    e.classList.add("scrollable"),
                    e._scrollInstance ??= n.AppUtils.addScrollbar(e),
                    e._isMousedown = !1,
                    e._clientY = 0;
                    const t = ({clientY: t}) => {
                        if (e._isMousedown) {
                            const i = e._clientY - t;
                            e._scrollInstance.scroll({
                                y: `+=${i}`
                            }),
                            e._clientY = t
                        }
                    }
                    ;
                    e.onmousedown = ({clientY: i}) => {
                        e._isMousedown = !0,
                        e._clientY = i,
                        window.addEventListener("mousemove", t),
                        window.addEventListener("mouseup", (function i() {
                            e._isMousedown = !1,
                            window.removeEventListener("mousemove", t),
                            window.removeEventListener("mouseup", i)
                        }
                        ))
                    }
                }
            }
            ))
        }
        createTabs(t) {
            this._tabIndices = [],
            this._activeTabIndex = 0;
            let e = 0;
            this._swiper && this._destroy(),
            this._tabElements = t.map(( ({title: t, content: i}, s) => {
                const n = document.createElement("button");
                n.innerHTML = t,
                n.className = "clickable " + (s === this._activeTabIndex ? "active" : ""),
                n.addEventListener("click", this._onTabClick),
                this._tabIndices.push({
                    start: e,
                    end: e + i.length - 1
                }),
                e += i.length;
                for (const t of i) {
                    const e = this._createSlideElements(t);
                    this.addSlide(e, t.onClick)
                }
                return n
            }
            )),
            this._children.tabsContainer.replaceChildren(...this._tabElements),
            this.setState({
                tabsVisibleClass: "",
                tabNumClass: `tabs-${this._tabElements.length}`
            })
        }
        _createSlideElements(t) {
            const {title: e, content: i, value: s} = t
              , n = [];
            if (e) {
                const t = document.createElement("h4");
                t.className = "title semi",
                t.innerHTML = e,
                n.push(t)
            }
            if (i) {
                const t = document.createElement("div");
                t.className = "description",
                t.innerHTML = i,
                n.push(t)
            }
            if (s) {
                const t = document.createElement("div");
                t.className = "value semi",
                t.innerHTML = s,
                n.push(t)
            }
            return n
        }
        _createBullets(t=0) {
            const {bullets: e} = this._children
              , {slides: i} = this._swiper;
            let s = [...i]
              , n = 0;
            if (this._tabElements) {
                const {start: t, end: e} = this._tabIndices[this._activeTabIndex];
                n = t,
                s = s.slice(t, e + 1)
            }
            const o = [...s].map(( (t, e) => {
                const i = document.createElement("span");
                return i.classList.add(this._bulletClass),
                i.setAttribute("data-slide-index", e + n),
                i.addEventListener("click", (t => {
                    const {slideIndex: e} = t.target.dataset;
                    this._swiper.slideTo(e)
                }
                )),
                i
            }
            ))
              , a = i => {
                i && "width" !== i.propertyName || (e.replaceChildren(...o),
                e.classList.remove("hidden"),
                this._setActiveBullet(t))
            }
            ;
            e.classList.contains("hidden") ? a() : (e.classList.add("hidden"),
            e.ontransitionend = a,
            e.ontransitioncancel = a)
        }
        _setActiveBullet(t) {
            const {bullets: e} = this._children;
            e.childNodes.forEach(( (e, i) => {
                e.classList.remove(this._activeBulletClass),
                i === t && e.classList.add(this._activeBulletClass)
            }
            ))
        }
        addSlide(t=[], e) {
            const i = document.createElement("div");
            i.className = `${e ? "clickable" : ""} ${this._swiperSlideClass}`,
            e && i.addEventListener("click", e),
            i.replaceChildren(...t),
            this._children.swiperSlides.append(i)
        }
        initSwiper() {
            const {carouselClass: t} = this._state
              , e = `.${t} .swiper-wrapper > div`;
            return n.AppUtils.elementReady(e).then(( () => {
                this._swiper ? (this._swiper.update(),
                this._addScrollbars(),
                this._createBullets(),
                this._swiper.slideTo(0)) : (this._swiper = new s.default(`.${t}`,this._config),
                this._postSwiperInitFunction(this._swiper))
            }
            ))
        }
        _postSwiperInitFunction() {
            this._addEvents(),
            this._addScrollbars(),
            this._createBullets(),
            this._swiper.update(),
            this._swiper.slideTo(0)
        }
        _destroy() {
            this._children.swiperSlides.innerHTML = "",
            clearTimeout(this._resizeTimeout)
        }
        _onTabClick(t) {
            const e = this._tabElements.findIndex((e => e === t.target))
              , {start: i} = this._tabIndices[e];
            this._swiper.slideTo(i)
        }
        expand() {
            this.setState({
                isExpanded: !0,
                isExpandedClass: "expanded"
            }),
            this.triggerCallbacks("expandtoggle", [!0])
        }
        collapse() {
            this.setState({
                isExpanded: !1,
                isExpandedClass: "collapsed"
            }),
            this.triggerCallbacks("expandtoggle", [!1])
        }
        setExpandState(t) {
            this.setState({
                isExpanded: t,
                isExpandedClass: t ? "expanded" : "collapsed"
            }),
            this.triggerCallbacks("expandtoggle", [t])
        }
        show(t=!0) {
            const e = this._app.getManager("layer").getLayer("ui").visible
              , i = this._children.swiperSlides?.childNodes?.length
              , s = () => {
                this._expandOnShow ? (this.setState({
                    isVisible: !0,
                    isVisibleClass: this._class.isVisible.true,
                    isExpanded: !0,
                    isExpandedClass: "expanded"
                }),
                this.triggerCallbacks("expandtoggle", [!0]),
                this.triggerCallbacks("visiblechange", [!0])) : super.show()
            }
            ;
            t && e && i ? this.initSwiper().then(( () => s())) : s()
        }
        hide() {
            this.setState({
                isVisible: !1,
                isVisibleClass: this._class.isVisible.false,
                isExpanded: !1,
                isExpandedClass: "collapsed"
            }),
            this.triggerCallbacks("expandtoggle", [!1, !1]),
            this.triggerCallbacks("visiblechange", [!1]),
            this._expandOnShow && (this._isInitialized = !1)
        }
        resize() {
            clearTimeout(this._resizeTimeout),
            this._resizeTimeout = setTimeout(( () => {
                this._addScrollbars()
            }
            ), 200)
        }
    }
    CarouselPanel.html = a(),
    e.default = CarouselPanel
}
, function(t) {
    t.exports = '<section id="panel-container" class="{{panelTypeClass}} {{isVisibleClass}} {{isExpandedClass}}">\n\n\t\x3c!-- Simple panel (collapsed) --\x3e\n\t<div class="panel-simple clickable" onclick="expand">\n\t\t<div class="expand-button">\n\t\t\t<div class="icon circle-arrow"></div>\n\t\t</div>\n\t\t<h5 class="simple-pretitle">{{preTitle}}</h5>\n\t\t<h4 class="simple-title">{{title}}</h4>\n\t</div>\n\n\t\x3c!-- Main panel (expanded) --\x3e\n\t<div class="panel-main">\n\n\t\t<div class="panel-header">\n\t\t\t<div class="header-title">\n\t\t\t\t<div class="title-icon icon icon-large {{headerIconClass}}"></div>\n\t\t\t\t<h4 class="title-text">{{title}}</h4>\n\t\t\t\t<div class="collapse-button clickable" onclick="collapse">\n\t\t\t\t\t<div class="icon circle-arrow"></div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t<h5 class="header-caption {{captionClass}}">{{caption}}</h5>\n\t\t</div>\n\n\t\t\x3c!-- Carousel content --\x3e\n\t\t<div key="content" class="panel-content">\n\t\t\t<nav key="tabsContainer" class="tabs-container {{tabsVisibleClass}} {{tabNumClass}}"></nav>\n\t\t\t<div class="swiper {{carouselClass}}">\n\t\t\t\t<div key="swiperSlides" class="swiper-wrapper"></div>\n\n\n\t\t\t\t<div class="swiper-pagination {{paginationClass}}"></div>\n\n\t\t\t\t<div class="swiper-button-prev icon prev-arrow {{prevButtonClass}}"></div>\n\t\t\t\t<div class="swiper-button-next icon next-arrow {{nextButtonClass}}"></div>\n\n\t\t\t\t<div key="bullets" class="bullet-container"></div>\n\n\t\t\t</div>\n\t\t</div>\n\n\t</div>\n\n\n\n</section>\n'
}
, , function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t, e, i) {
    "use strict";
    i.r(e);
    var s = i(487);
    i(490);
    e.default = s.default
}
, function(t, e, i) {
    "use strict";
    i.r(e);
    var s = i(2)
      , n = (i(138),
    i(488))
      , o = i.n(n)
      , a = i(147)
      , r = i(489);
    class ShareModal extends s.BaseComponent {
        constructor(t, e) {
            super(t, null, {
                isVisible: !1,
                iframeElements: !0,
                linkTitle: "",
                previewDevice: "",
                previewResolution: "",
                previewVisibleClass: s.AppUtils.isiPhone() ? "hidden" : "",
                isWide: null,
                ...e,
                config: {
                    title: "Share",
                    shareBtnParent: {
                        selector: ".header",
                        wideSelector: ".header",
                        threshold: 1025
                    },
                    linkAltText: "Eyes",
                    linkImageSrc: "",
                    paramsToKeep: ["time", "rate", "slide", "followId", ...e?.paramsToKeep ?? []],
                    resetOnClose: !0,
                    deviceResolutions: {
                        desktop: {
                            width: 1280,
                            height: 720
                        },
                        tablet: {
                            width: 1024,
                            height: 1366
                        },
                        phone: {
                            width: 375,
                            height: 667
                        }
                    },
                    ...e?.config
                }
            }),
            this._activeTab = null,
            this._srcURL = null,
            this._embedOptionsScrollbar = null,
            this._tippySingleton = null,
            this._tippyItems = null,
            this._tippyTimeout = null,
            this._embedQueries = {},
            this._inputElements = {},
            this.bindFunctions(["_iframeLoadEventListener"])
        }
        mergeEmbedControls() {
            const {controls: t} = this._config
              , e = r.default.map((e => {
                const {groupName: i, items: s} = e
                  , n = t.find((t => t.groupName === i));
                if (n) {
                    const {items: t} = n
                      , i = s.filter(( ({name: e}) => !t.some(( ({name: t}) => t === e))));
                    return {
                        ...e,
                        items: [...t, ...i]
                    }
                }
                return e
            }
            ))
              , i = t.filter((t => !e.some(( ({groupName: e}) => e === t.groupName))));
            this._config.embedOptions = [...e, ...i]
        }
        init() {
            super.init();
            const {canHover: t} = this._app;
            this.mergeEmbedControls(),
            this.setEmbedParams(),
            this.generateEmbedContent(),
            this.setIsWide(),
            this.createScrollbars(),
            this.createShareButton(),
            this.addShareButtonToParent(),
            a.default.setDefaultProps({
                theme: "default",
                touch: !0,
                hideOnClick: !1,
                delay: [300, null],
                placement: "top",
                trigger: "mouseenter click",
                onTrigger: e => {
                    clearTimeout(this._tippyTimeout),
                    t || (this._tippyTimeout = setTimeout(( () => {
                        e?.hide()
                    }
                    ), 3e3))
                }
                ,
                onClickOutside: t => {
                    t.hide()
                }
                ,
                onHidden: t => {
                    this._tippyItems?.forEach(( ({reference: t}) => t.blur()))
                }
            })
        }
        createScrollbars() {
            const {embedOptsContent: t} = this._children
              , e = t.parentElement;
            s.AppUtils.onAttachElement(e, ( () => {
                this._embedOptionsScrollbar = s.AppUtils.addScrollbar(e)
            }
            ))
        }
        getCurrentDevice() {
            return s.AppUtils.isTablet() ? "tablet" : s.AppUtils.isMobile() ? "phone" : "desktop"
        }
        createShareButton() {
            this.shareButton = document.createElement("button"),
            this.shareButton.className = "share-button clickable",
            this.shareButton.innerText = "Share";
            const t = document.createElement("span");
            t.className = "icon icon-share",
            this.shareButton.prepend(t),
            this.shareButton.addEventListener("click", ( () => {
                this.setSrcURL(),
                this.setPreviewDevice({
                    target: {
                        value: this.getCurrentDevice()
                    }
                }),
                this.setActiveTab("link");
                const {linkImage: t} = this._children
                  , {linkAltText: e, linkImageSrc: i} = this._config
                  , s = document.querySelector("title")?.innerText
                  , n = document.querySelector('meta[property="og:image"]')?.getAttribute("content")
                  , o = s || e
                  , a = "$OG_IMAGE" !== n && n || i;
                t.setAttribute("alt", o),
                t.setAttribute("src", a);
                const {fullTitle: r} = this._app.getManager("title")
                  , l = r ?? o;
                this.setState({
                    linkTitle: l
                }),
                this.show()
            }
            ))
        }
        setIsWide() {
            const {isWide: t} = this._state
              , {shareBtnParent: e} = this._config
              , {threshold: i} = e
              , s = window.innerWidth >= i;
            return t !== s && (this.setState({
                isWide: s
            }),
            !0)
        }
        addShareButtonToParent() {
            const {shareBtnParent: t} = this._config
              , {isWide: e} = this._state
              , {selector: i, wideSelector: n} = t;
            this.shareButton.parentNode?.removeChild(this.shareButton);
            const o = e ? n : i;
            s.AppUtils.elementReady(o, 3e3).then((t => (t.appendChild(this.shareButton),
            !0))).catch((t => t))
        }
        setSrcURL(t=window.location.href, e=!0) {
            const {linkCode: i} = this._children
              , {paramsToKeep: s} = this._config
              , n = t.split("?")
              , o = n[1] ? new URLSearchParams(n[1]) : new URLSearchParams
              , a = Array.from(o.keys());
            for (const t of a)
                s.includes(t) || o.delete(t);
            this._srcURL = `${n[0]}${o.size ? "?" : ""}${o.toString()}`,
            e && (i.textContent = t)
        }
        setEmbedParams() {
            const {embedOptions: t} = this._config;
            t.forEach(( ({items: t}) => {
                t.forEach((t => {
                    const {query: e, inputDefault: i, invert: s} = t
                      , n = s ? !i : i;
                    this._embedQueries[e] = n
                }
                ))
            }
            ))
        }
        updateEmbedParams(t, e) {
            this._embedQueries[t] !== e && void 0 !== this._embedQueries[t] && (this._embedQueries[t] = e,
            this.updateEmbedCode())
        }
        updateEmbedCode(t) {
            const {force: e=!1, updatePreview: i=!0} = t || {}
              , {embedCode: n, embedPreviewParent: o} = this._children
              , {iframeElements: a} = this._state
              , {srcURL: r, iframeString: l, noTrackingIframeString: c} = this.getEmbedCodeFromParams()
              , h = a ? l : r;
            if ((h !== n.textContent || e) && (n.textContent = h),
            i && !s.AppUtils.isiPhone() && (o?.innerHTML.replace(/&amp;/g, "&") !== c || e)) {
                o.querySelector("iframe")?.removeEventListener("load", this._iframeLoadEventListener),
                o.innerHTML = c;
                o.querySelector("iframe").addEventListener("load", this._iframeLoadEventListener)
            }
            this.resize()
        }
        calcTemplateWidth() {
            const {deviceResolutions: t} = this._config
              , {embedPreviewParent: e} = this._children
              , {previewDevice: i, useBrowserTemplate: s} = this._state;
            if (!s)
                return;
            const {width: n, height: o} = t[i] || t.desktop;
            console.log("\ncalculating template size for", i),
            console.log("width:", n),
            console.log("height:", o)
        }
        calcIframeTransform() {
            console.log("calcIframeTransform: ");
            const {previewResolution: t} = this._state
              , {width: e, height: i} = t;
            this.resize()
        }
        _iframeLoadEventListener(t) {
            const {contentWindow: e} = t.target;
            e && (e.onhashchange = () => {
                this.setSrcURL(e.location.href, !1),
                this.updateEmbedCode({
                    updatePreview: !1
                })
            }
            )
        }
        calcIframeTransforms() {
            const {embedPreviewParent: t} = this._children
              , {deviceResolutions: e} = this._config
              , {width: i, height: s} = e.desktop
              , {paddingTop: n, paddingRight: o, paddingBottom: a, paddingLeft: r} = getComputedStyle(t)
              , {clientWidth: l, clientHeight: c} = t
              , h = l - parseFloat(r) - parseFloat(o)
              , d = c - parseFloat(n) - parseFloat(a);
            this._element.style.setProperty("--iframe-width", `${i}px`),
            this._element.style.setProperty("--iframe-height", `${s}px`);
            const u = h / i
              , p = d / s
              , m = Math.min(u, p);
            this._element.style.setProperty("--iframe-scale", m);
            const _ = (h - i * m) / 2 / m;
            this._element.style.setProperty("--iframe-offset-x", `${_}px`)
        }
        setPreviewDevice(t) {
            const {value: e} = t.target
              , {previewDevice: i} = this._state;
            e !== i && (this.setState({
                previewDevice: e
            }),
            this.updateEmbedCode({
                force: !0
            }))
        }
        toggleIframeElements(t) {
            const {checked: e} = t.target;
            this.setState({
                iframeElements: e
            }),
            this.updateEmbedCode({
                updatePreview: !1
            })
        }
        getEmbedCodeFromParams() {
            const {embedOptions: t} = this._config
              , e = t.flatMap(( ({items: t}) => t))
              , i = this._srcURL.split("?")
              , s = new URLSearchParams(i[1])
              , n = new URLSearchParams(i[1])
              , o = Object.entries(this._embedQueries).filter(( ([t,i]) => {
                const {appQueryDefault: s, dependencies: n} = e.find(( ({query: e}) => e === t)) ?? {}
                  , o = !n || n?.length && n.every(( ([t,e]) => e(this._embedQueries[t])));
                return i !== s && o
            }
            ))
              , a = Object.fromEntries(o)
              , r = {
                ...a,
                tracking: "false"
            };
            Object.keys(a).forEach((t => s.set(t, a[t]))),
            Object.keys(r).forEach((t => n.set(t, r[t])));
            const l = `${i[0]}${s.size ? "?" : ""}${s.toString()}`;
            return {
                srcURL: l,
                iframeString: `<iframe src="${l}" allowfullscreen ></iframe>`,
                noTrackingIframeString: `<iframe src="${`${i[0]}${n.size ? "?" : ""}${n.toString()}`}" allowfullscreen ></iframe>`
            }
        }
        generateEmbedContent() {
            const {embedOptions: t} = this._config
              , {embedOptsContent: e, embedAdvOptsContent: i} = this._children;
            t.forEach(( ({isAdvanced: t, groupName: s, items: n}) => {
                const o = s ? "fieldset" : "div"
                  , a = document.createElement(o);
                if (a.className = "embed-group",
                s) {
                    const t = document.createElement("legend");
                    t.innerText = s,
                    a.appendChild(t)
                }
                this.createGroupInputs(n, a);
                (t ? i : e).appendChild(a)
            }
            ))
        }
        createGroupInputs(t, e) {
            t.forEach((t => {
                const {name: i, description: s, query: n, type: o, values: a, inputDefault: r, greyValue: l, appQueryDefault: c, invert: h, onChange: d} = t
                  , u = "radio" === o
                  , p = r === l;
                if ("checkbox" === o || "number" === o) {
                    const t = document.createElement("div");
                    t.className = `input-container ${o}-container ${p ? "greyed-out" : ""}`;
                    const u = `input-${n}`
                      , m = document.createElement("label");
                    m.className = "clickable",
                    m.innerText = i,
                    m.setAttribute("for", u);
                    const _ = document.createElement("input");
                    if (_.className = "clickable",
                    _.setAttribute("id", u),
                    _.setAttribute("type", o),
                    _.setAttribute("name", n),
                    "checkbox" === o && !0 === r)
                        _.setAttribute("checked", "");
                    else if ("number" === o) {
                        const [t,e,i] = a;
                        _.setAttribute("min", t),
                        _.setAttribute("max", e),
                        _.setAttribute("step", i ?? 1),
                        _.setAttribute("value", r),
                        _.setAttribute("inputmode", "decimal"),
                        _.setAttribute("required", "")
                    } else
                        _.setAttribute("value", r);
                    _.addEventListener("click", (t => t.stopPropagation())),
                    _.addEventListener("change", (e => {
                        const {checked: i, value: s, validity: a} = e.target;
                        if ("checkbox" === o) {
                            const t = h ? !i : i;
                            this.updateEmbedParams(n, t),
                            "function" == typeof d && d(i)
                        } else if ("number" === o) {
                            const e = parseFloat(s)
                              , i = a.valid ? e : c;
                            this.updateEmbedParams(n, i);
                            const o = !a.valid || e === l;
                            t.classList.toggle("greyed-out", o),
                            "function" == typeof d && d(s)
                        }
                    }
                    ));
                    const g = document.createElement("span");
                    g.className = "clickable icon icon-help",
                    g.setAttribute("data-tippy-content", s),
                    g.setAttribute("aria-label", `Help: ${s}`),
                    g.setAttribute("tabindex", "0"),
                    t.appendChild(_),
                    t.appendChild(m),
                    t.appendChild(g),
                    e.appendChild(t)
                } else if (u) {
                    const t = document.createElement("fieldset");
                    t.className = `radio-fieldset ${o}-option`;
                    const s = document.createElement("legend");
                    s.innerText = i,
                    t.appendChild(s),
                    a.forEach(( ({title: e, value: i, description: s}) => {
                        const a = document.createElement("div");
                        a.className = `input-container ${o}-container`;
                        const l = `input-${n}-${i}`
                          , c = document.createElement("label");
                        c.className = "clickable",
                        c.innerText = e,
                        c.setAttribute("for", l);
                        const h = document.createElement("input");
                        h.className = "clickable",
                        h.setAttribute("id", l),
                        h.setAttribute("type", o),
                        h.setAttribute("name", n),
                        h.setAttribute("value", i),
                        i === r && h.setAttribute("checked", ""),
                        h.addEventListener("change", (t => {
                            const {value: e} = t.target;
                            this.updateEmbedParams(n, e)
                        }
                        ));
                        const d = document.createElement("span");
                        d.className = "clickable icon icon-help",
                        d.setAttribute("data-tippy-content", s),
                        d.setAttribute("aria-label", `Help: ${s}`),
                        d.setAttribute("tabindex", "0"),
                        a.appendChild(h),
                        a.appendChild(c),
                        a.appendChild(d),
                        t.appendChild(a)
                    }
                    )),
                    e.appendChild(t)
                }
            }
            ))
        }
        destroyEmbedContent() {
            const {embedOptsContent: t, embedAdvOptsContent: e} = this._children;
            t.innerHTML = "",
            e.innerHTML = ""
        }
        setActiveTab(t) {
            const {tabHeaders: e, tabContent: i} = this._children;
            e.childNodes.forEach((e => {
                const i = e.classList.contains(t);
                e.classList.toggle("active", i)
            }
            )),
            i.childNodes.forEach((e => {
                const i = e.classList.contains(t);
                e.classList.toggle("active", i)
            }
            )),
            "embed" === t && (this.updateEmbedCode(),
            null === this._tippySingleton && (this._tippyItems = (0,
            a.default)(".icon-help"),
            this._tippySingleton = (0,
            a.createSingleton)(this._tippyItems, {
                moveTransition: "transform 0.2s ease-out"
            }))),
            this._activeTab = t
        }
        copyToClipboard(t) {
            const {linkCode: e, linkContainer: i, embedCode: s, copiedOverlay: n} = this._children
              , o = t.currentTarget.parentElement === i ? e.textContent : s?.textContent;
            o && navigator.clipboard.writeText(o).then(( () => (n.classList.remove("flash"),
            n.offsetWidth,
            n.classList.add("flash"),
            !0))).catch((t => {
                console.error("Could not copy text: ", t)
            }
            ))
        }
        handleClick(t) {
            const {resetOnClose: e} = this._config;
            (t.target === this._element || t.target === this._children.closeButton) && (this.hide(),
            this.resetScrollbar(),
            e && this.resetEmbedOptions(),
            this.destroyTooltips());
            "CODE" !== t.target?.nodeName && window.getSelection().removeAllRanges()
        }
        handleTabClick(t) {
            const e = t.target?.innerText?.toLowerCase();
            ("link" === e || "embed" === e) && this.setActiveTab(e)
        }
        destroyTooltips() {
            this._tippyItems = null,
            this._tippySingleton?.destroy(),
            this._tippySingleton = null
        }
        resetEmbedOptions() {
            this.setEmbedParams(),
            this.destroyEmbedContent(),
            this.generateEmbedContent()
        }
        resetScrollbar() {
            this._embedOptionsScrollbar.scroll(0)
        }
        resize() {
            this.calcIframeTransforms();
            this.setIsWide() && (this.addShareButtonToParent(),
            this.resetScrollbar())
        }
        setEnabled(t) {
            super.setEnabled(t),
            this.shareButton.classList.toggle("hidden", !t);
            t && !this.shareButton.parentNode && this.addShareButtonToParent()
        }
        __destroy() {
            super.__disable(),
            this.shareButton.parentNode?.removeChild(this.shareButton),
            this.shareButton = null
        }
    }
    ShareModal.html = o(),
    e.default = ShareModal
}
, function(t) {
    t.exports = '<div id="share-modal" class="{{isVisibleClass}}" onclick="handleClick">\n\t<article class="modal-main" >\n\t\t<header class="modal-header">\n\t\t\t<div class="modal-icon icon icon-share"></div>\n\t\t\t<h3 class="modal-title">Share</h3>\n\t\t\t\x3c!-- Tab headers --\x3e\n\t\t\t<ul class="tab-headers" onclick="handleTabClick" key="tabHeaders">\n\t\t\t\t<li class="tab-header link"><button class="clickable">Link</button></li>\n\t\t\t\t<li class="tab-header embed"><button class="clickable">Embed</button></li>\n\t\t\t</ul>\n\t\t\t<button class="modal-close clickable icon icon-close" key="closeButton"></button>\n\t\t</header>\n\t\t<section class="modal-content">\n\t\t\t \x3c!-- Tab content --\x3e\n\t\t\t<div class="tab-content" key="tabContent">\n\t\t\t\t<div class="tab-pane link" key="linkContainer">\n\t\t\t\t\t\x3c!-- Content for Link tab --\x3e\n\t\t\t\t\t<img key="linkImage">\n\t\t\t\t\t<div class="link-container">\n\t\t\t\t\t\t<span>{{linkTitle}}</span>\n\t\t\t\t\t\t<code class="scrollable" key="linkCode"></code>\n\t\t\t\t\t</div>\n\t\t\t\t\t<button class="copy-link clickable" onclick="copyToClipboard">\n\t\t\t\t\t\t<div class="icon icon-copy"></div>\n\t\t\t\t\t\t<span>Copy Link</span>\n\t\t\t\t\t</button>\n\t\t\t\t</div>\n\t\t\t\t<div class="tab-pane embed" key="embedContainer">\n\t\t\t\t\t\x3c!-- Content for Embed tab --\x3e\n\t\t\t\t\t<section class="main-section">\n\t\t\t\t\t\t<div class="preview-container {{previewDevice}} {{previewVisibleClass}}">\n\t\t\t\t\t\t\t<span>Interactive Preview</span>\n\t\t\t\t\t\t\t<div class="preview" key="embedPreviewParent"></div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<code class="scrollable" key="embedCode"></code>\n\t\t\t\t\t\t<div class="input-container">\n\t\t\t\t\t\t\t<input class="clickable" type="checkbox" id="iframe-elements-checkbox" onchange="toggleIframeElements" checked />\n\t\t\t\t\t\t\t<label class="clickable" for="iframe-elements-checkbox">Include i-frame elements</label>\n\t\t\t\t\t\t\t<span class="clickable icon icon-help" data-tippy-content="Include the iframe HTML tags in the embed code" aria-label="Help: Include the iframe HTML tags in the embed code" tabindex="0"></span>\n\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t<button class="copy-link clickable" onclick="copyToClipboard">\n\t\t\t\t\t\t\t<div class="icon icon-copy"></div>\n\t\t\t\t\t\t\t<span>Copy Embed Code</span>\n\t\t\t\t\t\t</button>\n\t\t\t\t\t</section>\n\t\t\t\t\t<section class="options-section">\n\t\t\t\t\t\t<h5>Embed Options</h5>\n\t\t\t\t\t\t<div class="options-container scrollable">\n\t\t\t\t\t\t\t<div class="options basic-options" key="embedOptsContent"></div>\n\t\t\t\t\t\t\t<details class="advanced">\n\t\t\t\t\t\t\t\t<summary class="clickable">Advanced Options</summary>\n\t\t\t\t\t\t\t\t<div class="options embed-adv-container" key="embedAdvOptsContent"></div>\n\t\t\t\t\t\t\t</details>\n\t\t\t\t\t\t</div>\n\n\t\t\t\t\t</section>\n\t\t\t\t</div>\n\t\t\t</div>\n\n\t\t</section>\n\t\t<h3 class="copied-overlay" key="copiedOverlay">Copied to clipboard!</h3>\n\n\t</article>\n</div>\n'
}
, function(t, e, i) {
    "use strict";
    i.r(e);
    e.default = [{
        groupName: "User Interface",
        isAdvanced: !1,
        items: [{
            name: "Show Detail Panel",
            description: "Displays the detail panel for an entity on the left side of the screen",
            query: "detailPanel",
            type: "checkbox",
            inputDefault: !0,
            appQueryDefault: !0
        }, {
            name: "Show NASA logo",
            description: "Displays the NASA logo in the top left corner",
            query: "logo",
            type: "checkbox",
            inputDefault: !0,
            appQueryDefault: !0
        }, {
            name: "Show Search",
            description: "Determines whether the search bar is visible",
            query: "search",
            type: "checkbox",
            inputDefault: !0,
            appQueryDefault: !0
        }, {
            name: "Show Share Button",
            description: "Determines whether the share button is visible",
            query: "shareButton",
            type: "checkbox",
            inputDefault: !0,
            appQueryDefault: !0
        }, {
            name: "Show Main Menu",
            description: "Determines whether the main menu is visible in the top right",
            query: "menu",
            type: "checkbox",
            inputDefault: !0,
            appQueryDefault: !0
        }, {
            name: "Show Expanded Settings Bar",
            description: "Determines whether the settings bar is expanded upon first load",
            query: "collapseSettingsOptions",
            type: "checkbox",
            inputDefault: !0,
            appQueryDefault: !1,
            invert: !0
        }, {
            name: "Show Fullscreen Button",
            description: "Include the fullscreen button in the settings bar",
            query: "hideFullScreenToggle",
            type: "checkbox",
            inputDefault: !0,
            appQueryDefault: !1,
            invert: !0
        }]
    }, {
        groupName: "Navigation",
        isAdvanced: !1,
        items: [{
            name: "Allow Navigation",
            description: "Allows the user to navigate to other entities",
            query: "locked",
            type: "checkbox",
            inputDefault: !0,
            appQueryDefault: !1,
            invert: !0
        }, {
            name: "Allow External Links",
            description: "Allows all external links to navigate away from the app to outside resources",
            query: "hideExternalLinks",
            type: "checkbox",
            inputDefault: !0,
            appQueryDefault: !1,
            invert: !0
        }]
    }, {
        groupName: "3D",
        isAdvanced: !1,
        items: [{
            name: "Lighting",
            query: "lighting",
            type: "radio",
            values: [{
                title: "Flood",
                value: "flood",
                description: "Flood lighting allows for even lighting across all 3D entities"
            }, {
                title: "Natural",
                value: "natural",
                description: "Natural lighting allows for realistic lighting based on the sun's position"
            }, {
                title: "Shadow",
                value: "shadow",
                description: "Shadow lighting allows for somewhat realistic lighting based on the sun's position, but highlights the shadows so they are not completely dark"
            }],
            inputDefault: "shadow",
            appQueryDefault: "shadow"
        }]
    }]
}
, function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t, e, i) {
    "use strict";
    i.r(e);
    var s = i(492);
    i(204),
    i(494);
    e.default = s.default
}
, function(t, e, i) {
    "use strict";
    i.r(e);
    var s = i(147)
      , n = i(2)
      , o = i(493)
      , a = i.n(o);
    class TimeController extends n.BaseComponent {
        constructor(t) {
            super(t, null, {
                isPlay: !1,
                playClass: "",
                rate: 0,
                rateDisplay: 0
            }),
            this._class.fontSize.small = "tiny",
            this._class.isPlay = {
                true: "icon-pause",
                false: "icon-play"
            },
            this._rates = [-94608e3, -31536e3, -6048e3, -604800, -86400, -36e3, -3600, -600, -60, -10, -1, 0, 1, 10, 60, 600, 3600, 36e3, 86400, 604800, 6048e3, 31536e3, 94608e3],
            this._manager = this._app.getManager("time"),
            this._router = this._app.getManager("router"),
            this._manager.setDefaultTimeRate(1);
            const e = this._manager.getTimeRate()
              , i = 0 !== e;
            this.setState({
                isPlay: i,
                playClass: this._class.isPlay[i],
                rate: e,
                rateDisplay: this.getRateDisplay()
            }),
            this.bindFunctions(["getRateLimits", "setRateLimits", "setRate", "setDefaultRate", "setRealRate", "decreaseRate", "increaseRate", "togglePlayPause", "onRateChange", "onForcedPause", "onForcedPauseResume"])
        }
        init() {
            super.init(),
            s.default.setDefaultProps({
                theme: "default",
                touch: ["hold", 2e3],
                delay: [600, null],
                plugins: [s.followCursor]
            }),
            (0,
            s.default)(this._children.toggleBtn, {
                placement: "top"
            }),
            (0,
            s.default)(this._children.increaseBtn, {
                placement: "top"
            }),
            (0,
            s.default)(this._children.decreaseBtn, {
                placement: "top"
            }),
            this._children.decreaseContainer.classList.add("bg-color", "gray", "dark"),
            this._children.increaseContainer.classList.add("bg-color", "gray", "dark"),
            this._children.label.classList.add("semi"),
            this._children.rateDisplay.classList.add("semi"),
            this._callbackRegistry.push({
                emitter: this._app.getManager("time"),
                event: "ratechange",
                callback: this.onRateChange
            })
        }
        getRateLimits() {
            return this._rates
        }
        setRateLimits(t) {
            this._rates = t
        }
        setRate(t) {
            this._router.navigate({
                time: this._manager.getTimeUrl(),
                rate: t
            }, this._router.currentRoute.url)
        }
        decreaseRate() {
            if (0 === this._rates.length)
                return;
            const t = this._rates.indexOf(this._manager.getTimeRate());
            0 !== t && this.setRate(this._rates[t - 1])
        }
        increaseRate() {
            if (0 === this._rates.length)
                return;
            const t = this._rates.indexOf(this._manager.getTimeRate());
            t !== this._rates.length - 1 && this.setRate(this._rates[t + 1])
        }
        togglePlayPause() {
            !this._state.isPlay ? this._manager.play() : this._manager.pause(),
            this.setRate(this._manager.getTimeRate())
        }
        setDefaultRate() {
            this.setRate(this._manager.getDefaultTimeRate())
        }
        setRealRate() {
            this.setRate(1)
        }
        onRateChange() {
            const t = this._manager.getTimeRate()
              , e = 0 !== t;
            e === this._state.isPlay && this._state.rate === t || (this._rates.length > 0 && !this._rates.includes(t) ? this.setRate(this._manager.getDefaultTimeRate()) : this.setState({
                isPlay: e,
                rate: t,
                playClass: this._class.isPlay[e],
                rateDisplay: this.getRateDisplay(t)
            }))
        }
        onForcedPause() {
            this.setRate(0)
        }
        onForcedPauseResume() {
            this.setDefaultRate()
        }
        getRateUnit(t=null) {
            null === t && (t = this._manager.getTimeRate());
            const e = t / 31536e3
              , i = t / 2592e3
              , s = t / 604800
              , n = t / 86400
              , o = t / 3600
              , a = t / 60;
            let r = "";
            return (e >= 1 || e <= -1) && e % 1 == 0 ? (t = e,
            r = " yr") : (i >= 1 || i <= -1) && i % 1 == 0 ? (t = i,
            r = " mth") : (s >= 1 || s <= -1) && s % 1 == 0 ? (t = s,
            r = " wk") : (n >= 1 || n <= -1) && n % 1 == 0 ? (t = n,
            r = " day") : (o >= 1 || o <= -1) && o % 1 == 0 ? (t = o,
            r = " hr") : (a >= 1 || a <= -1) && a % 1 == 0 ? (t = a,
            r = " min") : (t %= 60,
            r = " sec"),
            {
                rate: t,
                unit: r
            }
        }
        getRateDisplay(t) {
            const {rate: e, unit: i} = this.getRateUnit(t);
            return 0 !== e ? e + i + "(s)/sec" : "paused"
        }
    }
    TimeController.html = a(),
    e.default = TimeController
}
, function(t) {
    t.exports = '<div class="time-controller {{isVisibleClass}}">\n\t<div class="rate-container">\n\t\t<button key="toggleBtn" class="icon {{playClass}} clickable play-pause" data-tippy-content="Pause / play" onclick="togglePlayPause"></button>\n\t\t<label key="label" class="rate-label">rate</label>\n\t\t<button key="decreaseBtn" class="prev-rate clickable" data-tippy-content="Decrease time rate" onclick="decreaseRate">\n\t\t\t<span key="decreaseContainer" class="container">\n\t\t\t\t<span class="icon icon-backward"></span>\n\t\t\t</span>\n\t\t</button>\n\t\t<div class="vertical-line"></div>\n\t\t<button key="increaseBtn" class="next-rate clickable" data-tippy-content="Increase time rate" onclick="increaseRate">\n\t\t\t<span key="increaseContainer" class="container">\n\t\t\t\t<span class="icon icon-forward"></span>\n\t\t\t</span>\n\t\t</button>\n\t\t<label key="rateDisplay" class="rate-display-label">{{rateDisplay}}</label>\n\t</div>\n</div>\n'
}
, function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        CheckboxMultistate: function() {
            return s.default
        }
    });
    var s = i(496)
      , n = i(497);
    i(499);
    e.default = n.default
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        CheckboxMultistate: function() {
            return CheckboxMultistate
        }
    });
    i(2);
    var s = i(497)
      , n = i(498)
      , o = i.n(n);
    class CheckboxMultistate extends s.Checkbox {
        constructor(t, e={}) {
            super(t, {
                ...e,
                stateIndex: e.stateIndex ?? 0
            }),
            this._numStates = 3,
            this._initStates(),
            this.bindFunctions(["cycle"])
        }
        _initStates() {
            Object.assign(this._class, {
                checkbox: Array.from({
                    length: this._numStates
                }, ( (t, e) => 0 === e ? "" : e === this._numStates - 1 ? "checked" : `checkbox-state-${e}`)),
                text: Array.from({
                    length: this._numStates
                }, ( (t, e) => 0 === e || e === this._numStates - 1 ? "" : `text-state-${e}`)),
                icon: Array.from({
                    length: this._numStates
                }, ( (t, e) => 0 === e ? "checkbox-hover" : e === this._numStates - 1 ? "icon-checkmark" : `icon-state-${e}`))
            }),
            this.setState({
                isCheckedClass: this._class.checkbox[this._state.stateIndex],
                textClass: this._class.text[this._state.stateIndex],
                iconCheckmarkClass: this._class.icon[this._state.stateIndex]
            })
        }
        init() {
            super.init(),
            this._config.key && this._element.setAttribute("key", this._config.key),
            this._element.removeEventListener("click", this.toggle),
            this._element.addEventListener("click", this.cycle)
        }
        setNumStates(t) {
            t < 2 ? console.warn("Number of states must be at least 2") : (this._numStates = t,
            this._initStates())
        }
        getCurrentStateIndex() {
            return this._state.stateIndex
        }
        setClassesForIndex(t, e) {
            Object.keys(t).forEach((i => {
                this._class[i] || (this._class[i] = Array.from({
                    length: this._numStates
                }, ( () => ""))),
                this._class[i][e] = t[i]
            }
            )),
            this.setState({
                isCheckedClass: this._class.checkbox[this._state.stateIndex],
                textClass: this._class.text[this._state.stateIndex],
                iconCheckmarkClass: this._class.icon[this._state.stateIndex]
            })
        }
        async cycle(t, e=!1, i=null) {
            const s = i ?? (this._state.stateIndex + 1) % this._numStates;
            this.setState({
                stateIndex: s,
                isCheckedClass: this._class.checkbox[s],
                textClass: this._class.text[s],
                iconCheckmarkClass: this._class.icon[s]
            }, (async () => {
                e || "function" != typeof this._config.function || await this._config.function(t, s)
            }
            ))
        }
    }
    CheckboxMultistate.html = o(),
    e.default = CheckboxMultistate
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        Checkbox: function() {
            return Checkbox
        }
    });
    var s = i(2)
      , n = i(498)
      , o = i.n(n);
    class Checkbox extends s.BaseComponent {
        constructor(t, e={}) {
            super(t, null, {
                config: {
                    key: "",
                    colorClass: "",
                    function: null
                },
                isChecked: !1,
                text: "",
                checkboxClass: "",
                textClass: "",
                ...e
            }),
            Object.assign(this._class, {
                checkbox: {
                    true: "checked",
                    false: ""
                },
                color: {
                    true: this._config.colorClass,
                    false: ""
                },
                checkmark: {
                    true: "icon-checkmark",
                    false: "checkbox-hover"
                }
            }),
            Object.assign(this._state, {
                isCheckedClass: this._class.checkbox[this._state.isChecked],
                colorClass: this._class.color[this._state.isChecked],
                iconCheckmarkClass: this._class.checkmark[this._state.isChecked]
            }),
            this.bindFunctions(["toggle"])
        }
        init() {
            super.init(),
            this._config.key && this._element.setAttribute("key", this._config.key),
            this._element.addEventListener("click", this.toggle)
        }
        async toggle(t, e=!1) {
            const i = !this._state.isChecked
              , s = this._class.checkbox[i]
              , n = this._class.color[i]
              , o = this._class.checkmark[i];
            this.setState({
                isChecked: i,
                isCheckedClass: s,
                colorClass: n,
                iconCheckmarkClass: o
            }, (async () => {
                !e && this._config.function instanceof Function && await this._config.function(t)
            }
            ))
        }
    }
    Checkbox.html = o(),
    e.default = Checkbox
}
, function(t) {
    t.exports = '<li class="checkbox-option clickable {{checkboxClass}} {{isCheckedClass}}">\n\t<span key="icon" class="icon checkbox bg-color {{iconCheckmarkClass}}"></span>\n\t<span key="text" class="text {{textClass}}">{{text}}</span>\n</li>\n'
}
, function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        LayerPanel: function() {
            return LayerPanel
        }
    });
    var s = i(2)
      , n = i(501)
      , o = i.n(n);
    i(502);
    class LayerPanel extends s.BaseComponent {
        constructor(t, e={}) {
            e.config = {
                layers: e.layers || [],
                checkboxType: e.checkboxType || "default",
                ...e.config
            },
            super(t, null, {
                isVisible: !1,
                ui: t.getManager("layer").getLayer("ui").defaultVisibility,
                planets: t.getManager("layer").getLayer("planets").defaultVisibility,
                asteroids: t.getManager("layer").getLayer("asteroids").defaultVisibility,
                comets: t.getManager("layer").getLayer("comets").defaultVisibility,
                dwarfPlanets: t.getManager("layer").getLayer("dwarfPlanets").defaultVisibility,
                spacecraft: t.getManager("layer").getLayer("spacecraft").defaultVisibility,
                trails: t.getManager("layer").getLayer("trails").defaultVisibility,
                orbits: t.getManager("layer").getLayer("orbits").defaultVisibility,
                labels: t.getManager("layer").getLayer("labels").defaultVisibility,
                icons: t.getManager("layer").getLayer("icons").defaultVisibility,
                starfield: t.getManager("layer").getLayer("starfield").defaultVisibility,
                constellations: t.getManager("layer").getLayer("constellations").defaultVisibility,
                ...e
            }),
            this._eyesCheck = "eyes" === e.checkboxType,
            Object.assign(this._class, {
                checkbox: {
                    true: this._eyesCheck ? "active" : "active icon-checkmark",
                    false: this._eyesCheck ? "" : "checkbox-hover"
                },
                boxColor: {
                    true: "settings-alt",
                    false: ""
                },
                isVisible: {
                    true: "",
                    false: ""
                }
            }),
            Object.assign(this._state, {
                uiClass: this._class.checkbox[this._state.ui],
                uiColorClass: this._class.boxColor[this._state.ui],
                planetsClass: this._class.checkbox[this._state.planets],
                planetsColorClass: this._class.boxColor[this._state.planets],
                asteroidsClass: this._class.checkbox[this._state.asteroids],
                asteroidsColorClass: this._class.boxColor[this._state.asteroids],
                cometsClass: this._class.checkbox[this._state.comets],
                cometsColorClass: this._class.boxColor[this._state.comets],
                dwarfPlanetsClass: this._class.checkbox[this._state.dwarfPlanets],
                dwarfPlanetsColorClass: this._class.boxColor[this._state.dwarfPlanets],
                constellationsClass: this._class.checkbox[this._state.constellations],
                constellationsColorClass: this._class.boxColor[this._state.constellations],
                spacecraftClass: this._class.checkbox[this._state.spacecraft],
                spacecraftColorClass: this._class.boxColor[this._state.spacecraft],
                trailsClass: this._class.checkbox[this._state.trails],
                trailsColorClass: this._class.boxColor[this._state.trails],
                orbitsClass: this._class.checkbox[this._state.orbits],
                orbitsColorClass: this._class.boxColor[this._state.orbits],
                labelsClass: this._class.checkbox[this._state.labels],
                labelsColorClass: this._class.boxColor[this._state.labels],
                iconsClass: this._class.checkbox[this._state.icons],
                iconsColorClass: this._class.boxColor[this._state.icons],
                starfieldClass: this._class.checkbox[this._state.starfield],
                starfieldColorClass: this._class.boxColor[this._state.starfield]
            }),
            this._categories = {
                ui: "User Interface",
                planets: "Planet",
                asteroids: "Asteroid",
                comets: "Comet",
                dwarfPlanets: "Dwarf Planet",
                spacecraft: "Spacecraft",
                trails: "Trail",
                labels: "Label",
                icons: "Icons",
                starfield: "Star Field",
                constellations: "Constellations"
            },
            this._categoriesDisplay = {
                ui: "User Interface",
                planets: "Planets",
                asteroids: "Asteroids",
                comets: "Comets",
                dwarfPlanets: "Dwarf Planets",
                constellations: "Constellations",
                spacecraft: "Spacecraft",
                trails: "Trails",
                orbits: "Orbits",
                labels: "Labels",
                icons: "Icons",
                starfield: "Star Field"
            },
            this.bindFunctions(["toggleLayer", "handleLayerToggle"]),
            this._fadeInRight = null,
            this._fadeOutRight = null,
            this._fadeInBottom = null,
            this._fadeOutBottom = null,
            this._lastMode = s.AppUtils.isMobileMode(),
            this._initCallbacks()
        }
        getCategoriesDisplay() {
            return this._categoriesDisplay
        }
        resize() {
            super.resize(),
            this._updatePosition()
        }
        init() {
            super.init(),
            this._callbackRegistry.push({
                emitter: this._app.getManager("layer"),
                event: "toggleLayer",
                callback: this.handleLayerToggle
            });
            const t = this._children.layerPanelBody;
            if (t) {
                t.textContent = "";
                const e = document.createElement("div");
                e.className = "container",
                this._config.layers.forEach((t => {
                    const i = document.createElement("div");
                    i.classList.add("block");
                    const n = document.createElement("ul");
                    n.classList.add("layers"),
                    t.forEach((t => {
                        if (this._eyesCheck) {
                            const e = document.createElement("li");
                            e.setAttribute("key", t),
                            e.className = `layer-panel-layer item clickable {{${t}Class}}`;
                            const i = document.createElement("div");
                            i.classList.add("eyes-checkbox"),
                            i.innerHTML = `<input type="checkbox" id="layer-panel-checkbox-${t}" ${this._state[t] ? "checked" : ""}><label for="layer-panel-checkbox-${t}"></label>`,
                            e.append(i);
                            const s = document.createElement("span");
                            s.classList.add("small"),
                            s.textContent = this._categoriesDisplay[t],
                            e.append(s),
                            e.addEventListener("click", this.toggleLayer),
                            n.append(e)
                        } else {
                            const e = new s.Checkbox(this._app,{
                                config: {
                                    key: t,
                                    colorClass: this._class.boxColor.true,
                                    function: this.toggleLayer
                                },
                                isChecked: this._app.getManager("layer").getLayer(t).defaultVisibility,
                                text: this._categoriesDisplay[t],
                                checkboxClass: "layer-panel-layer item",
                                textClass: "small"
                            });
                            e.init(),
                            this._components.push(e),
                            n.appendChild(e.element)
                        }
                    }
                    )),
                    i.append(n),
                    e.append(i)
                }
                )),
                t.append(e),
                this._setVariables(t)
            }
        }
        _createAnimations() {
            this._fadeOutRight = s.AnimationUtils.directionalFade(this._element, {
                direction: "right",
                fade: "out",
                yOffset: 0
            }),
            this._fadeInRight = s.AnimationUtils.directionalFade(this._element, {
                direction: "right",
                fade: "in",
                yOffset: 0
            }),
            this._fadeOutBottom = s.AnimationUtils.directionalFade(this._element, {
                direction: "down",
                fade: "out",
                yOffset: 0
            }),
            this._fadeInBottom = s.AnimationUtils.directionalFade(this._element, {
                direction: "down",
                fade: "in",
                yOffset: 0
            })
        }
        _resetAnimations() {
            this._fadeInRight.currentTime = 0,
            this._fadeOutRight.currentTime = 0,
            this._fadeInBottom.currentTime = 0,
            this._fadeOutBottom.currentTime = 0,
            this._fadeInRight.pause(),
            this._fadeOutRight.pause(),
            this._fadeInBottom.pause(),
            this._fadeOutBottom.pause()
        }
        toggleLayer(t) {
            const e = t.target?.getAttribute("key") ?? t;
            this._app.getManager("layer").toggleLayer(e, {
                category: this._categories[e]
            })
        }
        handleLayerToggle(t, e, i) {
            const s = t + "Class"
              , n = t + "ColorClass";
            if (null !== this.getState(t) && (this.setState({
                [t]: e,
                [s]: this._class.checkbox[e],
                [n]: this._class.boxColor[e]
            }),
            this._eyesCheck)) {
                const i = document.getElementById(`layer-panel-checkbox-${t}`);
                i && (i.checked = e)
            }
            const o = this._components.find((e => e.getConfig().key === t));
            o && o.getState("isChecked") !== e && o.toggle(null, !0)
        }
        isCategoryEnabled(t) {
            return !this._children[t]?.classList.contains("disabled")
        }
        setCategoryEnabled(t, e=!0) {
            this._children[t]?.classList.toggle("disabled", !e)
        }
        hide() {
            this.getState("isVisible") && (super.hide(),
            document.body.style.setProperty("--settings-z-index", "40"),
            s.AppUtils.isMobileMode() ? (this._fadeOutBottom = s.AnimationUtils.directionalFade(this._element, {
                direction: "down",
                fade: "out",
                yOffset: 0
            }),
            this._fadeOutBottom.play()) : (this._fadeOutRight = s.AnimationUtils.directionalFade(this._element, {
                direction: "right",
                fade: "out",
                yOffset: 0
            }),
            this._fadeOutRight.play()))
        }
        show() {
            super.show(),
            document.body.style.setProperty("--settings-z-index", "50"),
            s.AppUtils.isMobileMode() ? (this._fadeInBottom = s.AnimationUtils.directionalFade(this._element, {
                direction: "down",
                fade: "in",
                yOffset: 0
            }),
            this._fadeInBottom.play()) : (this._fadeInRight = s.AnimationUtils.directionalFade(this._element, {
                direction: "right",
                fade: "in",
                yOffset: 0
            }),
            this._fadeInRight.play())
        }
        _updatePosition() {
            const t = s.AppUtils.isMobileMode();
            t !== this._lastMode && (this._lastMode = t,
            this._state.isVisible && this.show())
        }
        __enable() {
            super.__enable(),
            this._createAnimations()
        }
        __disable() {
            super.__disable(),
            this._fadeInRight = null,
            this._fadeOutRight = null,
            this._fadeInBottom = null,
            this._fadeOutBottom = null
        }
    }
    LayerPanel.html = o()
}
, function(t) {
    t.exports = '<div class="layer-panel {{isVisibleClass}}" id="layer-panel">\n\t<div class="header" onclick="hide">\n\t\t<h5 class="title">Layers</h5>\n\t\t<button class="icon icon-greater clickable close"></button>\n\t</div>\n\t<div key="layerPanelBody">\n\t</div>\n</div>\n'
}
, function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        Breadcrumb: function() {
            return Breadcrumb
        }
    });
    var s = i(2)
      , n = i(504)
      , o = i.n(n);
    i(505);
    class Breadcrumb extends s.BaseComponent {
        constructor(t, e={
            params: {}
        }) {
            e.params = {
                title: "",
                ...e.params
            },
            super(t, null, e),
            this._class.isHomeActiveClass = {
                true: "active",
                false: ""
            },
            this._crumbTexts = {
                compare: "Compare Size",
                events: "Mission Events"
            },
            this.setCrumbClickHandler((t => {
                this._app.getManager("router").navigate(t, "", {
                    __remove: "all",
                    keepTime: !0
                })
            }
            )),
            Object.assign(this._state, {
                isHomeActive: !1,
                isHomeActiveClass: this._class.isHomeActiveClass.false
            }),
            this.bindFunctions(["_goToHome"])
        }
        updateBreadcrumb(t) {
            this._element.innerHTML = "";
            const e = document.createDocumentFragment();
            !1 === this._app.getManager("router").configs.logo && this._children.staticLogo.classList.add("hidden"),
            this._app.getManager("router").configs.locked && this._children.static.classList.remove("clickable"),
            e.appendChild(this._children.static);
            const i = !t || 0 === t.length || 1 === t.length && "home" === t[0];
            if (i && (t = null),
            this.setState({
                isHomeActive: i,
                isHomeActiveClass: this._class.isHomeActiveClass[i]
            }),
            t && t.length > 0)
                for (let i = 0; i < t.length; i++) {
                    const s = t[i]
                      , n = t.slice(0, i + 1).join("/")
                      , o = this._createCrumb(s, n);
                    e.appendChild(o)
                }
            this._element.appendChild(e)
        }
        onRouteChange({routeParts: t}={}) {
            this.updateBreadcrumb(t)
        }
        setCrumbClickHandler(t) {
            this._onCrumbClick = t
        }
        _goToHome() {
            const t = this._app.getManager("router");
            "/home" === t.currentRoute.url ? this._app.cameraScripts.goToSystem("inner_solar_system") : t.navigate({
                __remove: "all"
            }, "/home")
        }
        _getCrumbText(t) {
            if (this._crumbTexts[t])
                return this._crumbTexts[t];
            const e = this._app.getManager("content").getEntityInfo([t]);
            if (e)
                return e.displayName || e.iauName;
            const i = this._app.getManager("content").events[t];
            if (i)
                return i.title;
            const s = this._app.getManager("content").getStoryList().stories[t];
            return s ? s.title : ""
        }
        _createCrumb(t, e) {
            const i = document.createElement("nav")
              , {locked: s} = this._app.getManager("router").configs;
            i.className = "container " + (s ? "" : "clickable"),
            s || i.addEventListener("click", ( () => {
                this._onCrumbClick(e)
            }
            ));
            const n = document.createElement("span");
            n.className = "separator icon icon-greater",
            i.appendChild(n);
            const o = document.createElement("a");
            return o.innerHTML = this._getCrumbText(t) || t,
            o.className = "text link",
            i.appendChild(o),
            i
        }
    }
    Breadcrumb.html = o()
}
, function(t) {
    t.exports = '<nav class="breadcrumb semi">\n\t<nav key="static" class="container clickable home {{isHomeActiveClass}}" onclick="_goToHome">\n\t\t<span key="staticLogo" class="icon icon-nasa-logo"></span>\n\t\t<h1 class="text uppercase">{$title}</h1>\n\t</nav>\n</nav>\n'
}
, function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        StoryBaseContentBlock: function() {
            return StoryBaseContentBlock
        }
    });
    var s = i(2);
    i(507);
    class StoryBaseContentBlock extends s.BaseComponent {
        constructor(t, e={
            config: {
                info: {}
            }
        }) {
            e.isVisible = !0,
            super(t, null, e),
            this._config.info.onEnter && (this.onEnter = async () => await this._config.info.onEnter(t, this)),
            this._config.info.onLeave && (this.onLeave = async () => await this._config.info.onLeave(t, this)),
            this.bindFunctions(["onEnter", "onLeave", "onClick"])
        }
        init() {
            super.init(this._config.info),
            this._element.classList.add("content-block", "{{isVisibleClass}}"),
            Array.isArray(this._config.info.classList) && this._element.classList.add(...this._config.info.classList),
            this._setVariables(this._element, !1),
            (this._config.info.clickable || this._config.info.func) && (this._element.classList.add("clickable"),
            this._element.addEventListener("click", this.onClick))
        }
        async onEnter() {}
        async onLeave() {}
        async onClick() {
            const {type: t} = this._config.info;
            "buttons" !== t && await this._config.info.func(this._app, this)
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        HintBlock: function() {
            return HintBlock
        }
    });
    var s = i(2)
      , n = i(509)
      , o = i.n(n);
    i(510);
    class HintBlock extends s.StoryBaseContentBlock {
        constructor(t, e={}) {
            super(t, {
                iconBefore: "icon-greater",
                iconAfter: "icon-greater",
                ...e
            }),
            Object.assign(this._state, {
                text: this._config.info.text || "Scroll to continue",
                isIconBeforeVisibleClass: this._class.isVisible[this._config.info.iconBeforeText || !1],
                isIconAfterVisibleClass: this._class.isVisible[this._config.info.iconAfterText || !1]
            })
        }
    }
    HintBlock.html = o()
}
, function(t) {
    t.exports = '<div class="hint-block {$class}">\n\t<span class="icon before {{iconBefore}} {{isIconBeforeVisibleClass}}"></span>\n\t<span class="text">{{text}}</span>\n\t<span class="icon after {{iconAfter}} {{isIconAfterVisibleClass}}"></span>\n</div>\n'
}
, function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        ToggleBlock: function() {
            return ToggleBlock
        }
    });
    var s = i(2)
      , n = i(512)
      , o = i.n(n);
    i(513);
    class ToggleBlock extends s.StoryBaseContentBlock {
        constructor(t, e={}) {
            super(t, {
                isSelected: !1,
                ...e
            }),
            this._class.isSelectedClass = {
                true: "selected",
                false: ""
            },
            this._config.info.selected = Boolean(this._config.info.selected),
            Object.assign(this._state, {
                isSelectedClass: this._class.isSelectedClass[this._state.isSelected]
            })
        }
        async onEnter() {
            await super.onEnter(),
            this._config.info.selected !== this._state.isSelected && await this.onClick()
        }
        async onLeave() {
            await super.onLeave(),
            this._state.isSelected && await this.onClick()
        }
        async onClick() {
            await super.onClick(),
            this._state.isSelected ? (this.unselect(),
            console.log("unselect")) : (this.select(),
            console.log("select"))
        }
        select() {
            this.setState({
                isSelected: !0,
                isSelectedClass: this._class.isSelectedClass.true
            })
        }
        unselect() {
            this.setState({
                isSelected: !1,
                isSelectedClass: this._class.isSelectedClass.false
            })
        }
    }
    ToggleBlock.html = o()
}
, function(t) {
    t.exports = '<div class="clickable toggle-block {{isSelectedClass}}">\n\t<button>\n\t\t{$text}\n\t</button>\n</div>\n'
}
, function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        TitleBlock: function() {
            return TitleBlock
        }
    });
    var s = i(2)
      , n = i(515)
      , o = i.n(n);
    class TitleBlock extends s.StoryBaseContentBlock {
    }
    TitleBlock.html = o()
}
, function(t) {
    t.exports = '<div class="title-block">\n\t<h1 class="title">{$title}</h1>\n\t<h2 class="subtitle">{$subtitle}</h2>\n</div>\n'
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        ImageBlock: function() {
            return ImageBlock
        }
    });
    var s = i(2)
      , n = i(517)
      , o = i.n(n);
    i(518);
    class ImageBlock extends s.StoryBaseContentBlock {
        onClick() {
            const t = this._element.cloneNode(!0);
            t.classList.add("fullscreen"),
            t.classList.remove("clickable"),
            this._app.getComponent("overlay").setContent(t),
            this._app.getComponent("overlay").show()
        }
    }
    ImageBlock.html = o()
}
, function(t) {
    t.exports = '<div class="image-block">\n\t<img class="{$className}" src="{$src}" alt="{$alt}">\n\t<span class="title">{$title}</span>\n</div>\n'
}
, function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        DescriptionBlock: function() {
            return DescriptionBlock
        }
    });
    var s = i(2)
      , n = i(520)
      , o = i.n(n);
    i(521);
    class DescriptionBlock extends s.StoryBaseContentBlock {
        constructor(t, e={}) {
            super(t, {
                hasMore: !1,
                isMoreVisible: !1,
                ...e
            }),
            this._class.hasMoreClass = {
                true: "",
                false: "hidden"
            },
            this._more = {
                isVisible: {
                    moreMessage: "Show Less",
                    moreIcon: "icon-minus",
                    moreClass: ""
                },
                isHidden: {
                    moreMessage: "Show More",
                    moreIcon: "icon-plus",
                    moreClass: "hidden"
                }
            },
            Object.assign(this._state, this._more.isHidden, {
                hasMoreClass: this._class.hasMoreClass[this._state.hasMore]
            })
        }
        init() {
            super.init();
            const t = Boolean(this._config.info.more);
            this.setState({
                hasMore: t,
                hasMoreClass: this._class.hasMoreClass[t]
            })
        }
        showMore() {
            this.setState({
                isMoreVisible: !0,
                ...this._more.isVisible
            })
        }
        hideMore() {
            this.setState({
                isMoreVisible: !1,
                ...this._more.isHidden
            })
        }
        toggleMore() {
            this._state.isMoreVisible ? this.hideMore() : this.showMore()
        }
    }
    DescriptionBlock.html = o()
}
, function(t) {
    t.exports = '<div class="description-block">\n\t<div key="header" class="header">\n\t\t<h2 class="title">{$title}</h2>\n\t\t<h3 class="subtitle semi">{$subtitle}</h3>\n\t</div>\n\t<div key="body" class="body">\n\t\t<div class="description">{$description}</div>\n\t\t<span class="more-description {{moreClass}}" >\n\t\t\t{$more}\n\t\t</span>\n\t\t<span class="clickable more-toggle {{hasMoreClass}}" onclick="toggleMore">\n\t\t\t<span class="x-small more-message">\n\t\t\t\t{{moreMessage}}\n\t\t\t</span>\n\t\t\t<span class="button clickable icon more-icon {{moreIcon}}"></span>\n\t\t</span>\n\t</div>\n\t<div key="footer" class="footer"></div>\n</div>\n'
}
, function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        ReplayButtonBlock: function() {
            return ReplayButtonBlock
        }
    });
    var s = i(2)
      , n = i(523)
      , o = i.n(n);
    i(524);
    class ReplayButtonBlock extends s.StoryBaseContentBlock {
        init() {
            this._config.info.text || (this._config.info.text = this._config.info.fromStart ? "Restart Story" : "Replay Animation"),
            super.init(this._config.info)
        }
        async onClick() {
            const t = this._app.getManager("router");
            this._config.info.fromStart ? t.navigate(t.currentRoute.url) : t.reload()
        }
    }
    ReplayButtonBlock.html = o()
}
, function(t) {
    t.exports = '<div class="clickable replay-button-block" onclick="onClick">\n\t<button>\n\t\t<span class="icon icon-replay"></span>\n\t\t<span class="text semi">{$text}</span>\n\t</button>\n</div>\n'
}
, function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        ButtonsBlock: function() {
            return ButtonsBlock
        }
    });
    var s = i(2)
      , n = i(526)
      , o = i.n(n);
    i(527);
    class ButtonsBlock extends s.StoryBaseContentBlock {
        constructor(t, e={}) {
            super(t, {
                ...e
            }),
            this._app = t,
            this._options = e;
            t.pioneer.getScene("main").getLoadedPromise().then(( () => (this.setUpHTML(e),
            !0))).catch((t => {
                console.warn(t)
            }
            ))
        }
        async setUpHTML(t) {
            const {buttonContent: e} = t.config.info
              , i = document.getElementsByClassName("buttons-block");
            e.forEach(( (t, e) => {
                const {id: s, iconSrc: n, label: o} = t
                  , a = document.createElement("button");
                i[0].appendChild(a),
                a.classList.add("clickable"),
                a.classList.add("custom-button"),
                a.classList.add(`${s}`),
                0 === e && a.classList.add("focused");
                const r = document.createElement("img");
                a.appendChild(r),
                r.classList.add("button-icon"),
                r.src = n;
                const l = document.createTextNode(o);
                a.appendChild(l),
                a.onclick = this.buttonClick
            }
            ))
        }
        buttonClick = async t => {
            const {buttonContent: e} = this._options.config.info
              , i = this._app.getManager("time")
              , s = Object.values(e).find((e => t.target.classList.contains(e.id)));
            document.querySelectorAll(".custom-button").forEach((t => t.classList.remove("focused"))),
            s.timeLimits ? (i.setMin(s.timeLimits.min),
            i.setMax(s.timeLimits.max)) : i.resetLimits();
            const {_id: n} = this._app.getComponent("story")
              , o = this._app.getManager("content").getStory(n).slides[0].time;
            i.setTime(s.startTime ?? o),
            i.setTimeRate(300),
            t.target.classList.add("focused"),
            s.onClick(this._app)
        }
    }
    ButtonsBlock.html = o()
}
, function(t) {
    t.exports = '<div class="buttons-block">\n\t<div class="block-title">{$blockTitle}</div>\n</div>\n'
}
, function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        CheckboxBlock: function() {
            return CheckboxBlock
        }
    });
    var s = i(2)
      , n = i(529)
      , o = i.n(n);
    i(530);
    class CheckboxBlock extends s.StoryBaseContentBlock {
        constructor(t, e={}) {
            super(t, {
                ...e
            });
            t.pioneer.getScene("main").getLoadedPromise().then(( () => (this.setUpHTML(e),
            !0))).catch((t => {
                console.warn(t)
            }
            )),
            this.options = e
        }
        async setUpHTML(t) {
            const {checkboxContent: e} = t.config.info
              , i = document.getElementsByClassName("checkboxes-block")[0];
            e.forEach((t => {
                const {id: e, label: s, onChange: n} = t
                  , o = document.createElement("label");
                o.classList.add("cb-container"),
                o.classList.add("clickable");
                const a = document.createElement("input");
                a.type = "checkbox",
                a.checked = !0,
                a.id = `${e}-checkbox`;
                const r = document.createElement("span");
                r.classList.add("checkmark"),
                o.appendChild(document.createTextNode(s)),
                o.appendChild(a),
                o.appendChild(r),
                i.appendChild(o),
                a.addEventListener("change", (t => {
                    n(t, this._app)
                }
                ))
            }
            ))
        }
        setChecked(t, e) {
            const i = document.getElementById(`${t}-checkbox`);
            i && (i.checked = e)
        }
    }
    CheckboxBlock.html = o()
}
, function(t) {
    t.exports = '<div class="checkboxes-block">\n\t<div class="cb-block-title">{$checkboxBlockTitle}</div>\n</div>\n'
}
, function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        Story: function() {
            return Story
        }
    });
    var s = i(2);
    i(532);
    class Story extends s.Carousel {
        constructor(t, e) {
            super(t, null, {
                isCloseButtonVisible: !0,
                closeButtonText: "Close",
                ...e
            }),
            this._id = "",
            this._info = [],
            this._blocks = {},
            this._config.navigationButtons.next.text = s.AppUtils.isPrimaryTouch() ? "Swipe to continue" : "Scroll to continue",
            this._onSlideChange = async (t, e=!1) => {
                const i = {
                    slide: this._children.slides[t].dataset.id
                };
                e ? i.time = this._app.getManager("time").getTimeUrl() : i.__remove = ["time"];
                const s = this._app.getManager("router")
                  , n = s.currentRoute;
                await s.navigate(i, n.url)
            }
        }
        init() {
            super.init();
            this._element.querySelector(".close-button")?.setAttribute("aria-label", "Close story"),
            this._setVariables(this._children.carousel, !1)
        }
        _setExpandToggleAriaLabel() {
            const t = this._element.querySelectorAll(".mobile-collapse")
              , e = this._state.isCollapsed ? "Collapse story panel" : "Expand story panel";
            t.forEach((t => t.setAttribute("aria-label", e)))
        }
        _toggleCollapse() {
            this._setExpandToggleAriaLabel(),
            super._toggleCollapse()
        }
        async onRouteChange(t, {cancelToken: e, slide: i, id: s}={}) {
            if (e && e.isCanceled)
                return;
            if (this.clear(),
            this._info = t,
            this._id = s,
            this._app.getManager("router").configs.locked) {
                const t = !1;
                this.setState({
                    isCloseButtonVisible: t,
                    isCloseButtonVisibleClass: this._class.isVisible[t]
                })
            }
            await this.setUp(),
            this._setExpandToggleAriaLabel();
            const n = i && this._children.slides.findIndex((t => t.dataset.id === i)) || 0;
            void 0 !== t[n]?.rate && this._app.getManager("time").setTimeRate(t[n].rate),
            await this.goToSlide(n)
        }
        async onQueryChange({cancelToken: t, slide: e}={}) {
            if (t && t.isCanceled)
                return;
            const i = e && this._children.slides.findIndex((t => t.dataset.id === e)) || 0;
            void 0 !== this._info[i]?.rate && this._app.getManager("time").setTimeRate(this._info[i].rate),
            await this.goToSlide(i)
        }
        async createBlockContent(t, e) {
            const {hideExternalLinks: i} = this.app.getManager("router").configs;
            let n;
            switch (t.type) {
            case "title":
                {
                    const e = {
                        ...t
                    };
                    e.title = !0 === i ? this.app.getManager("content").hideExternalLinksInText(e.title) : e.title,
                    n = new s.TitleBlock(this._app,{
                        config: {
                            info: e
                        }
                    });
                    break
                }
            case "description":
                {
                    const e = {
                        ...t
                    };
                    e.description = !0 === i ? this.app.getManager("content").hideExternalLinksInText(e.description) : e.description,
                    n = new s.DescriptionBlock(this._app,{
                        config: {
                            info: e
                        }
                    });
                    break
                }
            case "image":
            case "diagram":
                n = new s.ImageBlock(this._app,{
                    config: {
                        info: t
                    }
                });
                break;
            case "toggle":
                n = new s.ToggleBlock(this._app,{
                    config: {
                        info: t
                    }
                });
                break;
            case "hint":
                n = new s.HintBlock(this._app,{
                    config: {
                        info: t
                    }
                });
                break;
            case "replay":
                n = new s.ReplayButtonBlock(this._app,{
                    config: {
                        info: t
                    }
                });
                break;
            case "buttons":
                n = new s.ButtonsBlock(this._app,{
                    config: {
                        info: t
                    }
                });
                break;
            case "checkboxes":
                n = new s.CheckboxBlock(this._app,{
                    config: {
                        info: t
                    }
                })
            }
            return await n.init(),
            this._onEnter[e].push(n.onEnter),
            this._onLeave[e].push(n.onLeave),
            this._blocks[t.type] = n,
            n.element
        }
        getStoryBlock(t) {
            return this._blocks[t] || console.warn(`Block ${t} is not available`)
        }
        async createSlideContent(t, e) {
            if (!t.htmlFile) {
                const i = document.createDocumentFragment();
                for (let s = 0; s < t.content.length; s++) {
                    const n = t.content[s]
                      , o = await this.createBlockContent(n, e);
                    o && i.appendChild(o)
                }
                return i
            }
        }
        async setUp() {
            for (let t = 0; t < this._info.length; t++) {
                const {id: e, type: i, classList: s=[], onEnter: n, onLeave: o} = this._info[t];
                this._onEnter[t] = [],
                this._onLeave[t] = [],
                n && this._onEnter[t].push(( () => n(this._app, this)));
                const a = await this.createSlideContent(this._info[t], t);
                s.push("grid-layout", "simple-grid"),
                o && this._onLeave[t].push(( () => o(this._app, this))),
                this.addSlide({
                    id: e,
                    type: i,
                    classList: s,
                    content: a
                }, {
                    isFirst: 0 === t,
                    isLast: t === this._info.length - 1
                })
            }
        }
        close() {
            const t = this._app.getManager("router");
            t.navigate(t.homeRoute)
        }
        async onLeave(t) {
            if (await super.onLeave(t),
            "number" != typeof t) {
                this._app.getManager("router").removeQuery(["slide"])
            }
        }
        _updateTooltipsProps() {
            const {slideType: t} = this._state
              , e = getComputedStyle(document.body)
              , i = -(parseFloat(e.getPropertyValue("--gridHeaderHeight")) + 20);
            null !== this._progressTooltip && this._progressTooltip.setProps({
                offset: "overlay" === t ? [0, i] : [0, 10]
            })
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        KioskBase: function() {
            return KioskBase
        }
    });
    var s = i(2)
      , n = i(5)
      , o = i(534)
      , a = i.n(o);
    i(535);
    class KioskBase extends s.BaseComponent {
        static screenLastClicked = Math.ceil(n.TimeUtils.now());
        constructor(t, e={}) {
            super(t, null, {
                isVisible: !1,
                loadingTextVisibleClass: "hidden",
                sessionEndVisibleClass: "hidden",
                autoplayVisibleClass: "hidden",
                sessionTimerVisibleClass: "hidden",
                continueButtonVisibleClass: "",
                forceRestartClass: "",
                ...e
            }),
            this._router = this.app.getManager("router"),
            this.inactivityInterval = null,
            this.sessionInterval = null,
            this.timeOfDaySessionStarted = Math.ceil(n.TimeUtils.now()),
            this.componentDefaultVisibility = {
                menu: !1,
                shareModal: !1,
                infoPanel: !1,
                layerPanel: !1,
                featuredStoriesPanel: !0,
                timecontrolsCollapsible: !0
            }
        }
        init() {
            super.init();
            this.app.pioneer.getScene("main").getLoadedPromise().then(( () => {
                this.resetLastClicked(),
                this.validateQueries();
                const {maxSessionTime: t, maxInactivityTime: e, forceRestart: i} = this._router.configs;
                return this._isValidTime(t) && (this.maxSessionTime = s.AppUtils.minToSec(t),
                this.setUpSessionTimerComponent(),
                this.startSessionTimer(),
                !0 === i && this.setState({
                    continueButtonVisibleClass: "hidden",
                    forceRestartClass: "force-restart"
                })),
                this._isValidTime(e) && !this.inactivityInterval && (this.maxInactivityTime = s.AppUtils.minToSec(e),
                this.startInactivityTimer()),
                !0
            }
            )).catch((t => {
                console.warn(t)
            }
            ))
        }
        validateQueries() {
            const {maxSessionTime: t, maxInactivityTime: e} = this._router.configs
              , i = {};
            for (const [t,e] of Object.entries(this._router.configs))
                e && (i[t] = e);
            for (const t in i)
                t.toLowerCase().includes("time") && !this._isValidTime(i[t]) && delete i[t];
            const {maxSessionTime: s, maxInactivityTime: n} = i;
            this._isValidTime(s) && this._isValidTime(n) && (Math.abs(t - e) <= .05 && t > 0 && e > 0 ? i.maxInactivityTime = t + .1 : t >= e && (0 === e ? delete i.maxSessionTime : i.maxInactivityTime = t + 1)),
            this._router.setConfig("maxSessionTime", i.maxSessionTime),
            this._router.setConfig("maxInactivityTime", i.maxInactivityTime)
        }
        _isValidTime(t) {
            return "" !== t && !isNaN(Number(t)) && Number(t) > -1
        }
        setEnabled(t) {
            super.setEnabled(t);
            const {kiosk: e, maxSessionTime: i, maxInactivityTime: s} = this._router.configs;
            t && (e || this._isValidTime(i) || this._isValidTime(s)) && this.show()
        }
        resetLastClicked() {
            KioskBase.screenLastClicked = Math.ceil(n.TimeUtils.now())
        }
        async sessionStartOverButtonClick() {
            this.setState({
                loadingTextVisibleClass: ""
            }),
            await this.resetApp(),
            this.app.getManager("camera").waitForTransitionComplete().then(( () => (this.setState({
                loadingTextVisibleClass: "hidden"
            }),
            null))).catch((t => {
                console.warn("error: ", t)
            }
            ))
        }
        async onWindowInteract() {
            const {maxSessionTime: t, maxInactivityTime: e, forceRestart: i} = this._router.configs
              , {kioskAutoplay: s, kioskSessionEnd: n} = this._children
              , o = !this.isHidden(s)
              , a = !this.isHidden(n);
            this.setState({
                autoplayVisibleClass: "hidden"
            }),
            this.setState({
                sessionEndVisibleClass: "hidden"
            }),
            !o && !a || i || this.setState({
                loadingTextVisibleClass: ""
            }),
            clearInterval(this.inactivityInterval),
            this.inactivityInterval = null,
            o && (await this.app.getManager("camera").waitForTransitionComplete(),
            await this.resetApp()),
            this.app.getManager("camera").waitForTransitionComplete().then(( () => (this.setState({
                loadingTextVisibleClass: "hidden"
            }),
            null))).catch((t => {
                console.warn("error: ", t)
            }
            )),
            this.setState({
                sessionEndVisibleClass: "hidden"
            }),
            this.resetLastClicked(),
            this._isValidTime(t) && (o || a) && this.resetSessionTimer(),
            this._isValidTime(e) && this.startInactivityTimer()
        }
        setUpSessionTimerComponent() {
            const t = this.app.getComponent("kioskSessionClock")
              , {kioskSessionTimer: e} = this._children;
            t.setState({
                isKioskSessionTimer: !0
            }),
            t.show(),
            t.setEnabled(!0),
            t.setParent(e),
            this.updateSessionTimerComponent()
        }
        startSessionTimer() {
            this.timeOfDaySessionStarted = Math.ceil(n.TimeUtils.now()),
            clearInterval(this.sessionInterval),
            this.sessionInterval = setInterval(( () => {
                this.handleSessionTimer()
            }
            ), 1e3)
        }
        handleSessionTimer() {
            const {kioskAutoplay: t} = this._children
              , e = !this.isHidden(t)
              , i = Math.ceil(n.TimeUtils.now());
            this.timeElapsed = i - this.timeOfDaySessionStarted,
            this.setState({
                sessionTimerVisibleClass: ""
            }),
            this.timeElapsed < this.maxSessionTime ? this.updateSessionTimerComponent() : e || this.endSession()
        }
        async endSession() {
            const {forceRestart: t} = this._router.configs
              , {kioskSessionEnd: e} = this._children;
            clearInterval(this.sessionInterval),
            this.sessionInterval = null,
            this.setState({
                sessionTimerVisibleClass: "hidden"
            }),
            this.isHidden(e) && this.setState({
                sessionEndVisibleClass: ""
            }),
            !0 === t ? await this.resetApp() : this.resetComponents(this.componentDefaultVisibility)
        }
        resetSessionTimer() {
            this.timeElapsed = 0,
            this.setUpSessionTimerComponent(),
            this.startSessionTimer(),
            this.setState({
                sessionEndVisibleClass: "hidden"
            }),
            this.setState({
                sessionTimerVisibleClass: ""
            })
        }
        updateSessionTimerComponent() {
            const t = this.app.getComponent("kioskSessionClock")
              , e = s.AppUtils.formatCountdownTime(1e3 * this.maxSessionTime, 1e3 * (this.maxSessionTime - this.timeElapsed));
            t.update(e, !0)
        }
        startInactivityTimer() {
            clearInterval(this.inactivityInterval),
            this.inactivityInterval = setInterval((async () => {
                await this.handleMaxInactivityTime()
            }
            ), 1e3)
        }
        async handleMaxInactivityTime() {
            this.currentTimeWithoutActivity = Math.ceil(n.TimeUtils.now()) - KioskBase.screenLastClicked
        }
        async startAutoplay() {
            this.setState({
                sessionTimerVisibleClass: "hidden"
            }),
            this.setState({
                sessionEndVisibleClass: "hidden"
            }),
            this.setState({
                autoplayVisibleClass: ""
            }),
            await this.resetApp(),
            clearInterval(this.inactivityInterval),
            this.inactivityInterval = null
        }
        resetLayers(t) {
            if (t)
                for (const e of Object.keys(t)) {
                    const {defaultVisibility: t} = this.app.getManager("layer").getLayer(e);
                    this.app.getManager("layer").toggleLayer(e, {}, t)
                }
        }
        resetComponents(t) {
            if (t)
                for (const [e,i] of Object.entries(t)) {
                    const t = this.app.getComponent(e);
                    i ? t?.show() : t?.hide(),
                    this.app.getComponent(e)?.setExpanded?.(i)
                }
        }
        async resetApp() {
            const t = this.app.getComponent("layerPanel").getCategoriesDisplay()
              , {currentView: e} = this._router
              , i = this.app.getManager("camera").getContext().context === s.CameraScripts.CONTEXT.SYSTEM && "sun" === this.app.getManager("camera").getContext().id
              , n = this.app.getManager("camera").getIsTransitioning();
            this.resetLayers(t),
            this.resetComponents(this.componentDefaultVisibility),
            "/home" === !this._router.url ? this._router.navigate("/home") : n || i || (await this.app.cameraScripts.goToSystem("inner_solar_system"),
            "story" === e && this.app.getComponent("story")?.close()),
            this.app.getManager("camera").waitForTransitionComplete().then(( () => {
                this.app.getComponent("clock").backToLive(),
                this.app.getManager("layer").toggleLayer("planets", {}, !0)
            }
            )).catch((t => {
                console.warn("error: ", t)
            }
            ))
        }
        isHidden(t) {
            return t?.classList.contains("hidden")
        }
    }
    KioskBase.html = a()
}
, function(t) {
    t.exports = '<div key="kioskContainer" class=\'kiosk-container {{isVisibleClass}}\' onclick="onWindowInteract" ontouchstart="onWindowInteract">\n\t<div key="kioskLoadingText" class=\'loading-text {{loadingTextVisibleClass}}\'>\n\t\tStarting experience...\n\t</div>\n\t<div key="kioskSessionEnd" class="session-end-container {{sessionEndVisibleClass}}">\n\t\t<div key="sessionEndButtons" class="session-end-buttons-container">\n\t\t\t<div class="session-ended-msg">\n\t\t\t\tThis session has ended\n\t\t\t</div>\n\t\t\t<div key="kioskStartOverBtn" class=\'kiosk-btn session-end-btn {{forceRestartClass}}\' onclick="sessionStartOverButtonClick" ontouchstart="sessionStartOverButtonClick">\n\t\t\t\tSTART OVER\n\t\t\t</div>\n\t\t\t<div key="kioskContinueBtn" class=\'kiosk-btn session-end-btn {{continueButtonVisibleClass}}\'>\n\t\t\t\tCONTINUE\n\t\t\t</div>\n\t\t</div>\n\t</div>\n\t<div key="kioskAutoplay" class="autoplay-container {{autoplayVisibleClass}}">\n\t\t<div class=\'kiosk-btn touch-to-start-btn\'>\n\t\t\tTOUCH TO START\n\t\t</div>\n\t</div>\n\t<div key="kioskSessionTimer" class="session-timer-container {{sessionTimerVisibleClass}}">\n\t\t<div class="session-countdown-timer">Time left: </div>\n\t\t<Clock id="kioskSessionClock" class="session-countdown-timer {{isKioskCountdownClass}}"></Clock>\n\t</div>\n</div>\n'
}
, function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        Toast: function() {
            return Toast
        }
    });
    var s = i(2)
      , n = i(537)
      , o = i.n(n);
    i(538);
    class Toast extends s.BaseComponent {
        constructor(t, e={}) {
            super(t, null, {
                isVisible: !1,
                iconClass: "icon-locked",
                toastContent: "TOAST!",
                hideDelay: 2e3,
                errorClass: "",
                ...e
            }),
            this._hideTimeout = null
        }
        setIcon(t) {
            this.setState({
                iconClass: t
            })
        }
        setContent(t) {
            this.setState({
                toastContent: t
            })
        }
        setError(t) {
            this.setIcon(t ? "icon-error" : "icon-locked"),
            this.setState({
                errorClass: t ? "error" : ""
            })
        }
        show() {
            super.show();
            const {hideDelay: t} = this._state;
            t && (clearTimeout(this._hideTimeout),
            this._hideTimeout = setTimeout(( () => {
                this.hide()
            }
            ), t))
        }
        hide() {
            super.hide(),
            this.setState({
                errorClass: ""
            }),
            clearTimeout(this._hideTimeout)
        }
    }
    Toast.html = o()
}
, function(t) {
    t.exports = '<div class="toast-container {{isVisibleClass}} {{errorClass}}" role="alert" aria-live="polite" aria-atomic="true">\n\t<span class="icon {{iconClass}}" aria-hidden="true"></span>\n\t<div key="toastContent" class="toast-content">{{toastContent}}</div>\n\t<button type="button" class="close clickable icon icon-close" data-dismiss="toast" aria-label="Close alert" onclick="hide"></button>\n</div>\n'
}
, function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        BaseManager: function() {
            return BaseManager
        }
    });
    i(5),
    i(2);
    class BaseManager {
        constructor(t) {
            this._app = t,
            this._pioneer = t.pioneer,
            this._eventNames = [],
            this._callbacks = {}
        }
        get pioneer() {
            return this._pioneer
        }
        get app() {
            return this._app
        }
        _initCallbacks() {
            for (let t = 0; t < this._eventNames.length; t++)
                this._callbacks[this._eventNames[t]] = []
        }
        registerCallback(t, e) {
            "function" != typeof e || this._eventNames.indexOf(t) < 0 || this._callbacks[t].includes(e) || this._callbacks[t].push(e)
        }
        removeCallback(t, e) {
            if ("function" != typeof e || this._eventNames.indexOf(t) < 0)
                return;
            const i = this._callbacks[t].indexOf(e);
            i > -1 && this._callbacks[t].splice(i, 1)
        }
        triggerCallbacks(t, e=[]) {
            for (let i = this._callbacks[t].length - 1; i >= 0; i--) {
                (0,
                this._callbacks[t][i])(...e)
            }
        }
        bindFunctions(t=[]) {
            const e = this;
            for (let i = 0; i < t.length; i++) {
                const s = t[i];
                e[s] = e[s].bind(this)
            }
        }
        destroy() {
            this.__destroy()
        }
        __destroy() {}
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        SelectionManager: function() {
            return SelectionManager
        }
    });
    var s = i(5)
      , n = i(2);
    class SelectionManager extends n.BaseManager {
        constructor(t, e) {
            super(t),
            this._scene = e,
            this._id = null,
            this._isClickable = !0,
            this._isSuppressed = !1,
            this._eventNames.push("3dselection"),
            this._initCallbacks(),
            this.bindFunctions(["setSuppress", "handle3DSelection"])
        }
        setScene(t) {
            this._scene = t
        }
        selectEntity(t) {
            const e = this._id;
            if (t !== e) {
                const i = new CustomEvent("selectionupdate",{
                    detail: {
                        new: t,
                        old: this._id
                    }
                });
                window.dispatchEvent(i),
                this._id = t,
                this._switchSelectionClass(this._id, e)
            }
        }
        unselect() {
            const t = this._id;
            if (null !== t) {
                const t = new CustomEvent("unselect",{
                    old: this._id
                });
                window.dispatchEvent(t)
            }
            this._id = null,
            this._switchSelectionClass(this._id, t)
        }
        getCurrentId() {
            return this._id
        }
        setClickable(t) {
            this._isClickable = t
        }
        init3Dcallback(t) {
            t.setSelectionCallback(this.handle3DSelection)
        }
        _getLink(t) {
            return `/${t}`
        }
        setSuppress(t) {
            this._isSuppressed = t
        }
        handle3DSelection(t) {
            if (this._isClickable) {
                if (!this._isSuppressed && null !== t) {
                    const e = this._app.getManager("router")
                      , i = t.getName()
                      , s = this._getLink(i)
                      , n = "string" == typeof s ? s : s.path ?? ""
                      , {options: o={
                        keepTime: !0
                    }, query: a={}} = "object" == typeof s && s
                      , r = e.navigate(a, n, o);
                    this.triggerCallbacks("3dselection", [r, t])
                }
                this._isSuppressed = !1
            }
        }
        _switchSelectionClass(t, e) {
            if (null !== e) {
                const t = this._scene.getEntity(e);
                if (null !== t) {
                    const e = t.getComponent(s.DivComponent).getDiv();
                    e && e.classList.remove("selection")
                }
            }
            if (null !== t) {
                const e = this._scene.getEntity(t);
                if (null !== e) {
                    const t = e.getComponent(s.DivComponent).getDiv();
                    t && t.classList.add("selection")
                }
            }
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        LabelManager: function() {
            return LabelManager
        }
    });
    var s = i(5)
      , n = i(542)
      , o = i(2);
    class LabelManager extends o.BaseManager {
        constructor(t, e, i) {
            super(t),
            this._scene = e,
            this._eventNames.push("hoverchange", "labelclicked"),
            this._initCallbacks(),
            this._viewport = i,
            this._labelQuadtree = new n.LabelQuadtree(i),
            this._focusRect = new s.Rect,
            this._focusSize = .05,
            this._focusIntersectionRects = new s.FastMap,
            this._iconMap = {
                Universe: "no-icon",
                Galaxy: "no-icon",
                Star: "no-icon",
                Barycenter: "icon-circle-white-small",
                "Landing site": "icon-hexagon",
                Moon: "icon-circle-white-small",
                Asteroid: "icon-circle-white-small",
                "Dwarf Planet": "icon-circle-white-small",
                Comet: "icon-circle-white-small",
                Spacecraft: "icon-hexagon",
                Planet: "icon-circle-",
                Default: "icon-circle-white-small"
            },
            this._weightMap = {
                Universe: "100",
                Galaxy: "100",
                Star: "100",
                Barycenter: "0",
                "Landing site": "5",
                Asteroid: "15",
                Comet: "15",
                Moon: "25",
                "Dwarf Planet": "28",
                Spacecraft: "30",
                Planet: "50",
                Constellation: "10"
            },
            this._weights = {},
            this._labels = {},
            this._isClickable = !0,
            this._exceptions = new Set,
            this.bindFunctions(["update", "addLabel", "removeLabel", "toggleLabels", "toggleLabelForEntity", "toggleIcons", "toggleIconForEntity", "_clickCallback", "setUpLabel", "setUpIcon"])
        }
        update() {
            const t = this._viewport.getBounds().size
              , e = Math.max(t.x, t.y) * this._focusSize;
            this._focusRect.set((t.x - e) / 2, (t.y - e) / 2, e, e),
            this._labelQuadtree.setBounds("__focus", this._focusRect),
            this._labelQuadtree.update()
        }
        initLabelWeights(t, e=!0) {
            e && (this._weights = {});
            const i = this._app.getManager("label");
            for (const s of Object.keys(t)) {
                const n = t[s].category;
                this._weights[s] = {},
                void 0 !== this._weightMap[n] ? this._weights[s].weight = this._weightMap[n] : this._weights[s].weight = 1,
                e && i._labels[s] && i.setWeight(s, this._weights[s].weight)
            }
        }
        setWeight(t, e) {
            try {
                return this._labelQuadtree.setWeight(t, e),
                !0
            } catch (t) {
                return !1
            }
        }
        resetWeight(t) {
            const e = this._app.getManager("content")?.getEntityInfo(t)?.category
              , i = this.getDefaultWeight(t, e);
            this._labelQuadtree.setWeight(t, i)
        }
        getDefaultWeight(t, e) {
            return t.startsWith("constellation_") ? this._weightMap.Constellation : Object.keys(this._weights).length > 0 && void 0 !== this._weights[t] ? this._weights[t].weight : void 0 !== this._weightMap[e] ? this._weightMap[e] : 0
        }
        getWeightMap() {
            return this._weightMap
        }
        setWeightMap(t) {
            this._weightMap = t
        }
        setUpLabel(t) {
            const e = this._app.getManager("content")
              , i = this._app.getManager("layer")
              , s = e.getEntityInfo(t.getName())?.category
              , n = this.getDefaultWeight(t.getName(), s);
            this.addLabel(t, n),
            this.setLabelProps({
                getLabelClass: t => `no-select ${e.getClassName(t) ?? ""}`
            }, [t.getName()]);
            const o = t.getName()
              , a = i.getLayer("labels");
            null === a || a.visible || this.toggleLabelForEntity(!1, o)
        }
        addLabel(t, e) {
            t.getComponent(s.DivComponent) && (this._labels[t.getName()] = {
                name: t.getName(),
                el: t.getComponent(s.DivComponent).getDiv(),
                isClickable: !0
            },
            this._labelQuadtree.addEntity(t, e))
        }
        removeLabel(t) {
            t.getComponent(s.DivComponent) && (delete this._labels[t.getName()],
            this._labelQuadtree.removeEntity(t.getName()))
        }
        setUpIcon(t) {
            const e = this._app.getManager("layer")
              , i = t.getName()
              , s = e.getLayer("icons");
            null === s || s.visible || this.toggleIconForEntity(!1, i)
        }
        setLabelClickable(t, e) {
            this._labels[t] && (this._labels[t].isClickable = e,
            this._labels[t].el.classList.toggle("clickable", e))
        }
        setClickable(t) {
            this._isClickable = t;
            for (let e = 0, i = this._scene.getNumEntities(); e < i; e++) {
                const i = this._scene.getEntityAt(e).getComponent(s.DivComponent);
                if (null !== i) {
                    const e = i.getDiv();
                    t ? e.classList.remove("unclickable") : e.classList.add("unclickable")
                }
            }
        }
        addException(t) {
            this._exceptions.add(t)
        }
        removeException(t) {
            this._exceptions.delete(t)
        }
        addExceptions(t) {
            t.forEach((t => this._exceptions.add(t)))
        }
        removeExceptions(t) {
            t.forEach((t => this._exceptions.delete(t)))
        }
        toggleLabels(t, {scene: e}={}) {
            void 0 === e && (e = this._scene);
            for (let i = 0; i < e.getNumEntities(); i++)
                this.toggleLabelForEntity(t, e.getEntityAt(i).getName(), {
                    scene: e
                })
        }
        toggleLabelForEntity(t, e, {scene: i}={}) {
            let n = i;
            void 0 === n && (n = this._scene);
            const o = n.getEntity(e)
              , a = o.getComponent(s.DivComponent);
            this._exceptions.has(o.getName()) || null !== a && (t ? a.getDiv().lastElementChild?.classList.remove("hidden") : a.getDiv().lastElementChild?.classList.add("hidden"))
        }
        toggleIcons(t, {scene: e}={}) {
            void 0 === e && (e = this._scene);
            for (let i = 0; i < e.getNumEntities(); i++)
                this.toggleIconForEntity(t, e.getEntityAt(i).getName(), {
                    scene: e
                })
        }
        toggleIconForEntity(t, e, {scene: i}={}) {
            let n = i;
            void 0 === n && (n = this._scene);
            const o = n.getEntity(e)
              , a = o.getComponent(s.DivComponent);
            this._exceptions.has(o.getName()) || null !== a && (t ? a.getDiv().firstElementChild?.classList.remove("hidden") : a.getDiv().firstElementChild?.classList.add("hidden"))
        }
        _getLink(t) {
            return `/${t}`
        }
        _clickCallback(t) {
            const e = this._app.getManager("router")
              , i = this._getLink(t.getName())
              , s = "string" == typeof i ? i : i.path ?? ""
              , {options: n={
                keepTime: !0
            }, query: o={}} = "object" == typeof i && i;
            e.navigate(o, s, n)
        }
        setLabelProps({getLabelClass: t, getIconClass: e, getTextClass: i, handleClick: n, handleTouch: o, handleMouseEnter: a, handleMouseLeave: r}={}, l=Object.keys(this._labels), c, h) {
            let d = c;
            d || (d = this._scene);
            let u = h;
            u || (u = d.getEntity("camera"));
            const p = u.getComponent(s.CameraComponent);
            for (const c of l) {
                const l = d.getEntity(c)
                  , h = this._app.getManager("content").getEntityInfo(c)
                  , u = l.getComponent(s.DivComponent);
                if (null === u)
                    continue;
                u.setActiveCamera(p);
                const m = u.getDiv()
                  , _ = "function" == typeof t ? t(c) : "";
                m.className += ` ${_} clickable`;
                const g = document.createElement("span")
                  , y = document.createElement("span")
                  , f = this._iconMap[h?.category] ?? this._iconMap.Default
                  , b = "Planet" === h?.category ? c : ""
                  , T = "function" == typeof e ? e(c) : "";
                g.className = `icon ${f}${b} ${T}`,
                y.className = `text ${"function" == typeof i ? i(c) : ""}`,
                y.innerHTML = h?.displayName || h?.iauName || m.innerHTML,
                m.innerHTML = "",
                m.appendChild(g),
                m.appendChild(y);
                const v = async t => {
                    const e = this._labels[c];
                    this._isClickable && e?.isClickable && null !== this._clickCallback && (this._clickCallback(l),
                    t.preventDefault(),
                    this.triggerCallbacks("labelclicked", [!0]))
                }
                  , S = async t => {
                    const e = this._labels[c];
                    this._isClickable && e?.isClickable && (this.app.isDragging() || this.app.isTouchMax() || null === this._clickCallback || (this._clickCallback(l),
                    t.preventDefault(),
                    this.triggerCallbacks("labelclicked", [!0])))
                }
                ;
                m.addEventListener("mousedown", (t => {
                    t.preventDefault(),
                    this.triggerCallbacks("labelclicked", [!1])
                }
                )),
                m.addEventListener("touchstart", (t => {
                    t.preventDefault(),
                    this.triggerCallbacks("labelclicked", [!1])
                }
                ));
                const E = () => this.triggerCallbacks("hoverchange", [c, !0])
                  , C = () => this.triggerCallbacks("hoverchange", [c, !1])
                  , x = "function" == typeof n ? t => n(t, c) : v
                  , w = "function" == typeof o ? t => o(t, c) : S
                  , I = "function" == typeof a ? t => a(t, c) : E
                  , M = "function" == typeof r ? t => r(t, c) : C;
                null !== n && "true" !== m.getAttribute("hasClickListener") && (m.setAttribute("hasClickListener", "true"),
                m.addEventListener("click", x)),
                null !== o && "true" !== m.getAttribute("hasTouchEndListener") && (m.setAttribute("hasTouchEndListener", "true"),
                m.addEventListener("touchend", w)),
                null !== a && "true" !== m.getAttribute("hasMouseEnterListener") && (m.setAttribute("hasMouseEnterListener", "true"),
                m.addEventListener("mouseenter", I)),
                null !== r && "true" !== m.getAttribute("hasMouseLeaveListener") && (m.setAttribute("hasMouseLeaveListener", "true"),
                m.addEventListener("mouseleave", M)),
                "true" !== m.getAttribute("hasMouseMoveListener") && (m.setAttribute("hasMouseMoveListener", "true"),
                m.addEventListener("mousemove", (t => {
                    t.preventDefault()
                }
                ), !0))
            }
        }
        addClassToLabels(t, e) {
            for (const i of e) {
                const e = this._scene.getEntity(i)?.getComponent(s.DivComponent)?.getDiv();
                e?.classList.add(t)
            }
        }
        removeClassFromLabels(t, e) {
            for (const i of e) {
                const e = this._scene.getEntity(i)?.getComponent(s.DivComponent)?.getDiv();
                e?.classList.remove(t)
            }
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        Cameras: function() {
            return s.Cameras
        },
        DateTime: function() {
            return n.DateTime
        },
        Entity: function() {
            return o.Entity
        },
        Features: function() {
            return a.Features
        },
        LabelQuadtree: function() {
            return r.LabelQuadtree
        },
        Mapping: function() {
            return l.Mapping
        },
        Parenting: function() {
            return c.Parenting
        },
        Placemarks: function() {
            return h.Placemarks
        },
        SceneHelpers: function() {
            return d.SceneHelpers
        },
        Transitions: function() {
            return u.Transitions
        },
        AnnulusComponent: function() {
            return p.AnnulusComponent
        },
        CelestialGridComponent: function() {
            return m.CelestialGridComponent
        },
        ConstellationsComponent: function() {
            return _.ConstellationsComponent
        },
        DiscGridComponent: function() {
            return g.DiscGridComponent
        },
        ShadowConeComponent: function() {
            return y.ShadowConeComponent
        },
        FrustumComponent: function() {
            return f.FrustumComponent
        },
        OrbitLineComponent: function() {
            return b.OrbitLineComponent
        },
        TorusComponent: function() {
            return T.TorusComponent
        },
        WMTSComponent: function() {
            return v.WMTSComponent
        },
        KeyframePointingController: function() {
            return S.KeyframePointingController
        },
        KeyframeSpinController: function() {
            return E.KeyframeSpinController
        },
        PositionSumController: function() {
            return C.PositionSumController
        },
        ZoomFitController: function() {
            return x.ZoomFitController
        }
    });
    var s = i(543)
      , n = i(544)
      , o = i(545)
      , a = i(546)
      , r = i(547)
      , l = i(549)
      , c = i(550)
      , h = i(551)
      , d = i(552)
      , u = i(553)
      , p = i(554)
      , m = i(555)
      , _ = i(556)
      , g = i(557)
      , y = i(558)
      , f = i(559)
      , b = i(560)
      , T = i(561)
      , v = i(562)
      , S = i(657)
      , E = i(658)
      , C = i(659)
      , x = i(660);
    i(661),
    i(662),
    i(663),
    i(664),
    i(666),
    i(667),
    i(668),
    i(669),
    i(670),
    i(671),
    i(672),
    i(673),
    i(674),
    i(675),
    i(676),
    i(677),
    i(678),
    i(679),
    i(680),
    i(682),
    i(683),
    i(684)
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        Cameras: function() {
            return Cameras
        }
    });
    var s = i(5);
    class Cameras {
        static createFullSizeViewportAndCamera(t, e="main", i="camera") {
            const n = t.getEngine().addViewport(e);
            n.getDiv().style.width = "100%",
            n.getDiv().style.height = "100%";
            const o = t.addEntity(i).addComponent(s.CameraComponent);
            n.setCamera(o)
        }
        static focusOnEntity(t, e, {up: i=!0, orbiter: n=!1}) {
            const o = t.addController(s.AlignController);
            o.setPrimaryAlignType("point"),
            o.setPrimaryAxis(s.Vector3.YAxis),
            o.setPrimaryTargetEntity(e.getName()),
            i && (n ? (o.setSecondaryAlignType("position"),
            o.setSecondaryAxis(s.Vector3.ZAxis),
            o.setSecondaryTargetEntity(e.getName())) : (o.setSecondaryAlignType("align"),
            o.setSecondaryAxis(s.Vector3.ZAxis),
            o.setSecondaryTargetEntity(e.getName()),
            o.setSecondaryTargetAxis(s.Vector3.ZAxis)))
        }
        static async lookAtEntity(t, e, {duration: i=.5, finalUp: n, finalUpRelativeEntity: o, finalUpPosition: a=!1}) {
            if (t.getPosition().isNaN())
                return;
            const r = new s.Vector3;
            e.getPositionRelativeToEntity(r, s.Vector3.Zero, t),
            r.normalize(r);
            for (let e = 0; e < t.getNumControllers(); e++) {
                const i = t.getControllerAt(e);
                i.hasModifiedState("orientation") && (t.removeController(i),
                e--)
            }
            const l = t.addController(s.AlignController);
            l.setPrimaryAlignType("point"),
            l.setPrimaryAxis(s.Vector3.YAxis),
            l.setPrimaryTargetEntity(e.getName()),
            void 0 !== n && (void 0 === o && (o = e),
            a ? (l.setSecondaryAlignType("position"),
            l.setSecondaryAxis(s.Vector3.ZAxis),
            l.setSecondaryTargetEntity(o.getName())) : (l.setSecondaryAlignType("align"),
            l.setSecondaryAxis(s.Vector3.ZAxis),
            l.setSecondaryTargetEntity(o.getName()),
            l.setSecondaryTargetAxis(n)));
            const c = t.addController(s.TransitionController);
            c.setTransitionTime(i),
            await c.getEndPromise()
        }
        static async goToEntity(t, e, {up: i=!0, orbiter: n=!1, fixedToParent: o=!1, duration: a=1, distance: r, zoom: l=!0, destination: c, destinationUp: h, destinationInFocusFrame: d=!1, transitionFunction: u}) {
            void 0 === r && (r = 5 * e.getExtentsRadius()),
            (t.getPosition().isNaN() || t.getOrientation().isNaN()) && (t.setParent(e),
            void 0 === c ? t.setPosition(new s.Vector3(0,-r,0)) : t.setPosition(c),
            t.setOrientation(s.Quaternion.Identity),
            a = 0),
            void 0 === c && (c = new s.Vector3,
            t.getPositionRelativeToEntity(c, s.Vector3.Zero, e),
            c.normalize(c),
            c.mult(c, r),
            c.isNaN() && c.set(0, -r, 0)),
            t.clearControllers();
            const p = t.addController(s.FixedController);
            if (p.setPosition(c),
            void 0 !== h) {
                const t = new s.Vector3
                  , e = new s.Vector3;
                t.neg(c),
                t.normalize(t),
                e.setNormalTo(t, h);
                const i = new s.Quaternion;
                i.setFromAxes(void 0, t, e),
                p.setOrientation(i)
            }
            if (d) {
                const e = t.addController(s.RotateByEntityOrientationController);
                void 0 === h && e.setRotatingOrientation(!1)
            }
            this.focusOnEntity(t, e, {
                up: i,
                orbiter: n
            });
            const m = t.addController(s.TransitionController);
            m.setTransitionTime(a),
            m.setParent(e.getName()),
            u && m.setTransitionFunction(u),
            await m.getEndPromise(),
            t.clearControllers();
            const _ = t.addController(s.OrbitController);
            i ? n ? _.setYawAxisType("position") : _.setYawAxisType("z-axis") : t.addController(s.RollController),
            o && t.addController(s.FixedToParentController),
            l && t.addController(s.ZoomController),
            this.focusOnEntity(t, e, {
                up: i,
                orbiter: n
            })
        }
        static pickOnEntity(t, e, i) {
            const n = t.addController(s.PickController);
            n.setPickedEntity(e),
            n.setCallback((t => {
                const n = e.getComponent(s.SpheroidComponent);
                if (null !== n) {
                    const o = s.Vector3.pool.get();
                    o.rotateInverse(e.getOrientation(), t);
                    const a = s.LatLonAlt.pool.get();
                    n.llaFromXYZ(a, o),
                    i(o, a),
                    s.LatLonAlt.pool.release(a),
                    s.Vector3.pool.release(o)
                }
            }
            ))
        }
        static getDistanceToFitEntities(t, e, i, n) {
            const o = t.getComponent(s.CameraComponent);
            if (null === o)
                return NaN;
            let a = 0;
            const r = s.Vector3.pool.get()
              , l = Math.sin(o.getHorizontalFieldOfView() / 2)
              , c = Math.sin(o.getVerticalFieldOfView() / 2)
              , h = Math.tan(o.getHorizontalFieldOfView() / 2)
              , d = Math.tan(o.getVerticalFieldOfView() / 2);
            for (let t = 0; t < n.length; t++) {
                const o = n[t];
                let u = 0;
                const p = o.getComponent(s.RingsComponent);
                null !== p && (u = p.getOuterRadius()),
                o.getPositionRelativeToEntity(r, s.Vector3.Zero, i),
                r.rotateInverse(e, r),
                a = Math.max(a, Math.abs(r.x) / h + Math.max(o.getExtentsRadius(), u) / l - r.y),
                a = Math.max(a, Math.abs(r.z) / d + Math.max(o.getExtentsRadius(), u) / c - r.y)
            }
            return s.Vector3.pool.release(r),
            a
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        DateTime: function() {
            return DateTime
        }
    });
    var s = i(5);
    class DateTime {
        constructor(t=1, e=1, i=1, s=0, n=0, o=0, a=0) {
            this.year = t,
            this.month = e,
            this.day = i,
            this.hour = s,
            this.minute = n,
            this.second = o,
            this.millisecond = a
        }
        copy(t) {
            this.year = t.year,
            this.month = t.month,
            this.day = t.day,
            this.hour = t.hour,
            this.minute = t.minute,
            this.second = t.second,
            this.millisecond = t.millisecond
        }
        fromET(t) {
            const e = s.TimeUtils.etToUnix(t);
            DateTime._date.setTime(1e3 * e),
            this.year = DateTime._date.getUTCFullYear(),
            this.month = DateTime._date.getUTCMonth() + 1,
            this.day = DateTime._date.getUTCDate(),
            this.hour = DateTime._date.getUTCHours(),
            this.minute = DateTime._date.getUTCMinutes(),
            this.second = DateTime._date.getUTCSeconds(),
            this.millisecond = DateTime._date.getUTCMilliseconds();
            for (let i = 0, n = s.TimeUtils.leapSeconds.length; i < n; i++)
                if (Math.floor(e) === s.TimeUtils.leapSeconds[i] && e === s.TimeUtils.etToUnix(t - 1)) {
                    this.second += 1;
                    break
                }
        }
        toET() {
            DateTime._date.setUTCFullYear(this.year),
            DateTime._date.setUTCMonth(this.month - 1),
            DateTime._date.setUTCDate(this.day),
            DateTime._date.setUTCHours(this.hour),
            DateTime._date.setUTCMinutes(this.minute),
            DateTime._date.setUTCSeconds(this.second),
            DateTime._date.setUTCMilliseconds(this.millisecond);
            const t = DateTime._date.getTime() / 1e3;
            let e = s.TimeUtils.unixToEt(t);
            if (60 === this.second)
                for (let i = 0, n = s.TimeUtils.leapSeconds.length; i < n; i++)
                    if (Math.floor(t) === s.TimeUtils.leapSeconds[i] + 1) {
                        e -= 1;
                        break
                    }
            return e
        }
        fromDOY(t, e, i=0, s=0, n=0, o=0) {
            let a = 0;
            this.year = t,
            this.month = 1,
            this.hour = i,
            this.minute = s,
            this.second = n,
            this.millisecond = o;
            let r = this.getDaysInMonth();
            for (; e > a + r && this.month < 12; )
                a += r,
                this.month += 1,
                r = this.getDaysInMonth();
            this.day = e - a
        }
        toDOY() {
            const t = this.month;
            let e = 0;
            for (this.month = 1; this.month < t; this.month++)
                e += this.getDaysInMonth();
            return this.month = t,
            e += this.day,
            e
        }
        isLeapYear() {
            return this.year % 4 == 0 && this.year % 100 != 0 || this.year % 400 == 0
        }
        getDaysInMonth() {
            let t = DateTime._daysInMonth[this.month - 1];
            return 2 === this.month && this.isLeapYear() && (t += 1),
            t
        }
        parse(t) {
            this.year = parseInt(t.substring(0, 4)),
            t.length > 5 ? this.month = parseInt(t.substring(5, 7)) : this.month = 1,
            t.length > 8 ? this.day = parseInt(t.substring(8, 10)) : this.day = 1,
            t.length > 11 ? (this.hour = parseInt(t.substring(11, 13)),
            this.minute = parseInt(t.substring(14, 16))) : (this.hour = 0,
            this.minute = 0),
            t.length > 17 ? this.second = parseInt(t.substring(17, 19)) : this.second = 0,
            t.length > 20 ? this.millisecond = parseInt(t.substring(20)) * 10 ** (23 - t.length) : this.millisecond = 0
        }
        parseDOY(t) {
            const e = parseInt(t.substring(0, 4));
            let i = 1;
            t.length > 5 && (i = parseInt(t.substring(5, 8))),
            this.fromDOY(e, i),
            t.length > 9 ? (this.hour = parseInt(t.substring(9, 11)),
            this.minute = parseInt(t.substring(12, 14))) : (this.hour = 0,
            this.minute = 0),
            t.length > 15 ? this.second = parseInt(t.substring(15, 17)) : this.second = 0,
            t.length > 18 ? this.millisecond = parseInt(t.substring(18)) * 10 ** (21 - t.length) : this.millisecond = 0
        }
        toString() {
            return `${this.year.toString().padStart(4, "0")}-${this.month.toString().padStart(2, "0")}-${this.day.toString().padStart(2, "0")} ${this.hour.toString().padStart(2, "0")}:${this.minute.toString().padStart(2, "0")}:${this.second.toString().padStart(2, "0")}.${Math.floor(1e3 * this.millisecond).toString().padStart(6, "0")}`
        }
        toStringDOY() {
            return `${this.year.toString().padStart(4, "0")}-${this.toDOY().toString().padStart(3, "0")}`
        }
        static _daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
        static _date = new Date
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        Entity: function() {
            return Entity
        }
    });
    var s = i(5);
    class Entity {
        static register(t) {
            for (const e in t)
                Object.hasOwn(t, e) && this._entities.set(e, t[e])
        }
        static create(t, e, i) {
            const s = Entity._entities.get(t);
            if (void 0 === s)
                throw new Error(`Could not find the options for the entity with name ${t}`);
            return this.createFromOptions(t, s, e, i)
        }
        static createFromOptions(t, e, i, n) {
            let o = t;
            n && (void 0 !== n.namePrefix && (o = n.namePrefix + o),
            void 0 !== n.nameSuffix && (o += n.nameSuffix));
            let a = i.getEntity(o);
            if (null !== a)
                return a;
            a = i.addEntity(o);
            try {
                void 0 !== e.radius && (a.setOcclusionRadius(e.radius),
                a.setExtentsRadius(e.radius)),
                void 0 !== e.occlusionRadius && a.setOcclusionRadius(e.occlusionRadius),
                void 0 !== e.extentsRadius && a.setExtentsRadius(e.extentsRadius);
                for (const [t,i] of e.parents)
                    a.addParentingTableEntry(t, i);
                if (void 0 !== e.label) {
                    const t = a.addComponent(s.DivComponent).getDiv();
                    t.innerHTML = e.label,
                    t.className = "pioneer-label-div"
                }
                if (void 0 !== e.labelFadeEntity) {
                    const t = a.getComponent(s.DivComponent);
                    if (null === t)
                        throw new Error("There is no label.");
                    t.setFadeWhenCloseToEntity(e.labelFadeEntity)
                }
                if (e.trail) {
                    const t = a.addComponent(s.TrailComponent, e.trail.name);
                    if (t.setStartTime(e.trail.length),
                    e.trail.color ? t.setColor(new s.Color(e.trail.color[0],e.trail.color[1],e.trail.color[2],e.trail.color[3])) : t.setColor(new s.Color(1,1,1,.5)),
                    void 0 !== e.trail.relativeTo ? t.setRelativeToEntity(e.trail.relativeTo) : void 0 !== e.trail.relativeToOrientation && t.setRelativeToEntityOrientation(e.trail.relativeToOrientation),
                    void 0 !== e.trail.updatePointPositions && t.setUpdatePointPositions(!0),
                    e.trail.lengthCoverages) {
                        const t = e.trail.length;
                        for (let i = 0, n = e.trail.lengthCoverages.length; i < n; i++) {
                            const n = e.trail.lengthCoverages[i]
                              , o = a.addController(s.CoverageController, `trail_length_coverage.${i}`, a.getControllerAt(0) ?? void 0);
                            o.setCoverage(new s.Interval(n[1],n[2])),
                            o.setEnterFunction((t => {
                                const e = t.getComponent(s.TrailComponent);
                                null !== e && e.setStartTime(n[0])
                            }
                            )),
                            o.setExitFunction((e => {
                                const i = e.getComponent(s.TrailComponent);
                                null !== i && i.setStartTime(t)
                            }
                            ))
                        }
                    }
                }
                if (e.spheroid) {
                    const t = a.addComponent(s.SpheroidComponent, e.spheroid.name);
                    t.setEquatorialRadius(e.spheroid.equatorialRadius),
                    t.setPolarRadius(e.spheroid.polarRadius),
                    t.setPlanetographic(e.spheroid.planetographic)
                }
                if (e.spheroidLOD) {
                    const t = a.addComponent(s.SpheroidLODComponent, e.spheroidLOD.name ?? "basic");
                    if (e.spheroidLOD.materialOptions)
                        for (let i = 0, s = e.spheroidLOD.materialOptions.length; i < s; i++)
                            t.setMaterialOption(e.spheroidLOD.materialOptions[i], !0);
                    if (e.spheroidLOD.textures) {
                        t.setMapping("cube");
                        for (const i of Object.keys(e.spheroidLOD.textures))
                            t.setTexture(i, `$STATIC_ASSETS_URL/maps/${e.spheroidLOD.textures[i].url}`, e.spheroidLOD.textures[i].sizes)
                    }
                    e.spheroidLOD.shadowEntities && t.setShadowEntities(e.spheroidLOD.shadowEntities)
                }
                if (e.cmts) {
                    const t = a.addComponent(s.CMTSComponent, e.cmts.name);
                    for (const i of Object.keys(e.cmts.textures)) {
                        const s = e.cmts.textures[i];
                        t.setBaseUrl(i, s)
                    }
                    t.setMaxLevel(e.cmts.maxLevel ?? 0),
                    e.cmts.shadowEntities && t.setShadowEntities(e.cmts.shadowEntities)
                }
                if (e.model) {
                    const t = a.addComponent(s.ModelComponent, e.model.name);
                    if (t.setUrl(e.model.url),
                    e.model.rotate) {
                        const i = new s.Quaternion;
                        i.set(1, 0, 0, 0);
                        for (let t = 0, n = e.model.rotate.length; t < n; t++) {
                            let n, o;
                            const a = e.model.rotate[t];
                            if (void 0 !== a.x)
                                n = new s.Vector3(1,0,0),
                                o = a.x;
                            else if (void 0 !== a.y)
                                n = new s.Vector3(0,1,0),
                                o = a.y;
                            else {
                                if (void 0 === a.z)
                                    throw new Error("Invalid model rotate axis.");
                                n = new s.Vector3(0,0,1),
                                o = a.z
                            }
                            o = s.MathUtils.degToRad(o);
                            const r = new s.Quaternion;
                            r.setFromAxisAngle(n, o),
                            i.mult(r, i)
                        }
                        t.setRotation(i)
                    }
                    if (void 0 !== e.model.scale) {
                        const i = e.model.scale;
                        Array.isArray(i) ? t.setScale(new s.Vector3(i[0],i[1],i[2])) : t.setScale(i)
                    }
                    e.model.translate && t.setTranslation(e.model.translate),
                    e.model.shadowEntities && t.setShadowEntities(e.model.shadowEntities),
                    e.model.environmentMap && (void 0 !== e.model.environmentMap.cubemap ? (t.setEnvironmentCubemapUrl(e.model.environmentMap.cubemap),
                    t.setEnvironmentCylindricalUrl("")) : void 0 !== e.model.environmentMap.cylindrical && (t.setEnvironmentCylindricalUrl(e.model.environmentMap.cylindrical),
                    t.setEnvironmentCubemapUrl("")))
                }
                if (e.comet) {
                    const t = a.addComponent(s.CometTailComponent, e.comet.name);
                    void 0 !== e.comet.timeLength && t.setTimeLength(e.comet.timeLength),
                    t.setLightSource("sun");
                    const i = a.addComponent(s.CometTailComponent);
                    i.setTimeLength(.5 * t.getTimeLength()),
                    i.setColor(new s.Color(.214,.235,.371,.5)),
                    i.setStarAccelerationMultiplier(10),
                    i.setLightSource("sun");
                    const n = a.addComponent(s.CometTailComponent);
                    n.setStarAccelerationMultiplier(0),
                    n.setColor(new s.Color(1,1,1,10)),
                    n.setNumberOfParticles(1),
                    n.setLightSource("sun")
                }
                if (e.controllers)
                    for (let t = 0, n = e.controllers.length; t < n; t++) {
                        const n = e.controllers[t]
                          , o = n.type;
                        let r;
                        if ("fixed" === o) {
                            if (r = a.addController(s.FixedController, n.name),
                            n.position && r.setPosition(n.position),
                            n.orientation && r.setOrientation(n.orientation),
                            void 0 !== n.relativeToEntity) {
                                const t = a.addController(s.RotateByEntityOrientationController);
                                t.setEntityForOrientation(n.relativeToEntity),
                                n.coverage && 2 === n.coverage.length && t.setCoverage(new s.Interval(n.coverage[0],n.coverage[1]))
                            }
                            if (n.llaOnSpheroid) {
                                const t = n.llaOnSpheroidEntity ?? e.parents[0][1]
                                  , o = i.getEntity(t);
                                if (null !== o) {
                                    const e = o.getComponent(s.SpheroidComponent);
                                    if (null === e)
                                        throw new Error("Missing spheroid component.");
                                    n.coverage && 2 === n.coverage.length && r.setCoverage(new s.Interval(n.coverage[0],n.coverage[1]));
                                    const i = new s.Vector3;
                                    e.xyzFromLLA(i, n.llaOnSpheroid),
                                    r.setPosition(i);
                                    const l = new s.Quaternion;
                                    e.orientationFromLLA(l, n.llaOnSpheroid),
                                    r.setOrientation(l);
                                    const c = a.addController(s.RotateByEntityOrientationController);
                                    n.coverage && 2 === n.coverage.length && c.setCoverage(new s.Interval(n.coverage[0],n.coverage[1]));
                                    const h = a.addController(s.GroundClampController);
                                    h.setGroundEntityRef(t),
                                    n.coverage && 2 === n.coverage.length && h.setCoverage(new s.Interval(n.coverage[0],n.coverage[1]))
                                }
                            }
                        } else if ("dynamo" === o)
                            r = a.addController(s.DynamoController, n.name),
                            !0 !== n.customUrl ? r.setBaseUrl(`$DYNAMIC_ASSETS_URL/dynamo/${n.url}`) : r.setBaseUrl(n.url),
                            void 0 !== n.parentIsBarycenter && r.setHeaderValue("body", 1);
                        else if ("animdata" === o)
                            r = a.addController(s.AnimdataController, n.name),
                            r.setBaseUrlAndStateType(`$ANIMDATA_URL/${n.url}`, n.dataType);
                        else if ("align" === o)
                            r = a.addController(s.AlignController, n.name),
                            void 0 !== n.joint && r.setJoint(n.joint),
                            r.setPrimaryAlignType(n.primary.type),
                            r.setPrimaryTargetEntity(n.primary.target ?? ""),
                            r.setPrimaryAxis(n.primary.axis),
                            n.primary.targetAxis && r.setPrimaryTargetAxis(n.primary.targetAxis),
                            n.secondary && (r.setSecondaryAlignType(n.secondary.type),
                            r.setSecondaryTargetEntity(n.secondary.target ?? ""),
                            r.setSecondaryAxis(n.secondary.axis),
                            n.secondary.targetAxis && r.setSecondaryTargetAxis(n.secondary.targetAxis));
                        else if ("spin" === o)
                            r = a.addController(s.SpinController, n.name),
                            r.setAxis(n.axis, n.axisInFrameSpace ?? !0),
                            r.setRate(s.MathUtils.twoPi / (3600 * n.periodInHours)),
                            void 0 !== n.relativeToTime && r.setReferenceTime(n.relativeToTime);
                        else if ("rotateByEntityOrientation" === o)
                            r = a.addController(s.RotateByEntityOrientationController, n.name),
                            void 0 !== n.entityForOrientation && r.setEntityForOrientation(n.entityForOrientation),
                            void 0 !== n.rotatingOrientation && r.setRotatingOrientation(n.rotatingOrientation),
                            void 0 !== n.rotatingPosition && r.setRotatingPosition(n.rotatingPosition);
                        else if ("orbitalElements" === o) {
                            r = a.addController(s.OrbitalElementsController, n.name);
                            const t = n.epoch ?? 0
                              , e = new s.OrbitalElements;
                            if (e.epoch = t,
                            e.eccentricity = n.eccentricity,
                            e.semiMajorAxis = n.semiMajorAxis,
                            e.meanAngularMotion = n.meanAngularMotion,
                            e.meanAnomalyAtEpoch = n.meanAnomalyAtEpoch,
                            void 0 !== n.orbitOrientation)
                                e.orbitOrientation.copy(n.orbitOrientation);
                            else {
                                if (void 0 === n.inclination || void 0 === n.longitudeOfAscendingNode || void 0 === n.argumentOfPeriapsis)
                                    throw new Error("Either orbitOrientation or all of inclination, longitudeOfAscendingNode, and argumentOfPeriapsis must be defined.");
                                e.setOrbitOrientationFromElements(n.inclination, n.longitudeOfAscendingNode, n.argumentOfPeriapsis)
                            }
                            r.addOrbitalElements(t, e)
                        } else if ("coverage" === o)
                            r = a.addController(s.CoverageController, n.name),
                            r.setEnterFunction(n.enter),
                            r.setExitFunction(n.exit),
                            r.setUpdateFunction(n.update),
                            void 0 !== n.updateInterval && r.setUpdateInterval(n.updateInterval);
                        else {
                            if ("custom" !== o)
                                throw new Error(`The type "${o}" is unknown.`);
                            r = n.func(a)
                        }
                        n.coverage && 2 === n.coverage.length && r.setCoverage(new s.Interval(n.coverage[0],n.coverage[1]))
                    }
                e.postCreateFunction && e.postCreateFunction(a, n)
            } catch (t) {
                throw null !== a && i.removeEntity(a),
                t instanceof Error && (t.message = `While creating "${o}": ${t.message}`),
                t
            }
            return a
        }
        static getEntityOptions(t) {
            return Entity._entities.get(t)
        }
        static getEntityNamesInGroup(t) {
            const e = new Set;
            if ("" !== t) {
                const i = t.split(",").map((t => t.trim()));
                for (const [t,s] of Entity._entities) {
                    const n = s.groups;
                    if (!n)
                        continue;
                    let o = !0;
                    for (const t of i)
                        n.includes(t) || (o = !1);
                    o && e.add(t)
                }
            } else
                for (const t of Entity._entities.keys())
                    e.add(t);
            return e
        }
        static getGroups() {
            const t = new Set;
            for (const e of this._entities.values()) {
                const i = e.groups;
                if (void 0 !== i)
                    for (let e = 0; e < i.length; e++)
                        t.add(i[e])
            }
            return t
        }
        static createGroup(t, e, i) {
            const s = this.getEntityNamesInGroup(t);
            for (const t of s)
                this.create(t, e, i)
        }
        static _entities = new Map
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        Features: function() {
            return Features
        }
    });
    var s = i(5)
      , n = i(545);
    class Features {
        static setEnabled(t, e, i, s) {
            const n = Features.entityFeatureSetEnabledMap[e];
            if (void 0 === n)
                throw new Error(`Attempted to access unavailable feature ${i} for ${e}.`);
            const o = n[i];
            if (void 0 === o)
                throw new Error(`Attempted to access unavailable feature ${i} for ${e}.`);
            o(t, s)
        }
        static isEnabled(t, e, i) {
            const s = Features.entityFeatureIsEnabledMap[e];
            if (void 0 === s)
                throw new Error(`Attempted to access unavailable feature ${i} for ${e}.`);
            const n = s[i];
            if (void 0 === n)
                throw new Error(`Attempted to access unavailable feature ${i} for ${e}.`);
            return n(t)
        }
        static setEnabledJupiterAuroras(t, e) {
            if (e)
                Features._createJupiterModelComponent(t, "auroras", "auroras");
            else {
                const e = t.getEntity("jupiter");
                e && e.removeComponent("auroras")
            }
        }
        static isEnabledJupiterAuroras(t) {
            const e = t.getEntity("jupiter");
            return !!e && null !== e.getComponent(s.ModelComponent, "auroras")
        }
        static setEnabledJupiterMagnetosphere(t, e) {
            if (e)
                Features._createJupiterModelComponent(t, "magnetosphere", "magnetosphere");
            else {
                const e = t.getEntity("jupiter");
                e && e.removeComponent("magnetosphere")
            }
        }
        static isEnabledJupiterMagnetosphere(t) {
            const e = t.getEntity("jupiter");
            return !!e && null !== e.getComponent(s.ModelComponent, "magnetosphere")
        }
        static setEnabledJupiterRadiationBelt(t, e) {
            if (e)
                for (let e = 1; e <= 4; e++)
                    Features._createJupiterModelComponent(t, `radiation_belt_${e}`, `radbelt${e}`);
            else {
                const e = t.getEntity("jupiter");
                if (e)
                    for (let t = 1; t <= 4; t++)
                        e.removeComponent(`radiation_belt_${t}`)
            }
        }
        static isEnabledJupiterRadiationBelt(t) {
            const e = t.getEntity("jupiter");
            if (!e)
                return !1;
            for (let t = 1; t <= 4; t++)
                if (null === e.getComponent(s.ModelComponent, `radiation_belt_${t}`))
                    return !1;
            return !0
        }
        static setEnabledSaturnMagnetosphere(t, e) {
            e ? n.Entity.createFromOptions("saturn_magnetosphere", {
                radius: 5027500,
                parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
                model: {
                    url: "$STATIC_ASSETS_URL/models/saturn/magnetosphere/saturn_magnetosphere.gltf",
                    scale: 1078.27002124,
                    rotate: [{
                        x: 90
                    }]
                },
                controllers: [{
                    type: "fixed",
                    position: s.Vector3.Zero
                }, {
                    type: "align",
                    primary: {
                        type: "align",
                        target: "saturn",
                        axis: s.Vector3.ZAxis,
                        targetAxis: s.Vector3.ZAxis
                    },
                    secondary: {
                        type: "point",
                        target: "sun",
                        axis: s.Vector3.XAxis
                    }
                }],
                postCreateFunction: t => {
                    t.setCanOcclude(!1);
                    const e = t.addComponent(s.ModelComponent);
                    e.setUrl("$STATIC_ASSETS_URL/models/saturn/magnetosphere_thin/saturn_magnetosphere_thin.gltf"),
                    e.setScale(1078.27002124),
                    e.setRotation(new s.Quaternion(Math.sqrt(.5),Math.sqrt(.5),0,0)),
                    e.setPixelRadiusVisibleInterval(new s.Interval(4e3,Number.POSITIVE_INFINITY)),
                    e.setResourcesLoadedCallback(( () => {
                        e.getThreeJsObjects()[0].renderOrder = -1
                    }
                    ));
                    const i = t.getComponent(s.ModelComponent);
                    i && (i.setPixelRadiusVisibleInterval(new s.Interval(0,4e3)),
                    i.setResourcesLoadedCallback(( () => {
                        i.getThreeJsObjects()[0].renderOrder = -1
                    }
                    )))
                }
            }, t) : t.removeEntity("saturn_magnetosphere")
        }
        static isEnabledSaturnMagnetosphere(t) {
            return null !== t.getEntity("saturn_magnetosphere")
        }
        static _createJupiterModelComponent(t, e, i) {
            const n = t.getEntity("jupiter");
            if (!n)
                throw new Error("The entity jupiter is not found.");
            const o = n.addComponent(s.ModelComponent, e);
            o.setUrl(`$STATIC_ASSETS_URL/models/jupiter/${e}/jupiter_${i}.gltf`),
            o.setScale(1337.08);
            const a = new s.Quaternion(Math.SQRT1_2,Math.SQRT1_2,0,0)
              , r = new s.Quaternion(Math.SQRT1_2,0,0,Math.SQRT1_2);
            a.mult(r, a),
            o.setRotation(a)
        }
        static entityFeatureSetEnabledMap = {
            jupiter: {
                auroras: Features.setEnabledJupiterAuroras,
                magnetosphere: Features.setEnabledJupiterMagnetosphere,
                radiationBelt: Features.setEnabledJupiterRadiationBelt
            },
            saturn: {
                magnetosphere: Features.setEnabledSaturnMagnetosphere
            }
        };
        static entityFeatureIsEnabledMap = {
            jupiter: {
                auroras: Features.isEnabledJupiterAuroras,
                magnetosphere: Features.isEnabledJupiterMagnetosphere,
                radiationBelt: Features.isEnabledJupiterRadiationBelt
            },
            saturn: {
                magnetosphere: Features.isEnabledSaturnMagnetosphere
            }
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        LabelQuadtree: function() {
            return LabelQuadtree
        }
    });
    var s = i(5)
      , n = i(548);
    class LabelQuadtree {
        constructor(t) {
            this._viewport = t,
            this._labelInfos = {},
            this._labelNames = [],
            this._quadtree = new n.Quadtree(t),
            this._labelNamesIndex = 0,
            this._doOcclusions = !0,
            this._intersections = {},
            this._divBoundsAdjustmentFunction = void 0,
            this._isLessWeights = this._isLessWeights.bind(this),
            this._isLessWeightsAndZ = this._isLessWeightsAndZ.bind(this)
        }
        destroy() {
            for (let t = 0, e = this._labelNames.length; t < e; t++) {
                const e = this._labelNames[t];
                this._setLabelOcclusion(this._labelInfos[e].divComponent, !1)
            }
            this._labelInfos = {},
            this._labelNames = []
        }
        getDoOcclusions() {
            return this._doOcclusions
        }
        setDoOcclusions(t) {
            if (this._doOcclusions = t,
            !this._doOcclusions)
                for (let t = 0, e = this._labelNames.length; t < e; t++) {
                    const e = this._labelNames[t];
                    this._setLabelOcclusion(this._labelInfos[e].divComponent, !1)
                }
        }
        addEntity(t, e) {
            const i = t.getName();
            if (void 0 !== this._labelInfos[i])
                return;
            const n = t.getComponent(s.DivComponent);
            if (null === n)
                throw new Error(`Entity ${t.getName()} added with no div component.`);
            const o = {
                weight: e,
                z: Number.POSITIVE_INFINITY,
                divComponent: n
            };
            this._labelInfos[i] = o,
            this._labelNames.push(i),
            s.Sort.sort(this._labelNames, this._isLessWeights),
            this._intersections[i] = new s.FastSet,
            this._intersections[`${i}-div`] = new s.FastSet
        }
        removeEntity(t) {
            void 0 !== this._labelInfos[t] && (delete this._labelInfos[t],
            delete this._intersections[t],
            delete this._intersections[`${t}-div`],
            this._labelNames.splice(this._labelNames.findIndex((e => e === t)), 1),
            this._quadtree.removeBounds(`${t}-div`),
            this._quadtree.removeBounds(t))
        }
        getBounds(t, e) {
            this._quadtree.getBounds(t, e)
        }
        setBounds(t, e) {
            if (t.endsWith("-div"))
                throw new Error("Cannot make a bounds name end with `-div`, as it is reserved for entities.");
            if (this._labelNames.includes(t))
                throw new Error(`There is an entity named ${t}. Use addEntity() instead.`);
            this._intersections[t] = new s.FastSet,
            this._quadtree.setBounds(t, e)
        }
        removeRect(t) {
            if (t in this._labelInfos)
                throw new Error(`There is an entity named ${t}. Use removeEntity() instead.`);
            delete this._intersections[t],
            this._quadtree.removeBounds(t)
        }
        setWeight(t, e) {
            const i = this._labelInfos[t];
            if (void 0 === i)
                throw new Error(`Weight set for entity ${t} not in the label quadtree.`);
            i.weight = e,
            s.Sort.sort(this._labelNames, this._isLessWeights)
        }
        getIntersections(t, e) {
            this._quadtree.getIntersections(t, e)
        }
        setDivBoundsAdjustFunction(t) {
            this._divBoundsAdjustmentFunction = t
        }
        update() {
            const t = this._viewport.getCamera();
            if (null === t)
                return;
            const e = t.getEntity().getScene();
            if (0 === this._labelNames.length)
                return;
            const i = this._labelNamesIndex % this._labelNames.length
              , n = Math.min(this._labelNames.length, 20)
              , o = s.Rect.pool.get();
            for (let a = 0; a < n; a++) {
                const n = this._labelNames[(i + a) % this._labelNames.length]
                  , r = this._labelInfos[n]
                  , l = e.getEntity(n);
                if (null === l) {
                    this.removeEntity(n),
                    a--;
                    continue
                }
                const c = s.Rect.pool.get();
                c.origin.copy(l.getPixelSpacePosition(t)),
                c.size.set(0, 0),
                this._quadtree.setBounds(n, c),
                s.Rect.pool.release(c);
                const h = l.getComponent(s.DivComponent);
                h ? (o.copy(h.getBounds()),
                this._divBoundsAdjustmentFunction && this._divBoundsAdjustmentFunction(o),
                this._quadtree.setBounds(`${n}-div`, o)) : this._quadtree.removeBounds(`${n}-div`),
                r.z = l.getCameraSpacePosition(t).magnitude()
            }
            if (s.Rect.pool.release(o),
            this._doOcclusions)
                for (let t = 0; t < n; t++) {
                    const e = this._labelNames[(i + t) % this._labelNames.length]
                      , s = this._labelInfos[e]
                      , n = this._intersections[e];
                    if (this._isLabelOccludedInDiv(s.divComponent)) {
                        this._setLabelOcclusion(s.divComponent, !1);
                        continue
                    }
                    this._quadtree.getIntersections(`${e}-div`, n);
                    let o = !1;
                    for (let t = 0, e = n.getSize(); t < e; t++) {
                        let e = n.getAt(t);
                        if (!e.endsWith("-div"))
                            continue;
                        e = e.substring(0, e.length - 4);
                        const i = this._labelInfos[e];
                        if (void 0 !== i && !this._isLabelOccluded(i.divComponent) && this._isLessWeightsAndZ(s, i)) {
                            o = !0;
                            break
                        }
                    }
                    this._setLabelOcclusion(s.divComponent, o)
                }
            this._labelNamesIndex = (i + n) % this._labelNames.length
        }
        _isLabelOccludedInDiv(t) {
            return t.getDiv().classList.contains(t.getHiddenClass())
        }
        _isLabelOccluded(t) {
            return t.getDiv().classList.contains(`${t.getHiddenClass()}ByLabelQuadtree`) || t.getDiv().classList.contains(t.getHiddenClass())
        }
        _setLabelOcclusion(t, e) {
            t.getDiv().classList.toggle(`${t.getHiddenClass()}ByLabelQuadtree`, e)
        }
        _isLessWeights(t, e) {
            const i = this._labelInfos[t]
              , s = this._labelInfos[e];
            return i.weight < s.weight
        }
        _isLessWeightsAndZ(t, e) {
            if (t.weight !== e.weight)
                return t.weight < e.weight;
            if (t.z !== e.z)
                return t.z > e.z;
            const i = t.divComponent.getEntity().getName()
              , s = e.divComponent.getEntity().getName();
            return i.localeCompare(s) < 0
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        Quadtree: function() {
            return Quadtree
        }
    });
    var s = i(5);
    class Quadtree {
        constructor(t, e=8) {
            this._viewport = t,
            this._maxValuesPerNode = e,
            this._root = {
                bounds: new s.Rect(0,0,this._viewport.getBounds().size.x,this._viewport.getBounds().size.y),
                values: [],
                depth: 0,
                parent: null,
                children: null
            },
            this._nameArray = [],
            this._valueMap = {}
        }
        setBounds(t, e) {
            if (!this._root.bounds.size.equals(this._viewport.getBounds().size)) {
                this._root = {
                    bounds: new s.Rect(0,0,this._viewport.getBounds().size.x,this._viewport.getBounds().size.y),
                    values: [],
                    depth: 0,
                    parent: null,
                    children: null
                };
                for (const t of this._nameArray)
                    this._insertValueInNode(this._valueMap[t], this._root)
            }
            let i = this._valueMap[t];
            if (void 0 === i && (i = {
                name: t,
                bounds: new s.Rect,
                node: null,
                withinViewport: !1,
                intersectionFlags: new s.FastMap
            },
            this._valueMap[t] = i,
            this._nameArray.push(t)),
            i.bounds.copy(e),
            i.withinViewport = this._root.bounds.intersects(i.bounds),
            i.withinViewport)
                if (null === i.node)
                    this._insertValueInNode(i, this._root);
                else if (i.node.bounds.surrounds(i.bounds)) {
                    if (null !== i.node.children)
                        for (let t = 0; t < 4; t++) {
                            const e = i.node.children[t];
                            if (e.bounds.surrounds(i.bounds)) {
                                this._removeValueFromNode(i),
                                this._insertValueInNode(i, e);
                                break
                            }
                        }
                } else
                    this._removeValueFromNode(i),
                    this._insertValueInNode(i, this._root);
            else
                this._removeValueFromNode(i)
        }
        removeBounds(t) {
            const e = this._valueMap[t];
            void 0 !== e && (this._removeValueFromNode(e),
            this._nameArray.splice(this._nameArray.findIndex((e => e === t)), 1),
            delete this._valueMap[t])
        }
        getBounds(t, e) {
            const i = this._valueMap[e];
            void 0 !== i ? t.copy(i.bounds) : t.set(NaN, NaN, NaN, NaN)
        }
        getIntersections(t, e) {
            const i = this._valueMap[t];
            if (void 0 !== i && null !== i.node) {
                for (let t = 0, e = i.intersectionFlags.getSize(); t < e; t++)
                    i.intersectionFlags.getAt(t).value = !1;
                this._getNodeIntersections(i, i.node, !1);
                for (let t = 0; t < i.intersectionFlags.getSize(); t++) {
                    const s = i.intersectionFlags.getAt(t);
                    s.value ? e.add(s.key) : (i.intersectionFlags.delete(s.key),
                    e.delete(s.key),
                    t--)
                }
            } else
                e.clear()
        }
        _getNodeIntersections(t, e, i) {
            for (let i = 0, s = e.values.length; i < s; i++) {
                const s = e.values[i];
                s.withinViewport && s.bounds.intersects(t.bounds) && s !== t && t.intersectionFlags.set(s.name, !0)
            }
            if (i || null === e.children)
                null !== e.parent && this._getNodeIntersections(t, e.parent, !0);
            else
                for (let s = 0; s < 4; s++)
                    this._getNodeIntersections(t, e.children[s], i)
        }
        _insertValueInNode(t, e) {
            if (null === e.children && e.values.length < this._maxValuesPerNode || e.depth >= 8)
                return e.values.push(t),
                void (t.node = e);
            if (null === e.children) {
                const t = e.bounds;
                e.children = [{
                    bounds: new s.Rect(t.origin.x,t.origin.y,t.size.x / 2,t.size.y / 2),
                    values: [],
                    depth: e.depth + 1,
                    parent: e,
                    children: null
                }, {
                    bounds: new s.Rect(t.origin.x + t.size.x / 2,t.origin.y,t.size.x / 2,t.size.y / 2),
                    values: [],
                    depth: e.depth + 1,
                    parent: e,
                    children: null
                }, {
                    bounds: new s.Rect(t.origin.x,t.origin.y + t.size.y / 2,t.size.x / 2,t.size.y / 2),
                    values: [],
                    depth: e.depth + 1,
                    parent: e,
                    children: null
                }, {
                    bounds: new s.Rect(t.origin.x + t.size.x / 2,t.origin.y + t.size.y / 2,t.size.x / 2,t.size.y / 2),
                    values: [],
                    depth: e.depth + 1,
                    parent: e,
                    children: null
                }];
                const i = e.values;
                e.values = [];
                for (const t of i)
                    t.node = null,
                    this._insertValueInNode(t, e)
            }
            for (let i = 0; i < 4; i++) {
                const s = e.children[i];
                if (s.bounds.surrounds(t.bounds))
                    return void this._insertValueInNode(t, s)
            }
            e.values.push(t),
            t.node = e
        }
        _removeValueFromNode(t) {
            const e = t.node;
            if (!e)
                return;
            if (e.values.splice(e.values.findIndex((e => e === t)), 1),
            t.node = null,
            null === e.children)
                return;
            if (e.values.length >= this._maxValuesPerNode / 2)
                return;
            let i = e.values.length;
            for (let t = 0; t < 4; t++) {
                const s = e.children[t];
                if (null !== s.children)
                    return;
                if (i += s.values.length,
                i >= this._maxValuesPerNode / 2)
                    return
            }
            for (let t = 0; t < 4; t++) {
                const i = e.children[t];
                for (const t of i.values)
                    e.values.push(t),
                    t.node = e
            }
            e.children = null
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        Mapping: function() {
            return Mapping
        }
    });
    var s = i(5);
    class Mapping {
        static getTypes(t) {
            return Mapping._types[t] ?? []
        }
        static async set(t, e, i, s) {
            const n = [];
            for (const s of Mapping.getTypes(e))
                s !== i && n.push(Mapping.setEnabled(t, e, s, !1, {}));
            n.push(Mapping.setEnabled(t, e, i, !0, s)),
            await Promise.allSettled(n)
        }
        static async setEnabled(t, e, i, s, n) {
            if ("basic" === i)
                await Mapping.setBasic(t, e, s);
            else {
                if (!i.startsWith("cmts"))
                    throw new Error(`Invalid type ${i}.`);
                await Mapping.setCMTS(t, e, s, n)
            }
        }
        static async setBasic(t, e, i) {
            const n = t.getEntity(e);
            if (null === n)
                throw new Error(`No entity named '${e}' exists.`);
            const o = n.getComponent(s.SpheroidLODComponent, "basic");
            if (null === o)
                throw new Error(`The entity '${e}' does not have a spheroidLOD named 'basic'.`);
            o.setEnabled(i),
            i && (o.setVisible(!1),
            await o.getLoadedPromise(),
            o.setVisible(!0))
        }
        static async setCMTS(t, e, i, n) {
            const o = t.getEntity(e);
            if (null === o)
                throw new Error(`No entity named '${e}' exists.`);
            let a = o.getComponent(s.CMTSComponent, "cmts");
            if (i && !a) {
                if (a = o.addComponent(s.CMTSComponent, "cmts"),
                "earth" === e) {
                    if (a.setBaseUrl("color", `$DYNAMIC_ASSETS_URL/cmts/${e}/color`),
                    a.setBaseUrl("normal", `$DYNAMIC_ASSETS_URL/cmts/${e}/normal`),
                    a.setBaseUrl("height", `$DYNAMIC_ASSETS_URL/cmts/${e}/height`),
                    a.setBaseUrl("specular", `$DYNAMIC_ASSETS_URL/cmts/${e}/specular`),
                    n && !1 === n.night || a.setBaseUrl("night", `$DYNAMIC_ASSETS_URL/cmts/${e}/night`),
                    n)
                        if (!0 === n.clouds)
                            a.setBaseUrl("decal", `$DYNAMIC_ASSETS_URL/cmts/${e}/cloud`);
                        else if (!0 === n.floatingClouds) {
                            const t = o.addComponent(s.CMTSComponent, "floatingClouds");
                            t.setBaseUrl("color", `$DYNAMIC_ASSETS_URL/cmts/${e}/cloud`),
                            t.setTransparent(!0),
                            t.setShadowEntities(["moon"]),
                            t.setHeightOffset(15),
                            t.setIsGroundComponent(!1)
                        }
                    a.setShadowEntities(["moon"])
                } else
                    "mars" === e ? (a.setBaseUrl("color", `$DYNAMIC_ASSETS_URL/cmts/${e}/color`),
                    a.setBaseUrl("normal", `$DYNAMIC_ASSETS_URL/cmts/${e}/normal`),
                    a.setBaseUrl("height", `$DYNAMIC_ASSETS_URL/cmts/${e}/height`),
                    a.setShadowEntities(["phobos", "deimos"])) : "moon" === e && (a.setBaseUrl("color", `$DYNAMIC_ASSETS_URL/cmts/${e}/color`),
                    a.setBaseUrl("normal", `$DYNAMIC_ASSETS_URL/cmts/${e}/normal`),
                    a.setBaseUrl("height", `$DYNAMIC_ASSETS_URL/cmts/${e}/height`),
                    a.setShadowEntities(["earth"]));
                a.setVisible(!1),
                await a.getLoadedPromise(),
                await a.getTilesLoadedPromise(),
                a.setVisible(!0)
            } else if (!i && a && (o.removeComponent(a),
            "earth" === e)) {
                const t = o.getComponent(s.CMTSComponent, "floatingClouds");
                t && o.removeComponent(t)
            }
        }
        static _types = {
            earth: ["basic", "cmts"],
            moon: ["basic", "cmts"],
            mars: ["basic", "cmts"]
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        Parenting: function() {
            return Parenting
        }
    });
    var s = i(5)
      , n = i(545);
    class Parenting {
        static getParentOfEntity(t, e) {
            const i = n.Entity.getEntityOptions(t);
            if (void 0 === i)
                throw new Error(`There are no entity options for ${t}.`);
            const o = i.parents
              , a = s.Sort.getIndex(e, o, Parenting._isStartTimeLessThanTime);
            return a < o.length && e === o[a][0] ? o[a][1] : a > 0 ? o[a - 1][1] : ""
        }
        static getAllAncestorsOfEntity(t) {
            const e = new Set;
            return this._getAllAncestorsOfEntityRecursed(t, e),
            e
        }
        static _getAllAncestorsOfEntityRecursed(t, e) {
            const i = n.Entity.getEntityOptions(t);
            if (void 0 === i?.parents)
                return;
            const s = i.parents;
            for (const t of s) {
                const i = t[1];
                e.has(i) || (e.add(i),
                this._getAllAncestorsOfEntityRecursed(i, e))
            }
        }
        static _isStartTimeLessThanTime(t, e) {
            return t[0] < e
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        Placemarks: function() {
            return Placemarks
        }
    });
    var s = i(5);
    class Placemarks {
        static addPlacemark(t, e, i, n, o, a) {
            const r = i.getScene().addEntity(t);
            r.setParent(i),
            r.setCanOcclude(!1),
            r.setExtentsRadius(.001);
            const l = r.addComponent(s.DivComponent).getDiv();
            return l.innerHTML = e,
            l.classList.add("pioneer-label-div"),
            r.addController(s.FixedController),
            r.addController(s.RotateByEntityOrientationController),
            r.addController(s.GroundClampController),
            this.updateLLA(r, n, o, a),
            r
        }
        static updateLLA(t, e, i, n) {
            const o = t.getParent()
              , a = t.getController(s.FixedController)
              , r = t.getController(s.GroundClampController);
            if (null === o || null === a || null === r)
                throw new Error("There must be a parent and fixed and ground clamp controllers.");
            const l = o.getComponent(s.SpheroidComponent);
            if (null === l)
                throw new Error("There must be a spheroid for the placemark's parent.");
            const c = s.LatLonAlt.pool.get()
              , h = s.Vector3.pool.get();
            c.set(s.MathUtils.degToRad(e), s.MathUtils.degToRad(i), 0),
            l.xyzFromLLA(h, c),
            a.setPosition(h),
            s.Vector3.pool.release(h);
            const d = s.Quaternion.pool.get()
              , u = s.Vector3.pool.get()
              , p = s.Vector3.pool.get();
            l.eastFromLLA(u, c),
            l.northFromLLA(p, c),
            d.setFromAxes(u, p, void 0),
            a.setOrientation(d),
            s.Vector3.pool.release(u),
            s.Vector3.pool.release(p),
            s.Quaternion.pool.release(d),
            s.LatLonAlt.pool.release(c),
            r.setGroundEntityRef(o.getName()),
            r.setDistanceFromGround(n)
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        SceneHelpers: function() {
            return SceneHelpers
        }
    });
    var s = i(5)
      , n = i(545);
    class SceneHelpers {
        static getEclipJ2000ToJ2000Rotation() {
            return this.eclipJ2000ToJ2000Rotation
        }
        static llaToXYZ(t, e, i, n) {
            const o = e.getComponent(s.SpheroidComponent);
            null !== o && (o.xyzFromLLA(t, i),
            n || t.rotate(e.getOrientation(), t))
        }
        static xyzToLLA(t, e, i, n) {
            const o = e.getComponent(s.SpheroidComponent);
            if (null !== o) {
                const a = s.Vector3.pool.get();
                n ? a.copy(i) : a.rotateInverse(e.getOrientation(), i),
                o.llaFromXYZ(t, a),
                s.Vector3.pool.release(a)
            }
        }
        static getDependentEntities(t) {
            const e = new Set;
            return this._getDependentEntitiesRecursed(t, e),
            e.delete(t),
            e
        }
        static loadEntities(t, e, i, s, o, a) {
            for (let t = 0; t < i.getNumEntities(); t++) {
                const s = i.getEntityAt(t);
                e.has(s.getName()) || (a?.(s),
                i.removeEntity(s),
                t--)
            }
            const r = new Set;
            for (const e of t) {
                for (const t of SceneHelpers.getDependentEntities(e))
                    r.add(t);
                r.add(e)
            }
            for (const t of r) {
                o?.(n.Entity.create(t, i, s))
            }
        }
        static _getDependentEntitiesRecursed(t, e) {
            const i = n.Entity.getEntityOptions(t);
            if (void 0 === i)
                return;
            const s = new Set
              , o = i.parents;
            for (const t of o)
                "" !== t[1] && s.add(t[1]);
            if (void 0 !== i.lightSource && s.add(i.lightSource),
            void 0 !== i.trail?.relativeTo && s.add(i.trail.relativeTo),
            i.controllers)
                for (let t = 0, e = i.controllers.length; t < e; t++) {
                    const e = i.controllers[t];
                    "align" === e.type && (void 0 !== e.primary.target && s.add(e.primary.target),
                    void 0 !== e.secondary?.target && s.add(e.secondary.target))
                }
            if (void 0 !== i.labelFadeEntity && s.add(i.labelFadeEntity),
            i.dependents)
                for (let t = 0, e = i.dependents.length; t < e; t++)
                    s.add(i.dependents[t]);
            for (const t of s)
                e.has(t) || (e.add(t),
                this._getDependentEntitiesRecursed(t, e))
        }
        static eclipJ2000ToJ2000Rotation = new s.Quaternion(.9791532214288992,.2031230389823101,0,0,!0)
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        Transitions: function() {
            return Transitions
        }
    });
    var s = i(5);
    class Transitions {
        static jumpToLocationOnSphere(t, e, i, n, o, a, r, l, c, h) {
            t <= 0 && (t = .001),
            h = Transitions.easeInOut(h);
            const d = o.getParent();
            if (void 0 === n) {
                if (!d)
                    throw new Error("Needs entity parent or sphere entity.");
                n = d
            }
            const u = s.Vector3.pool.get()
              , p = s.Vector3.pool.get();
            d ? (d.getPositionRelativeToEntity(u, a, n),
            d.getPositionRelativeToEntity(p, r, n)) : (u.copy(a),
            p.copy(r));
            const m = u.magnitude() - e
              , _ = p.magnitude() - e
              , g = s.Vector3.pool.get();
            i ? n.getOrientation().getAxis(g, 2) : g.cross(u, p),
            g.normalize(g),
            g.isZero() && g.set(0, 0, 1);
            const y = s.Vector3.pool.get()
              , f = s.Vector3.pool.get()
              , b = s.Quaternion.pool.get();
            b.setFromAxis(g, 2),
            y.rotateInverse(b, u),
            f.rotateInverse(b, p);
            const T = s.LatLonAlt.pool.get()
              , v = s.LatLonAlt.pool.get();
            s.Geometry.getLLAFromXYZOnSphere(T, y, 0),
            s.Geometry.getLLAFromXYZOnSphere(v, f, 0),
            s.Vector3.pool.release(f),
            s.Vector3.pool.release(y);
            let S = T.lon * Math.cos(T.lat)
              , E = v.lon * Math.cos(v.lat);
            S + Math.PI < E && (S += 2 * Math.PI),
            E + Math.PI < S && (E += 2 * Math.PI);
            const C = e * t * Math.sqrt((E - S) * (E - S) + (v.lat - T.lat) * (v.lat - T.lat))
              , x = s.Vector2.pool.get();
            Transitions._jumpOnCircle(x, C, m, _, h);
            const w = x.x
              , I = x.y;
            s.Vector2.pool.release(x);
            const M = s.Vector3.pool.get();
            M.normalize(u),
            M.mult(M, I + e);
            const A = s.LatLonAlt.pool.get();
            let N;
            N = 0 !== C ? (C - w) / C : 0,
            A.lat = s.MathUtils.lerp(T.lat, v.lat, N),
            A.lon = s.MathUtils.lerpAngle(T.lon, v.lon, N),
            A.alt = I,
            s.Geometry.getXYZFromLLAOnSphere(M, A, e),
            M.rotate(b, M),
            s.LatLonAlt.pool.release(A),
            s.LatLonAlt.pool.release(T),
            s.LatLonAlt.pool.release(v),
            s.Quaternion.pool.release(b),
            M.isNaN() && M.copy(p),
            d && n.getPositionRelativeToEntity(M, M, d),
            o.setPosition(M),
            s.Vector3.pool.release(M),
            s.Vector3.pool.release(g);
            const L = s.Vector3.pool.get();
            n.getPositionRelativeToEntity(L, s.Vector3.Zero, o),
            L.normalize(L);
            const k = s.Vector3.pool.get()
              , V = s.Quaternion.pool.get();
            i ? n.getOrientation().getAxis(k, 2) : (V.slerp(l, c, h),
            V.getAxis(k, 2)),
            k.setNormalTo(L, k),
            V.setFromAxes(void 0, L, k),
            o.setOrientation(V),
            s.Vector3.pool.release(k),
            s.Quaternion.pool.release(V),
            s.Vector3.pool.release(L),
            s.Vector3.pool.release(u),
            s.Vector3.pool.release(p)
        }
        static easeInOut(t) {
            const e = t * t;
            return e / (2 * (e - t) + 1)
        }
        static _jumpOnCircle(t, e, i, s, n) {
            let o, a;
            if (Math.abs(e / (s - i)) > 1e-6) {
                const t = (s - i) / -e * (s + i) / 2 + e / 2
                  , r = Math.sign(e) * Math.acos((i * s + (e - t) * -t) / Math.sqrt(i * i + (e - t) * (e - t)) / Math.sqrt(s * s + t * t))
                  , l = Math.cos(n * r)
                  , c = Math.sin(n * r);
                o = (e - t) * c + i * l,
                a = t + (e - t) * l - i * c
            } else
                o = n * s + (1 - n) * i,
                a = (1 - n) * e;
            1 === n && (o = s,
            a = 0),
            t.set(a, o)
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        AnnulusComponent: function() {
            return AnnulusComponent
        }
    });
    var s = i(5);
    class AnnulusComponent extends s.BaseComponent {
        constructor(t, e) {
            super(t, e),
            this._sizeInner = 1,
            this._sizeOuter = 1,
            this._ignoreDistance = !1,
            this._minDistanceM = 0,
            this._minDistanceB = 0,
            this._maxDistanceM = Number.POSITIVE_INFINITY,
            this._maxDistanceB = Number.POSITIVE_INFINITY,
            this._color = new s.Color(1,1,1,1),
            this._color.freeze(),
            this._alphaMultiplier = 1,
            this._numPointsOnCircle = 200,
            this._meshDirty = !0,
            this.__setRadius(this._sizeOuter),
            this.__setUsesEntityOrientation(!0)
        }
        getInnerRadius() {
            return this._sizeInner
        }
        setInnerRadius(t) {
            this._sizeInner = t,
            this._meshDirty = !0
        }
        getOuterRadius() {
            return this._sizeOuter
        }
        setOuterRadius(t) {
            this._sizeOuter = t,
            this._meshDirty = !0,
            this.__setRadius(t)
        }
        setIgnoreDistance(t) {
            this._ignoreDistance = t,
            this._alphaMultiplier = 1,
            s.ThreeJsHelper.setUniformColorRGBA(this.getThreeJsMaterials()[0], "color", this._color, this._alphaMultiplier)
        }
        setMinDistance(t) {
            this._minDistanceM = 1 / (t - t / 1.1),
            this._minDistanceB = -1 * this._minDistanceM * t / 1.1
        }
        setMaxDistance(t) {
            this._maxDistanceM = -1 / (1.1 * t - t),
            this._maxDistanceB = -1 * this._maxDistanceM * t * 1.1
        }
        getColor() {
            return this._color
        }
        setColor(t) {
            this._color.thaw(),
            this._color.copy(t),
            this._color.freeze(),
            s.ThreeJsHelper.setUniformColorRGBA(this.getThreeJsMaterials()[0], "color", this._color, this._alphaMultiplier)
        }
        __prepareForRender(t) {
            if (s.ThreeJsHelper.setOrientationToEntity(this.getThreeJsObjects()[0], this.getEntity()),
            s.ThreeJsHelper.setPositionToEntity(this.getThreeJsObjects()[0], this.getEntity(), t),
            this._meshDirty && this._updateMesh(),
            !this._ignoreDistance) {
                const e = this.getEntity().getCameraSpacePosition(t).magnitude()
                  , i = this._minDistanceM * e + this._minDistanceB
                  , n = this._maxDistanceM * e + this._maxDistanceB;
                this._alphaMultiplier = s.MathUtils.clamp01(Math.min(i, n)),
                s.ThreeJsHelper.setUniformColorRGBA(this.getThreeJsMaterials()[0], "color", this._color, this._alphaMultiplier)
            }
        }
        async __loadResources() {
            const t = this.getEntity().getScene().getEngine().getMaterialManager().getPreloaded("basic_alpha");
            this.getThreeJsMaterials().push(t),
            s.ThreeJsHelper.setUniformColorRGBA(t, "color", this._color, this._alphaMultiplier);
            const e = s.ThreeJsHelper.createMeshObject(this, t, [{
                name: "position",
                dimensions: 3
            }], !1);
            this.getThreeJsObjects().push(e)
        }
        __unloadResources() {
            s.ThreeJsHelper.destroyAllObjectsAndMaterials(this)
        }
        _updateMesh() {
            const t = new Float32Array(4 * this._numPointsOnCircle * 3)
              , e = new Uint16Array(6 * this._numPointsOnCircle);
            let i = 0
              , n = 0;
            const o = new s.Vector3
              , a = new s.Vector3
              , r = this._sizeOuter
              , l = this._sizeInner / this._sizeOuter;
            for (let c = 0; c < this._numPointsOnCircle; c++) {
                const h = c / this._numPointsOnCircle * s.MathUtils.twoPi
                  , d = (c + 1) % this._numPointsOnCircle / this._numPointsOnCircle * s.MathUtils.twoPi;
                o.set(r * Math.cos(h), r * Math.sin(h), 0),
                a.set(r * Math.cos(d), r * Math.sin(d), 0),
                t[i + 0] = o.x * l,
                t[i + 1] = o.y * l,
                t[i + 2] = o.z * l,
                t[i + 3] = o.x,
                t[i + 4] = o.y,
                t[i + 5] = o.z,
                t[i + 6] = a.x,
                t[i + 7] = a.y,
                t[i + 8] = a.z,
                t[i + 9] = a.x * l,
                t[i + 10] = a.y * l,
                t[i + 11] = a.z * l,
                e[n + 0] = i / 3 + 0,
                e[n + 1] = i / 3 + 1,
                e[n + 2] = i / 3 + 2,
                e[n + 3] = i / 3 + 2,
                e[n + 4] = i / 3 + 3,
                e[n + 5] = i / 3 + 0,
                i += 12,
                n += 6
            }
            const c = this.getThreeJsObjects()[0].geometry;
            s.ThreeJsHelper.setVertices(c, "position", t),
            s.ThreeJsHelper.setIndices(c, e),
            this._meshDirty = !1
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        CelestialGridComponent: function() {
            return CelestialGridComponent
        }
    });
    var s = i(5);
    class CelestialGridComponent extends s.BaseComponent {
        constructor(t, e) {
            super(t, e),
            this._degreesPerLine = 10,
            this._color = new s.Color(1,1,1,1),
            this._color.freeze(),
            this._lineMesh = null,
            this._meshDirty = !0
        }
        setRadius(t) {
            this.__setRadius(t),
            s.ThreeJsHelper.setScale(this.getThreeJsObjects(), this.getRadius())
        }
        getColor() {
            return this._color
        }
        setColor(t) {
            this._color.thaw(),
            this._color.copy(t),
            this._color.freeze(),
            this._meshDirty = !0
        }
        getDegreesPerLine() {
            return this._degreesPerLine
        }
        setDegreesPerLine(t) {
            this._degreesPerLine = t,
            this._meshDirty = !0
        }
        __prepareForRender(t) {
            this._lineMesh && (this._meshDirty && this._updateMesh(),
            s.ThreeJsHelper.setPositionToEntity(this.getThreeJsObjects(), this.getEntity(), t),
            this._lineMesh.prepareForRender(t))
        }
        async __loadResources() {
            this._lineMesh = new s.LineMesh(this),
            this._updateMesh()
        }
        __unloadResources() {
            s.ThreeJsHelper.destroyAllObjectsAndMaterials(this),
            this._lineMesh = null
        }
        _updateMesh() {
            if (!this._lineMesh)
                return;
            const t = [];
            for (let e = 0; e < 360; e += this._degreesPerLine) {
                const i = Math.min(e + this._degreesPerLine, 360)
                  , n = s.MathUtils.degToRad(e)
                  , o = s.MathUtils.degToRad(i);
                for (let e = -90; e < 90; e += this._degreesPerLine) {
                    const i = Math.min(e + this._degreesPerLine, 90)
                      , a = s.MathUtils.degToRad(e)
                      , r = s.MathUtils.degToRad(i);
                    -90 < e && e < 90 && (t.push(new s.Vector3(Math.sin(n) * Math.cos(a),Math.cos(n) * Math.cos(a),Math.sin(a))),
                    t.push(new s.Vector3(Math.sin(o) * Math.cos(a),Math.cos(o) * Math.cos(a),Math.sin(a)))),
                    t.push(new s.Vector3(Math.sin(n) * Math.cos(a),Math.cos(n) * Math.cos(a),Math.sin(a))),
                    t.push(new s.Vector3(Math.sin(n) * Math.cos(r),Math.cos(n) * Math.cos(r),Math.sin(r)))
                }
            }
            const e = [];
            for (let i = 0, s = t.length; i < s; i++)
                e.push(this._color);
            const i = [];
            for (let e = 0, s = t.length; e < s; e++)
                i.push(2);
            this._lineMesh.setPositions(t),
            this._lineMesh.setColors(e),
            this._lineMesh.setWidths(i),
            s.ThreeJsHelper.setOrientation(this.getThreeJsObjects(), s.Quaternion.Identity),
            s.ThreeJsHelper.setScale(this.getThreeJsObjects(), this.getRadius()),
            this._meshDirty = !1
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        ConstellationsComponent: function() {
            return ConstellationsComponent
        }
    });
    var s = i(5)
      , n = i(552);
    class ConstellationsComponent extends s.BaseComponent {
        constructor(t, e) {
            super(t, e),
            this._url = "",
            this._database = [],
            this._numVertices = [],
            this._labelEntities = [],
            this._color = new s.Color,
            this._lineWidth = 2,
            this._glowWidth = 0,
            this._highlightedIndex = void 0,
            this._highlightColor = new s.Color,
            this._highlightWidth = 0,
            this._lineMeshes = [],
            this.__setRadius(Number.POSITIVE_INFINITY)
        }
        setColor(t) {
            this._color.copy(t);
            for (let t = 0; t < this._lineMeshes.length; t++) {
                const e = [];
                for (let i = 0; i < this._numVertices[t]; i++)
                    e.push(this._color);
                this._lineMeshes[t].setColors(e)
            }
        }
        setLineWidth(t) {
            this._lineWidth = t;
            for (let e = 0; e < this._lineMeshes.length; e++)
                this._lineMeshes[e].setWidths(t)
        }
        setGlowWidth(t) {
            this._glowWidth = t;
            for (let t = 0, e = this._lineMeshes.length; t < e; t++)
                this._lineMeshes[t].setGlowWidth(this._glowWidth)
        }
        setUrl(t) {
            this._url = t,
            this.resetResources()
        }
        getNames() {
            const t = [];
            for (let e = 0, i = this._database.length; e < i; e++)
                t.push(this._database[e].name);
            return t
        }
        setHighlight(t, e, i) {
            if (this._lineMeshes.length > 0 && void 0 !== this._highlightedIndex) {
                const t = [];
                for (let e = 0, i = this._numVertices[this._highlightedIndex]; e < i; e++)
                    t.push(this._color);
                this._lineMeshes[this._highlightedIndex].setColors(t),
                this._lineMeshes[this._highlightedIndex].setWidths(this._lineWidth)
            }
            if (this._highlightedIndex = t,
            this._highlightColor.copy(e),
            this._highlightWidth = i,
            this._lineMeshes.length > 0 && void 0 !== this._highlightedIndex) {
                const t = [];
                for (let e = 0, i = this._numVertices[this._highlightedIndex]; e < i; e++)
                    t.push(this._highlightColor);
                this._lineMeshes[this._highlightedIndex].setColors(t),
                this._lineMeshes[this._highlightedIndex].setWidths(this._highlightWidth)
            }
        }
        getNearestConstellationIndex(t, e) {
            let i, s = Number.POSITIVE_INFINITY;
            for (let n = 0, o = this._labelEntities.length; n < o; n++) {
                const o = t.distance(this._labelEntities[n].getPixelSpacePosition(e));
                o < s && (s = o,
                i = n)
            }
            return i
        }
        __prepareForRender(t) {
            s.ThreeJsHelper.setPositionToEntity(this.getThreeJsObjects(), this.getEntity(), t);
            for (let e = 0; e < this._lineMeshes.length; e++)
                this._lineMeshes[e].prepareForRender(t)
        }
        async __loadResources() {
            this._labelEntities = [],
            this._lineMeshes = [],
            this._numVertices = [];
            const t = await this.getEntity().getScene().getEngine().getDownloader().download(this._url, "binary", -this.getEntity().getLeastCameraDepth());
            if ("completed" === t.status && t.content instanceof ArrayBuffer) {
                const e = new s.Reader(t.content);
                for (; !e.isAtEnd(); ) {
                    const t = {
                        name: "",
                        stars: [],
                        segments: [],
                        color: []
                    };
                    t.name = e.readString(e.readByte()),
                    t.color = [e.readByte(), e.readByte(), e.readByte(), e.readByte()];
                    const i = e.readByte();
                    for (let s = 0; s < i; s++)
                        t.stars.push([e.readFloat32(), e.readFloat32(), e.readFloat32()]);
                    const s = 2 * e.readByte();
                    for (let i = 0; i < s; i++)
                        t.segments.push(e.readByte());
                    this._database.push(t)
                }
            }
            for (let t = 0; t < this._database.length; t++) {
                const e = this._database[t].stars
                  , i = this._database[t].segments
                  , n = []
                  , o = []
                  , a = [];
                for (let r = 0; r < i.length; r++) {
                    const l = i[r];
                    n.push(new s.Vector3(e[l][2],-e[l][0],e[l][1])),
                    o.push(t === this._highlightedIndex ? this._highlightColor : this._color),
                    a.push(t === this._highlightedIndex ? this._highlightWidth : this._lineWidth)
                }
                const r = new s.LineMesh(this);
                r.setPositions(n),
                r.setColors(o),
                r.setWidths(a),
                r.setGlowWidth(this._glowWidth),
                this._lineMeshes.push(r),
                this._numVertices.push(i.length)
            }
            s.ThreeJsHelper.setOrientation(this.getThreeJsObjects(), n.SceneHelpers.getEclipJ2000ToJ2000Rotation());
            for (let t = 0; t < this._database.length; t++) {
                const e = this._database[t].stars
                  , i = new s.Vector3(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY)
                  , o = new s.Vector3(Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY)
                  , a = Math.sqrt(e[0][0] * e[0][0] + e[0][1] * e[0][1] + e[0][2] * e[0][2]);
                for (let t = 0; t < e.length; t++) {
                    const r = e[t]
                      , l = new s.Vector3;
                    l.set(r[2], -r[0], r[1]),
                    l.rotate(n.SceneHelpers.getEclipJ2000ToJ2000Rotation(), l),
                    l.normalize(l),
                    l.mult(l, a),
                    i.x > l.x && (i.x = l.x),
                    o.x < l.x && (o.x = l.x),
                    i.y > l.y && (i.y = l.y),
                    o.y < l.y && (o.y = l.y),
                    i.z > l.z && (i.z = l.z),
                    o.z < l.z && (o.z = l.z)
                }
                const r = new s.Vector3;
                r.add(i, o),
                r.mult(r, .5);
                const l = this.getEntity().getScene().addEntity(`constellation_label_${this._database[t].name}`);
                l.setParent(this.getEntity()),
                l.setOrientation(s.Quaternion.Identity),
                l.setPosition(r);
                const c = l.addComponent(s.DivComponent);
                c.setAlignment(new s.Vector2(.5,.5));
                const h = c.getDiv();
                h.classList.add("pioneer-constellation-label"),
                h.innerHTML = this._database[t].name,
                this._labelEntities.push(l)
            }
        }
        __unloadResources() {
            for (let t = 0; t < this._labelEntities.length; t++)
                this.getEntity().getScene().removeEntity(this._labelEntities[t]);
            s.ThreeJsHelper.destroyAllObjectsAndMaterials(this),
            this._lineMeshes = [],
            this._database = []
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        DiscGridComponent: function() {
            return DiscGridComponent
        }
    });
    var s = i(5);
    class DiscGridComponent extends s.BaseComponent {
        constructor(t, e) {
            super(t, e),
            this._size = 1,
            this._color = new s.Color(1,1,1,1),
            this._color.freeze(),
            this._lineWidth = 1,
            this._numCircles = 10,
            this._numSpokes = 20,
            this._radialPower = 1,
            this._ignoreDistance = !1,
            this._lineMesh = null,
            this._meshDirty = !0,
            this.__setRadius(this._size),
            this.__setUsesEntityOrientation(!0)
        }
        getSize() {
            return this._size
        }
        setSize(t) {
            this._size = t,
            this.__setRadius(this._size),
            null !== this._lineMesh && this._lineMesh.setScale(this._size)
        }
        getColor() {
            return this._color
        }
        setColor(t) {
            this._color.thaw(),
            this._color.copy(t),
            this._color.freeze(),
            this._meshDirty = !0
        }
        getLineWidth() {
            return this._lineWidth
        }
        setLineWidth(t) {
            this._lineWidth = t,
            null !== this._lineMesh && this._lineMesh.setWidths(this._lineWidth)
        }
        getNumCircles() {
            return this._numCircles
        }
        setNumCircles(t) {
            this._numCircles = t,
            this._meshDirty = !0
        }
        getNumSpokes() {
            return this._numSpokes
        }
        setNumSpokes(t) {
            this._numSpokes = t,
            this._meshDirty = !0
        }
        getRadialPower() {
            return this._radialPower
        }
        setRadialPower(t) {
            this._radialPower = t,
            this._meshDirty = !0
        }
        setIgnoreDistance(t) {
            this._ignoreDistance = t
        }
        __prepareForRender(t) {
            if (this._lineMesh) {
                if (this._meshDirty && this._updateMesh(),
                !this._ignoreDistance) {
                    const e = (.02 - this.getEntity().getNormalSpaceExtentsRadius(t)) / .02;
                    this._lineMesh.setAlphaMultiplier(e)
                }
                this._lineMesh.prepareForRender(t);
                for (let e = 0, i = this.getThreeJsObjects().length; e < i; e++)
                    s.ThreeJsHelper.setOrientationToEntity(this.getThreeJsObjects()[e], this.getEntity()),
                    s.ThreeJsHelper.setPositionToEntity(this.getThreeJsObjects()[e], this.getEntity(), t)
            }
        }
        async __loadResources() {
            this._lineMesh = new s.LineMesh(this),
            this._updateMesh(),
            this._lineMesh.setScale(this._size)
        }
        __unloadResources() {
            s.ThreeJsHelper.destroyAllObjectsAndMaterials(this),
            this._lineMesh = null
        }
        _updateMesh() {
            if (!this._lineMesh)
                return;
            const t = [];
            for (let e = 1; e <= this._numCircles; e++) {
                const i = 1 !== this._radialPower ? this._radialPower ** (e - this._numCircles) : e / this._numCircles
                  , n = 50;
                for (let e = 0; e < n; e++) {
                    const o = e / n * s.MathUtils.twoPi
                      , a = (e + 1) % n / n * s.MathUtils.twoPi;
                    t.push(new s.Vector3(i * Math.cos(o),i * Math.sin(o),0)),
                    t.push(new s.Vector3(i * Math.cos(a),i * Math.sin(a),0))
                }
            }
            for (let e = 0; e < this._numSpokes; e++) {
                const i = e / this._numSpokes * s.MathUtils.twoPi;
                t.push(s.Vector3.Zero),
                t.push(new s.Vector3(Math.cos(i),Math.sin(i),0))
            }
            const e = [];
            for (let i = 0, s = t.length; i < s; i++)
                e.push(this._color);
            this._lineMesh.setPositions(t),
            this._lineMesh.setColors(e),
            this._lineMesh.setWidths(this._lineWidth),
            this._meshDirty = !1
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        ShadowConeComponent: function() {
            return ShadowConeComponent
        }
    });
    var s = i(5);
    class ShadowConeComponent extends s.BaseComponent {
        constructor(t, e) {
            super(t, e),
            this._color = new s.Color(1,1,1,1),
            this._color.freeze(),
            this._sourceEntity = new s.EntityRef(this.getEntity().getScene()),
            this._shadowType = "umbra",
            this._targetEntity = new s.EntityRef(this.getEntity().getScene()),
            this._visibleDistanceInterval = new s.Interval(0,Number.POSITIVE_INFINITY),
            this._visibleDistanceInterval.freeze(),
            this._alphaMultiplier = 1,
            this._numberOfCirclePoints = 20,
            this.__setRadius(Number.POSITIVE_INFINITY)
        }
        getColor() {
            return this._color
        }
        setColor(t) {
            this._color.thaw(),
            this._color.copy(t),
            this._color.freeze(),
            s.ThreeJsHelper.setUniformColorRGBA(this.getThreeJsMaterials()[0], "color", this._color, this._alphaMultiplier)
        }
        getSourceEntity() {
            return this._sourceEntity.getName()
        }
        setSourceEntity(t) {
            this._sourceEntity.setName(t)
        }
        getTargetEntity() {
            return this._targetEntity.getName()
        }
        setTargetEntity(t) {
            this._targetEntity.setName(t)
        }
        getShadowType() {
            return this._shadowType
        }
        setShadowType(t) {
            this._shadowType = t,
            this.resetResources()
        }
        getVisibleDistanceInterval() {
            return this._visibleDistanceInterval
        }
        setVisibleDistanceInterval(t) {
            this._visibleDistanceInterval.thaw(),
            this._visibleDistanceInterval.copy(t),
            this._visibleDistanceInterval.freeze()
        }
        __prepareForRender(t) {
            this._updateMesh(),
            s.ThreeJsHelper.setPositionToEntity(this.getThreeJsObjects()[0], this.getEntity(), t);
            const e = this.getEntity().getCameraSpacePosition(t).magnitude()
              , i = .5 * (this._visibleDistanceInterval.max - this._visibleDistanceInterval.min)
              , n = Math.min(.5 * this._visibleDistanceInterval.min, i)
              , o = Math.min(.5 * this._visibleDistanceInterval.max, i);
            e < this._visibleDistanceInterval.min + n ? this._alphaMultiplier = Math.max(0, (e - this._visibleDistanceInterval.min) / n) : e > this._visibleDistanceInterval.max - o ? this._alphaMultiplier = Math.max(0, (this._visibleDistanceInterval.max - e) / o) : this._alphaMultiplier = 1,
            s.ThreeJsHelper.setUniformColorRGBA(this.getThreeJsMaterials()[0], "color", this._color, this._alphaMultiplier)
        }
        async __loadResources() {
            const t = this.getEntity().getScene().getEngine().getMaterialManager().getPreloaded("basic_alpha");
            this.getThreeJsMaterials().push(t),
            s.ThreeJsHelper.setUniformColorRGBA(t, "color", this._color, this._alphaMultiplier);
            const e = s.ThreeJsHelper.createMeshObject(this, t, [{
                name: "position",
                dimensions: 3
            }], !1);
            this.getThreeJsObjects().push(e),
            this._createMesh()
        }
        __unloadResources() {
            s.ThreeJsHelper.destroyAllObjectsAndMaterials(this)
        }
        _createMesh() {
            const t = new Float32Array(2 * this._numberOfCirclePoints * 3)
              , e = new Uint16Array(6 * this._numberOfCirclePoints);
            for (let t = 0; t < this._numberOfCirclePoints; t++) {
                const i = (t + 1) % this._numberOfCirclePoints;
                e[6 * t + 0] = t,
                e[6 * t + 1] = i,
                e[6 * t + 2] = i + this._numberOfCirclePoints,
                e[6 * t + 3] = i + this._numberOfCirclePoints,
                e[6 * t + 4] = t + this._numberOfCirclePoints,
                e[6 * t + 5] = t
            }
            const i = this.getThreeJsObjects()[0].geometry;
            s.ThreeJsHelper.setVertices(i, "position", t),
            s.ThreeJsHelper.setIndices(i, e)
        }
        _updateMesh() {
            const t = this._sourceEntity.get();
            if (null === t)
                return;
            const e = this._targetEntity.get()
              , i = t.getExtentsRadius()
              , n = this.getEntity().getExtentsRadius()
              , o = s.Vector3.pool.get();
            this.getEntity().getPositionRelativeToEntity(o, s.Vector3.Zero, t);
            const a = o.magnitude();
            if (o.normalize(o),
            o.isNaN())
                return;
            let r = 10 * n;
            if (null !== e) {
                const t = s.Vector3.pool.get();
                e.getPositionRelativeToEntity(t, s.Vector3.Zero, this.getEntity()),
                r = t.magnitude(),
                s.Vector3.pool.release(t)
            }
            const l = this.getThreeJsObjects()[0].geometry.getAttribute("position")
              , c = l.array;
            let h, d, u, p;
            if ("umbra" === this._shadowType) {
                const t = (i - n) / a
                  , e = n / t
                  , s = t / Math.sqrt(1 - t * t);
                u = n * t,
                p = Math.min(r, e),
                h = s * (e - u),
                d = s * (e - p)
            } else {
                const t = (i + n) / a
                  , e = -n / t
                  , s = t / Math.sqrt(1 - t * t);
                u = -n * t,
                p = r,
                h = -s * (e - u),
                d = -s * (e - p)
            }
            null !== this.getEntity().getComponent(s.SpheroidComponent) && (h *= 1.02);
            for (let t = 0; t < this._numberOfCirclePoints; t++) {
                const e = t / this._numberOfCirclePoints * s.MathUtils.twoPi
                  , i = Math.cos(e)
                  , n = Math.sin(e);
                c[3 * t + 0] = h * i,
                c[3 * t + 1] = h * n,
                c[3 * t + 2] = u,
                c[3 * (t + this._numberOfCirclePoints) + 0] = d * i,
                c[3 * (t + this._numberOfCirclePoints) + 1] = d * n,
                c[3 * (t + this._numberOfCirclePoints) + 2] = p
            }
            l.needsUpdate = !0;
            const m = s.Quaternion.pool.get()
              , _ = s.Quaternion.pool.get()
              , g = s.Vector3.pool.get();
            m.copyFromThreeJs(this.getThreeJsObjects()[0].quaternion),
            m.getAxis(g, 2),
            _.setFromVectorFromTo(g, o),
            m.mult(_, m),
            s.ThreeJsHelper.setOrientation(this.getThreeJsObjects()[0], m),
            s.Quaternion.pool.release(m),
            s.Vector3.pool.release(g),
            s.Quaternion.pool.release(_),
            s.Vector3.pool.release(o)
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        FrustumComponent: function() {
            return FrustumComponent
        }
    });
    var s = i(5);
    class FrustumComponent extends s.BaseComponent {
        constructor(t, e) {
            super(t, e),
            this._frustumType = "pyramid",
            this._color = new s.Color(1,1,1,1),
            this._color.freeze(),
            this._lineWidth = 1,
            this._lineMesh = null,
            this._visibleDistanceInterval = new s.Interval(0,Number.POSITIVE_INFINITY),
            this._visibleDistanceInterval.freeze(),
            this._intersectionEntities = [],
            this._alphaMultiplier = 1,
            this._length = 1,
            this._hFOVRad = 1,
            this._vFOVRad = 1,
            this._nearBase = new s.Vector2(0,0),
            this._nearBase.freeze(),
            this._farBase = new s.Vector2(0,0),
            this._farBase.freeze(),
            this._originOffset = new s.Vector3(0,0,0),
            this._originOffset.freeze(),
            this._direction = new s.Vector3(1,0,0),
            this._direction.freeze(),
            this._spinAngle = 0,
            this._relativeToEntityOrientation = !0,
            this._numberOfCirclePoints = 24,
            this._numConeLines = 2,
            this._hiddenPyramidEdges = [],
            this._keyframes = [],
            this._useKeyframes = !1
        }
        getFrustumType() {
            return this._frustumType
        }
        setFrustumType(t) {
            this._frustumType = t
        }
        getIntersectionEntities() {
            return this._intersectionEntities
        }
        setIntersectionEntities(t) {
            this._intersectionEntities = t
        }
        getHorizontalFOV() {
            return this._hFOVRad
        }
        getVerticalFOV() {
            return this._vFOVRad
        }
        setFOVRadians(t, e=t) {
            this._hFOVRad = t,
            this._vFOVRad = e,
            this._farBase.thaw(),
            this._farBaseFromLengthAndFOV(this._farBase, this._length, t, e),
            this._farBase.freeze()
        }
        setFOVDegrees(t, e=t) {
            this.setFOVRadians(s.MathUtils.degToRad(t), s.MathUtils.degToRad(e))
        }
        getLength() {
            return this._length
        }
        setLength(t) {
            this._length = t,
            this.setFOVRadians(this._hFOVRad, this._vFOVRad)
        }
        getNearBase(t) {
            return t.copy(this._nearBase)
        }
        getFarBase(t) {
            return t.copy(this._farBase)
        }
        setNearBase(t, e=t) {
            this._nearBase.thaw(),
            this._nearBase.set(t, e),
            this._nearBase.freeze(),
            this._updateFOVFromBases()
        }
        setFarBase(t, e=t) {
            this._farBase.thaw(),
            this._farBase.set(t, e),
            this._farBase.freeze(),
            this._updateFOVFromBases()
        }
        getColor() {
            return this._color
        }
        setColor(t) {
            this._color.thaw(),
            this._color.copy(t),
            this._color.freeze()
        }
        getAlphaMultiplier() {
            return this._alphaMultiplier
        }
        setAlphaMultiplier(t) {
            this._alphaMultiplier = t,
            this._color.thaw(),
            this._color.a = t,
            this._color.freeze()
        }
        getVisibleDistanceInterval() {
            return this._visibleDistanceInterval
        }
        setVisibleDistanceInterval(t) {
            this._visibleDistanceInterval.thaw(),
            this._visibleDistanceInterval.copy(t),
            this._visibleDistanceInterval.freeze()
        }
        getOriginOffset() {
            return this._originOffset
        }
        setOriginOffset(t) {
            this._originOffset.thaw(),
            this._originOffset.copy(t),
            this._originOffset.freeze()
        }
        getDirection() {
            return this._direction
        }
        setDirection(t) {
            this._direction.thaw(),
            this._direction.normalize(t),
            this._direction.freeze()
        }
        getSpinAngle() {
            return this._spinAngle
        }
        setSpinAngle(t) {
            this._spinAngle = t
        }
        getNumberOfCirclePoints() {
            return this._numberOfCirclePoints
        }
        setNumberOfCirclePoints(t) {
            this._numberOfCirclePoints = t
        }
        getNumConeLines() {
            return this._numConeLines
        }
        setNumConeLines(t) {
            this._numConeLines = t
        }
        getHiddenPyramidEdges() {
            return this._hiddenPyramidEdges
        }
        setHiddenPyramidEdges(t) {
            this._hiddenPyramidEdges = t
        }
        getRelativeToEntityOrientation() {
            return this._relativeToEntityOrientation
        }
        getKeyframes() {
            return this._keyframes
        }
        setKeyframes(t) {
            this._keyframes = t,
            this._updateMesh()
        }
        getUseKeyframes() {
            return this._useKeyframes
        }
        setUseKeyframes(t) {
            this._useKeyframes = t,
            this._updateMesh()
        }
        setRelativeToEntityOrientation(t) {
            this._relativeToEntityOrientation = t
        }
        _farBaseFromLengthAndFOV(t, e, i, s) {
            e += this._nearBase.x / 2 / Math.tan(i / 2),
            t.set(Math.tan(i / 2) * e * 2, Math.tan(s / 2) * e * 2)
        }
        _updateFOVFromBases() {
            if (this._nearBase.x > 0 && this._length > 0) {
                const t = this._nearBase.x / 2 / Math.tan(this._hFOVRad / 2) + this._length;
                this._hFOVRad = 2 * Math.atan(this._farBase.x / 2 / t),
                this._vFOVRad = 2 * Math.atan(this._farBase.y / 2 / t)
            }
        }
        async __loadResources() {
            this._lineMesh = new s.LineMesh(this),
            this._updateMesh()
        }
        __unloadResources() {
            s.ThreeJsHelper.destroyAllObjectsAndMaterials(this),
            this._lineMesh = null
        }
        __prepareForRender(t) {
            if (!this._lineMesh)
                return;
            if (this._updateMesh(),
            this._relativeToEntityOrientation) {
                const t = s.Vector3.pool.get()
                  , e = s.Vector3.pool.get();
                t.rotate(this.getEntity().getOrientation(), this._originOffset),
                e.rotate(this.getEntity().getOrientation(), this._direction),
                s.Vector3.pool.release(t),
                s.Vector3.pool.release(e)
            }
            s.ThreeJsHelper.setPositionToEntity(this.getThreeJsObjects()[0], this.getEntity(), t);
            const e = this.getEntity().getCameraSpacePosition(t).magnitude()
              , i = .5 * (this._visibleDistanceInterval.max - this._visibleDistanceInterval.min)
              , n = Math.min(.5 * this._visibleDistanceInterval.min, i)
              , o = Math.min(.5 * this._visibleDistanceInterval.max, i);
            e < this._visibleDistanceInterval.min + n ? this.setAlphaMultiplier(Math.max(0, (e - this._visibleDistanceInterval.min) / n)) : e > this._visibleDistanceInterval.max - o ? this.setAlphaMultiplier(Math.max(0, (this._visibleDistanceInterval.max - e) / o)) : this.setAlphaMultiplier(1),
            this._lineMesh.prepareForRender(t)
        }
        _updateMesh() {
            if (!this._lineMesh)
                return;
            const t = [];
            if (this._useKeyframes) {
                if (0 === this._keyframes.length)
                    return void this._updateLineMesh(t);
                const e = this.getEntity().getScene().getEngine().getTime()
                  , i = s.Sort.getIndex(e, this._keyframes, ( (t, e) => t[1] < e))
                  , n = this._keyframes[i][0]
                  , o = this._keyframes[i][1];
                if (n > e || e >= o)
                    return void this._updateLineMesh(t)
            }
            let e = this._direction
              , i = this._originOffset
              , n = s.Vector3.YAxis
              , o = s.Vector3.XAxis;
            if (this._relativeToEntityOrientation) {
                n = s.Vector3.pool.get(),
                n.set(0, 1, 0),
                n.rotate(this.getEntity().getOrientation(), n),
                o = s.Vector3.pool.get(),
                o.set(1, 0, 0),
                o.rotate(this.getEntity().getOrientation(), o);
                const t = s.Vector3.pool.get()
                  , a = s.Vector3.pool.get();
                t.rotate(this.getEntity().getOrientation(), this._direction),
                a.rotate(this.getEntity().getOrientation(), this._originOffset),
                e = t,
                i = a
            }
            let a = this._length
              , r = this._farBase;
            if (this._intersectionEntities.length > 0) {
                const t = s.Interval.pool.get()
                  , i = s.Vector3.pool.get();
                i.setMagnitude(e, this._length);
                const n = s.Vector3.pool.get();
                this._intersectionEntities.forEach((e => {
                    const o = this.getEntity().getScene().getEntity(e);
                    if (o && (o.getPositionRelativeToEntity(n, s.Vector3.Zero, this.getEntity()),
                    s.Geometry.getLineSphereIntersectionWithLineStartAtOrigin(t, i, n, o.getExtentsRadius()),
                    !isNaN(t.min) && t.min >= 0 && t.min <= 1)) {
                        const e = t.min * this._length
                          , i = e > 100 ? 11 : 5;
                        a = Math.min(a, e - i)
                    }
                }
                )),
                s.Interval.pool.release(t),
                s.Vector3.pool.release(n),
                s.Vector3.pool.release(i),
                a < this._length && (r = s.Vector2.pool.get(),
                this._farBaseFromLengthAndFOV(r, a, this._hFOVRad, this._vFOVRad))
            }
            const l = s.Vector3.pool.get()
              , c = s.Vector3.pool.get()
              , h = s.Vector3.pool.get();
            h.set(i.x + e.x * a, i.y + e.y * a, i.z + e.z * a);
            const d = s.Quaternion.pool.get();
            d.setFromAxisAngle(e, this._spinAngle),
            l.cross(e, n),
            l.isZero() && l.cross(e, o),
            l.normalize(l),
            c.cross(e, l),
            c.normalize(c),
            l.rotate(d, l),
            c.rotate(d, c);
            const u = .5 * this._nearBase.x
              , p = .5 * this._nearBase.y
              , m = .5 * r.x
              , _ = .5 * r.y;
            function g(t, e, i, n, o) {
                const a = e * n
                  , r = i * o;
                return new s.Vector3(t.x + a * l.x + r * c.x,t.y + a * l.y + r * c.y,t.z + a * l.z + r * c.z)
            }
            if ("pyramid" === this._frustumType) {
                const e = [g(i, -1, -1, u, p), g(i, 1, -1, u, p), g(i, 1, 1, u, p), g(i, -1, 1, u, p), g(h, -1, -1, m, _), g(h, 1, -1, m, _), g(h, 1, 1, m, _), g(h, -1, 1, m, _)];
                for (let i = 0; i < 4; i++)
                    t.push(e[i], e[(i + 1) % 4]),
                    t.push(e[4 + i], e[4 + (i + 1) % 4]),
                    this._hiddenPyramidEdges.includes(i) || t.push(e[i], e[4 + i])
            } else if ("cone" === this._frustumType) {
                const e = 2 * Math.PI / this._numberOfCirclePoints;
                let s = e
                  , n = g(i, u, p, 1, 0)
                  , o = g(h, m, _, 1, 0);
                for (let a = 0; a < this._numberOfCirclePoints; a++) {
                    const a = g(i, u, p, Math.cos(s), Math.sin(s))
                      , r = g(h, m, _, Math.cos(s), Math.sin(s));
                    t.push(n, a),
                    t.push(o, r),
                    n = a,
                    o = r,
                    s += e
                }
                for (let e = 0; e < this._numConeLines; e++) {
                    const s = e * (2 * Math.PI / this._numConeLines)
                      , n = g(i, u, p, Math.cos(s), Math.sin(s))
                      , o = g(h, m, _, Math.cos(s), Math.sin(s));
                    t.push(n, o)
                }
            }
            s.Vector3.pool.release(l),
            s.Vector3.pool.release(c),
            s.Vector3.pool.release(h),
            s.Quaternion.pool.release(d),
            this._relativeToEntityOrientation && (s.Vector3.pool.release(n),
            s.Vector3.pool.release(o),
            s.Vector3.pool.release(e),
            s.Vector3.pool.release(i)),
            a < this._length && s.Vector2.pool.release(r),
            this._updateLineMesh(t)
        }
        _updateLineMesh(t) {
            if (!this._lineMesh)
                return;
            const e = [];
            for (let i = 0, s = t.length; i < s; i++)
                e.push(this._color);
            const i = [];
            for (let e = 0, s = t.length; e < s; e++)
                i.push(this._lineWidth);
            this._lineMesh.setPositions(t),
            this._lineMesh.setColors(e),
            this._lineMesh.setWidths(i)
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        OrbitLineComponent: function() {
            return OrbitLineComponent
        }
    });
    var s = i(5);
    class OrbitLineComponent extends s.BaseComponent {
        constructor(t, e) {
            super(t, e),
            this._color = new s.Color(1,1,1,1),
            this._color.freeze(),
            this._farSideAlphaFade = 1,
            this._lineWidth = 5,
            this._glowWidth = 0,
            this._lineMesh = null,
            this._positions = [],
            this._colors = [],
            this._widths = [],
            this._pixelSpaceRadiiAlphaFade = [5, 1],
            this.__setRadius(Number.POSITIVE_INFINITY)
        }
        getColor() {
            return this._color
        }
        setColor(t) {
            if (this._color.thaw(),
            this._color.copy(t),
            this._color.freeze(),
            null !== this._lineMesh) {
                for (let t = 0, e = this._colors.length; t < e; t++)
                    this._colors[t].copy(this._color);
                this._lineMesh.setColors(this._colors)
            }
        }
        getFarSideAlphaFade() {
            return this._farSideAlphaFade
        }
        setFarSideAlphaFade(t) {
            this._farSideAlphaFade = t
        }
        getLineWidth() {
            return this._lineWidth
        }
        setLineWidth(t) {
            if (this._lineWidth = t,
            null !== this._lineMesh) {
                for (let t = 0, e = this._widths.length; t < e; t++)
                    this._widths[t] = this._lineWidth;
                this._lineMesh.setWidths(this._widths)
            }
        }
        setGlowWidth(t) {
            this._glowWidth = t,
            s.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], "glowWidth", this._glowWidth)
        }
        setPixelSpaceRadiiAlphaFade(t, e) {
            this._pixelSpaceRadiiAlphaFade[0] = t,
            this._pixelSpaceRadiiAlphaFade[1] = e
        }
        __prepareForRender(t) {
            if (!this._lineMesh)
                return;
            this._updateMesh();
            const e = this.getEntity().getPixelSpaceExtentsRadius(t);
            if (isNaN(e))
                this._lineMesh.setAlphaMultiplier(1);
            else {
                const t = (e - this._pixelSpaceRadiiAlphaFade[0]) / (this._pixelSpaceRadiiAlphaFade[1] - this._pixelSpaceRadiiAlphaFade[0]);
                this._lineMesh.setAlphaMultiplier(s.MathUtils.lerp(0, 1, s.MathUtils.clamp01(t)))
            }
            s.ThreeJsHelper.setPositionToEntity(this.getThreeJsObjects(), this.getEntity(), t),
            this._lineMesh.prepareForRender(t)
        }
        async __loadResources() {
            this._lineMesh = new s.LineMesh(this);
            for (let t = 0, e = 720; t < e; t++)
                this._positions.push(new s.Vector3),
                this._colors.push(new s.Color),
                this._colors[t].copy(this._color),
                this._widths.push(this._lineWidth);
            this._lineMesh.setColors(this._colors),
            this._lineMesh.setWidths(this._widths),
            this._lineMesh.setGlowWidth(this._glowWidth)
        }
        __unloadResources() {
            this._positions = [],
            this._colors = [],
            this._widths = [],
            s.ThreeJsHelper.destroyAllObjectsAndMaterials(this),
            this._lineMesh = null
        }
        _updateMesh() {
            if (!this._lineMesh)
                return;
            const t = this.getEntity()
              , e = t.getScene().getEngine().getTime();
            let i = 0;
            for (let n = t.getNumControllers() - 1; n >= 0; n--) {
                const o = t.getController(s.DynamoController, n);
                if (null !== o && o.getCoverage().contains(e) && "orb" === o.getPointType()) {
                    i = o.getHeaderValue("gravitationalParameter1") + o.getHeaderValue("gravitationalParameter2");
                    break
                }
            }
            OrbitLineComponent.orbitalElements.setFromPositionAndVelocity(t.getPosition(), t.getVelocity(), e, i);
            const n = t.getPosition()
              , o = OrbitLineComponent.orbitalElements.getTrueAnomalyFromPosition(n)
              , a = OrbitLineComponent.orbitalElements.getEccentricAnomalyFromTrueAnomaly(o);
            let r = !1;
            for (let t = 0; t < 360; t += 1) {
                const e = 2 * t
                  , i = (2 * t - 1 + this._positions.length) % this._positions.length;
                let o = OrbitLineComponent.orbitalElements.getEccentricAnomalyFromTrueAnomaly(s.MathUtils.degToRad(t - 180));
                const l = OrbitLineComponent.orbitalElements.getEccentricAnomalyFromTrueAnomaly(s.MathUtils.degToRad(t + 1 - 180));
                (o < a && a < l || l < a && a < o) && (o = a);
                const c = OrbitLineComponent.orbitalElements.getMeanAnomalyFromEccentricAnomaly(o)
                  , h = OrbitLineComponent.orbitalElements.epoch + (c - OrbitLineComponent.orbitalElements.meanAnomalyAtEpoch) / OrbitLineComponent.orbitalElements.meanAngularMotion
                  , d = this._positions[e];
                if (OrbitLineComponent.orbitalElements.project(d, OrbitLineComponent.velocity, h),
                d.sub(d, n),
                this._positions[i].copy(d),
                isNaN(c)) {
                    r = !0;
                    const t = (e + 1) % this._positions.length
                      , s = (i - 1 + this._positions.length) % this._positions.length;
                    this._positions[e].set(0, 0, 0),
                    this._positions[i].set(0, 0, 0),
                    this._positions[t].set(0, 0, 0),
                    this._positions[s].set(0, 0, 0),
                    this._colors[e].a = 0,
                    this._colors[i].a = 0,
                    this._colors[t].a = 0,
                    this._colors[s].a = 0;
                    continue
                }
                let u = s.MathUtils.angle(o, a) / Math.PI;
                u = s.MathUtils.clamp01(u);
                const p = s.MathUtils.lerp(1, this._farSideAlphaFade, u);
                this._colors[e].mult(this._color, p),
                r || this._colors[i].mult(this._color, p),
                r = !1
            }
            OrbitLineComponent.orbitalElements.eccentricity >= 1 && (this._positions[this._positions.length - 2].copy(this._positions[this._positions.length - 3]),
            this._positions[this._positions.length - 1].copy(this._positions[this._positions.length - 3]),
            this._colors[this._colors.length - 2].a = 0,
            this._colors[this._colors.length - 1].a = 0),
            this._lineMesh.setPositions(this._positions),
            this._lineMesh.setColors(this._colors)
        }
        static orbitalElements = new s.OrbitalElements;
        static velocity = new s.Vector3
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        TorusComponent: function() {
            return TorusComponent
        }
    });
    var s = i(5);
    class TorusComponent extends s.BaseComponent {
        constructor(t, e) {
            super(t, e),
            this._color = new s.Color(1,1,1,1),
            this._color.freeze(),
            this._innerRadius = 1,
            this._outerRadius = 10,
            this._visibleDistanceInterval = new s.Interval(0,Number.POSITIVE_INFINITY),
            this._visibleDistanceInterval.freeze(),
            this._alphaMultiplier = 1,
            this.__setRadius(this._outerRadius),
            this.__setUsesEntityOrientation(!0)
        }
        getColor() {
            return this._color
        }
        setColor(t) {
            this._color.thaw(),
            this._color.copy(t),
            this._color.freeze(),
            s.ThreeJsHelper.setUniformColorRGBA(this.getThreeJsMaterials()[0], "color", this._color, this._alphaMultiplier)
        }
        getInnerRadius() {
            return this._innerRadius
        }
        setInnerRadius(t) {
            this._innerRadius = t,
            this.resetResources()
        }
        getOuterRadius() {
            return this._outerRadius
        }
        setOuterRadius(t) {
            this._outerRadius = t,
            this.__setRadius(this._outerRadius),
            this.resetResources()
        }
        getVisibleDistanceInterval() {
            return this._visibleDistanceInterval
        }
        setVisibleDistanceInterval(t) {
            this._visibleDistanceInterval.thaw(),
            this._visibleDistanceInterval.copy(t),
            this._visibleDistanceInterval.freeze()
        }
        __prepareForRender(t) {
            s.ThreeJsHelper.setOrientationToEntity(this.getThreeJsObjects()[0], this.getEntity()),
            s.ThreeJsHelper.setPositionToEntity(this.getThreeJsObjects()[0], this.getEntity(), t);
            const e = this.getEntity().getCameraSpacePosition(t).magnitude()
              , i = .5 * (this._visibleDistanceInterval.max - this._visibleDistanceInterval.min)
              , n = Math.min(.5 * this._visibleDistanceInterval.min, i)
              , o = Math.min(.5 * this._visibleDistanceInterval.max, i);
            e < this._visibleDistanceInterval.min + n ? this._alphaMultiplier = Math.max(0, (e - this._visibleDistanceInterval.min) / n) : e > this._visibleDistanceInterval.max - o ? this._alphaMultiplier = Math.max(0, (this._visibleDistanceInterval.max - e) / o) : this._alphaMultiplier = 1,
            s.ThreeJsHelper.setUniformColorRGBA(this.getThreeJsMaterials()[0], "color", this._color, this._alphaMultiplier)
        }
        async __loadResources() {
            const t = this.getEntity().getScene().getEngine().getMaterialManager().getPreloaded("basic_alpha");
            this.getThreeJsMaterials().push(t),
            s.ThreeJsHelper.setUniformColorRGBA(t, "color", this._color, this._alphaMultiplier);
            const e = s.ThreeJsHelper.createMeshObject(this, t, [{
                name: "position",
                dimensions: 3
            }], !1);
            this.getThreeJsObjects().push(e),
            this._createMesh()
        }
        __unloadResources() {
            s.ThreeJsHelper.destroyAllObjectsAndMaterials(this)
        }
        _createMesh() {
            const t = 100
              , e = 20
              , i = new Float32Array(6e3)
              , n = new Uint16Array(12e3)
              , o = (this._outerRadius + this._innerRadius) / 2
              , a = (this._outerRadius - this._innerRadius) / 2;
            for (let r = 0; r < t; r++) {
                const l = r / t * s.MathUtils.twoPi
                  , c = Math.cos(l)
                  , h = Math.sin(l);
                for (let l = 0; l < e; l++) {
                    const d = l / e * s.MathUtils.twoPi
                      , u = Math.cos(d)
                      , p = Math.sin(d)
                      , m = 3 * (r * e + l);
                    i[m + 0] = c * (o + a * u),
                    i[m + 1] = h * (o + a * u),
                    i[m + 2] = a * p;
                    const _ = 6 * (r * e + l)
                      , g = (r + 1) % t
                      , y = (l + 1) % e;
                    n[_ + 0] = r * e + l,
                    n[_ + 1] = g * e + l,
                    n[_ + 2] = r * e + y,
                    n[_ + 3] = g * e + y,
                    n[_ + 4] = r * e + y,
                    n[_ + 5] = g * e + l
                }
            }
            const r = this.getThreeJsObjects()[0].geometry;
            s.ThreeJsHelper.setVertices(r, "position", i),
            s.ThreeJsHelper.setIndices(r, n)
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        WMTSComponent: function() {
            return WMTSComponent
        }
    });
    var s = i(5)
      , n = i(563);
    class WMTSComponent extends s.BaseComponent {
        constructor(t, e) {
            super(t, e),
            this._capabilities = null,
            this._endPoint = "",
            this._layerIdentifier = "",
            this._tileMatrixSetIdentifier = "",
            this._style = "",
            this._dimensionValues = new Map,
            this._minLevel = Number.NEGATIVE_INFINITY,
            this._maxLevel = Number.POSITIVE_INFINITY,
            this._materialOptions = new Set,
            this._splitJoinThresholdFactor = 512,
            this._layer = null,
            this._tileMatrixSet = null,
            this._tileUrl = "",
            this._shadowEntities = [],
            this._engine = this.getEntity().getScene().getEngine(),
            this._cameraPositions = [],
            this._rootTile = null,
            this._tilePixelSize = void 0,
            this._tilesLoadedPromise = null,
            this._transitionsCompleteCallback = null,
            this._loadsThisFrame = 0,
            this._atmosphereComponentRef = new s.ComponentRef(this.getEntity().getScene(),s.AtmosphereComponent,this.getEntity().getName()),
            this._spheroidComponentRef = new s.ComponentRef(this.getEntity().getScene(),s.SpheroidComponent,this.getEntity().getName()),
            this._spheroidComponentRef.setRefChangedCallback(this._spheroidRefChangedCallback.bind(this)),
            this._spheroidChangedCallback = this._spheroidChangedCallback.bind(this),
            this.__setUsesEntityOrientation(!0)
        }
        getEndPoint() {
            return this._endPoint
        }
        setEndPoint(t) {
            this._endPoint = t,
            this.resetResources()
        }
        getLayer() {
            return this._layerIdentifier
        }
        setLayer(t) {
            this._layerIdentifier = t,
            this.resetResources()
        }
        getTileMatrixSet() {
            return this._tileMatrixSetIdentifier
        }
        setTileMatrixSet(t) {
            this._tileMatrixSetIdentifier = t,
            this.resetResources()
        }
        getStyle() {
            return this._style
        }
        setStyle(t) {
            this._style = t,
            this.resetResources()
        }
        getDimensionValue(t) {
            return this._dimensionValues.get(t)
        }
        setDimensionValue(t, e) {
            this._dimensionValues.set(t, e),
            this.resetResources()
        }
        getLayers() {
            return null !== this._capabilities ? this._capabilities.layers : new Map
        }
        getMinLevel() {
            return this._minLevel
        }
        setMinLevel(t) {
            this._minLevel = t
        }
        getMaxLevel() {
            return this._maxLevel
        }
        setMaxLevel(t) {
            this._maxLevel = t
        }
        isMaterialOptionEnabled(t) {
            return this._materialOptions.has(t)
        }
        setMaterialOption(t, e) {
            const i = this.getThreeJsMaterials();
            if (e && !this._materialOptions.has(t)) {
                this._materialOptions.add(t);
                for (let e = 0, s = i.length; e < s; e++) {
                    const s = i[e];
                    s.defines[t] = !0,
                    s.needsUpdate = !0
                }
            } else if (!e && this._materialOptions.has(t)) {
                this._materialOptions.delete(t);
                for (let e = 0, s = i.length; e < s; e++) {
                    const s = i[e];
                    delete s.defines[t],
                    s.needsUpdate = !0
                }
            }
        }
        async getTilesLoadedPromise() {
            this._tilesLoadedPromise && await this._tilesLoadedPromise
        }
        setSpheroidReference(t) {
            this._spheroidComponentRef.set(this.getEntity().getName(), t)
        }
        __getLayer() {
            return this._layer
        }
        __getTileMatrixSet() {
            return this._tileMatrixSet
        }
        __getTileUrl() {
            return this._tileUrl
        }
        __getLayerBounds() {
            return null !== this._layer ? this._layer.boundingBox : null
        }
        __getMaxLevel() {
            return this._maxLevel
        }
        __getMinLevel() {
            return this._minLevel
        }
        __getSplitJoinFactor() {
            return this._splitJoinThresholdFactor
        }
        __getTilePixelSize() {
            return this._tilePixelSize
        }
        __setTilePixelSize(t) {
            this._tilePixelSize = t
        }
        __getLoadsThisFrame() {
            return this._loadsThisFrame
        }
        __incLoadsThisFrame() {
            this._loadsThisFrame += 1
        }
        __getCameraPositions() {
            return this._cameraPositions
        }
        __getSpheroidComponent() {
            return this._spheroidComponentRef.get()
        }
        __getMaterialOptions() {
            return this._materialOptions
        }
        __destroy() {
            const t = this._spheroidComponentRef.get();
            null !== t && t.removeChangedCallback(this._spheroidChangedCallback),
            super.__destroy()
        }
        __update() {
            if (this._spheroidComponentRef.update(),
            null === this._rootTile)
                return;
            for (; this._cameraPositions.length > this._engine.getNumViewports(); )
                this._cameraPositions.pop();
            for (; this._cameraPositions.length < this._engine.getNumViewports(); )
                this._cameraPositions.push(new s.Vector3);
            const t = s.Vector3.pool.get();
            for (let e = 0, i = this._engine.getNumViewports(); e < i; e++) {
                const i = this._engine.getViewportAt(e).getCamera();
                i && (t.neg(this.getEntity().getCameraSpacePosition(i)),
                this._cameraPositions[e].rotateInverse(this.getEntity().getOrientation(), t))
            }
            s.Vector3.pool.release(t),
            this._loadsThisFrame = 0;
            const e = this._rootTile.update();
            if (null === this._tilesLoadedPromise && e && (this._tilesLoadedPromise = new Promise((t => {
                this._transitionsCompleteCallback = t
            }
            ))),
            null !== this._tilesLoadedPromise && !e) {
                const t = this._transitionsCompleteCallback;
                this._tilesLoadedPromise = null,
                this._transitionsCompleteCallback = null,
                t && t()
            }
        }
        __prepareForRender(t) {
            s.ThreeJsHelper.setOrientationToEntity(this.getThreeJsObjects(), this.getEntity()),
            s.ThreeJsHelper.setPositionToEntity(this.getThreeJsObjects(), this.getEntity(), t);
            const e = this._atmosphereComponentRef.get();
            s.MaterialUtils.setUniforms(this.getThreeJsMaterials(), t, this.getEntity(), this._shadowEntities, e, !0)
        }
        async __loadResources() {
            if ("" !== this._endPoint) {
                this._capabilities = new n.Capabilities(this._endPoint,this._engine,-this.getEntity().getLeastCameraDepth()),
                await this._capabilities.readyPromise;
                let t = this._layerIdentifier;
                if ("" === t) {
                    const e = this._capabilities.layers;
                    if (1 === e.size)
                        for (const [,i] of e)
                            t = i
                }
                if ("" === t)
                    return;
                if (this._layer = this._capabilities.getLayer(t),
                null === this._layer)
                    throw new Error(`Invalid layer: "${t}".`);
                let e = this._tileMatrixSetIdentifier;
                if ("" === e) {
                    const t = this._layer.tileMatrixSets;
                    if (1 === t.size)
                        for (const i of t)
                            e = i
                }
                if (this._tileMatrixSet = this._capabilities.getTileMatrixSet(e),
                null === this._tileMatrixSet)
                    throw new Error(`Invalid tile matrix set: "${e}".`);
                await this._tileMatrixSet.readyPromise;
                const i = new s.Rect;
                i.copy(this._tileMatrixSet.boundingBox),
                1 === this._tileMatrixSet.getNumTiles(0).x && (i.size.x *= 2),
                1 === this._tileMatrixSet.getNumTiles(0).y && (i.origin.y -= i.size.y,
                i.size.y *= 2);
                let o = this._style;
                "" === o && (o = this._layer.defaultStyle);
                for (const [t,e] of this._layer.dimensions)
                    this._dimensionValues.has(t) || this._dimensionValues.set(t, e);
                this._tileUrl = this._layer.url,
                this._tileUrl = this._tileUrl.replace("{TileMatrixSet}", this._tileMatrixSet.identifier),
                this._tileUrl = this._tileUrl.replace("{Style}", o),
                this._dimensionValues.forEach(( (t, e) => {
                    this._tileUrl = this._tileUrl.replace(`{${e}}`, t)
                }
                )),
                this._rootTile = new WMTSTile(this,null,-1,0,0,i)
            }
        }
        __unloadResources() {
            this._capabilities = null,
            this._layer = null,
            this._tileMatrixSet = null,
            this._tileUrl = "",
            this._rootTile && (this._rootTile.destroy(),
            this._rootTile = null)
        }
        _spheroidRefChangedCallback(t, e) {
            null !== t && t.removeChangedCallback(this._spheroidChangedCallback),
            null !== e && e.addChangedCallback(this._spheroidChangedCallback),
            this._spheroidChangedCallback()
        }
        _spheroidChangedCallback() {
            const t = this._spheroidComponentRef.get();
            null !== t ? this.__setRadius(Math.max(t.getEquatorialRadius(), t.getPolarRadius())) : this.__setRadius(0),
            this.resetResources()
        }
    }
    class WMTSTile extends s.Tile {
        constructor(t, e, i, n, o, a) {
            super(e),
            this._component = t,
            this._level = i,
            this._row = n,
            this._col = o,
            this._tileBounds = new s.Rect,
            this._tileBounds.copy(a),
            this._center = new s.Vector3,
            this._radius = 0,
            this._threeJsMaterial = null,
            this._threeJsObject = null;
            const r = t.__getSpheroidComponent()
              , l = this._component.__getTileMatrixSet();
            if (!l || !r)
                throw new Error(`Missing spheroid or tile matrix set in ${t}`);
            const c = new s.Vector3;
            l.crsUnitsToXYZ(c, this._tileBounds.origin, r);
            const h = new s.Vector2;
            h.add(this._tileBounds.origin, this._tileBounds.size);
            const d = new s.Vector3;
            l.crsUnitsToXYZ(d, h, r);
            const u = new s.Vector2;
            u.addMult(this._tileBounds.origin, this._tileBounds.size, .5),
            l.crsUnitsToXYZ(this._center, u, r);
            const p = new s.Vector3
              , m = new s.Vector3;
            p.x = Math.min(c.x, d.x, this._center.x),
            p.y = Math.min(c.y, d.y, this._center.y),
            p.z = Math.min(c.z, d.z, this._center.z),
            m.x = Math.max(c.x, d.x, this._center.x),
            m.y = Math.max(c.y, d.y, this._center.y),
            m.z = Math.max(c.z, d.z, this._center.z),
            this._center.add(p, m),
            this._center.mult(this._center, .5);
            const _ = new s.Vector3;
            _.sub(this._center, p),
            this._radius = _.magnitude()
        }
        createNewTile(t, e, i) {
            const n = t._level + 1
              , o = 2 * t._row + e
              , a = 2 * t._col + i
              , r = t._component.__getTileMatrixSet();
            if (!r)
                return null;
            const l = r.getNumTiles(t._level + 1);
            if (o >= l.y || a >= l.x)
                return null;
            const c = new s.Rect;
            return c.origin.set(t._tileBounds.origin.x + .5 * i * t._tileBounds.size.x, t._tileBounds.origin.y + .5 * (1 - e) * t._tileBounds.size.y),
            c.size.set(.5 * t._tileBounds.size.x, .5 * t._tileBounds.size.y),
            new WMTSTile(t._component,t,n,o,a,c)
        }
        checkSplit() {
            const t = this._component.__getTileMatrixSet();
            if (!t || this._level >= t.numLevels - 1)
                return !1;
            const e = this._component.__getLayerBounds();
            if (!e || !this._tileBounds.intersects(e))
                return !1;
            if (this._level >= this._component.__getMaxLevel())
                return !1;
            if (this._component.__getLoadsThisFrame() >= 1)
                return !1;
            if (this._level < this._component.__getMinLevel())
                return !0;
            if (-1 === this._level)
                return !0;
            let i = this._component.__getTilePixelSize();
            if (void 0 === i) {
                if (!this._threeJsMaterial)
                    return !1;
                if (i = this._threeJsMaterial.uniforms.colorTexture.value.image.width,
                1 === i)
                    return !1;
                this._component.__setTilePixelSize(i)
            }
            return this._getNearestDistance() < this._component.__getSplitJoinFactor() * this._radius / i
        }
        checkJoin() {
            if (-1 === this._level)
                return !1;
            if (this._component.__getLoadsThisFrame() >= 1)
                return !1;
            if (this._level > this._component.__getMaxLevel())
                return !0;
            if (this._level <= this._component.__getMinLevel())
                return !1;
            let t = this._component.__getTilePixelSize();
            if (void 0 === t) {
                if (!this._threeJsMaterial)
                    return !1;
                t = this._threeJsMaterial.uniforms.colorTexture.value.image.width,
                this._component.__setTilePixelSize(t)
            }
            return this._getNearestDistance() > this._component.__getSplitJoinFactor() * this._radius * 4 / t
        }
        async load() {
            if (-1 === this._level)
                return;
            if (this._component.__incLoadsThisFrame(),
            null !== this._threeJsMaterial)
                throw new Error("Tile already has material.");
            const t = this._component.__getLayerBounds();
            if (!t)
                throw new Error("There is no layer bounds.");
            if (this._tileBounds.intersects(t)) {
                this._threeJsMaterial = s.MaterialUtils.get(),
                this._component.getThreeJsMaterials().push(this._threeJsMaterial);
                for (const t of this._component.__getMaterialOptions())
                    this._threeJsMaterial.defines[t] = !0;
                let t = this._component.__getTileUrl();
                t = t.replace("{TileMatrix}", `${this._level}`),
                t = t.replace("{TileRow}", `${this._row}`),
                t = t.replace("{TileCol}", `${this._col}`);
                const e = this._threeJsMaterial.uniforms.colorTexture;
                await s.ThreeJsHelper.loadTextureIntoUniform(this._component, e, t, !1)
            }
        }
        unload() {
            if (-1 !== this._level && null !== this._threeJsMaterial) {
                const t = this._component.getThreeJsMaterials();
                for (let e = 0, i = t.length; e < i; e++)
                    if (t[e] === this._threeJsMaterial) {
                        t.splice(e, 1);
                        break
                    }
                this._threeJsMaterial.uniforms.shadowRingsTexture?.value && (this._threeJsMaterial.uniforms.shadowRingsTexture.value = null),
                s.ThreeJsHelper.destroyMaterial(this._threeJsMaterial, !0),
                this._threeJsMaterial = null
            }
        }
        async activate() {
            if (-1 === this._level)
                return;
            const t = this._component.__getLayer()
              , e = this._component.__getTileMatrixSet()
              , i = this._component.__getSpheroidComponent();
            if (!(t && this._threeJsMaterial && e && i))
                throw new Error("Missing layer or Three.js material.");
            this._threeJsObject = s.ThreeJsHelper.createMeshObject(this._component, this._threeJsMaterial, [{
                name: "position",
                dimensions: 3
            }, {
                name: "normal",
                dimensions: 3
            }, {
                name: "uv",
                dimensions: 2
            }], !1),
            this._component.getThreeJsObjects().push(this._threeJsObject),
            s.ThreeJsHelper.useInDynEnvMap(this._threeJsObject, !0);
            const n = 21
              , o = new Float32Array(1323)
              , a = new Float32Array(1323)
              , r = new Float32Array(882)
              , l = new Uint16Array(2520)
              , c = t.boundingBox
              , h = new s.Vector2
              , d = new s.Vector2
              , u = new s.Vector3;
            for (let t = 0; t < 21; t++) {
                let p = 1 - t / 20;
                h.y = s.MathUtils.lerp(this._tileBounds.origin.y, this._tileBounds.origin.y + this._tileBounds.size.y, p),
                d.y = s.MathUtils.clamp(h.y, c.origin.y, c.origin.y + c.size.y),
                p += (d.y - h.y) / this._tileBounds.size.y;
                for (let m = 0; m < n; m++) {
                    let _ = m / 20;
                    h.x = s.MathUtils.lerp(this._tileBounds.origin.x, this._tileBounds.origin.x + this._tileBounds.size.x, _),
                    d.x = s.MathUtils.clamp(h.x, c.origin.x, c.origin.x + c.size.x),
                    _ += (d.x - h.x) / this._tileBounds.size.x,
                    e.crsUnitsToXYZ(u, d, i);
                    const g = t * n + m;
                    o[3 * g + 0] = u.x,
                    o[3 * g + 1] = u.y,
                    o[3 * g + 2] = u.z,
                    u.normalize(u),
                    a[3 * g + 0] = u.x,
                    a[3 * g + 1] = u.y,
                    a[3 * g + 2] = u.z,
                    r[2 * g + 0] = _,
                    r[2 * g + 1] = 1 - p;
                    const y = t * n + m;
                    m < 20 && t < 20 && (l[6 * y + 0] = n * (t + 0) + (m + 0),
                    l[6 * y + 1] = n * (t + 1) + (m + 0),
                    l[6 * y + 2] = n * (t + 1) + (m + 1),
                    l[6 * y + 3] = n * (t + 0) + (m + 0),
                    l[6 * y + 4] = n * (t + 1) + (m + 1),
                    l[6 * y + 5] = n * (t + 0) + (m + 1))
                }
            }
            s.ThreeJsHelper.setVertices(this._threeJsObject.geometry, "position", o),
            s.ThreeJsHelper.setVertices(this._threeJsObject.geometry, "normal", a),
            s.ThreeJsHelper.setVertices(this._threeJsObject.geometry, "uv", r),
            s.ThreeJsHelper.setIndices(this._threeJsObject.geometry, l)
        }
        deactivate() {
            if (-1 === this._level)
                return;
            const t = this._component.getThreeJsObjects();
            for (let e = 0, i = t.length; e < i; e++)
                if (t[e] === this._threeJsObject) {
                    t.splice(e, 1);
                    break
                }
            this._threeJsObject && s.ThreeJsHelper.destroyObject(this._threeJsObject),
            this._threeJsObject = null
        }
        update() {
            let t = this.check();
            const e = this.getChildren();
            for (let i = 0, s = e.length; i < s; i++)
                t = e[i].update() || t;
            return t
        }
        _getNearestDistance() {
            let t = Number.POSITIVE_INFINITY;
            const e = s.Vector3.pool.get();
            for (let i = 0, s = this._component.__getCameraPositions().length; i < s; i++) {
                const s = this._component.__getCameraPositions()[i];
                e.sub(this._center, s);
                const n = Math.max(0, e.magnitude() - this._radius);
                t > n && (t = n)
            }
            return s.Vector3.pool.release(e),
            t
        }
        toString() {
            return `${this._level}-${this._row}-${this._col}`
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        Capabilities: function() {
            return Capabilities
        },
        Layer: function() {
            return Layer
        },
        TileMatrixSet: function() {
            return TileMatrixSet
        }
    });
    var s = i(5)
      , n = i(564);
    class Capabilities {
        constructor(t, e, i) {
            this.endPoint = t,
            this.layers = new Map,
            this._capabilitiesXML = new Document,
            this.readyPromise = e.getDownloader().download(`${this.endPoint}/1.0.0/WMTSCapabilities.xml`, "text", i).then((t => {
                if ("string" == typeof t.content) {
                    this._capabilitiesXML = (new DOMParser).parseFromString(t.content, "application/xml");
                    const e = this._capabilitiesXML.querySelectorAll("Contents > Layer");
                    for (const i of e) {
                        const e = i.querySelector("*|Title")
                          , s = i.querySelector("*|Identifier");
                        if (!e || !s || null === e.textContent || null === s.textContent)
                            throw new Error(`Malformed WMTSCapabilities.xml at ${t.actualUrl}`);
                        this.layers.set(e.textContent, s.textContent)
                    }
                }
            }
            ))
        }
        getLayer(t) {
            let e = null;
            if (null !== this._capabilitiesXML) {
                const i = this._capabilitiesXML.querySelectorAll("Contents > Layer");
                for (const s of i) {
                    const i = s.querySelector("*|Identifier");
                    if (!i)
                        continue;
                    t === i.textContent && (e = new Layer(s,`${this.endPoint}/1.0.0`))
                }
            }
            return e
        }
        getTileMatrixSet(t) {
            let e = null;
            if (null !== this._capabilitiesXML) {
                const i = this._capabilitiesXML.querySelectorAll("Contents > TileMatrixSet");
                for (const s of i) {
                    const i = s.querySelector("*|Identifier");
                    if (!i)
                        continue;
                    t === i.textContent && (e = new TileMatrixSet(s))
                }
            }
            return e
        }
    }
    class Layer {
        constructor(t, e) {
            const i = t.querySelector("*|Title");
            if (!i || null === i.textContent)
                throw new Error(`Malformed WMTSCapabilities.xml at ${e}`);
            const n = t.querySelector("*|Identifier");
            if (!n || null === n.textContent)
                throw new Error(`Malformed WMTSCapabilities.xml at ${e}`);
            this.title = i.textContent,
            this.identifier = n.textContent,
            this.styles = new Map,
            this.defaultStyle = "",
            this.boundingBox = new s.Rect,
            this.dimensions = new Map,
            this.tileMatrixSets = new Set,
            this.url = "",
            this._baseUrl = e;
            const o = t.querySelectorAll("Style");
            for (const t of o) {
                const e = t.querySelector("*|Title")
                  , i = t.querySelector("*|Identifier");
                if (!e || !i || null === e.textContent || null === i.textContent)
                    continue;
                const s = e.textContent
                  , n = i.textContent;
                this.styles.set(s, n),
                "true" === t.getAttribute("isDefault") && (this.defaultStyle = n)
            }
            let a = t.querySelector("*|BoundingBox");
            if (null === a && (a = t.querySelector("*|WGS84BoundingBox")),
            null === a)
                throw new Error(`Layer "${this.identifier}" missing a BoundingBox or a WGS84BoundingBox tag.`);
            const r = a.querySelector("*|LowerCorner")
              , l = a.querySelector("*|UpperCorner");
            if (!r || !l || null === r.textContent || null === l.textContent)
                throw new Error(`Layer "${this.identifier}" missing BoundingBox corners.`);
            const c = r.textContent.split(" ")
              , h = l.textContent.split(" ");
            this.boundingBox.origin.set(Number.parseFloat(c[0]), Number.parseFloat(c[1])),
            this.boundingBox.size.set(Number.parseFloat(h[0]) - this.boundingBox.origin.x, Number.parseFloat(h[1]) - this.boundingBox.origin.y);
            const d = t.querySelectorAll("Dimension");
            for (const t of d) {
                const e = t.querySelector("*|Identifier")
                  , i = t.querySelector("Default");
                if (!e || !i || null === e.textContent || null === i.textContent)
                    continue;
                const s = e.textContent
                  , n = i.textContent;
                this.dimensions.set(s, n)
            }
            const u = t.querySelectorAll("TileMatrixSetLink");
            for (const t of u) {
                const e = t.querySelector("TileMatrixSet");
                if (!e || null === e.textContent)
                    continue;
                const i = e.textContent;
                this.tileMatrixSets.add(i)
            }
            const p = t.querySelector("ResourceURL");
            if (!p)
                throw new Error(`Layer "${this.identifier}" missing ResourceURL.`);
            const m = p.getAttribute("template");
            if (null === m)
                throw new Error(`Layer "${this.identifier}" missing ResourceURL template attribute.`);
            this.url = m,
            /^(?:[a-z]+:)?\/\//iu.test(this.url) || (this.url = this._baseUrl + this.url)
        }
    }
    class TileMatrixSet {
        constructor(t) {
            const e = t.querySelector("*|Identifier");
            if (!e || null === e.textContent)
                throw new Error("TileMatrixSet missing identifier.");
            const i = t.querySelector("*|SupportedCRS");
            if (!i || null === i.textContent)
                throw new Error(`TileMatrixSet ${this.identifier} missing SupportedCRS.`);
            let o;
            this.identifier = e.textContent,
            this.crs = i.textContent,
            this.boundingBox = new s.Rect,
            this.readyPromise = Promise.resolve(),
            this.numLevels = 0,
            this._numTiles = [];
            let a = 0;
            for (const e of t.querySelectorAll("TileMatrix")) {
                const t = e.querySelector("ScaleDenominator");
                if (!t)
                    throw new Error(`ScaleDenominator tag not found for TileMatrix ${a} of TileMatrixSet ${this.identifier}.`);
                const i = parseFloat(t.innerHTML);
                if (void 0 !== o && Math.abs(2 * i - o) / i > .01)
                    throw new Error(`ScaleDenominator for TileMatrix ${a} of TileMatrixSet ${this.identifier} must be half of the next higher level, but is not.`);
                o = i;
                const n = e.querySelector("MatrixWidth")
                  , r = e.querySelector("MatrixHeight");
                if (!n || !r)
                    throw new Error(`MatrixWidth or MatrixHeight tag not found for TileMatrix ${a} of TileMatrixSet ${this.identifier}.`);
                this._numTiles[a] = new s.Vector2(parseFloat(n.innerHTML),parseFloat(r.innerHTML)),
                a += 1
            }
            this.numLevels = a;
            const r = t.querySelector("TileMatrix");
            if (!r)
                throw new Error(`TileMatrix tag not found for TileMatrixSet ${this.identifier}.`);
            const l = r.querySelector("ScaleDenominator");
            if (!l || null === l.textContent)
                throw new Error(`ScaleDenominator tag not found for TileMatrixSet ${this.identifier} level 0.`);
            const c = Number.parseFloat(l.textContent)
              , h = r.querySelector("TileWidth");
            if (!h || null === h.textContent)
                throw new Error(`TileWidth tag not found for TileMatrixSet ${this.identifier} level 0.`);
            const d = r.querySelector("TileHeight");
            if (!d || null === d.textContent)
                throw new Error(`TileHeight tag not found for TileMatrixSet ${this.identifier} level 0.`);
            const u = new s.Vector2(Number.parseFloat(h.textContent),Number.parseFloat(d.textContent))
              , p = 28e-8 * c
              , m = new s.Vector2(p * u.x,p * u.y)
              , _ = new s.Vector2(m.x * this._numTiles[0].x,m.y * this._numTiles[0].y)
              , g = r.querySelector("TopLeftCorner");
            if (!g || null === g.textContent)
                throw new Error(`MatrixWidth or MatrixHeight tag not found for TileMatrix ${a} of TileMatrixSet ${this.identifier}.`);
            const y = g.textContent.split(" ");
            this.boundingBox.origin.set(Number.parseFloat(y[0]), Number.parseFloat(y[1])),
            this.readyPromise = TileMatrixSet.setCRS(this.crs).then((t => {
                this.crs = t;
                let e = 1e3;
                const i = n.default.defs(this.crs);
                void 0 !== i.to_meter ? e = 1e3 / i.to_meter : "degrees" === i.units ? e = .00898315284 : "feet" !== i.units && "us feet" !== i.units || (e = 3280.83333335),
                this.boundingBox.size.x = Math.round(_.x * e * 1e6) / 1e6,
                this.boundingBox.size.y = Math.round(_.y * e * 1e6) / 1e6,
                this.boundingBox.origin.y -= this.boundingBox.size.y
            }
            ))
        }
        getNumTiles(t) {
            return this._numTiles[t]
        }
        crsUnitsToXYZ(t, e, i) {
            const o = s.LatLonAlt.pool.get()
              , a = s.MathUtils.clamp(e.x, this.boundingBox.origin.x, this.boundingBox.origin.x + this.boundingBox.size.x)
              , r = s.MathUtils.clamp(e.y, this.boundingBox.origin.y, this.boundingBox.origin.y + this.boundingBox.size.y)
              , l = (0,
            n.default)(this.crs, "WGS84", [a, r]);
            o.set(s.MathUtils.degToRad(l[1]), s.MathUtils.degToRad(l[0]), 0),
            i.xyzFromLLA(t, o),
            s.LatLonAlt.pool.release(o)
        }
        static async setCRS(t) {
            t.startsWith("urn:ogc:def:crs:") && (t = t.substring("urn:ogc:def:crs:".length));
            let e = TileMatrixSet.crsToWKT.get(t);
            if (void 0 === e) {
                if (t.startsWith("EPSG::"))
                    throw new Error("Only CRS starting with EPSG:: supported.");
                {
                    const i = `https://epsg.io/${t.substring("EPSG::".length)}.proj4`
                      , s = await fetch(i);
                    e = await s.text()
                }
            }
            return n.default.defs(t, e),
            t
        }
        static crsToWKT = new Map([["EPSG::104903", 'GEOGCS["GCS_Moon_2000",DATUM["D_Moon_2000",SPHEROID["Moon_2000_IAU_IAG",1737400.0,0.0]],PRIMEM["Reference_Meridian",0.0],UNIT["Degree",0.0174532925199433]]'], ["EPSG::104905", 'GEOGCS["GCS_Mars_2000",DATUM["D_Mars_2000",SPHEROID["Mars_2000_IAU_IAG",3396190.0,169.8944472236118]],PRIMEM["Reference_Meridian",0.0],UNIT["Degree",0.0174532925199433]]'], ["EPSG::4326", "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs"], ["EPSG::3857", "+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext +no_defs"], ["OGC:1.3:84", n.default.defs("WGS84")], ["OGC:1.3:CRS84", n.default.defs("WGS84")], ["OGC:2:84", n.default.defs("WGS84")]])
    }
}
, , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        KeyframePointingController: function() {
            return KeyframePointingController
        }
    });
    var s = i(5);
    class KeyframePointingController extends s.BaseController {
        constructor(t, e) {
            super(t, e),
            this._keyframes = [],
            this._direction = new s.Vector3(1,0,0),
            this.addModifiedState("orientation")
        }
        setKeyframes(t) {
            for (let t = 0, e = this._keyframes.length; t < e; t++) {
                let e = this._keyframes[t][1];
                e.startsWith("-") && (e = e.substring(1)),
                "velocity" === e ? this.removeDependentState(this.getEntity().getName(), "velocity") : this.removeDependentState(e, "position")
            }
            this._keyframes = [];
            for (let e = 0, i = t.length; e < i; e++) {
                this._keyframes.push([t[e][0], t[e][1]]);
                let i = this._keyframes[e][1];
                i.startsWith("-") && (i = i.substring(1)),
                "velocity" === i ? this.addDependentState(this.getEntity().getName(), "velocity") : this.addDependentState(i, "position")
            }
            this._keyframes.sort(( (t, e) => t[0] - e[0]))
        }
        setDirection(t) {
            this._direction.copy(t)
        }
        __updateOrientationAtTime(t, e) {
            t.isNaN() && t.copy(s.Quaternion.Identity),
            this._getNewOrientation(t, e, t)
        }
        __update() {
            if (0 === this._keyframes.length)
                return;
            const t = this.getEntity()
              , e = t.getScene().getEngine().getTime();
            t.getOrientation().isNaN() && t.setOrientation(s.Quaternion.Identity);
            const i = s.Quaternion.pool.get();
            this._getNewOrientation(i, e, t.getOrientation()),
            t.setOrientation(i),
            s.Quaternion.pool.release(i)
        }
        _getNewOrientation(t, e, i) {
            const n = s.Sort.getIndex(e, this._keyframes, ( (t, e) => t[0] < e));
            let o = 0
              , a = 0;
            n === this._keyframes.length ? (o = this._keyframes.length - 1,
            a = this._keyframes.length - 1) : n > 0 && (o = n - 1,
            a = n);
            const r = this._keyframes[o]
              , l = this._keyframes[a]
              , c = l[0] > r[0] ? (e - r[0]) / (l[0] - r[0]) : 0
              , h = s.Vector3.pool.get()
              , d = s.Vector3.pool.get();
            this._getDirection(h, e, r[1]),
            this._getDirection(d, e, l[1]),
            d.slerp(h, d, c),
            d.normalize(d),
            h.rotate(i, this._direction);
            const u = s.Quaternion.pool.get();
            u.setFromVectorFromTo(h, d),
            t.mult(u, i),
            s.Quaternion.pool.release(u),
            s.Vector3.pool.release(d),
            s.Vector3.pool.release(h)
        }
        _getDirection(t, e, i) {
            const n = this.getEntity()
              , o = i.startsWith("-");
            if (o && (i = i.substring(1)),
            i.startsWith("velocity"))
                if ((i = i.substring(8)).startsWith(" rel ")) {
                    i = i.substring(5);
                    const o = n.getScene().getEntity(i);
                    null !== o && n.getVelocityRelativeToEntity(t, s.Vector3.Zero, o, e)
                } else
                    n.getVelocityAtTime(t, e);
            else {
                const o = n.getScene().getEntity(i);
                null !== o ? o.getPositionRelativeToEntity(t, s.Vector3.Zero, n, e) : t.copy(s.Vector3.NaN)
            }
            t.normalize(t),
            o && t.mult(t, -1)
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        KeyframeSpinController: function() {
            return KeyframeSpinController
        }
    });
    var s = i(5);
    class KeyframeSpinController extends s.BaseController {
        constructor(t, e) {
            super(t, e),
            this._keyframes = [],
            this._axis = new s.Vector3(1,0,0),
            this._startingAngle = 0,
            this.addModifiedState("orientation")
        }
        setKeyframes(t) {
            this._keyframes = [];
            let e = 0;
            for (let i = 0, n = t.length; i < n; i++)
                i > 0 && (e = s.MathUtils.wrap(e + (t[i][0] - t[i - 1][0]) * (t[i - 1][1] + t[i][1]) * .5, 0, 2 * Math.PI)),
                this._keyframes.push([t[i][0], t[i][1], e]);
            this._keyframes.sort(( (t, e) => t[0] - e[0]))
        }
        setAxis(t) {
            this._axis.copy(t)
        }
        setStartingAngle(t) {
            this._startingAngle = t
        }
        __updateOrientationAtTime(t, e) {
            t.isNaN() && t.copy(s.Quaternion.Identity),
            this._getNewOrientation(t, e, t)
        }
        __update() {
            if (0 === this._keyframes.length)
                return;
            const t = this.getEntity()
              , e = t.getScene().getEngine().getTime();
            t.getOrientation().isNaN() && t.setOrientation(s.Quaternion.Identity);
            const i = s.Quaternion.pool.get();
            this._getNewOrientation(i, e, t.getOrientation()),
            t.setOrientation(i),
            s.Quaternion.pool.release(i)
        }
        _getNewOrientation(t, e, i) {
            const n = s.Sort.getIndex(e, this._keyframes, ( (t, e) => t[0] < e));
            let o = 0
              , a = 0;
            n === this._keyframes.length ? (o = this._keyframes.length - 1,
            a = this._keyframes.length - 1) : n > 0 && (o = n - 1,
            a = n);
            const r = this._keyframes[o]
              , l = this._keyframes[a]
              , c = l[0] > r[0] ? (e - r[0]) / (l[0] - r[0]) : 0
              , h = s.MathUtils.wrap(this._startingAngle + r[2] + (e - r[0]) * (r[1] + c * l[1]) / (1 + c), 0, 2 * Math.PI)
              , d = s.Vector3.pool.get();
            d.rotate(i, this._axis);
            const u = s.Quaternion.pool.get();
            u.setFromAxisAngle(d, h),
            t.mult(u, i),
            s.Vector3.pool.release(d),
            s.Quaternion.pool.release(u)
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        PositionSumController: function() {
            return PositionSumController
        }
    });
    var s = i(5);
    class PositionSumController extends s.BaseController {
        constructor(t, e) {
            super(t, e),
            this._entities = new s.FastMap,
            this.addModifiedState("position")
        }
        addEntity(t, e, i) {
            const n = new s.EntityRef(this.getEntity().getScene());
            n.setName(t),
            this._entities.set(t, {
                ref: n,
                mult: e,
                add: i
            }),
            this.addDependentState(t, "position")
        }
        removeEntity(t) {
            this._entities.delete(t),
            this.removeDependentState(t, "position")
        }
        setEntityParams(t, e, i) {
            const s = this._entities.get(t);
            if (!s)
                throw new Error(`The entity ${t} has not been previously added to the controller.`);
            void 0 !== e && (s.mult = e),
            void 0 !== i && (s.add = i)
        }
        __update() {
            const t = this.getEntity().getParent();
            if (!t)
                return;
            const e = s.Vector3.pool.get()
              , i = s.Vector3.pool.get();
            e.set(0, 0, 0);
            for (let n = 0, o = this._entities.getSize(); n < o; n++) {
                const o = this._entities.getAt(n).value
                  , a = o.ref.get();
                if (null === a)
                    continue;
                a.getPositionRelativeToEntity(i, s.Vector3.Zero, t);
                const r = i.magnitude();
                e.addMult(e, i, o.mult + (r > 0 ? o.add / r : 0))
            }
            this.getEntity().setPosition(e),
            s.Vector3.pool.release(e),
            s.Vector3.pool.release(i)
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        ZoomFitController: function() {
            return ZoomFitController
        }
    });
    var s = i(5);
    class ZoomFitController extends s.BaseController {
        constructor(t, e) {
            super(t, e),
            this._entities = new s.FastMap,
            this._tightFit = !1,
            this._zoomOutOnly = !1,
            this._edgeSize = 0,
            this.addModifiedState("position")
        }
        addEntity(t) {
            const e = new s.EntityRef(this.getEntity().getScene());
            e.setName(t),
            this._entities.set(t, {
                ref: e
            }),
            this.addDependentState(t, "position")
        }
        removeEntity(t) {
            this._entities.delete(t),
            this.removeDependentState(t, "position")
        }
        setTightFit(t) {
            this._tightFit = t
        }
        setZoomOutOnly(t) {
            this._zoomOutOnly = t
        }
        setEdgeSize(t) {
            this._edgeSize = t
        }
        __update() {
            const t = this.getEntity().getParent();
            if (!t)
                return;
            let e = 1;
            const i = this.getEntity().getComponent(s.CameraComponent);
            if (null !== i) {
                const t = Math.min(i.getHorizontalFieldOfView(), i.getVerticalFieldOfView());
                e = Math.tan(t / 2)
            }
            const n = s.Vector3.pool.get();
            n.normalize(this.getEntity().getPosition()),
            0 === n.magnitudeSqr() && (this.getEntity().getOrientation().getAxis(n, 1),
            n.neg(n)),
            n.isNaN() && n.copy(s.Vector3.YAxisNeg);
            const o = (1 + this._edgeSize / (.5 - this._edgeSize)) / e;
            let a = 0;
            const r = s.Vector3.pool.get();
            for (let e = 0, i = this._entities.getSize(); e < i; e++) {
                const i = this._entities.getAt(e).value.ref.get();
                if (null === i)
                    continue;
                i.getPositionRelativeToEntity(r, s.Vector3.Zero, t);
                const l = i.getExtentsRadius();
                let c;
                if (this._tightFit) {
                    const t = r.dot(n);
                    r.addMult(r, n, -t);
                    c = t + o * r.magnitude() + l * Math.sqrt(o * o + 1)
                } else
                    c = r.magnitude() + l;
                a = Math.max(a, c)
            }
            s.Vector3.pool.release(r),
            this._tightFit || (a *= Math.sqrt(o * o + 1)),
            (!this._zoomOutOnly || a > this.getEntity().getPosition().magnitude()) && (n.mult(n, a),
            this.getEntity().setPosition(n)),
            s.Vector3.pool.release(n)
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e);
    var s = i(5);
    i(545).Entity.register({
        j2000_ecliptic: {
            label: "J2000 Ecliptic",
            extentsRadius: 1e-5,
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            controllers: [{
                type: "fixed",
                position: s.Vector3.Zero,
                orientation: new s.Quaternion(.9791532214288992,.2031230389823101,0,0,!0)
            }]
        },
        l1: {
            groups: ["lagrange_points"],
            label: "L1",
            extentsRadius: 1e-5,
            parents: [[Number.NEGATIVE_INFINITY, "earth"]],
            controllers: [{
                type: "dynamo",
                url: "l1"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.XAxis
                },
                secondary: {
                    type: "align",
                    target: "j2000_ecliptic",
                    axis: s.Vector3.ZAxis,
                    targetAxis: s.Vector3.ZAxis
                }
            }]
        },
        l2: {
            groups: ["lagrange_points"],
            label: "L2",
            extentsRadius: 1e-5,
            parents: [[Number.NEGATIVE_INFINITY, "earth"]],
            controllers: [{
                type: "dynamo",
                url: "l2"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        l4: {
            groups: ["lagrange_points"],
            label: "L4",
            extentsRadius: 1e-5,
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            controllers: [{
                type: "dynamo",
                url: "l4"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        l5: {
            groups: ["lagrange_points"],
            label: "L5",
            extentsRadius: 1e-5,
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            controllers: [{
                type: "dynamo",
                url: "l5"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        }
    })
}
, function(t, e, i) {
    "use strict";
    i.r(e);
    var s = i(5)
      , n = i(545)
      , o = i(552);
    n.Entity.register({
        observable_universe: {
            groups: ["stars"],
            radius: 5e23,
            systemRadius: 5e23,
            label: "Observable Universe",
            parents: [],
            controllers: [{
                type: "fixed",
                position: s.Vector3.Zero,
                orientation: s.Quaternion.Identity
            }],
            postCreateFunction: t => {
                t.setCanOcclude(!1)
            }
        },
        milky_way: {
            groups: ["stars"],
            radius: 1e18,
            systemRadius: 13e18,
            label: "Milky Way",
            parents: [[Number.NEGATIVE_INFINITY, "observable_universe"]],
            controllers: [{
                type: "fixed",
                position: s.Vector3.Zero,
                orientation: s.Quaternion.Identity
            }],
            postCreateFunction: (t, e) => {
                t.setCanOcclude(!1);
                const i = t.getController(s.FixedController);
                if (!i)
                    return;
                const n = new s.Vector3
                  , o = 192.85948120833 * Math.PI / 180
                  , a = 27.12825119444 * Math.PI / 180;
                n.x = Math.cos(o) * Math.cos(a),
                n.y = Math.sin(o) * Math.cos(a),
                n.z = Math.sin(a);
                const r = new s.Vector3
                  , l = 266.40499625 * Math.PI / 180
                  , c = -28.93617241667 * Math.PI / 180;
                r.x = Math.cos(l) * Math.cos(c),
                r.y = Math.sin(l) * Math.cos(c),
                r.z = Math.sin(c);
                const h = new s.Quaternion;
                if (h.setFromAxes(r, void 0, n),
                i.setOrientation(h),
                e && !0 === e.milkyWaySprite) {
                    const e = t.addComponent(s.SpriteComponent);
                    e.setTextureUrl("$STATIC_ASSETS_URL/sprites/milky_way.png"),
                    e.setSize(new s.Vector2(12e17,12e17)),
                    e.setTransparent(!0),
                    e.setBlending("normal"),
                    e.setFadeDistance(12e15)
                }
                const d = t.addController(s.SpinController);
                d.setAxis(new s.Vector3(-.8676661356982597,-.19807638974470915,.45598379452940485), !1),
                d.setRate(-2192686e-23),
                d.setReferenceAngle(0),
                d.setReferenceTime(0)
            }
        },
        sun: {
            groups: ["stars"],
            radius: 695500,
            systemRadius: 2991957e7,
            label: "Sun",
            parents: [[Number.NEGATIVE_INFINITY, "milky_way"]],
            spheroid: {
                equatorialRadius: 695500,
                polarRadius: 695500,
                planetographic: !1
            },
            spheroidLOD: {
                materialOptions: ["colorMapEmissive"],
                textures: {
                    color: {
                        url: "sun/color_$SIZE_$FACE.png",
                        sizes: [4, 512]
                    }
                }
            },
            controllers: [{
                type: "fixed",
                position: s.Vector3.Zero,
                orientation: s.Quaternion.Identity
            }],
            postCreateFunction: (t, e) => {
                t.addComponent(s.LightSourceComponent).setAbsoluteMagnitude(4.83);
                const i = t.addComponent(s.AtmosphereComponent);
                i.setEmissivity(1),
                i.setScaleHeight(2e5),
                i.setDensity(8e-7),
                i.setColor(new s.Color(1,1,64 / 255));
                const n = t.addComponent(s.SpriteComponent);
                n.setBillboard(!0),
                n.setTextureUrl("$STATIC_ASSETS_URL/sprites/sun_glow.png"),
                n.setSize(new s.Vector2(100,100)),
                n.setSizeUnits("pixels"),
                n.setTransparent(!0),
                n.setColorMultiplier(new s.Color(1,1,.5)),
                n.setRenderOrder(-2);
                const a = t.addController(s.OrbitalElementsController)
                  , r = new s.OrbitalElements;
                if (r.epoch = 0,
                r.eccentricity = 0,
                r.semiMajorAxis = 246237071e9,
                r.meanAngularMotion = -2192686e-23,
                r.meanAnomalyAtEpoch = Math.PI,
                r.orbitOrientation.set(-.48894750765094835, -.4832106839985283, .19625375824756275, .6992297419646486),
                a.addOrbitalElements(-1e100, r),
                a.addOrbitalElements(1e100, r),
                void 0 !== e && !0 === e.skybox) {
                    t.addComponent(s.SkyboxComponent).setTextureUrl(`$STATIC_ASSETS_URL/env_maps/starmap_${e.skyboxResolution ?? 2048}.jpg`)
                }
                if (void 0 === e || !0 === e.skybox && !0 === e.starfield || !1 !== e.starfield) {
                    t.addComponent(s.StarfieldComponent).setUrl("$STATIC_ASSETS_URL/stars/galaxies.0.bin");
                    const i = e?.starfieldSize;
                    for (let e = 0; e < 6; e++) {
                        const n = t.addComponent(s.StarfieldComponent);
                        n.setUrl(`$STATIC_ASSETS_URL/stars/stars.${e}.bin`),
                        void 0 !== i && n.setParticleSize(i)
                    }
                }
                if (void 0 !== e && !0 === e.heliosphere) {
                    const e = t.addComponent(s.ModelComponent);
                    e.setUrl("$STATIC_ASSETS_URL/models/heliosphere/voyager_heliosphere.gltf"),
                    e.setScale(new s.Vector3(201e6,19e7,19e7)),
                    e.setForceLoaded(!0);
                    const i = new s.LatLonAlt(0,-105 * Math.PI / 180,0)
                      , n = new s.Vector3;
                    s.Geometry.getXYZFromLLAOnSphere(n, i, 1),
                    n.rotate(o.SceneHelpers.getEclipJ2000ToJ2000Rotation(), n),
                    n.normalize(n);
                    const a = new s.Quaternion;
                    a.setFromVectorFromTo(new s.Vector3(.9937396508197329,.11171728072160429,.0008692392338424033), n),
                    e.setRotation(a)
                }
            }
        },
        mercury: {
            groups: ["planets"],
            radius: 2439.4,
            systemRadius: 292764,
            label: "Mercury",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0,
                color: [.6, .6, .6, .7]
            },
            spheroid: {
                equatorialRadius: 2439.4,
                polarRadius: 2439.4,
                planetographic: !1
            },
            spheroidLOD: {
                textures: {
                    color: {
                        url: "mercury/color_$SIZE_$FACE.png",
                        sizes: [4, 512, 4096]
                    }
                }
            },
            controllers: [{
                type: "dynamo",
                url: "mercury/sun/orb"
            }, {
                type: "dynamo",
                url: "mercury/ori"
            }]
        },
        venus: {
            groups: ["planets"],
            radius: 6051.8,
            systemRadius: 726216,
            label: "Venus",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0,
                color: [.9, .8, .45, .7]
            },
            spheroid: {
                equatorialRadius: 6051.8,
                polarRadius: 6051.8,
                planetographic: !1
            },
            spheroidLOD: {
                textures: {
                    color: {
                        url: "venus/color_$SIZE_$FACE.png",
                        sizes: [4, 512]
                    }
                }
            },
            controllers: [{
                type: "dynamo",
                url: "venus/sun/orb"
            }, {
                type: "dynamo",
                url: "venus/ori"
            }],
            postCreateFunction: t => {
                const e = t.addComponent(s.AtmosphereComponent);
                e.setScaleHeight(15),
                e.setDensity(.001),
                e.setColor(new s.Color(213 / 255,160 / 255,94 / 255)),
                e.setSunBrightness(.25)
            }
        },
        earth: {
            groups: ["planets"],
            radius: 6378.1,
            systemRadius: 765372,
            label: "Earth",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0,
                color: [0, .6, .8, .7]
            },
            spheroid: {
                equatorialRadius: 6378.137,
                polarRadius: 6356.752,
                planetographic: !0
            },
            spheroidLOD: {
                textures: {
                    color: {
                        url: "earth/color_$SIZE_$FACE.png",
                        sizes: [16, 512, 4096]
                    },
                    normal: {
                        url: "earth/normal_$SIZE_$FACE.png",
                        sizes: [16, 512, 4096]
                    },
                    specular: {
                        url: "earth/specular_$SIZE_$FACE.png",
                        sizes: [16, 512, 4096]
                    },
                    night: {
                        url: "earth/night_$SIZE_$FACE.png",
                        sizes: [16, 512, 4096]
                    },
                    decal: {
                        url: "earth/cloud_$SIZE_$FACE.png",
                        sizes: [16, 512, 4096]
                    }
                },
                shadowEntities: ["moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "earth/sun/orb"
            }, {
                type: "dynamo",
                url: "earth/ori"
            }],
            postCreateFunction: (t, e) => {
                if (e && !1 === e.clouds) {
                    const e = t.getComponent(s.SpheroidLODComponent);
                    if (!e)
                        return;
                    e.setTexture("decal", "")
                }
                const i = t.addComponent(s.AtmosphereComponent);
                i.setScaleHeight(8),
                i.setDensity(.0015),
                i.setColor(new s.Color(214.5 / 255,267 / 255,1.5)),
                i.setSunBrightness(2),
                i.setSunsetColor(new s.Color(1,.5,0)),
                i.setSunsetIntensity(1.2)
            }
        },
        mars: {
            groups: ["planets"],
            radius: 3396.2,
            systemRadius: 46922,
            label: "Mars",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0,
                color: [.89, .51, .35, .7]
            },
            spheroid: {
                equatorialRadius: 3396.19,
                polarRadius: 3376.2,
                planetographic: !1
            },
            spheroidLOD: {
                textures: {
                    color: {
                        url: "mars/color_$SIZE_$FACE.png",
                        sizes: [4, 512, 4096]
                    }
                },
                shadowEntities: ["phobos", "deimos"]
            },
            controllers: [{
                type: "dynamo",
                url: "mars/sun/orb"
            }, {
                type: "dynamo",
                url: "mars/ori"
            }],
            postCreateFunction: t => {
                const e = t.addComponent(s.AtmosphereComponent);
                e.setScaleHeight(10.8),
                e.setDensity(.001),
                e.setColor(new s.Color(225 / 255,178 / 255,112 / 255)),
                e.setSunBrightness(.8),
                e.setSunsetColor(new s.Color(10 / 255,75 / 255,140 / 255)),
                e.setSunsetIntensity(1)
            }
        },
        jupiter: {
            groups: ["planets"],
            radius: 71492,
            systemRadius: 3782501,
            label: "Jupiter",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            spheroid: {
                equatorialRadius: 71492,
                polarRadius: 66854,
                planetographic: !1
            },
            spheroidLOD: {
                textures: {
                    color: {
                        url: "jupiter/color_$SIZE_$FACE.jpg",
                        sizes: [16, 512, 4096]
                    }
                },
                shadowEntities: ["io", "europa", "ganymede", "callisto"]
            },
            controllers: [{
                type: "dynamo",
                url: "jupiter/sun/orb"
            }, {
                type: "dynamo",
                url: "jupiter/ori"
            }, {
                type: "coverage",
                coverage: [Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY],
                update: t => {
                    if (t.getOrientation().isNaN())
                        return;
                    const e = t.getScene().getEngine().getTime()
                      , i = a.rotations;
                    let n = (i[i.length - 1][1] - i[i.length - 2][1]) / (i[i.length - 1][0] - i[i.length - 2][0])
                      , o = a.hintIndex;
                    if (e < i[o][0] || o < i.length - 1 && i[o + 1][0] <= e)
                        if (e >= i[i.length - 1][0])
                            o = i.length - 1;
                        else if (e < i[0][0])
                            o = 0,
                            n = 0;
                        else
                            for (let t = i.length - 2; t >= 0; t--)
                                i[t][0] <= e && e < i[t + 1][0] && (o = t,
                                n = (i[t + 1][1] - i[t][1]) / (i[t + 1][0] - i[t][0]));
                    else
                        o < i.length - 1 && (n = (i[o + 1][1] - i[o][1]) / (i[o + 1][0] - i[o][0]));
                    a.hintIndex = o;
                    const r = i[o][1] + (e - i[o][0]) * n
                      , l = s.MathUtils.wrap(a.referenceAngleInSystemIII - (r + a.textureAngleOffset - a.referenceAngleInSystemII) + (e - a.referenceTime) * a.offsetFactor, 0, 360)
                      , c = t.getComponent(s.SpheroidLODComponent);
                    null !== c && c.setLongitudeRotation(s.MathUtils.degToRad(l))
                }
            }],
            postCreateFunction: t => {
                const e = t.addComponent(s.AtmosphereComponent);
                e.setScaleHeight(200),
                e.setDensity(5e-5),
                e.setColor(new s.Color(234 / 255,202 / 255,170 / 255)),
                e.setSunBrightness(.25)
            }
        },
        saturn: {
            groups: ["planets"],
            radius: 60268,
            systemRadius: 7184413,
            label: "Saturn",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            spheroid: {
                equatorialRadius: 60268,
                polarRadius: 54364,
                planetographic: !1
            },
            spheroidLOD: {
                materialOptions: ["shadowRings"],
                textures: {
                    color: {
                        url: "saturn/color_$SIZE_$FACE.png",
                        sizes: [4, 512]
                    }
                },
                shadowEntities: ["iapetus", "dione", "rhea", "tethys", "titan", "mimas", "enceladus"]
            },
            controllers: [{
                type: "dynamo",
                url: "saturn/sun/orb"
            }, {
                type: "dynamo",
                url: "saturn/ori"
            }],
            postCreateFunction: t => {
                const e = t.addComponent(s.RingsComponent);
                e.setInnerRadius(74270.580913),
                e.setOuterRadius(140478.924731),
                e.setTopTextureUrl("$STATIC_ASSETS_URL/sprites/saturn_rings_top.png"),
                e.setBottomTextureUrl("$STATIC_ASSETS_URL/sprites/saturn_rings_bottom.png"),
                e.setFadeDistance(250),
                e.setShadowEntities(["iapetus", "dione", "rhea", "tethys", "titan", "mimas", "enceladus"]);
                const i = t.addComponent(s.AtmosphereComponent);
                i.setScaleHeight(200),
                i.setDensity(5e-5),
                i.setColor(new s.Color(234 / 255,202 / 255,151 / 255))
            }
        },
        uranus: {
            groups: ["planets"],
            radius: 25559,
            systemRadius: 1164893,
            label: "Uranus",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0,
                color: [.67, .92, 1, .7]
            },
            spheroid: {
                equatorialRadius: 25559,
                polarRadius: 24973,
                planetographic: !1
            },
            spheroidLOD: {
                textures: {
                    color: {
                        url: "uranus/color_$SIZE_$FACE.png",
                        sizes: [4, 256]
                    }
                },
                shadowEntities: ["titania", "oberon", "umbriel", "ariel", "miranda"]
            },
            controllers: [{
                type: "dynamo",
                url: "uranus/sun/orb"
            }, {
                type: "dynamo",
                url: "uranus/ori"
            }],
            postCreateFunction: t => {
                const e = t.addComponent(s.RingsComponent);
                e.setInnerRadius(26840),
                e.setOuterRadius(103e3),
                e.setTopTextureUrl("$STATIC_ASSETS_URL/sprites/uranus_rings.png"),
                e.setBottomTextureUrl("$STATIC_ASSETS_URL/sprites/uranus_rings.png"),
                e.setFadeDistance(250),
                e.setShadowEntities(["miranda", "ariel", "umbriel", "titania", "oberon"]);
                const i = t.addComponent(s.AtmosphereComponent);
                i.setScaleHeight(200),
                i.setDensity(5e-5),
                i.setColor(new s.Color(147 / 255,183 / 255,201 / 255)),
                i.setSunsetColor(new s.Color(164 / 255,168 / 255,.4)),
                i.setSunsetIntensity(1)
            }
        },
        neptune: {
            groups: ["planets"],
            radius: 24764,
            systemRadius: 43213894,
            label: "Neptune",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0,
                color: [.48, .69, 1, .7]
            },
            spheroid: {
                equatorialRadius: 24764,
                polarRadius: 24341,
                planetographic: !1
            },
            spheroidLOD: {
                textures: {
                    color: {
                        url: "neptune/color_$SIZE_$FACE.png",
                        sizes: [4, 256]
                    }
                },
                shadowEntities: ["triton", "proteus", "despina", "galatea", "larissa"]
            },
            controllers: [{
                type: "dynamo",
                url: "neptune/sun/orb"
            }, {
                type: "dynamo",
                url: "neptune/ori"
            }],
            postCreateFunction: t => {
                const e = t.addComponent(s.RingsComponent);
                e.setInnerRadius(40900),
                e.setOuterRadius(62964),
                e.setTopTextureUrl("$STATIC_ASSETS_URL/sprites/neptune_rings.png"),
                e.setBottomTextureUrl("$STATIC_ASSETS_URL/sprites/neptune_rings.png"),
                e.setFadeDistance(250);
                const i = t.addComponent(s.AtmosphereComponent);
                i.setScaleHeight(200),
                i.setDensity(5e-5),
                i.setColor(new s.Color(138 / 255,160 / 255,1))
            }
        }
    });
    const a = {
        hintIndex: 0,
        textureAngleOffset: -60.38,
        referenceTime: 617098056,
        referenceAngleInSystemII: 313.47,
        referenceAngleInSystemIII: 305,
        offsetFactor: -3074e-9,
        rotations: [[-1136116758, 15], [-1037534358, 28], [-938951958, 22], [-867931156, 0], [-812721554, 12], [-744292752, 47], [-639143949, 62], [-533822346, 48], [-483883145, 27], [-391953544, 15], [102427264, 85], [315576066, 138], [615211269, 312], [660052869, 347]]
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e);
    var s = i(5);
    i(545).Entity.register({
        "1_ceres": {
            groups: ["dwarf planets"],
            radius: 473,
            label: "Ceres",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            spheroid: {
                equatorialRadius: 482.6,
                polarRadius: 445.6,
                planetographic: !1
            },
            spheroidLOD: {
                textures: {
                    color: {
                        url: "1_ceres/color_$SIZE_$FACE.jpg",
                        sizes: [16, 512, 4096]
                    }
                }
            },
            controllers: [{
                type: "dynamo",
                url: "1_ceres/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 12
            }]
        },
        "101955_bennu": {
            groups: ["asteroids", "NEOs", "PHAs"],
            radius: .246,
            label: "Bennu",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/101955_bennu/Bennu.gltf",
                rotate: [{
                    x: 83
                }, {
                    z: -168
                }],
                scale: 9956e-7
            },
            controllers: [{
                type: "dynamo",
                url: "101955_bennu/sun/orb"
            }, {
                type: "dynamo",
                url: "101955_bennu/ori"
            }]
        },
        "11351_leucus": {
            groups: ["asteroids"],
            radius: 17.0775,
            label: "Leucus",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: 17.0775
            },
            controllers: [{
                type: "dynamo",
                url: "11351_leucus/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 445.732
            }]
        },
        "12923_zephyr": {
            groups: ["asteroids", "NEOs", "PHAs"],
            radius: 1.03,
            label: "Zephyr",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [1.03, 1.03, 1.03]
            },
            controllers: [{
                type: "dynamo",
                url: "12923_zephyr/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 3.891
            }]
        },
        "134340_pluto": {
            groups: ["dwarf planets", "moons", "134340_pluto_barycenter"],
            radius: 1187,
            label: "Pluto",
            labelFadeEntity: "sun",
            parents: [[Number.NEGATIVE_INFINITY, "134340_pluto_barycenter"]],
            trail: {
                length: void 0
            },
            spheroid: {
                equatorialRadius: 1187,
                polarRadius: 1187,
                planetographic: !1
            },
            spheroidLOD: {
                textures: {
                    color: {
                        url: "134340_pluto/color_$SIZE_$FACE.png",
                        sizes: [4, 512, 4096]
                    }
                }
            },
            controllers: [{
                type: "dynamo",
                url: "134340_pluto/134340_pluto_barycenter/orb"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    axis: s.Vector3.XAxis,
                    target: "charon"
                },
                secondary: {
                    type: "velocity",
                    axis: s.Vector3.YAxis,
                    target: "charon"
                }
            }]
        },
        "134340_pluto_barycenter": {
            groups: ["134340_pluto", "barycenters"],
            occlusionRadius: .001,
            extentsRadius: 28e3,
            systemRadius: 130153,
            label: "Barycenter",
            labelFadeEntity: "134340_pluto",
            trail: {
                length: void 0
            },
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            controllers: [{
                type: "dynamo",
                url: "134340_pluto_barycenter/sun/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }],
            postCreateFunction: t => {
                const e = t.getComponent(s.DivComponent);
                e && e.setFadeWhenCloseToCamera(!1),
                t.setCanOcclude(!1)
            }
        },
        "136108_haumea": {
            groups: ["dwarf planets", "TNOs"],
            radius: 816,
            label: "Haumea",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/136108_haumea/haumea.gltf",
                scale: [1, 1, 1]
            },
            controllers: [{
                type: "dynamo",
                url: "136108_haumea/sun/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        "136199_eris": {
            groups: ["dwarf planets", "TNOs"],
            radius: 1163,
            label: "Eris",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            spheroid: {
                equatorialRadius: 1163,
                polarRadius: 1163,
                planetographic: !1
            },
            spheroidLOD: {
                textures: {
                    color: {
                        url: "136199_eris/color_$SIZE_$FACE.png",
                        sizes: [4, 512]
                    }
                }
            },
            controllers: [{
                type: "dynamo",
                url: "136199_eris/sun/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        "136472_makemake": {
            groups: ["dwarf planets", "TNOs"],
            radius: 715,
            label: "Makemake",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            spheroid: {
                equatorialRadius: 717,
                polarRadius: 710,
                planetographic: !1
            },
            spheroidLOD: {
                textures: {
                    color: {
                        url: "136472_makemake/color_$SIZE_$FACE.png",
                        sizes: [4, 512]
                    }
                }
            },
            controllers: [{
                type: "dynamo",
                url: "136472_makemake/sun/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        "14827_hypnos": {
            groups: ["asteroids", "NEOs", "PHAs"],
            radius: .4535,
            label: "Hypnos",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [.4535, .4535, .4535]
            },
            controllers: [{
                type: "dynamo",
                url: "14827_hypnos/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 12
            }]
        },
        "15094_polymele": {
            groups: ["asteroids"],
            radius: 10.5375,
            label: "Polymele",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: 10.5375
            },
            controllers: [{
                type: "dynamo",
                url: "15094_polymele/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 5.8607
            }]
        },
        "1566_icarus": {
            groups: ["asteroids", "NEOs", "PHAs"],
            radius: .805,
            label: "Icarus",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [.805, .8, .585]
            },
            controllers: [{
                type: "dynamo",
                url: "1566_icarus/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 2.2726
            }]
        },
        "16_psyche": {
            groups: ["asteroids"],
            radius: 125,
            label: "16 Psyche",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/16_psyche/psycheAsteroid.gltf",
                scale: [100, 100, 100],
                rotate: [{
                    x: 90
                }, {
                    z: -120
                }]
            },
            controllers: [{
                type: "dynamo",
                url: "16_psyche/sun/orb"
            }, {
                type: "dynamo",
                url: "16_psyche/ori"
            }]
        },
        "1620_geographos": {
            groups: ["asteroids", "NEOs", "PHAs"],
            radius: 2.5,
            label: "Geographos",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [2.5, 1, 1.05]
            },
            controllers: [{
                type: "dynamo",
                url: "1620_geographos/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 5.224
            }]
        },
        "162173_ryugu": {
            groups: ["asteroids", "NEOs", "PHAs"],
            radius: .45,
            label: "Ryugu",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/162173_ryugu/ryugu.gltf",
                rotate: [{
                    x: -90
                }]
            },
            controllers: [{
                type: "dynamo",
                url: "ssd/162173_ryugu/sun/orb"
            }, {
                type: "dynamo",
                url: "162173_ryugu/ori"
            }]
        },
        "1862_apollo": {
            groups: ["asteroids", "NEOs", "PHAs"],
            radius: .75,
            label: "Apollo",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [.75, .75, .75]
            },
            controllers: [{
                type: "dynamo",
                url: "1862_apollo/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 3.065
            }]
        },
        "1981_midas": {
            groups: ["asteroids", "NEOs", "PHAs"],
            radius: .975,
            label: "Midas",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [.975, .975, .975]
            },
            controllers: [{
                type: "dynamo",
                url: "1981_midas/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 5.22
            }]
        },
        "1991_vg": {
            groups: ["asteroids", "NEOs"],
            radius: .00425,
            label: "1991 VG",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [.00425, .00425, .00425]
            },
            controllers: [{
                type: "dynamo",
                url: "1991_vg/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 12
            }]
        },
        "1993_hd": {
            groups: ["asteroids", "asteroid belt"],
            radius: .005,
            label: "1993 HD",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [.005, .005, .005]
            },
            controllers: [{
                type: "dynamo",
                url: "1993_hd/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 12
            }]
        },
        "1994_cc_a": {
            groups: ["asteroids", "NEOs", "PHAs"],
            radius: .325,
            label: "1994 CC",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [.325, .325, .325]
            },
            controllers: [{
                type: "dynamo",
                url: "1994_cc_a/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 2.3886
            }]
        },
        "1996_xb27": {
            groups: ["asteroids", "NEOs"],
            radius: .042,
            label: "1996 XB<sub>27</sub>",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [.042, .042, .042]
            },
            controllers: [{
                type: "dynamo",
                url: "1996_xb27/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 1.195
            }]
        },
        "1998_ky26": {
            groups: ["asteroids", "NEOs"],
            radius: .015,
            label: "1998 KY<sub>26</sub>",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [.015, .015, .015]
            },
            controllers: [{
                type: "dynamo",
                url: "1998_ky26/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: .1784
            }]
        },
        "1998_ml14": {
            groups: ["asteroids", "NEOs", "PHAs"],
            radius: .5,
            label: "1998 ML<sub>14</sub>",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [.5, .5, .5]
            },
            controllers: [{
                type: "dynamo",
                url: "1998_ml14/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 14.28
            }]
        },
        "1998_qe2": {
            groups: ["asteroids", "NEOs", "PHAs"],
            radius: 1.375,
            label: "1998 QE<sub>2</sub>",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [1.375, 1.375, 1.375]
            },
            controllers: [{
                type: "dynamo",
                url: "1998_qe2/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 4.749
            }]
        },
        "1999_ao10": {
            groups: ["asteroids", "NEOs"],
            radius: .025,
            label: "1999 AO<sub>10</sub>",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [.025, .025, .025]
            },
            controllers: [{
                type: "dynamo",
                url: "1999_ao10/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 12
            }]
        },
        "1999_cg9": {
            groups: ["asteroids", "NEOs"],
            radius: .005,
            label: "1999 CG<sub>9</sub>",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [.005, .005, .005]
            },
            controllers: [{
                type: "dynamo",
                url: "1999_cg9/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 12
            }]
        },
        "1999_vx25": {
            groups: ["asteroids", "NEOs"],
            radius: .005,
            label: "1999 VX<sub>25</sub>",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [.005, .005, .005]
            },
            controllers: [{
                type: "dynamo",
                url: "1999_vx25/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 12
            }]
        },
        "2_pallas": {
            groups: ["asteroids", "asteroid belt"],
            radius: 291,
            label: "Pallas",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [291, 278, 250]
            },
            controllers: [{
                type: "dynamo",
                url: "2_pallas/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 7.8132
            }]
        },
        "2000_ae205": {
            groups: ["asteroids", "NEOs"],
            radius: .005,
            label: "2000 AE<sub>205</sub>",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [.005, .005, .005]
            },
            controllers: [{
                type: "dynamo",
                url: "2000_ae205/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 12
            }]
        },
        "2000_lg6": {
            groups: ["asteroids", "NEOs"],
            radius: .005,
            label: "2000 LG<sub>6</sub>",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [.005, .005, .005]
            },
            controllers: [{
                type: "dynamo",
                url: "2000_lg6/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 12
            }]
        },
        "2000_sg344": {
            groups: ["asteroids", "NEOs"],
            radius: .0185,
            label: "2000 SG<sub>344</sub>",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [.0185, .0185, .0185]
            },
            controllers: [{
                type: "dynamo",
                url: "2000_sg344/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 12
            }]
        },
        "2001_bb16": {
            groups: ["asteroids", "NEOs"],
            radius: .005,
            label: "2001 BB<sub>16</sub>",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [.005, .005, .005]
            },
            controllers: [{
                type: "dynamo",
                url: "2001_bb16/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 12
            }]
        },
        "2001_fr85": {
            groups: ["asteroids", "NEOs"],
            radius: .005,
            label: "2001 FR<sub>85</sub>",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [.005, .005, .005]
            },
            controllers: [{
                type: "dynamo",
                url: "2001_fr85/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 12
            }]
        },
        "2001_gp2": {
            groups: ["asteroids", "NEOs"],
            radius: .005,
            label: "2001 GP<sub>2</sub>",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [.005, .005, .005]
            },
            controllers: [{
                type: "dynamo",
                url: "2001_gp2/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 12
            }]
        },
        "2001_qj142": {
            groups: ["asteroids", "NEOs"],
            radius: .005,
            label: "2001 QJ<sub>142</sub>",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [.005, .005, .005]
            },
            controllers: [{
                type: "dynamo",
                url: "2001_qj142/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 12
            }]
        },
        "2001_sn263_a": {
            groups: ["asteroids", "NEOs"],
            radius: 1.45,
            label: "(153591) 2001 SN<sub>263</sub>",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [1.4, 1.35, 1.45]
            },
            controllers: [{
                type: "dynamo",
                url: "2001_sn263_a/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 3.423
            }]
        },
        "2003_sm84": {
            groups: ["asteroids", "NEOs"],
            radius: .005,
            label: "2003 SM<sub>84</sub>",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [.005, .005, .005]
            },
            controllers: [{
                type: "dynamo",
                url: "2003_sm84/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 12
            }]
        },
        "2003_uv11": {
            groups: ["asteroids", "NEOs"],
            radius: .13,
            label: "(503941) 2003 UV<sub>11</sub>",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [.13, .13, .13]
            },
            controllers: [{
                type: "dynamo",
                url: "2003_uv11/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 18.25
            }]
        },
        "2003_yn107": {
            groups: ["asteroids", "NEOs"],
            radius: .01,
            label: "2003 YN<sub>107</sub>",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [.01, .01, .01]
            },
            controllers: [{
                type: "dynamo",
                url: "2003_yn107/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 12
            }]
        },
        "2005_er95": {
            groups: ["asteroids", "NEOs"],
            radius: .005,
            label: "2003 ER<sub>95</sub>",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [.005, .005, .005]
            },
            controllers: [{
                type: "dynamo",
                url: "2005_er95/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 12
            }]
        },
        "2005_lc": {
            groups: ["asteroids", "NEOs"],
            radius: .005,
            label: "2005 LC",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [.005, .005, .005]
            },
            controllers: [{
                type: "dynamo",
                url: "2005_lc/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 12
            }]
        },
        "2005_qp87": {
            groups: ["asteroids", "NEOs"],
            radius: .005,
            label: "2005 QP<sub>87</sub>",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [.005, .005, .005]
            },
            controllers: [{
                type: "dynamo",
                url: "2005_qp87/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 12
            }]
        },
        "2005_yu55": {
            groups: ["asteroids", "NEOs"],
            radius: .18,
            label: "2005 YU<sub>55</sub>",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [.18, .18, .18]
            },
            controllers: [{
                type: "dynamo",
                url: "2005_yu55/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 18
            }]
        },
        "2006_bz147": {
            groups: ["asteroids", "NEOs"],
            radius: .005,
            label: "2006 BZ<sub>147</sub>",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [.005, .005, .005]
            },
            controllers: [{
                type: "dynamo",
                url: "2006_bz147/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 12
            }]
        },
        "2006_jy26": {
            groups: ["asteroids", "NEOs"],
            radius: .00475,
            label: "2006 JY<sub>26</sub>",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [.00475, .00475, .00475]
            },
            controllers: [{
                type: "dynamo",
                url: "2006_jy26/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 12
            }]
        },
        "2006_qq56": {
            groups: ["asteroids", "NEOs"],
            radius: .005,
            label: "2006 QQ<sub>56</sub>",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [.005, .005, .005]
            },
            controllers: [{
                type: "dynamo",
                url: "2006_qq56/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 12
            }]
        },
        "2006_rh120": {
            groups: ["asteroids", "NEOs"],
            radius: .00125,
            label: "2006 RH<sub>120</sub>",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [.00125, .00125, .00125]
            },
            controllers: [{
                type: "dynamo",
                url: "2006_rh120/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: .04583
            }]
        },
        "2006_ub17": {
            groups: ["asteroids", "NEOs"],
            radius: .005,
            label: "2006 UB<sub>17</sub>",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [.005, .005, .005]
            },
            controllers: [{
                type: "dynamo",
                url: "2006_ub17/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 12
            }]
        },
        "2007_tf15": {
            groups: ["asteroids", "NEOs"],
            radius: .005,
            label: "2007 TF<sub>15</sub>",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [.005, .005, .005]
            },
            controllers: [{
                type: "dynamo",
                url: "2007_tf15/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 12
            }]
        },
        "2007_un12": {
            groups: ["asteroids", "NEOs"],
            radius: .005,
            label: "2007 UN<sub>12</sub>",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [.005, .005, .005]
            },
            controllers: [{
                type: "dynamo",
                url: "2007_un12/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 12
            }]
        },
        "2007_vu6": {
            groups: ["asteroids", "NEOs"],
            radius: .005,
            label: "2007 VU<sub>6</sub>",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [.005, .005, .005]
            },
            controllers: [{
                type: "dynamo",
                url: "2007_vu6/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 12
            }]
        },
        "2008_bt2": {
            groups: ["asteroids", "NEOs"],
            radius: .005,
            label: "2008 BT<sub>2</sub>",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [.005, .005, .005]
            },
            controllers: [{
                type: "dynamo",
                url: "2008_bt2/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 12
            }]
        },
        "2008_cx118": {
            groups: ["asteroids", "NEOs"],
            radius: .005,
            label: "2008 CX<sub>118</sub>",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [.005, .005, .005]
            },
            controllers: [{
                type: "dynamo",
                url: "2008_cx118/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 12
            }]
        },
        "2008_ea9": {
            groups: ["asteroids", "NEOs"],
            radius: .005,
            label: "2008 EA<sub>9</sub>",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [.005, .005, .005]
            },
            controllers: [{
                type: "dynamo",
                url: "2008_ea9/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 12
            }]
        },
        "2008_el": {
            groups: ["asteroids", "NEOs"],
            radius: .005,
            label: "2008 EL",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [.005, .005, .005]
            },
            controllers: [{
                type: "dynamo",
                url: "2008_el/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 12
            }]
        },
        "2008_hu4": {
            groups: ["asteroids", "NEOs"],
            radius: .005,
            label: "2008 HU<sub>4</sub>",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [.005, .005, .005]
            },
            controllers: [{
                type: "dynamo",
                url: "2008_hu4/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 12
            }]
        },
        "2008_jl24": {
            groups: ["asteroids", "NEOs"],
            radius: .005,
            label: "2008 JL<sub>24</sub>",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [.005, .005, .005]
            },
            controllers: [{
                type: "dynamo",
                url: "2008_jl24/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: .05385
            }]
        },
        "2008_kt": {
            groups: ["asteroids", "NEOs"],
            radius: .005,
            label: "2008 KT",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [.005, .005, .005]
            },
            controllers: [{
                type: "dynamo",
                url: "2008_kt/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 12
            }]
        },
        "2008_tc3": {
            groups: ["asteroids", "NEOs"],
            radius: .00205,
            label: "2008 TC<sub>3</sub>",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [.00205, .00205, .00205]
            },
            controllers: [{
                type: "dynamo",
                url: "2008_tc3/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: .0269409
            }]
        },
        "2008_ts10": {
            groups: ["asteroids", "NEOs"],
            radius: .005,
            label: "2008 TS<sub>10</sub>",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [.005, .005, .005]
            },
            controllers: [{
                type: "dynamo",
                url: "2008_ts10/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 12
            }]
        },
        "2008_ua202": {
            groups: ["asteroids", "NEOs"],
            radius: .025,
            label: "2008 UA<sub>202</sub>",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [.025, .025, .025]
            },
            controllers: [{
                type: "dynamo",
                url: "2008_ua202/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 12
            }]
        },
        "2009_bd": {
            groups: ["asteroids", "NEOs"],
            radius: .0055,
            label: "2009 BD",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [.0055, .0055, .0055]
            },
            controllers: [{
                type: "dynamo",
                url: "2009_bd/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 12
            }]
        },
        "2009_os5": {
            groups: ["asteroids", "NEOs"],
            radius: .005,
            label: "2009 OS<sub>5</sub>",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [.005, .005, .005]
            },
            controllers: [{
                type: "dynamo",
                url: "2009_os5/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 12
            }]
        },
        "2009_rt1": {
            groups: ["asteroids", "NEOs"],
            radius: .005,
            label: "2009 RT<sub>1</sub>",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [.005, .005, .005]
            },
            controllers: [{
                type: "dynamo",
                url: "2009_rt1/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 12
            }]
        },
        "2009_yf": {
            groups: ["asteroids", "NEOs"],
            radius: .005,
            label: "2009 YF",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [.005, .005, .005]
            },
            controllers: [{
                type: "dynamo",
                url: "2009_yf/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 12
            }]
        },
        "2010_an61": {
            groups: ["asteroids", "NEOs"],
            radius: .005,
            label: "2010 AN<sub>61</sub>",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [.005, .005, .005]
            },
            controllers: [{
                type: "dynamo",
                url: "2010_an61/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 12
            }]
        },
        "2010_dj": {
            groups: ["asteroids", "NEOs"],
            radius: .005,
            label: "2010 DJ",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [.005, .005, .005]
            },
            controllers: [{
                type: "dynamo",
                url: "2010_dj/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 12
            }]
        },
        "2010_jw34": {
            groups: ["asteroids", "NEOs"],
            radius: .005,
            label: "2010 JW<sub>34</sub>",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [.005, .005, .005]
            },
            controllers: [{
                type: "dynamo",
                url: "2010_jw34/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 12
            }]
        },
        "2010_tg19": {
            groups: ["asteroids", "NEOs"],
            radius: .005,
            label: "2010 TG<sub>19</sub>",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [.005, .005, .005]
            },
            controllers: [{
                type: "dynamo",
                url: "2010_tg19/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 12
            }]
        },
        "2010_tn167": {
            groups: ["asteroids", "NEOs"],
            radius: .005,
            label: "2010 TN<sub>167</sub>",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [.005, .005, .005]
            },
            controllers: [{
                type: "dynamo",
                url: "2010_tn167/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 12
            }]
        },
        "2010_ub": {
            groups: ["asteroids", "NEOs"],
            radius: .005,
            label: "2010 UB",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [.005, .005, .005]
            },
            controllers: [{
                type: "dynamo",
                url: "2010_ub/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 12
            }]
        },
        "2063_bacchus": {
            groups: ["asteroids", "NEOs"],
            radius: .555,
            label: "Bacchus",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [.555, .265, .25]
            },
            controllers: [{
                type: "dynamo",
                url: "2063_bacchus/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 14.904
            }]
        },
        "21_lutetia": {
            groups: ["asteroids", "asteroid belt"],
            radius: 60.5,
            label: "Lutetia",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [60.5, 50.5, 37.5]
            },
            controllers: [{
                type: "dynamo",
                url: "21_lutetia/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 8.1655
            }]
        },
        "2101_adonis": {
            groups: ["asteroids", "NEOs", "PHAs"],
            radius: .2615,
            label: "Adonis",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [.2615, .2615, .2615]
            },
            controllers: [{
                type: "dynamo",
                url: "2101_adonis/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 12
            }]
        },
        "2102_tantalus": {
            groups: ["asteroids", "NEOs", "PHAs"],
            radius: .8245,
            label: "Tantalus",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [.8245, .8245, .8245]
            },
            controllers: [{
                type: "dynamo",
                url: "2102_tantalus/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 2.384
            }]
        },
        "2135_aristaeus": {
            groups: ["asteroids", "NEOs", "PHAs"],
            radius: .5,
            label: "Aristaeus",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [.5, .5, .5]
            },
            controllers: [{
                type: "dynamo",
                url: "2135_aristaeus/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 12
            }]
        },
        "216_kleopatra": {
            groups: ["asteroids", "asteroid belt"],
            radius: 138,
            label: "Kleopatra",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [138, 47, 39]
            },
            controllers: [{
                type: "dynamo",
                url: "216_kleopatra/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 5.385
            }]
        },
        "21900_orus": {
            groups: ["asteroids"],
            radius: 25.405,
            label: "Orus",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: 25.405
            },
            controllers: [{
                type: "dynamo",
                url: "21900_orus/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 13.45
            }]
        },
        "225088_gonggong": {
            groups: ["dwarf planets", "TNOs"],
            radius: 615,
            label: "225088 Gonggong",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            spheroid: {
                equatorialRadius: 615,
                polarRadius: 596.55,
                planetographic: !1
            },
            spheroidLOD: {},
            controllers: [{
                type: "dynamo",
                url: "225088_gonggong/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 22.4
            }],
            postCreateFunction: t => {
                const e = t.getComponent(s.SpheroidLODComponent);
                e && e.setResourcesLoadedCallback(( () => {
                    e.getThreeJsMaterials().forEach((t => {
                        t.defines.baseColor = !0,
                        t.uniforms.color.value.set(.463, .404, .306, 1)
                    }
                    ))
                }
                ))
            }
        },
        "225088_gonggong_i_xiangliu": {
            groups: ["225088_gonggong", "moons"],
            radius: 70,
            label: "Xiangliu",
            parents: [[Number.NEGATIVE_INFINITY, "225088_gonggong"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: 70
            },
            controllers: [{
                type: "orbitalElements",
                eccentricity: .2908,
                semiMajorAxis: 24021,
                meanAngularMotion: 288342e-11,
                meanAnomalyAtEpoch: 0,
                inclination: 1.45001954256,
                longitudeOfAscendingNode: .55833082771,
                argumentOfPeriapsis: .1,
                coverage: [Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY]
            }, {
                type: "align",
                primary: {
                    type: "point",
                    axis: s.Vector3.YAxis,
                    target: "225088_gonggong"
                }
            }]
        },
        "2340_hathor": {
            groups: ["asteroids", "NEOs", "PHAs"],
            radius: .105,
            label: "Hathor",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [.105, .105, .105]
            },
            controllers: [{
                type: "dynamo",
                url: "2340_hathor/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 3.35
            }]
        },
        "243_ida": {
            groups: ["asteroids", "asteroid belt"],
            radius: 29.9,
            label: "Ida",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [18.6 * 1.3, 25.4 * 1.3, 77.74],
                rotate: [{
                    y: 90
                }]
            },
            controllers: [{
                type: "dynamo",
                url: "243_ida/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 4.634
            }]
        },
        "25143_itokawa": {
            groups: ["asteroids", "NEOs", "PHAs"],
            radius: .165,
            label: "Itokawa",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/25143_itokawa/itokawa.gltf",
                rotate: [{
                    x: 90
                }]
            },
            controllers: [{
                type: "dynamo",
                url: "25143_itokawa/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 12.132
            }]
        },
        "253_mathilde": {
            groups: ["asteroids", "asteroid belt"],
            radius: 33,
            label: "Mathilde",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [33, 24, 23]
            },
            controllers: [{
                type: "dynamo",
                url: "253_mathilde/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 417.7
            }]
        },
        "2867_steins": {
            groups: ["asteroids", "asteroid belt"],
            radius: 3.415,
            label: "Å teins",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [3.415, 2.85, 2.21]
            },
            controllers: [{
                type: "dynamo",
                url: "2867_steins/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 6.049
            }]
        },
        "3_juno": {
            groups: ["asteroids", "asteroid belt"],
            radius: 160,
            label: "Juno",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [160, 133.5, 100]
            },
            controllers: [{
                type: "dynamo",
                url: "3_juno/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 7.21
            }]
        },
        "3122_florence": {
            groups: ["asteroids", "NEOs", "PHAs"],
            radius: 2.2,
            label: "Florence",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [2.2, 2.2, 2.2]
            },
            controllers: [{
                type: "dynamo",
                url: "3122_florence/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 2.3581
            }]
        },
        "3200_phaethon": {
            groups: ["asteroids", "NEOs", "PHAs"],
            radius: 2.9,
            label: "Phaethon",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [2.9, 2.9, 2.9]
            },
            controllers: [{
                type: "dynamo",
                url: "3200_phaethon/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 3.604
            }]
        },
        "3362_khufu": {
            groups: ["asteroids", "NEOs", "PHAs"],
            radius: .35,
            label: "Khufu",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [.35, .35, .35]
            },
            controllers: [{
                type: "dynamo",
                url: "3362_khufu/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 12
            }]
        },
        "3548_eurybates": {
            groups: ["asteroids"],
            radius: 31.9425,
            label: "Eurybates",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: 31.9425
            },
            controllers: [{
                type: "dynamo",
                url: "3548_eurybates/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 8.711
            }]
        },
        "367943_duende": {
            groups: ["asteroids", "NEOs"],
            radius: .02,
            label: "Duende",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [.01, .01, .02]
            },
            controllers: [{
                type: "dynamo",
                url: "367943_duende/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 9.485
            }]
        },
        "37655_illapa": {
            groups: ["asteroids", "NEOs", "PHAs"],
            radius: .75,
            label: "Illapa",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [.75, .75, .75]
            },
            controllers: [{
                type: "dynamo",
                url: "37655_illapa/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 2.6556
            }]
        },
        "4_vesta": {
            groups: ["asteroids", "asteroid belt"],
            radius: 262.7,
            label: "Vesta",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/4_vesta/4_vesta.gltf",
                rotate: [{
                    x: 90
                }]
            },
            controllers: [{
                type: "dynamo",
                url: "4_vesta/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 12
            }]
        },
        "4015_wilson-harrington": {
            groups: ["asteroids", "NEOs", "PHAs"],
            radius: 2,
            label: "Wilson-Harrington",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [2, 2, 2]
            },
            controllers: [{
                type: "dynamo",
                url: "4015_wilson-harrington/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 3.5736
            }]
        },
        "4179_toutatis": {
            groups: ["asteroids", "NEOs", "PHAs"],
            radius: 2.13,
            label: "Toutatis",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [1.35, 1.015, 2.13]
            },
            controllers: [{
                type: "dynamo",
                url: "4179_toutatis/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 176
            }]
        },
        "4183_cuno": {
            groups: ["asteroids", "NEOs", "PHAs"],
            radius: 1.8255,
            label: "Cuno",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [1.8255, 1.8255, 1.89255]
            },
            controllers: [{
                type: "dynamo",
                url: "4183_cuno/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 3.5595
            }]
        },
        "433_eros": {
            groups: ["asteroids", "NEOs"],
            radius: 8.42,
            label: "Eros",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/433_eros/433_eros.gltf"
            },
            controllers: [{
                type: "dynamo",
                url: "433_eros/sun/orb"
            }, {
                type: "dynamo",
                url: "433_eros/ori"
            }]
        },
        "4450_pan": {
            groups: ["asteroids", "NEOs", "PHAs"],
            radius: .5,
            label: "Pan",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [.5, .5, .5]
            },
            controllers: [{
                type: "dynamo",
                url: "4450_pan/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 56.48
            }]
        },
        "4486_mithra": {
            groups: ["asteroids", "NEOs", "PHAs"],
            radius: 1.175,
            label: "Mithra",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [1.175, .825, .72]
            },
            controllers: [{
                type: "dynamo",
                url: "4486_mithra/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 67.5
            }]
        },
        "4769_castalia": {
            groups: ["asteroids", "NEOs", "PHAs"],
            radius: .9,
            label: "Castalia",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [.4, .4, .9]
            },
            controllers: [{
                type: "dynamo",
                url: "4769_castalia/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 4.095
            }]
        },
        "486958_arrokoth": {
            groups: ["TNOs"],
            radius: 15,
            label: "Arrokoth",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/486958_arrokoth/mu69.gltf",
                scale: [1, 1, 1],
                rotate: [{
                    x: -110
                }, {
                    y: 180
                }]
            },
            controllers: [{
                type: "dynamo",
                url: "486958_arrokoth/sun/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }, {
                type: "spin",
                axis: new s.Vector3(-6.121453676996425e-10,.9396926211599973,.34202014229786787),
                periodInHours: 13
            }],
            postCreateFunction: t => {
                const e = t.getController(s.SpinController);
                null !== e && (e.setReferenceAngle(0),
                e.setReferenceTime(599590968))
            }
        },
        "5011_ptah": {
            groups: ["asteroids", "NEOs", "PHAs"],
            radius: .78,
            label: "Ptah",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [.78, .78, .78]
            },
            controllers: [{
                type: "dynamo",
                url: "5011_ptah/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 12
            }]
        },
        "52246_donaldjohanson": {
            groups: ["asteroids"],
            radius: 1.9475,
            label: "Donaldjohanson",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: 1.9475
            },
            controllers: [{
                type: "dynamo",
                url: "52246_donaldjohanson/sun/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        "5535_annefrank": {
            groups: ["asteroids"],
            radius: 2.412,
            label: "Annefrank",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: 2.412
            },
            controllers: [{
                type: "dynamo",
                url: "5535_annefrank/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 15.12
            }]
        },
        "617_patroclus": {
            groups: ["asteroids", "617_patroclus_barycenter"],
            radius: 64,
            label: "Patroclus",
            labelFadeEntity: "sun",
            parents: [[Number.NEGATIVE_INFINITY, "617_patroclus_barycenter"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [64, 58, 49],
                shadowEntities: ["menoetius"]
            },
            controllers: [{
                type: "align",
                primary: {
                    type: "point",
                    axis: s.Vector3.XAxis,
                    target: "menoetius"
                }
            }],
            postCreateFunction: t => {
                const e = t.getController(s.AlignController);
                if (!e)
                    return;
                const i = t.addController(s.OrbitalElementsController, void 0, e)
                  , n = new s.OrbitalElements;
                n.epoch = 0,
                n.eccentricity = 0,
                n.semiMajorAxis = 664,
                n.meanAngularMotion = 1697791e-11,
                n.meanAnomalyAtEpoch = Math.PI,
                n.setOrbitOrientationFromElements(1.97244894756, 0, 0),
                i.addOrbitalElements(-1e100, n),
                i.addOrbitalElements(1e100, n)
            }
        },
        "617_patroclus_barycenter": {
            groups: ["asteroids"],
            radius: 664,
            label: "Patroclus",
            labelFadeEntity: "617_patroclus",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            controllers: [{
                type: "dynamo",
                url: "617_patroclus/sun/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }],
            postCreateFunction: t => {
                t.setCanOcclude(!1)
            }
        },
        "6239_minos": {
            groups: ["asteroids", "NEOs", "PHAs"],
            radius: .237,
            label: "Minos",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [.237, .237, .237]
            },
            controllers: [{
                type: "dynamo",
                url: "6239_minos/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 3.5558
            }]
        },
        "6489_golevka": {
            groups: ["asteroids", "NEOs", "PHAs"],
            radius: .265,
            label: "Golevka",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [.265, .265, .265]
            },
            controllers: [{
                type: "dynamo",
                url: "6489_golevka/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 6.026
            }]
        },
        "65803_didymos": {
            groups: ["asteroids", "NEOs", "PHAs"],
            radius: .39,
            label: "Didymos",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/65803_didymos/Didymos.gltf",
                rotate: [{
                    z: 180
                }, {
                    x: -90
                }]
            },
            controllers: [{
                type: "dynamo",
                url: "65803_didymos/sun/orb"
            }, {
                type: "fixed",
                orientation: new s.Quaternion(0,1,0,0)
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 2.2593,
                relativeToTime: 0
            }]
        },
        "66391_moshup": {
            groups: ["asteroids", "NEOs", "PHAs"],
            radius: .766,
            label: "Moshup",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [.766, .7475, .6735]
            },
            controllers: [{
                type: "dynamo",
                url: "66391_moshup/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 2.7645
            }]
        },
        "69230_hermes": {
            groups: ["asteroids", "NEOs", "PHAs"],
            radius: .425,
            label: "Hermes",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [.425, .425, .425]
            },
            controllers: [{
                type: "dynamo",
                url: "69230_hermes/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 13.894
            }]
        },
        "90377_sedna": {
            groups: ["dwarf planets", "TNOs"],
            radius: 497.5,
            label: "Sedna",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [497.5, 497.5, 497.5]
            },
            controllers: [{
                type: "dynamo",
                url: "90377_sedna/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 10.273
            }]
        },
        "951_gaspra": {
            groups: ["asteroids", "asteroid belt"],
            radius: 9.1,
            label: "Gaspra",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/951_gaspra/gaspra.gltf"
            },
            controllers: [{
                type: "dynamo",
                url: "951_gaspra/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 7.042
            }]
        },
        "9969_braille": {
            groups: ["asteroids", "asteroid belt"],
            radius: 1.05,
            label: "Braille",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [1.05, .5, .5]
            },
            controllers: [{
                type: "dynamo",
                url: "9969_braille/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: 226.4
            }]
        },
        "99942_apophis": {
            groups: ["asteroids", "NEOs", "PHAs"],
            radius: .225,
            label: "Apophis",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/99942_apophis/apophis.gltf"
            },
            controllers: [{
                type: "dynamo",
                url: "99942_apophis/sun/orb"
            }, {
                type: "spin",
                axis: new s.Vector3(.20112425201023415,.46925803805904115,.8598522715968735),
                periodInHours: 30.4
            }]
        },
        "152830_dinkinesh": {
            groups: ["asteroids"],
            radius: .45,
            label: "Dinkinesh",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: .45
            },
            controllers: [{
                type: "dynamo",
                url: "152830_dinkinesh/sun/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        charon: {
            groups: ["134340_pluto", "moons", "134340_pluto_barycenter"],
            radius: 603.5,
            label: "Charon",
            parents: [[Number.NEGATIVE_INFINITY, "134340_pluto_barycenter"]],
            trail: {
                length: void 0
            },
            spheroid: {
                equatorialRadius: 603.5,
                polarRadius: 603.5,
                planetographic: !1
            },
            spheroidLOD: {
                textures: {
                    color: {
                        url: "charon/color_$SIZE_$FACE.png",
                        sizes: [4, 512, 2048]
                    }
                }
            },
            controllers: [{
                type: "dynamo",
                url: "charon/134340_pluto_barycenter/orb"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    axis: s.Vector3.XAxis,
                    target: "134340_pluto"
                },
                secondary: {
                    type: "velocity",
                    axis: s.Vector3.YAxis,
                    target: "134340_pluto"
                }
            }]
        },
        dactyl: {
            groups: ["243_ida", "moons"],
            radius: .7,
            label: "Dactyl",
            parents: [[Number.NEGATIVE_INFINITY, "243_ida"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [.8, .7, .6],
                rotate: [{
                    z: 90
                }]
            },
            controllers: [{
                type: "align",
                primary: {
                    type: "point",
                    axis: s.Vector3.XAxis,
                    target: "243_ida"
                }
            }],
            postCreateFunction: t => {
                const e = t.getController(s.AlignController);
                if (!e)
                    return;
                const i = t.addController(s.OrbitalElementsController, void 0, e)
                  , n = new s.OrbitalElements;
                n.epoch = 0,
                n.eccentricity = 0,
                n.semiMajorAxis = 90,
                n.meanAngularMotion = 8726646e-11,
                n.meanAnomalyAtEpoch = 0,
                n.orbitOrientation.set(.8728453580255966, .1876084386162498, -.08948587100888229, .4415159494547423),
                i.addOrbitalElements(-1e100, n),
                i.addOrbitalElements(1e100, n)
            }
        },
        dimorphos: {
            groups: ["65803_didymos", "moons"],
            radius: .085,
            label: "Dimorphos",
            parents: [[Number.NEGATIVE_INFINITY, "65803_didymos"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/dimorphos/Dimorphos.gltf"
            },
            controllers: [{
                type: "dynamo",
                url: "dimorphos/65803_didymos/orb"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    axis: s.Vector3.XAxis,
                    target: "65803_didymos"
                },
                secondary: {
                    type: "align",
                    axis: s.Vector3.ZAxis,
                    target: "65803_didymos",
                    targetAxis: s.Vector3.ZAxis
                }
            }]
        },
        hiiaka: {
            groups: ["136108_haumea", "moons"],
            radius: 160,
            label: "Hi'iaka",
            parents: [[Number.NEGATIVE_INFINITY, "136108_haumea"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [160, 160, 160]
            },
            controllers: [{
                type: "align",
                primary: {
                    type: "point",
                    axis: s.Vector3.XAxis,
                    target: "136108_haumea"
                }
            }],
            postCreateFunction: t => {
                const e = t.getController(s.AlignController);
                if (!e)
                    return;
                const i = t.addController(s.OrbitalElementsController, void 0, e)
                  , n = new s.OrbitalElements;
                n.epoch = 0,
                n.eccentricity = .0513,
                n.semiMajorAxis = 49880,
                n.meanAngularMotion = 148049e-11,
                n.meanAnomalyAtEpoch = 0,
                n.setOrbitOrientationFromElements(2.20532822965, 0, 0),
                i.addOrbitalElements(-1e100, n),
                i.addOrbitalElements(1e100, n)
            }
        },
        hydra: {
            groups: ["134340_pluto", "moons", "134340_pluto_barycenter"],
            radius: 25,
            label: "Hydra",
            parents: [[Number.NEGATIVE_INFINITY, "134340_pluto_barycenter"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [25, 25, 25],
                shadowEntities: ["134340_pluto"]
            },
            controllers: [{
                type: "dynamo",
                url: "hydra/134340_pluto_barycenter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        kerberos: {
            groups: ["134340_pluto", "moons", "134340_pluto_barycenter"],
            radius: 8.25,
            label: "Kerberos",
            parents: [[Number.NEGATIVE_INFINITY, "134340_pluto_barycenter"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [8.25, 8.25, 8.25],
                shadowEntities: ["134340_pluto"]
            },
            controllers: [{
                type: "dynamo",
                url: "kerberos/134340_pluto_barycenter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        menoetius: {
            groups: ["617_patroclus_barycenter", "moons"],
            radius: 58,
            label: "Menoetius",
            parents: [[Number.NEGATIVE_INFINITY, "617_patroclus_barycenter"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [58, 54, 45],
                shadowEntities: ["617_patroclus"]
            },
            controllers: [{
                type: "align",
                primary: {
                    type: "point",
                    axis: s.Vector3.XAxis,
                    target: "617_patroclus"
                }
            }],
            postCreateFunction: t => {
                const e = t.getController(s.AlignController);
                if (!e)
                    return;
                const i = t.addController(s.OrbitalElementsController, void 0, e)
                  , n = new s.OrbitalElements;
                n.epoch = 0,
                n.eccentricity = 0,
                n.semiMajorAxis = 664,
                n.meanAngularMotion = 1697791e-11,
                n.meanAnomalyAtEpoch = 0,
                n.setOrbitOrientationFromElements(1.97244894756, 0, 0),
                i.addOrbitalElements(-1e100, n),
                i.addOrbitalElements(1e100, n)
            }
        },
        namaka: {
            groups: ["136108_haumea", "moons"],
            radius: 85,
            label: "NÄmaka",
            parents: [[Number.NEGATIVE_INFINITY, "136108_haumea"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [85, 85, 85]
            },
            controllers: [{
                type: "align",
                primary: {
                    type: "point",
                    axis: s.Vector3.XAxis,
                    target: "136108_haumea"
                }
            }],
            postCreateFunction: t => {
                const e = t.getController(s.AlignController);
                if (!e)
                    return;
                const i = t.addController(s.OrbitalElementsController, void 0, e)
                  , n = new s.OrbitalElements;
                n.epoch = 0,
                n.eccentricity = .249,
                n.semiMajorAxis = 25657,
                n.meanAngularMotion = 39786e-10,
                n.meanAnomalyAtEpoch = 0,
                n.setOrbitOrientationFromElements(1.97244894756, 0, 0),
                i.addOrbitalElements(-1e100, n),
                i.addOrbitalElements(1e100, n)
            }
        },
        nix: {
            groups: ["134340_pluto", "moons", "134340_pluto_barycenter"],
            radius: 24,
            label: "Nix",
            parents: [[Number.NEGATIVE_INFINITY, "134340_pluto_barycenter"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [24, 24, 24],
                shadowEntities: ["134340_pluto"]
            },
            controllers: [{
                type: "dynamo",
                url: "nix/134340_pluto_barycenter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        styx: {
            groups: ["134340_pluto", "moons", "134340_pluto_barycenter"],
            radius: 5.5,
            label: "Styx",
            parents: [[Number.NEGATIVE_INFINITY, "134340_pluto_barycenter"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [5.5, 5.5, 5.5],
                shadowEntities: ["134340_pluto"]
            },
            controllers: [{
                type: "dynamo",
                url: "styx/134340_pluto_barycenter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        }
    })
}
, function(t, e, i) {
    "use strict";
    i.r(e);
    var s = i(5)
      , n = i(545)
      , o = i(665);
    n.Entity.register({
        "1i_oumuamua": {
            groups: ["comets"],
            occlusionRadius: .03,
            extentsRadius: .225,
            label: "Ê»Oumuamua",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/1i_oumuamua/oumuamua.gltf"
            },
            comet: {},
            controllers: [{
                type: "dynamo",
                url: "1i_oumuamua/sun/orb"
            }, {
                type: "spin",
                axis: new s.Vector3(.57735026919,.57735026919,.57735026919),
                periodInHours: 8.1
            }]
        },
        "1p_halley": {
            groups: ["comets"],
            radius: 6,
            label: "Halley (1P/Halley)",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [6, 6, 6]
            },
            comet: {},
            controllers: [{
                type: "dynamo",
                url: "1p_halley/sun/orb"
            }, {
                type: "spin",
                periodInHours: 52,
                axis: s.Vector3.ZAxis,
                axisInFrameSpace: !1
            }]
        },
        "103p_hartley_2": {
            groups: ["comets"],
            radius: 2,
            label: "Hartley 2 (103P/Hartley)",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/103p_hartley_2/hartley_2.gltf"
            },
            comet: {},
            controllers: [{
                type: "dynamo",
                url: "103p_hartley_2/sun/orb"
            }, {
                type: "dynamo",
                url: "103p_hartley_2/ori"
            }]
        },
        "9p_tempel_1": {
            groups: ["comets"],
            radius: 5,
            label: "Tempel 1 (9P/Tempel)",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/9p_tempel_1/9p_tempel.gltf",
                rotate: [{
                    y: 90
                }]
            },
            comet: {},
            controllers: [{
                type: "dynamo",
                url: "9p_tempel_1/sun/orb"
            }, {
                type: "dynamo",
                url: "9p_tempel_1/ori"
            }]
        },
        "81p_wild_2": {
            groups: ["comets"],
            radius: 2.5,
            label: "Wild 2 (81P/Wild)",
            parents: [[Number.NEGATIVE_INFINITY, "sun"], [-800047271, "jupiter"], [-797029475, "sun"]],
            trail: {
                length: void 0,
                lengthCoverages: [[1356976800, Number.NEGATIVE_INFINITY, -611927948.817], [189345600, -611927948.817, Number.POSITIVE_INFINITY]]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [2.5, 2.5, 2.5]
            },
            comet: {},
            controllers: [{
                type: "dynamo",
                url: "81p_wild_2/sun/1/orb"
            }, {
                type: "dynamo",
                url: "81p_wild_2/jupiter/orb"
            }, {
                type: "dynamo",
                url: "81p_wild_2/sun/2/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        "67p_churyumov_gerasimenko": {
            groups: ["comets"],
            radius: 4.1,
            label: "Churyumovâ€“Gerasimenko (67P/C-G)",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/67p_churyumov_gerasimenko/67p_churyumov_gerasimenko.gltf",
                rotate: [{
                    x: 90
                }],
                scale: .00124
            },
            comet: {},
            controllers: [{
                type: "dynamo",
                url: "67p_churyumov_gerasimenko/sun/orb"
            }, {
                type: "spin",
                axis: new s.Vector3(.15191127889562422,.404099951782066,.9020123016422935),
                axisInFrameSpace: !1,
                periodInHours: 12.0550932412
            }, {
                type: "dynamo",
                url: "67p_churyumov_gerasimenko/ori"
            }],
            postCreateFunction: t => {
                t.setOrientation(new s.Quaternion(.26732846830704055,.017948528101847026,.22012096235022358,.9379552773483394)),
                o.EntityUtils.addGeyser(t, 1, 1, 100, 1, 1, [1, -.25, 1.2], [0, 0, 1]),
                o.EntityUtils.addGeyser(t, 2, .5, 100, 1, 1, [-1.2, -.25, .6], [.2, -.5, 1]),
                o.EntityUtils.addGeyser(t, 1, .07, 100, 1, 10, [-1.2, .1, .6], [.2, -.5, 1]),
                o.EntityUtils.addGeyser(t, 1, 1, 100, 1, 1, [-.8, .75, 1], [.2, .5, 1]),
                o.EntityUtils.addGeyser(t, 1, .5, 100, 1, 1, [-.8, .35, -1], [.2, .25, -1])
            }
        },
        "19p_borrelly": {
            groups: ["comets"],
            radius: 2.4,
            label: "Borrelly (19P/Borrelly)",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/19p_borrelly/borrelly.gltf"
            },
            comet: {},
            controllers: [{
                type: "dynamo",
                url: "19p_borrelly/sun/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        c_1995_o1: {
            groups: ["comets"],
            radius: 5,
            label: "Hale-Bopp (C/1995 O1)",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [5, 5, 5]
            },
            comet: {},
            controllers: [{
                type: "dynamo",
                url: "c_1995_o1/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                axisInFrameSpace: !1,
                periodInHours: 11.766666666
            }]
        },
        c_2010_x1: {
            groups: ["comets"],
            radius: 5,
            label: "Elenin (C/2010 X1)",
            parents: [[Number.NEGATIVE_INFINITY, "sun"], [370699266.182, ""]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [5, 5, 5]
            },
            comet: {},
            controllers: [{
                type: "dynamo",
                url: "c_2010_x1/sun/pos"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        c_2012_s1: {
            groups: ["comets"],
            radius: 3,
            label: "ISON (C/2012 S1)",
            parents: [[Number.NEGATIVE_INFINITY, "sun"], [440596867.184, ""]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [3, 3, 3]
            },
            comet: {},
            controllers: [{
                type: "dynamo",
                url: "c_2012_s1/sun/pos"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        c_2013_a1: {
            groups: ["comets"],
            radius: 5,
            label: "Siding Spring (C/2013 A1)",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [5, 5, 5]
            },
            comet: {},
            controllers: [{
                type: "dynamo",
                url: "c_2013_a1/sun/pos"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                axisInFrameSpace: !1,
                periodInHours: 8
            }]
        },
        c_2019_y4: {
            groups: ["comets"],
            radius: 3,
            label: "ATLAS (C/2019 Y4)",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [3, 3, 3]
            },
            comet: {},
            controllers: [{
                type: "dynamo",
                url: "c_2019_y4/sun/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        c_2020_f3: {
            groups: ["comets"],
            radius: 6,
            label: "NEOWISE (C/2020 F3)",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [6, 6, 6]
            },
            comet: {},
            controllers: [{
                type: "dynamo",
                url: "c_2020_f3/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                axisInFrameSpace: !1,
                periodInHours: 7.58
            }]
        },
        c_2025_n1: {
            groups: ["comets"],
            radius: 2.8,
            label: "3I/ATLAS (C/2025 N1)",
            parents: [[Number.NEGATIVE_INFINITY, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [2.8, 2.8, 2.8]
            },
            comet: {},
            controllers: [{
                type: "dynamo",
                url: "c_2025_n1/sun/orb"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                axisInFrameSpace: !1,
                periodInHours: 16.16
            }]
        }
    })
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        EntityUtils: function() {
            return EntityUtils
        }
    });
    var s = i(5);
    class EntityUtils {
        static addGeyser(t, e, i, n, o, a, r, l) {
            const c = t.addComponent(s.ParticleSprayComponent);
            c.setNumberOfParticles(n),
            c.setSizeOfParticles(.25 * e * a),
            c.setSpeedOfParticles(o * e),
            c.setColorOfParticles(new s.Color(1,1,1,.5 * i)),
            c.setSpread(1 * a),
            c.setParticleSpacingRandom(!1),
            c.setLength(2.5 * e),
            c.setOriginOffset(new s.Vector3(r[0],r[1],r[2])),
            c.setDirection(new s.Vector3(l[0],l[1],l[2]))
        }
        static showSubObjectDuringInterval(t, e, i, n) {
            const o = t.getComponent(s.ModelComponent);
            if (!o)
                return;
            o.setHiddenObject(e, !0);
            const a = t.addController(s.CoverageController);
            a.setCoverage(new s.Interval(i,n)),
            a.setEnterFunction((t => {
                const i = t.getComponent(s.ModelComponent);
                i && i.setHiddenObject(e, !1)
            }
            )),
            a.setExitFunction((t => {
                const i = t.getComponent(s.ModelComponent);
                i && i.setHiddenObject(e, !0)
            }
            ))
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i(545).Entity.register({
        moon: {
            groups: ["earth", "moons"],
            radius: 1737.4,
            label: "Moon",
            parents: [[Number.NEGATIVE_INFINITY, "earth"]],
            trail: {
                length: void 0,
                color: [0, .6, .8, .7]
            },
            spheroid: {
                equatorialRadius: 1737.4,
                polarRadius: 1737.4,
                planetographic: !0
            },
            spheroidLOD: {
                textures: {
                    color: {
                        url: "moon/color_$SIZE_$FACE.png",
                        sizes: [16, 512, 4096]
                    }
                },
                shadowEntities: ["earth"]
            },
            controllers: [{
                type: "dynamo",
                url: "moon/earth/orb"
            }, {
                type: "dynamo",
                url: "moon/ori"
            }]
        }
    })
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i(545).Entity.register({
        adrastea: {
            groups: ["jupiter", "moons", "amalthea", "inner", "regular"],
            radius: 8.2,
            label: "Adrastea",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [8.2, 8.2, 8.2],
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "adrastea/jupiter/orb"
            }, {
                type: "dynamo",
                url: "adrastea/ori"
            }]
        },
        amalthea: {
            groups: ["jupiter", "moons", "amalthea", "inner", "regular"],
            radius: 83.5,
            label: "Amalthea",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [83.5, 83.5, 83.5],
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "amalthea/jupiter/orb"
            }, {
                type: "dynamo",
                url: "amalthea/ori"
            }]
        },
        callisto: {
            groups: ["jupiter", "moons", "main", "galilean", "regular"],
            radius: 2410.3,
            label: "Callisto",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            spheroid: {
                equatorialRadius: 2410.3,
                polarRadius: 2410.3,
                planetographic: !1
            },
            spheroidLOD: {
                textures: {
                    color: {
                        url: "callisto/color_$SIZE_$FACE.png",
                        sizes: [4, 512]
                    }
                },
                shadowEntities: ["jupiter", "io", "europa", "ganymede"]
            },
            controllers: [{
                type: "dynamo",
                url: "callisto/jupiter/orb"
            }, {
                type: "dynamo",
                url: "callisto/ori"
            }]
        },
        europa: {
            groups: ["jupiter", "moons", "main", "galilean", "regular"],
            radius: 1569,
            label: "Europa",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            spheroid: {
                equatorialRadius: 1569,
                polarRadius: 1569,
                planetographic: !1
            },
            spheroidLOD: {
                textures: {
                    color: {
                        url: "europa/color_$SIZE_$FACE.png",
                        sizes: [4, 512, 1024]
                    }
                },
                shadowEntities: ["jupiter", "io", "callisto", "ganymede"]
            },
            controllers: [{
                type: "dynamo",
                url: "europa/jupiter/orb"
            }, {
                type: "dynamo",
                url: "europa/ori"
            }]
        },
        ganymede: {
            groups: ["jupiter", "moons", "main", "galilean", "regular"],
            radius: 2634.1,
            label: "Ganymede",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            spheroid: {
                equatorialRadius: 2634.1,
                polarRadius: 2634.1,
                planetographic: !1
            },
            spheroidLOD: {
                textures: {
                    color: {
                        url: "ganymede/color_$SIZE_$FACE.png",
                        sizes: [4, 512]
                    }
                },
                shadowEntities: ["jupiter", "io", "europa", "callisto"]
            },
            controllers: [{
                type: "dynamo",
                url: "ganymede/jupiter/orb"
            }, {
                type: "dynamo",
                url: "ganymede/ori"
            }]
        },
        io: {
            groups: ["jupiter", "moons", "main", "galilean", "regular"],
            radius: 1821.3,
            label: "Io",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            spheroid: {
                equatorialRadius: 1821.3,
                polarRadius: 1821.3,
                planetographic: !1
            },
            spheroidLOD: {
                textures: {
                    color: {
                        url: "io/color_$SIZE_$FACE.png",
                        sizes: [4, 512, 1024]
                    }
                },
                shadowEntities: ["jupiter", "europa", "ganymede", "callisto"]
            },
            controllers: [{
                type: "dynamo",
                url: "io/jupiter/orb"
            }, {
                type: "dynamo",
                url: "io/ori"
            }]
        },
        metis: {
            groups: ["jupiter", "moons", "amalthea", "inner", "regular"],
            radius: 21.5,
            label: "Metis",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [21.5, 21.5, 21.5],
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "metis/jupiter/orb"
            }, {
                type: "dynamo",
                url: "metis/ori"
            }]
        },
        thebe: {
            groups: ["jupiter", "moons", "amalthea", "inner", "regular"],
            radius: 49,
            label: "Thebe",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [49, 49, 49],
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "thebe/jupiter/orb"
            }, {
                type: "dynamo",
                url: "thebe/ori"
            }]
        }
    })
}
, function(t, e, i) {
    "use strict";
    i.r(e);
    var s = i(5);
    i(545).Entity.register({
        aitne: {
            groups: ["jupiter", "moons", "irregular", "carme"],
            radius: 1.5,
            label: "Aitne",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [1.5, 1.5, 1.5],
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "aitne/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        ananke: {
            groups: ["jupiter", "moons", "irregular", "ananke"],
            radius: 14,
            label: "Ananke",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [14, 14, 14],
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "ananke/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        aoede: {
            groups: ["jupiter", "moons", "irregular", "pasiphae"],
            radius: 2,
            label: "Aoede",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [2, 2, 2],
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "aoede/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        arche: {
            groups: ["jupiter", "moons", "irregular", "carme"],
            radius: 1.5,
            label: "Arche",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [1.5, 1.5, 1.5],
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "arche/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        autonoe: {
            groups: ["jupiter", "moons", "irregular", "pasiphae"],
            radius: 2,
            label: "Autonoe",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [2, 2, 2],
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "autonoe/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        callirrhoe: {
            groups: ["jupiter", "moons", "irregular", "pasiphae"],
            radius: 4.3,
            label: "Callirrhoe",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [4.3, 4.3, 4.3],
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "callirrhoe/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        carme: {
            groups: ["jupiter", "moons", "irregular", "carme"],
            radius: 23,
            label: "Carme",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [23, 23, 23],
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "carme/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        carpo: {
            groups: ["jupiter", "moons", "irregular"],
            radius: 1.5,
            label: "Carpo",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [1.5, 1.5, 1.5],
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "carpo/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        chaldene: {
            groups: ["jupiter", "moons", "irregular", "carme"],
            radius: 1.9,
            label: "Chaldene",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [1.9, 1.9, 1.9],
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "chaldene/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        cyllene: {
            groups: ["jupiter", "moons", "irregular", "pasiphae"],
            radius: 1,
            label: "Cyllene",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [1, 1, 1],
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "cyllene/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        dia: {
            groups: ["jupiter", "moons", "irregular", "himalia"],
            radius: 2,
            label: "Dia",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: 2,
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "dia/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        eirene: {
            groups: ["jupiter", "moons", "irregular", "carme"],
            radius: 2,
            label: "Eirene",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: 2,
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "eirene/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        elara: {
            groups: ["jupiter", "moons", "irregular", "himalia"],
            radius: 43,
            label: "Elara",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [43, 43, 43],
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "elara/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        erinome: {
            groups: ["jupiter", "moons", "irregular", "carme"],
            radius: 1.6,
            label: "Erinome",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [1.6, 1.6, 1.6],
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "erinome/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        ersa: {
            groups: ["jupiter", "moons", "irregular", "himalia"],
            radius: 1.5,
            label: "Ersa",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: 1.5,
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "ersa/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        euanthe: {
            groups: ["jupiter", "moons", "irregular", "ananke"],
            radius: 1.5,
            label: "Euanthe",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [1.5, 1.5, 1.5],
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "euanthe/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        eukelade: {
            groups: ["jupiter", "moons", "irregular", "carme"],
            radius: 2,
            label: "Eukelade",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [2, 2, 2],
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "eukelade/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        eupheme: {
            groups: ["jupiter", "moons", "irregular", "ananke"],
            radius: 1,
            label: "Eupheme",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: 1,
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "eupheme/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        euporie: {
            groups: ["jupiter", "moons", "irregular", "ananke"],
            radius: 1,
            label: "Euporie",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [1, 1, 1],
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "euporie/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        eurydome: {
            groups: ["jupiter", "moons", "irregular", "pasiphae"],
            radius: 1.5,
            label: "Eurydome",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [1.5, 1.5, 1.5],
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "eurydome/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        harpalyke: {
            groups: ["jupiter", "moons", "irregular", "ananke"],
            radius: 2.2,
            label: "Harpalyke",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [2.2, 2.2, 2.2],
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "harpalyke/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        hegemone: {
            groups: ["jupiter", "moons", "irregular", "pasiphae"],
            radius: 1.5,
            label: "Hegemone",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [1.5, 1.5, 1.5],
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "hegemone/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        helike: {
            groups: ["jupiter", "moons", "irregular", "ananke"],
            radius: 2,
            label: "Helike",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [2, 2, 2],
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "helike/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        hermippe: {
            groups: ["jupiter", "moons", "irregular", "ananke"],
            radius: 2,
            label: "Hermippe",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [2, 2, 2],
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "hermippe/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        herse: {
            groups: ["jupiter", "moons", "irregular", "carme"],
            radius: 1,
            label: "Herse",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [1, 1, 1],
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "herse/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        himalia: {
            groups: ["jupiter", "moons", "irregular", "himalia"],
            radius: 85,
            label: "Himalia",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [85, 85, 85],
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "himalia/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        iocaste: {
            groups: ["jupiter", "moons", "irregular", "ananke"],
            radius: 2.6,
            label: "Iocaste",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [2.6, 2.6, 2.6],
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "iocaste/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        isonoe: {
            groups: ["jupiter", "moons", "irregular", "carme"],
            radius: 1.9,
            label: "Isonoe",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [1.9, 1.9, 1.9],
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "isonoe/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        jupiter_li: {
            groups: ["jupiter", "moons", "irregular", "carme"],
            radius: 1,
            label: "Jupiter LI",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: 1,
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "jupiter_li/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        jupiter_lii: {
            groups: ["jupiter", "moons", "irregular", "ananke"],
            radius: .5,
            label: "Jupiter LII",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: .5,
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "jupiter_lii/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        jupiter_liv: {
            groups: ["jupiter", "moons", "irregular", "ananke"],
            radius: .5,
            label: "Jupiter LIV",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: .5,
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "jupiter_liv/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        jupiter_lv: {
            groups: ["jupiter", "moons", "irregular", "ananke"],
            radius: 1,
            label: "Jupiter LV",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: 1,
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "jupiter_lv/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        jupiter_lvi: {
            groups: ["jupiter", "moons", "irregular", "pasiphae"],
            radius: .5,
            label: "Jupiter LVI",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: .5,
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "jupiter_lvi/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        jupiter_lix: {
            groups: ["jupiter", "moons", "irregular", "pasiphae"],
            radius: 1,
            label: "Jupiter LIX",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: 1,
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "jupiter_lix/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        jupiter_lxi: {
            groups: ["jupiter", "moons", "irregular", "carme"],
            radius: 1,
            label: "Jupiter LXI",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: 1,
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "jupiter_lxi/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        jupiter_lxiii: {
            groups: ["jupiter", "moons", "irregular", "carme"],
            radius: 1,
            label: "Jupiter LXIII",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: 1,
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "jupiter_lxiii/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        jupiter_lxiv: {
            groups: ["jupiter", "moons", "irregular", "ananke"],
            radius: 1,
            label: "Jupiter LXIV",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: 1,
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "jupiter_lxiv/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        jupiter_lxvi: {
            groups: ["jupiter", "moons", "irregular", "carme"],
            radius: 1,
            label: "Jupiter LXVI",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: 1,
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "jupiter_lxvi/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        jupiter_lxvii: {
            groups: ["jupiter", "moons", "irregular", "pasiphae"],
            radius: 1,
            label: "Jupiter LXVII",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: 1,
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "jupiter_lxvii/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        jupiter_lxviii: {
            groups: ["jupiter", "moons", "irregular", "ananke"],
            radius: 1,
            label: "Jupiter LXVIII",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: 1,
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "jupiter_lxviii/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        jupiter_lxix: {
            groups: ["jupiter", "moons", "irregular", "carme"],
            radius: .5,
            label: "Jupiter LXIX",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: .5,
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "jupiter_lxix/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        jupiter_lxx: {
            groups: ["jupiter", "moons", "irregular", "ananke"],
            radius: 1.5,
            label: "Jupiter LXX",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: 1.5,
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "jupiter_lxx/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        jupiter_lxxii: {
            groups: ["jupiter", "moons", "irregular", "ananke"],
            radius: 1,
            label: "Jupiter LXXII",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: 1,
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "jupiter_lxxii/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        kale: {
            groups: ["jupiter", "moons", "irregular", "carme"],
            radius: 1,
            label: "Kale",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [1, 1, 1],
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "kale/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        kallichore: {
            groups: ["jupiter", "moons", "irregular", "carme"],
            radius: 1,
            label: "Kallichore",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [1, 1, 1],
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "kallichore/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        kalyke: {
            groups: ["jupiter", "moons", "irregular", "carme"],
            radius: 2.6,
            label: "Kalyke",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [2.6, 2.6, 2.6],
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "kalyke/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        kore: {
            groups: ["jupiter", "moons", "irregular", "pasiphae"],
            radius: 1,
            label: "Kore",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [1, 1, 1],
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "kore/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        leda: {
            groups: ["jupiter", "moons", "irregular", "himalia"],
            radius: 10,
            label: "Leda",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [10, 10, 10],
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "leda/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        lysithea: {
            groups: ["jupiter", "moons", "irregular", "himalia"],
            radius: 18,
            label: "Lysithea",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [18, 18, 18],
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "lysithea/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        megaclite: {
            groups: ["jupiter", "moons", "irregular", "pasiphae"],
            radius: 2.7,
            label: "Megaclite",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [2.7, 2.7, 2.7],
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "megaclite/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        mneme: {
            groups: ["jupiter", "moons", "irregular", "ananke"],
            radius: 1,
            label: "Mneme",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [1, 1, 1],
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "mneme/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        orthosie: {
            groups: ["jupiter", "moons", "irregular", "ananke"],
            radius: 1,
            label: "Orthosie",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [1, 1, 1],
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "orthosie/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        pandia: {
            groups: ["jupiter", "moons", "irregular", "himalia"],
            radius: 1.5,
            label: "Pandia",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: 1.5,
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "pandia/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        pasiphae: {
            groups: ["jupiter", "moons", "irregular", "pasiphae"],
            radius: 30,
            label: "Pasiphae",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [30, 30, 30],
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "pasiphae/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        pasithee: {
            groups: ["jupiter", "moons", "irregular", "carme"],
            radius: 1,
            label: "Pasithee",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [1, 1, 1],
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "pasithee/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        philophrosyne: {
            groups: ["jupiter", "moons", "irregular", "pasiphae"],
            radius: 1,
            label: "Philophrosyne",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: 1,
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "philophrosyne/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        praxidike: {
            groups: ["jupiter", "moons", "irregular", "ananke"],
            radius: 3.4,
            label: "Praxidike",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [3.4, 3.4, 3.4],
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "praxidike/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2003_j_2: {
            groups: ["jupiter", "moons", "irregular", "ananke"],
            radius: 1,
            label: "S/2003 J 2",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: 1,
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2003_j_2/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2003_j_4: {
            groups: ["jupiter", "moons", "irregular", "pasiphae"],
            radius: 1,
            label: "S/2003 J 4",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: 1,
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2003_j_4/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2003_j_9: {
            groups: ["jupiter", "moons", "irregular", "carme"],
            radius: .5,
            label: "S/2003 J 9",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: .5,
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2003_j_9/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2003_j_10: {
            groups: ["jupiter", "moons", "irregular", "carme"],
            radius: 1,
            label: "S/2003 J 10",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: 1,
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2003_j_10/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2003_j_12: {
            groups: ["jupiter", "moons", "irregular", "ananke"],
            radius: .5,
            label: "S/2003 J 12",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: .5,
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2003_j_12/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2003_j_16: {
            groups: ["jupiter", "moons", "irregular", "ananke"],
            radius: 1,
            label: "S/2003 J 16",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: 1,
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2003_j_16/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2003_j_23: {
            groups: ["jupiter", "moons", "irregular", "pasiphae"],
            radius: 1,
            label: "S/2003 J 23",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: 1,
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2003_j_23/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2003_j_24: {
            groups: ["jupiter", "moons", "irregular", "carme"],
            radius: 1,
            label: "S/2003 J 24",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: 1,
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2003_j_24/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2011_j_3: {
            groups: ["jupiter", "moons", "irregular", "himalia"],
            radius: 1.5,
            label: "S/2011 J 3",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: 1.5,
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2011_j_3/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2016_j_3: {
            groups: ["jupiter", "moons", "irregular", "carme"],
            radius: 1,
            label: "S/2016 J 3",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: 1,
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2016_j_3/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2016_j_4: {
            groups: ["jupiter", "moons", "irregular", "pasiphae"],
            radius: .5,
            label: "S/2016 J 4",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: .5,
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2016_j_4/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2018_j_2: {
            groups: ["jupiter", "moons", "irregular", "himalia"],
            radius: 1.5,
            label: "S/2018 J 2",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: 1.5,
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2018_j_2/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2018_j_3: {
            groups: ["jupiter", "moons", "irregular", "carme"],
            radius: .5,
            label: "S/2018 J 3",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: .5,
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2018_j_3/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2018_j_4: {
            groups: ["jupiter", "moons", "irregular", "carpo"],
            radius: 1,
            label: "S/2018 J 4",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: 1,
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2018_j_4/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2021_j_1: {
            groups: ["jupiter", "moons", "irregular", "ananke"],
            radius: .5,
            label: "S/2021 J 1",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: .5,
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2021_j_1/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2021_j_2: {
            groups: ["jupiter", "moons", "irregular", "ananke"],
            radius: 1,
            label: "S/2021 J 2",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: 1,
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2021_j_2/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2021_j_3: {
            groups: ["jupiter", "moons", "irregular", "ananke"],
            radius: 1,
            label: "S/2021 J 3",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: 1,
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2021_j_3/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2021_j_4: {
            groups: ["jupiter", "moons", "irregular", "carme"],
            radius: .5,
            label: "S/2021 J 4",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: .5,
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2021_j_4/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2021_j_5: {
            groups: ["jupiter", "moons", "irregular", "carme"],
            radius: 1,
            label: "S/2021 J 5",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: 1,
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2021_j_5/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2021_j_6: {
            groups: ["jupiter", "moons", "irregular", "carme"],
            radius: .5,
            label: "S/2021 J 6",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: .5,
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2021_j_6/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2022_j_1: {
            groups: ["jupiter", "moons", "irregular", "carme"],
            radius: .5,
            label: "S/2022 J 1",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: .5,
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2022_j_1/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2022_j_2: {
            groups: ["jupiter", "moons", "irregular", "carme"],
            radius: .5,
            label: "S/2022 J 2",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: .5,
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2022_j_2/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2022_j_3: {
            groups: ["jupiter", "moons", "irregular", "ananke"],
            radius: .5,
            label: "S/2022 J 3",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: .5,
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2022_j_3/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        sinope: {
            groups: ["jupiter", "moons", "irregular", "pasiphae"],
            radius: 19,
            label: "Sinope",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [19, 19, 19],
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "sinope/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        sponde: {
            groups: ["jupiter", "moons", "irregular", "pasiphae"],
            radius: 1,
            label: "Sponde",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [1, 1, 1],
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "sponde/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        taygete: {
            groups: ["jupiter", "moons", "irregular", "carme"],
            radius: 2.5,
            label: "Taygete",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [2.5, 2.5, 2.5],
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "taygete/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        thelxinoe: {
            groups: ["jupiter", "moons", "irregular", "ananke"],
            radius: 1,
            label: "Thelxinoe",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [1, 1, 1],
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "thelxinoe/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        themisto: {
            groups: ["jupiter", "moons", "irregular"],
            radius: 4,
            label: "Themisto",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [4, 4, 4],
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "themisto/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        thyone: {
            groups: ["jupiter", "moons", "irregular", "ananke"],
            radius: 2,
            label: "Thyone",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [2, 2, 2],
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "thyone/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        valetudo: {
            groups: ["jupiter", "moons", "irregular"],
            radius: .5,
            label: "Valetudo",
            parents: [[Number.NEGATIVE_INFINITY, "jupiter"]],
            trail: {
                length: void 0,
                color: [.95, .71, .64, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: .5,
                shadowEntities: ["jupiter"]
            },
            controllers: [{
                type: "dynamo",
                url: "valetudo/jupiter/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        }
    })
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i(545).Entity.register({
        phobos: {
            groups: ["mars", "moons"],
            radius: 14,
            label: "Phobos",
            parents: [[Number.NEGATIVE_INFINITY, "mars"]],
            trail: {
                length: void 0,
                color: [.89, .51, .35, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/phobos/phobos.gltf",
                scale: [1, 1, 1],
                rotate: [{
                    z: 90
                }, {
                    y: 90
                }],
                shadowEntities: ["mars"]
            },
            controllers: [{
                type: "dynamo",
                url: "phobos/mars/orb"
            }, {
                type: "dynamo",
                url: "phobos/ori"
            }]
        },
        deimos: {
            groups: ["mars", "moons"],
            radius: 8.70951,
            label: "Deimos",
            parents: [[Number.NEGATIVE_INFINITY, "mars"]],
            trail: {
                length: void 0,
                color: [.89, .51, .35, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/deimos/deimos.gltf",
                scale: [1, 1, 1],
                rotate: [{
                    y: -180
                }],
                shadowEntities: ["mars"]
            },
            controllers: [{
                type: "dynamo",
                url: "deimos/mars/orb"
            }, {
                type: "dynamo",
                url: "deimos/ori"
            }]
        }
    })
}
, function(t, e, i) {
    "use strict";
    i.r(e);
    var s = i(5);
    i(545).Entity.register({
        despina: {
            groups: ["neptune", "moons", "regular"],
            radius: 90,
            label: "Despina",
            parents: [[Number.NEGATIVE_INFINITY, "neptune"]],
            trail: {
                length: void 0,
                color: [.48, .69, 1, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [90, 90, 90],
                shadowEntities: ["neptune"]
            },
            controllers: [{
                type: "dynamo",
                url: "despina/neptune/orb"
            }, {
                type: "dynamo",
                url: "despina/ori"
            }]
        },
        galatea: {
            groups: ["neptune", "moons", "regular"],
            radius: 102,
            label: "Galatea",
            parents: [[Number.NEGATIVE_INFINITY, "neptune"]],
            trail: {
                length: void 0,
                color: [.48, .69, 1, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [102, 102, 102],
                shadowEntities: ["neptune"]
            },
            controllers: [{
                type: "dynamo",
                url: "galatea/neptune/orb"
            }, {
                type: "dynamo",
                url: "galatea/ori"
            }]
        },
        halimede: {
            groups: ["neptune", "moons", "irregular"],
            radius: 31,
            label: "Halimede",
            parents: [[Number.NEGATIVE_INFINITY, "neptune"]],
            trail: {
                length: void 0,
                color: [.48, .69, 1, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [31, 31, 31],
                shadowEntities: ["neptune"]
            },
            controllers: [{
                type: "dynamo",
                url: "halimede/neptune/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        hippocamp: {
            groups: ["neptune", "moons", "regular"],
            radius: 17.4,
            label: "Hippocamp",
            parents: [[Number.NEGATIVE_INFINITY, "neptune"]],
            trail: {
                length: void 0,
                color: [.48, .69, 1, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [17.4, 17.4, 17.4],
                shadowEntities: ["neptune"]
            },
            controllers: [{
                type: "dynamo",
                url: "hippocamp/neptune/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        laomedeia: {
            groups: ["neptune", "moons", "irregular"],
            radius: 21,
            label: "Laomedeia",
            parents: [[Number.NEGATIVE_INFINITY, "neptune"]],
            trail: {
                length: void 0,
                color: [.48, .69, 1, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [21, 21, 21],
                shadowEntities: ["neptune"]
            },
            controllers: [{
                type: "dynamo",
                url: "laomedeia/neptune/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        larissa: {
            groups: ["neptune", "moons", "regular"],
            radius: 108,
            label: "Larissa",
            parents: [[Number.NEGATIVE_INFINITY, "neptune"]],
            trail: {
                length: void 0,
                color: [.48, .69, 1, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [108, 108, 108],
                shadowEntities: ["neptune"]
            },
            controllers: [{
                type: "dynamo",
                url: "larissa/neptune/orb"
            }, {
                type: "dynamo",
                url: "larissa/ori"
            }]
        },
        naiad: {
            groups: ["neptune", "moons", "regular"],
            radius: 48,
            label: "Naiad",
            parents: [[Number.NEGATIVE_INFINITY, "neptune"]],
            trail: {
                length: void 0,
                color: [.48, .69, 1, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [48, 48, 48],
                shadowEntities: ["neptune"]
            },
            controllers: [{
                type: "dynamo",
                url: "naiad/neptune/orb"
            }, {
                type: "dynamo",
                url: "naiad/ori"
            }]
        },
        nereid: {
            groups: ["neptune", "moons", "irregular"],
            radius: 170,
            label: "Nereid",
            parents: [[Number.NEGATIVE_INFINITY, "neptune"]],
            trail: {
                length: void 0,
                color: [.48, .69, 1, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [170, 170, 170],
                shadowEntities: ["neptune"]
            },
            controllers: [{
                type: "dynamo",
                url: "nereid/neptune/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        neso: {
            groups: ["neptune", "moons", "irregular"],
            radius: 30,
            label: "Neso",
            parents: [[Number.NEGATIVE_INFINITY, "neptune"]],
            trail: {
                length: void 0,
                color: [.48, .69, 1, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [30, 30, 30],
                shadowEntities: ["neptune"]
            },
            controllers: [{
                type: "dynamo",
                url: "neso/neptune/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        proteus: {
            groups: ["neptune", "moons", "regular"],
            radius: 232.5,
            label: "Proteus",
            parents: [[Number.NEGATIVE_INFINITY, "neptune"]],
            trail: {
                length: void 0,
                color: [.48, .69, 1, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/proteus/proteus.gltf",
                scale: [1, 1, 1]
            },
            controllers: [{
                type: "dynamo",
                url: "proteus/neptune/orb"
            }, {
                type: "dynamo",
                url: "proteus/ori"
            }]
        },
        psamathe: {
            groups: ["neptune", "moons", "irregular"],
            radius: 20,
            label: "Psamathe",
            parents: [[Number.NEGATIVE_INFINITY, "neptune"]],
            trail: {
                length: void 0,
                color: [.48, .69, 1, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [20, 20, 20],
                shadowEntities: ["neptune"]
            },
            controllers: [{
                type: "dynamo",
                url: "psamathe/neptune/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        sao: {
            groups: ["neptune", "moons", "irregular"],
            radius: 22,
            label: "Sao",
            parents: [[Number.NEGATIVE_INFINITY, "neptune"]],
            trail: {
                length: void 0,
                color: [.48, .69, 1, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [22, 22, 22],
                shadowEntities: ["neptune"]
            },
            controllers: [{
                type: "dynamo",
                url: "sao/neptune/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        thalassa: {
            groups: ["neptune", "moons", "regular"],
            radius: 54,
            label: "Thalassa",
            parents: [[Number.NEGATIVE_INFINITY, "neptune"]],
            trail: {
                length: void 0,
                color: [.48, .69, 1, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [54, 54, 54],
                shadowEntities: ["neptune"]
            },
            controllers: [{
                type: "dynamo",
                url: "thalassa/neptune/orb"
            }, {
                type: "dynamo",
                url: "thalassa/ori"
            }]
        },
        triton: {
            groups: ["neptune", "moons", "irregular"],
            radius: 1353.4,
            label: "Triton",
            parents: [[Number.NEGATIVE_INFINITY, "neptune"]],
            trail: {
                length: void 0,
                color: [.48, .69, 1, .7]
            },
            spheroid: {
                equatorialRadius: 1353.4,
                polarRadius: 1353.4,
                planetographic: !1
            },
            spheroidLOD: {
                textures: {
                    color: {
                        url: "triton/color_$SIZE_$FACE.jpg",
                        sizes: [16, 512, 4096]
                    }
                },
                shadowEntities: ["neptune"]
            },
            controllers: [{
                type: "dynamo",
                url: "triton/neptune/orb"
            }, {
                type: "dynamo",
                url: "triton/ori"
            }]
        }
    })
}
, function(t, e, i) {
    "use strict";
    i.r(e);
    var s = i(5)
      , n = i(545)
      , o = i(665);
    n.Entity.register({
        dione: {
            groups: ["saturn", "moons", "inner", "major"],
            radius: 561.7,
            label: "Dione",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            spheroid: {
                equatorialRadius: 561.7,
                polarRadius: 561.7,
                planetographic: !1
            },
            spheroidLOD: {
                textures: {
                    color: {
                        url: "dione/color_$SIZE_$FACE.png",
                        sizes: [4, 512, 2048]
                    }
                },
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "dione/saturn/orb"
            }, {
                type: "dynamo",
                url: "dione/ori"
            }]
        },
        enceladus: {
            groups: ["saturn", "moons", "inner", "major"],
            radius: 252.1,
            label: "Enceladus",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            spheroid: {
                equatorialRadius: 252.1,
                polarRadius: 252.1,
                planetographic: !1
            },
            spheroidLOD: {
                textures: {
                    color: {
                        url: "enceladus/color_$SIZE_$FACE.png",
                        sizes: [4, 512, 2048]
                    }
                },
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "enceladus/saturn/orb"
            }, {
                type: "dynamo",
                url: "enceladus/ori"
            }],
            postCreateFunction: t => {
                o.EntityUtils.addGeyser(t, 100, .1, 20, .002, 4, [-20.16, .8 * -69.23, .8 * -240.99], [-.0999, -.2747, -.9563]),
                o.EntityUtils.addGeyser(t, 100, .1, 20, .002, 4, [-49.384, .8 * -24.61, .8 * -243.08], [-.2449, -.0976, -.9646]),
                o.EntityUtils.addGeyser(t, 100, .1, 20, .002, 4, [.8 * -35.82, -37.496, -196], [-.1421, -.1859, -.9722]),
                o.EntityUtils.addGeyser(t, 100, .1, 20, .002, 4, [21.259, .7 * -17.54, -174.685], [.1205, -.0696, -.9902]),
                o.EntityUtils.addGeyser(t, 100, .1, 20, .002, 4, [0, 1.54, -176.393], [0, .0087, -.9999]),
                o.EntityUtils.addGeyser(t, 100, .1, 20, .002, 4, [-21.658, 21.658, -173.719], [-.1227, .1227, -.9848]),
                o.EntityUtils.addGeyser(t, 100, .1, 20, .002, 4, [32.193, .7 * -34.55, .7 * -245.35], [.1824, -.1371, -.9736]),
                o.EntityUtils.addGeyser(t, 100, .1, 20, .002, 4, [-46.719, .68 * .9, -221.931], [-.2059, .0026, -.9785]),
                o.EntityUtils.addGeyser(t, 100, .1, 20, .002, 4, [.9 * -31.81, -12.024, -224.667], [-.1262, -.053, -.9905]),
                o.EntityUtils.addGeyser(t, 100, .1, 20, .002, 4, [.9 * -5.49, -26.793, -225.162], [-.0217, -.1181, -.9927]),
                o.EntityUtils.addGeyser(t, 100, .1, 20, .002, 4, [14.886, -42.39, -222.309], [.0656, -.1869, -.9801]),
                o.EntityUtils.addGeyser(t, 100, .1, 20, .002, 4, [-13.176, 48.112, -195.328], [-.0653, .2386, -.9689]),
                o.EntityUtils.addGeyser(t, 100, .1, 20, .002, 4, [51.52 * .8, 19.176, .8 * -245.51], [.2044, .0951, -.9742]),
                o.EntityUtils.addGeyser(t, 100, .1, 20, .002, 4, [22.504, 33.52 * .8, -198.536], [.1116, .133, -.9848])
            }
        },
        hyperion: {
            groups: ["saturn", "moons", "outer", "major"],
            radius: 135,
            label: "Hyperion",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/hyperion/hyperion.gltf",
                scale: [1, 1, 1]
            },
            controllers: [{
                type: "dynamo",
                url: "hyperion/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        iapetus: {
            groups: ["saturn", "moons", "outer", "major"],
            radius: 735.6,
            label: "Iapetus",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            spheroid: {
                equatorialRadius: 735.6,
                polarRadius: 735.6,
                planetographic: !1
            },
            spheroidLOD: {
                textures: {
                    color: {
                        url: "iapetus/color_$SIZE_$FACE.png",
                        sizes: [4, 512, 2048]
                    }
                },
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "iapetus/saturn/orb"
            }, {
                type: "dynamo",
                url: "iapetus/ori"
            }]
        },
        mimas: {
            groups: ["saturn", "moons", "inner", "major"],
            radius: 198.3,
            label: "Mimas",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/mimas/mimas.gltf",
                scale: [1, 1, 1],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "mimas/saturn/orb"
            }, {
                type: "dynamo",
                url: "mimas/ori"
            }]
        },
        rhea: {
            groups: ["saturn", "moons", "outer", "major"],
            radius: 764.3,
            label: "Rhea",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            spheroid: {
                equatorialRadius: 764.3,
                polarRadius: 764.3,
                planetographic: !1
            },
            spheroidLOD: {
                textures: {
                    color: {
                        url: "rhea/color_$SIZE_$FACE.png",
                        sizes: [4, 512, 2048]
                    }
                },
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "rhea/saturn/orb"
            }, {
                type: "dynamo",
                url: "rhea/ori"
            }]
        },
        tethys: {
            groups: ["saturn", "moons", "inner", "major"],
            radius: 538.4,
            label: "Tethys",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            spheroid: {
                equatorialRadius: 538.4,
                polarRadius: 527.5,
                planetographic: !1
            },
            spheroidLOD: {
                textures: {
                    color: {
                        url: "tethys/color_$SIZE_$FACE.png",
                        sizes: [4, 512, 2048]
                    }
                },
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "tethys/saturn/orb"
            }, {
                type: "dynamo",
                url: "tethys/ori"
            }]
        },
        titan: {
            groups: ["saturn", "moons", "outer", "major"],
            radius: 2575,
            label: "Titan",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            spheroid: {
                equatorialRadius: 2575,
                polarRadius: 2575,
                planetographic: !1
            },
            spheroidLOD: {
                textures: {
                    color: {
                        url: "titan/color_$SIZE_$FACE.png",
                        sizes: [4, 512, 1024]
                    }
                },
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "titan/saturn/orb"
            }, {
                type: "dynamo",
                url: "titan/ori"
            }],
            postCreateFunction: t => {
                const e = t.addComponent(s.AtmosphereComponent);
                e.setScaleHeight(75),
                e.setDensity(5e-4),
                e.setColor(new s.Color(179 / 255,145 / 255,53 / 255)),
                e.setSunsetColor(new s.Color(0,71 / 255,.8)),
                e.setSunsetIntensity(.5)
            }
        }
    })
}
, function(t, e, i) {
    "use strict";
    i.r(e);
    var s = i(5);
    i(545).Entity.register({
        aegaeon: {
            groups: ["saturn", "moons", "minor", "ring moonlet"],
            radius: .12,
            label: "Aegaeon",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [.12, .12, .12],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "aegaeon/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        aegir: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 3,
            label: "Aegir",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [3, 3, 3],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "aegir/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        albiorix: {
            groups: ["saturn", "moons", "minor", "gallic"],
            radius: 16,
            label: "Albiorix",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [16, 16, 16],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "albiorix/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        alvaldi: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 3,
            label: "Alvaldi",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: 3,
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "alvaldi/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        angrboda: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 1.5,
            label: "Angrboda",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: 1.5,
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "angrboda/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        anthe: {
            groups: ["saturn", "moons", "minor", "alkyonides"],
            radius: .9,
            label: "Anthe",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [.9, .9, .9],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "anthe/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        atlas: {
            groups: ["saturn", "moons", "minor", "ring shepherd"],
            radius: 15.1,
            label: "Atlas",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [15.1, 15.1, 15.1],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "atlas/saturn/orb"
            }, {
                type: "dynamo",
                url: "atlas/ori"
            }]
        },
        bebhionn: {
            groups: ["saturn", "moons", "minor", "gallic"],
            radius: 3,
            label: "Bebhionn",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [3, 3, 3],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "bebhionn/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        beli: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 1.5,
            label: "Beli",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: 1.5,
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "beli/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        bergelmir: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 3,
            label: "Bergelmir",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [3, 3, 3],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "bergelmir/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        bestla: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 3.5,
            label: "Bestla",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [3.5, 3.5, 3.5],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "bestla/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        calypso: {
            groups: ["saturn", "moons", "minor", "trojan"],
            radius: 10.7,
            label: "Calypso",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [10.7, 10.7, 10.7],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "calypso/saturn/orb"
            }, {
                type: "dynamo",
                url: "calypso/ori"
            }]
        },
        daphnis: {
            groups: ["saturn", "moons", "minor", "ring shepherd"],
            radius: 3.8,
            label: "Daphnis",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [3.8, 3.8, 3.8],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "daphnis/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        eggther: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 3,
            label: "Eggther",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: 3,
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "eggther/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        epimetheus: {
            groups: ["saturn", "moons", "minor", "co-orbital"],
            radius: 58.1,
            label: "Epimetheus",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [58.1, 58.1, 58.1],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "epimetheus/saturn/orb"
            }, {
                type: "dynamo",
                url: "epimetheus/ori"
            }]
        },
        erriapus: {
            groups: ["saturn", "moons", "minor", "gallic"],
            radius: 5,
            label: "Erriapus",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [5, 5, 5],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "erriapus/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        farbauti: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 2.5,
            label: "Farbauti",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [2.5, 2.5, 2.5],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "farbauti/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        fenrir: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 2,
            label: "Fenrir",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [2, 2, 2],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "fenrir/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        fornjot: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 3,
            label: "Fornjot",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [3, 3, 3],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "fornjot/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        geirrod: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 2,
            label: "Geirrod",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: 2,
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "geirrod/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        gerd: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 2,
            label: "Gerd",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: 2,
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "gerd/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        greip: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 3,
            label: "Greip",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [3, 3, 3],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "greip/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        gridr: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 2,
            label: "Gridr",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: 2,
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "gridr/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        gunnlod: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 2,
            label: "Gunnlod",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: 2,
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "gunnlod/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        hati: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 3,
            label: "Hati",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [3, 3, 3],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "hati/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        helene: {
            groups: ["saturn", "moons", "minor", "trojan"],
            radius: 17.6,
            label: "Helene",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [17.6, 17.6, 17.6],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "helene/saturn/orb"
            }, {
                type: "dynamo",
                url: "helene/ori"
            }]
        },
        hyrrokkin: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 3,
            label: "Hyrrokkin",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [3, 3, 3],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "hyrrokkin/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        ijiraq: {
            groups: ["saturn", "moons", "minor", "inuit"],
            radius: 6,
            label: "Ijiraq",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [6, 6, 6],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "ijiraq/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        janus: {
            groups: ["saturn", "moons", "minor", "co-orbital"],
            radius: 89.5,
            label: "Janus",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [89.5, 89.5, 89.5],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "janus/saturn/orb"
            }, {
                type: "dynamo",
                url: "janus/ori"
            }]
        },
        jarnsaxa: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 3,
            label: "Jarnsaxa",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [3, 3, 3],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "jarnsaxa/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        kari: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 3,
            label: "Kari",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [3, 3, 3],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "kari/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        kiviuq: {
            groups: ["saturn", "moons", "minor", "inuit"],
            radius: 8,
            label: "Kiviuq",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [8, 8, 8],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "kiviuq/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        loge: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 3,
            label: "Loge",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [3, 3, 3],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "loge/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        methone: {
            groups: ["saturn", "moons", "minor", "alkyonides"],
            radius: 1.6,
            label: "Methone",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [1.6, 1.6, 1.6],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "methone/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        mundilfari: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 3.5,
            label: "Mundilfari",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [3.5, 3.5, 3.5],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "mundilfari/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        narvi: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 3.5,
            label: "Narvi",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [3.5, 3.5, 3.5],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "narvi/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        paaliaq: {
            groups: ["saturn", "moons", "minor", "inuit"],
            radius: 11,
            label: "Paaliaq",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [11, 11, 11],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "paaliaq/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        pallene: {
            groups: ["saturn", "moons", "minor", "alkyonides"],
            radius: 2.5,
            label: "Pallene",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [2.5, 2.5, 2.5],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "pallene/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        pan: {
            groups: ["saturn", "moons", "minor", "ring shepherd"],
            radius: 14.1,
            label: "Pan",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [14.1, 14.1, 14.1],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "pan/saturn/orb"
            }, {
                type: "dynamo",
                url: "pan/ori"
            }]
        },
        pandora: {
            groups: ["saturn", "moons", "minor", "ring shepherd"],
            radius: 40.7,
            label: "Pandora",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [40.7, 40.7, 40.7],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "pandora/saturn/orb"
            }, {
                type: "dynamo",
                url: "pandora/ori"
            }]
        },
        phoebe: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 106.5,
            label: "Phoebe",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/phoebe/phoebe.gltf"
            },
            controllers: [{
                type: "dynamo",
                url: "phoebe/saturn/orb"
            }, {
                type: "dynamo",
                url: "phoebe/ori"
            }]
        },
        polydeuces: {
            groups: ["saturn", "moons", "minor", "trojan"],
            radius: 1.3,
            label: "Polydeuces",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [1.3, 1.3, 1.3],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "polydeuces/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        prometheus: {
            groups: ["saturn", "moons", "minor", "ring shepherd"],
            radius: 43.1,
            label: "Prometheus",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [43.1, 43.1, 43.1],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "prometheus/saturn/orb"
            }, {
                type: "dynamo",
                url: "prometheus/ori"
            }]
        },
        s_2004_s_7: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 3,
            label: "S/2004 S 7",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: 3,
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2004_s_7/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2004_s_12: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 2.5,
            label: "S/2004 S 12",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: 2.5,
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2004_s_12/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2004_s_13: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 3,
            label: "S/2004 S 13",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: 3,
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2004_s_13/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2004_s_17: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 2,
            label: "S/2004 S 17",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: 2,
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2004_s_17/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2004_s_21: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 1.5,
            label: "S/2004 S 21",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: 1.5,
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2004_s_21/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2004_s_24: {
            groups: ["saturn", "moons", "minor", "gallic"],
            radius: 1.5,
            label: "S/2004 S 24",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: 1.5,
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2004_s_24/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2004_s_28: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 2,
            label: "S/2004 S 28",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: 2,
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2004_s_28/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2004_s_31: {
            groups: ["saturn", "moons", "minor", "inuit"],
            radius: 2,
            label: "S/2004 S 31",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: 2,
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2004_s_31/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2004_s_36: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 1.5,
            label: "S/2004 S 36",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: 1.5,
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2004_s_36/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2004_s_37: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 2,
            label: "S/2004 S 37",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: 2,
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2004_s_37/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2004_s_39: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 1.5,
            label: "S/2004 S 39",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: 1.5,
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2004_s_39/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2006_s_1: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 2.5,
            label: "S/2006 S 1",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: 2.5,
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2006_s_1/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2006_s_3: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 3,
            label: "S/2006 S 3",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: 3,
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2006_s_3/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2007_s_2: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 3,
            label: "S/2007 S 2",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: 3,
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2007_s_2/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2007_s_3: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 2.5,
            label: "S/2007 S 3",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: 2.5,
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2007_s_3/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2009_s_1: {
            groups: ["saturn", "moons", "propeller moonlet"],
            radius: .15,
            label: "S/2009 S 1",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: .15,
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "fixed",
                orientation: s.Quaternion.Identity
            }],
            postCreateFunction: t => {
                const e = t.getController(s.FixedController);
                if (!e)
                    return;
                const i = t.addController(s.OrbitalElementsController, void 0, e)
                  , n = new s.OrbitalElements;
                n.epoch = 0,
                n.eccentricity = 0,
                n.semiMajorAxis = 117e3,
                n.meanAngularMotion = .00015472777,
                n.meanAnomalyAtEpoch = -1.5,
                n.orbitOrientation.set(-.9397445462795919, .02005900203250964, -.052689008288728606, -.33719681579275607),
                i.addOrbitalElements(-1e100, n),
                i.addOrbitalElements(1e100, n)
            }
        },
        s_2019_s_1: {
            groups: ["saturn", "moons", "minor", "inuit"],
            radius: 3,
            label: "S/2019 S 1",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: 3,
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2019_s_1/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        saturn_lviii: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 2,
            label: "Saturn LVIII",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: 2,
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "saturn_lviii/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        saturn_lx: {
            groups: ["saturn", "moons", "minor", "inuit"],
            radius: 2,
            label: "Saturn LX",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: 2,
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "saturn_lx/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        saturn_lxiv: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 1.5,
            label: "Saturn LXIV",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: 1.5,
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "saturn_lxiv/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        siarnaq: {
            groups: ["saturn", "moons", "minor", "inuit"],
            radius: 20,
            label: "Siarnaq",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [20, 20, 20],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "siarnaq/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        skathi: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 4,
            label: "Skathi",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [4, 4, 4],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "skathi/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        skoll: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 3,
            label: "Skoll",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [3, 3, 3],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "skoll/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        skrymir: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 2,
            label: "Skrymir",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: 2,
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "skrymir/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        surtur: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 3,
            label: "Surtur",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [3, 3, 3],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "surtur/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        suttungr: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 3.5,
            label: "Suttungr",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [3.5, 3.5, 3.5],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "suttungr/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        tarqeq: {
            groups: ["saturn", "moons", "minor", "inuit"],
            radius: 3,
            label: "Tarqeq",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [3, 3, 3],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "tarqeq/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        tarvos: {
            groups: ["saturn", "moons", "minor", "gallic"],
            radius: 7.5,
            label: "Tarvos",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [7.5, 7.5, 7.5],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "tarvos/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        telesto: {
            groups: ["saturn", "moons", "minor", "trojan"],
            radius: 12.4,
            label: "Telesto",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [12.4, 12.4, 12.4],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "telesto/saturn/orb"
            }, {
                type: "dynamo",
                url: "telesto/ori"
            }]
        },
        thiazzi: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 2,
            label: "Thiazzi",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: 2,
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "thiazzi/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        thrymr: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 3.5,
            label: "Thrymr",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [3.5, 3.5, 3.5],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "thrymr/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        ymir: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 9,
            label: "Ymir",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: void 0,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [9, 9, 9],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "ymir/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2004_s_40: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 2,
            label: "S/2004 S 40",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: 66061440,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [2, 2, 2],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2004_s_40/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2004_s_41: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 2,
            label: "S/2004 S 41",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: 79022304,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [2, 2, 2],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2004_s_41/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2004_s_42: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 2,
            label: "S/2004 S 42",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: 79998624,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [2, 2, 2],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2004_s_42/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2004_s_43: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 2,
            label: "S/2004 S 43",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: 84678912,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [2, 2, 2],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2004_s_43/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2004_s_44: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 2.5,
            label: "S/2004 S 44",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: 88660224,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [2.5, 2.5, 2.5],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2004_s_44/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2004_s_45: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 2,
            label: "S/2004 S 45",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: 89743680,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [2, 2, 2],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2004_s_45/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2004_s_46: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 1.5,
            label: "S/2004 S 46",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: 95694912,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [1.5, 1.5, 1.5],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2004_s_46/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2004_s_47: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 2,
            label: "S/2004 S 47",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: 65879136,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [2, 2, 2],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2004_s_47/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2004_s_48: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 2,
            label: "S/2004 S 48",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: 107343360,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [2, 2, 2],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2004_s_48/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2004_s_49: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 2,
            label: "S/2004 S 49",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: 109231200,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [2, 2, 2],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2004_s_49/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2004_s_50: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 1.5,
            label: "S/2004 S 50",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: 108902016,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [1.5, 1.5, 1.5],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2004_s_50/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2004_s_51: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 2,
            label: "S/2004 S 51",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: 131278752,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [2, 2, 2],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2004_s_51/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2004_s_52: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 1.5,
            label: "S/2004 S 52",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: 141175872,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [1.5, 1.5, 1.5],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2004_s_52/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2004_s_53: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 2,
            label: "S/2004 S 53",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: 115986816,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [2, 2, 2],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2004_s_53/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2005_s_4: {
            groups: ["saturn", "moons", "minor", "inuit"],
            radius: 2.5,
            label: "S/2005 S 4",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: 38899008,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [2.5, 2.5, 2.5],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2005_s_4/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2005_s_5: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 1.5,
            label: "S/2005 S 5",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: 101763648,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [1.5, 1.5, 1.5],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2005_s_5/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2006_s_10: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 1.5,
            label: "S/2006 S 10",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: 84943296,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [1.5, 1.5, 1.5],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2006_s_10/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2006_s_11: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 1.5,
            label: "S/2006 S 11",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: 90052992,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [1.5, 1.5, 1.5],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2006_s_11/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2006_s_12: {
            groups: ["saturn", "moons", "minor", "gallic"],
            radius: 2,
            label: "S/2006 S 12",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: 89428320,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [2, 2, 2],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2006_s_12/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2006_s_13: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 2,
            label: "S/2006 S 13",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: 91638432,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [2, 2, 2],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2006_s_13/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2006_s_14: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 1.5,
            label: "S/2006 S 14",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: 99591552,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [1.5, 1.5, 1.5],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2006_s_14/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2006_s_15: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 2,
            label: "S/2006 S 15",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: 104886144,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [2, 2, 2],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2006_s_15/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2006_s_16: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 1.5,
            label: "S/2006 S 16",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: 104329728,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [1.5, 1.5, 1.5],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2006_s_16/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2006_s_17: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 2,
            label: "S/2006 S 17",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: 109259712,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [2, 2, 2],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2006_s_17/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2006_s_18: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 2,
            label: "S/2006 S 18",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: 112181760,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [2, 2, 2],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2006_s_18/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2006_s_19: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 2,
            label: "S/2006 S 19",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: 120038112,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [2, 2, 2],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2006_s_19/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2006_s_20: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 2.5,
            label: "S/2006 S 20",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: 49012128,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [2.5, 2.5, 2.5],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2006_s_20/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2006_s_9: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 1.5,
            label: "S/2006 S 9",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: 55977696,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [1.5, 1.5, 1.5],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2006_s_9/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2007_s_5: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 2,
            label: "S/2007 S 5",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: 64530432,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [2, 2, 2],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2007_s_5/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2007_s_6: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 1.5,
            label: "S/2007 S 6",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: 82036800,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [1.5, 1.5, 1.5],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2007_s_6/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2007_s_7: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 2,
            label: "S/2007 S 7",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: 65170656,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [2, 2, 2],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2007_s_7/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2007_s_8: {
            groups: ["saturn", "moons", "minor", "gallic"],
            radius: 2,
            label: "S/2007 S 8",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: 72308160,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [2, 2, 2],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2007_s_8/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2007_s_9: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 2,
            label: "S/2007 S 9",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: 93145248,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [2, 2, 2],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2007_s_9/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2019_s_10: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 1.5,
            label: "S/2019 S 10",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: 97030656,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [1.5, 1.5, 1.5],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2019_s_10/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2019_s_11: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 2,
            label: "S/2019 S 11",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: 96336e3,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [2, 2, 2],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2019_s_11/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2019_s_12: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 2,
            label: "S/2019 S 12",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: 98396640,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [2, 2, 2],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2019_s_12/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2019_s_13: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 1.5,
            label: "S/2019 S 13",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: 98921088,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [1.5, 1.5, 1.5],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2019_s_13/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2019_s_14: {
            groups: ["saturn", "moons", "minor", "inuit"],
            radius: 2,
            label: "S/2019 S 14",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: 77167296,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [2, 2, 2],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2019_s_14/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2019_s_15: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 1.5,
            label: "S/2019 S 15",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: 100357056,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [1.5, 1.5, 1.5],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2019_s_15/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2019_s_16: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 1.5,
            label: "S/2019 S 16",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: 115877088,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [1.5, 1.5, 1.5],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2019_s_16/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2019_s_17: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 2,
            label: "S/2019 S 17",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: 111576096,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [2, 2, 2],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2019_s_17/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2019_s_18: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 1.5,
            label: "S/2019 S 18",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: 114657984,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [1.5, 1.5, 1.5],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2019_s_18/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2019_s_19: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 1.5,
            label: "S/2019 S 19",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: 113879520,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [1.5, 1.5, 1.5],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2019_s_19/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2019_s_2: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 1.5,
            label: "S/2019 S 2",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: 69104448,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [1.5, 1.5, 1.5],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2019_s_2/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2019_s_20: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 1.5,
            label: "S/2019 S 20",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: 118838880,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [1.5, 1.5, 1.5],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2019_s_20/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2019_s_21: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 2,
            label: "S/2019 S 21",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: 141378048,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [2, 2, 2],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2019_s_21/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2019_s_3: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 2,
            label: "S/2019 S 3",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: 72380736,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [2, 2, 2],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2019_s_3/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2019_s_4: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 1.5,
            label: "S/2019 S 4",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: 78128064,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [1.5, 1.5, 1.5],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2019_s_4/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2019_s_5: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 1.5,
            label: "S/2019 S 5",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: 85568832,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [1.5, 1.5, 1.5],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2019_s_5/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2019_s_6: {
            groups: ["saturn", "moons", "minor", "inuit"],
            radius: 2,
            label: "S/2019 S 6",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: 79202880,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [2, 2, 2],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2019_s_6/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2019_s_7: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 2,
            label: "S/2019 S 7",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: 93337056,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [2, 2, 2],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2019_s_7/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2019_s_8: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 2,
            label: "S/2019 S 8",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: 94061952,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [2, 2, 2],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2019_s_8/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2019_s_9: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 2,
            label: "S/2019 S 9",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: 94444704,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [2, 2, 2],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2019_s_9/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2020_s_1: {
            groups: ["saturn", "moons", "minor", "inuit"],
            radius: 2,
            label: "S/2020 S 1",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: 38975040,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [2, 2, 2],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2020_s_1/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2020_s_10: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 1.5,
            label: "S/2020 S 10",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: 131951808,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [1.5, 1.5, 1.5],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2020_s_10/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2020_s_2: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 1.5,
            label: "S/2020 S 2",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: 77552640,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [1.5, 1.5, 1.5],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2020_s_2/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2020_s_3: {
            groups: ["saturn", "moons", "minor", "inuit"],
            radius: 1.5,
            label: "S/2020 S 3",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: 78450336,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [1.5, 1.5, 1.5],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2020_s_3/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2020_s_4: {
            groups: ["saturn", "moons", "minor", "gallic"],
            radius: 1.5,
            label: "S/2020 S 4",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: 80085888,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [1.5, 1.5, 1.5],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2020_s_4/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2020_s_5: {
            groups: ["saturn", "moons", "minor", "inuit"],
            radius: 1.5,
            label: "S/2020 S 5",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: 80687232,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [1.5, 1.5, 1.5],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2020_s_5/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2020_s_6: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 1.5,
            label: "S/2020 S 6",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: 100989504,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [1.5, 1.5, 1.5],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2020_s_6/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2020_s_7: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 1.5,
            label: "S/2020 S 7",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: 74450880,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [1.5, 1.5, 1.5],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2020_s_7/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2020_s_8: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 1.5,
            label: "S/2020 S 8",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: 106109568,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [1.5, 1.5, 1.5],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2020_s_8/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        s_2020_s_9: {
            groups: ["saturn", "moons", "minor", "norse"],
            radius: 2,
            label: "S/2020 S 9",
            parents: [[Number.NEGATIVE_INFINITY, "saturn"]],
            trail: {
                length: 132621408,
                color: [.72, .65, .52, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [2, 2, 2],
                shadowEntities: ["saturn"]
            },
            controllers: [{
                type: "dynamo",
                url: "s_2020_s_9/saturn/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        }
    })
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i(545).Entity.register({
        ariel: {
            groups: ["uranus", "moons", "major"],
            radius: 578.9,
            label: "Ariel",
            parents: [[Number.NEGATIVE_INFINITY, "uranus"]],
            trail: {
                length: void 0,
                color: [.67, .92, 1, .7]
            },
            spheroid: {
                equatorialRadius: 578.9,
                polarRadius: 578.9,
                planetographic: !1
            },
            spheroidLOD: {
                textures: {
                    color: {
                        url: "ariel/color_$SIZE_$FACE.png",
                        sizes: [4, 512]
                    }
                },
                shadowEntities: ["uranus"]
            },
            controllers: [{
                type: "dynamo",
                url: "ariel/uranus/orb"
            }, {
                type: "dynamo",
                url: "ariel/ori"
            }]
        },
        miranda: {
            groups: ["uranus", "moons", "major"],
            radius: 235.8,
            label: "Miranda",
            parents: [[Number.NEGATIVE_INFINITY, "uranus"]],
            trail: {
                length: void 0,
                color: [.67, .92, 1, .7]
            },
            spheroid: {
                equatorialRadius: 235.8,
                polarRadius: 235.8,
                planetographic: !1
            },
            spheroidLOD: {
                textures: {
                    color: {
                        url: "miranda/color_$SIZE_$FACE.png",
                        sizes: [4, 256]
                    }
                },
                shadowEntities: ["uranus"]
            },
            controllers: [{
                type: "dynamo",
                url: "miranda/uranus/orb"
            }, {
                type: "dynamo",
                url: "miranda/ori"
            }]
        },
        oberon: {
            groups: ["uranus", "moons", "major"],
            radius: 761.4,
            label: "Oberon",
            parents: [[Number.NEGATIVE_INFINITY, "uranus"]],
            trail: {
                length: void 0,
                color: [.67, .92, 1, .7]
            },
            spheroid: {
                equatorialRadius: 761.4,
                polarRadius: 761.4,
                planetographic: !1
            },
            spheroidLOD: {
                textures: {
                    color: {
                        url: "oberon/color_$SIZE_$FACE.png",
                        sizes: [4, 512]
                    }
                },
                shadowEntities: ["uranus"]
            },
            controllers: [{
                type: "dynamo",
                url: "oberon/uranus/orb"
            }, {
                type: "dynamo",
                url: "oberon/ori"
            }]
        },
        titania: {
            groups: ["uranus", "moons", "major"],
            radius: 788.4,
            label: "Titania",
            parents: [[Number.NEGATIVE_INFINITY, "uranus"]],
            trail: {
                length: void 0,
                color: [.67, .92, 1, .7]
            },
            spheroid: {
                equatorialRadius: 788.4,
                polarRadius: 788.4,
                planetographic: !1
            },
            spheroidLOD: {
                textures: {
                    color: {
                        url: "titania/color_$SIZE_$FACE.png",
                        sizes: [4, 512]
                    }
                },
                shadowEntities: ["uranus"]
            },
            controllers: [{
                type: "dynamo",
                url: "titania/uranus/orb"
            }, {
                type: "dynamo",
                url: "titania/ori"
            }]
        },
        umbriel: {
            groups: ["uranus", "moons", "major"],
            radius: 584.7,
            label: "Umbriel",
            parents: [[Number.NEGATIVE_INFINITY, "uranus"]],
            trail: {
                length: void 0,
                color: [.67, .92, 1, .7]
            },
            spheroid: {
                equatorialRadius: 584.7,
                polarRadius: 584.7,
                planetographic: !1
            },
            spheroidLOD: {
                textures: {
                    color: {
                        url: "umbriel/color_$SIZE_$FACE.png",
                        sizes: [4, 256]
                    }
                },
                shadowEntities: ["uranus"]
            },
            controllers: [{
                type: "dynamo",
                url: "umbriel/uranus/orb"
            }, {
                type: "dynamo",
                url: "umbriel/ori"
            }]
        }
    })
}
, function(t, e, i) {
    "use strict";
    i.r(e);
    var s = i(5);
    i(545).Entity.register({
        belinda: {
            groups: ["uranus", "moons", "minor", "inner"],
            radius: 45,
            label: "Belinda",
            parents: [[Number.NEGATIVE_INFINITY, "uranus"]],
            trail: {
                length: void 0,
                color: [.67, .92, 1, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [45, 45, 45],
                shadowEntities: ["uranus"]
            },
            controllers: [{
                type: "dynamo",
                url: "belinda/uranus/orb"
            }, {
                type: "dynamo",
                url: "belinda/ori"
            }]
        },
        bianca: {
            groups: ["uranus", "moons", "minor", "inner"],
            radius: 25.7,
            label: "Bianca",
            parents: [[Number.NEGATIVE_INFINITY, "uranus"]],
            trail: {
                length: void 0,
                color: [.67, .92, 1, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [25.7, 25.7, 25.7],
                shadowEntities: ["uranus"]
            },
            controllers: [{
                type: "dynamo",
                url: "bianca/uranus/orb"
            }, {
                type: "dynamo",
                url: "bianca/ori"
            }]
        },
        caliban: {
            groups: ["uranus", "moons", "minor", "irregular"],
            radius: 36,
            label: "Caliban",
            parents: [[Number.NEGATIVE_INFINITY, "uranus"]],
            trail: {
                length: void 0,
                color: [.67, .92, 1, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [36, 36, 36],
                shadowEntities: ["uranus"]
            },
            controllers: [{
                type: "dynamo",
                url: "caliban/uranus/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        cordelia: {
            groups: ["uranus", "moons", "minor", "inner"],
            radius: 20.1,
            label: "Cordelia",
            parents: [[Number.NEGATIVE_INFINITY, "uranus"]],
            trail: {
                length: void 0,
                color: [.67, .92, 1, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [20.1, 20.1, 20.1],
                shadowEntities: ["uranus"]
            },
            controllers: [{
                type: "dynamo",
                url: "cordelia/uranus/orb"
            }, {
                type: "dynamo",
                url: "cordelia/ori"
            }]
        },
        cressida: {
            groups: ["uranus", "moons", "minor", "inner"],
            radius: 39.8,
            label: "Cressida",
            parents: [[Number.NEGATIVE_INFINITY, "uranus"]],
            trail: {
                length: void 0,
                color: [.67, .92, 1, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [39.8, 39.8, 39.8],
                shadowEntities: ["uranus"]
            },
            controllers: [{
                type: "dynamo",
                url: "cressida/uranus/orb"
            }, {
                type: "dynamo",
                url: "cressida/ori"
            }]
        },
        cupid: {
            groups: ["uranus", "moons", "minor", "inner"],
            radius: 9,
            label: "Cupid",
            parents: [[Number.NEGATIVE_INFINITY, "uranus"]],
            trail: {
                length: void 0,
                color: [.67, .92, 1, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [9, 9, 9],
                shadowEntities: ["uranus"]
            },
            controllers: [{
                type: "dynamo",
                url: "cupid/uranus/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        desdemona: {
            groups: ["uranus", "moons", "minor", "inner"],
            radius: 32,
            label: "Desdemona",
            parents: [[Number.NEGATIVE_INFINITY, "uranus"]],
            trail: {
                length: void 0,
                color: [.67, .92, 1, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [32, 32, 32],
                shadowEntities: ["uranus"]
            },
            controllers: [{
                type: "dynamo",
                url: "desdemona/uranus/orb"
            }, {
                type: "dynamo",
                url: "desdemona/ori"
            }]
        },
        ferdinand: {
            groups: ["uranus", "moons", "minor", "irregular"],
            radius: 10,
            label: "Ferdinand",
            parents: [[Number.NEGATIVE_INFINITY, "uranus"]],
            trail: {
                length: void 0,
                color: [.67, .92, 1, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [10, 10, 10],
                shadowEntities: ["uranus"]
            },
            controllers: [{
                type: "dynamo",
                url: "ferdinand/uranus/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        francisco: {
            groups: ["uranus", "moons", "minor", "irregular"],
            radius: 11,
            label: "Francisco",
            parents: [[Number.NEGATIVE_INFINITY, "uranus"]],
            trail: {
                length: void 0,
                color: [.67, .92, 1, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [11, 11, 11],
                shadowEntities: ["uranus"]
            },
            controllers: [{
                type: "dynamo",
                url: "francisco/uranus/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        juliet: {
            groups: ["uranus", "moons", "minor", "inner"],
            radius: 46.8,
            label: "Juliet",
            parents: [[Number.NEGATIVE_INFINITY, "uranus"]],
            trail: {
                length: void 0,
                color: [.67, .92, 1, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [46.8, 46.8, 46.8],
                shadowEntities: ["uranus"]
            },
            controllers: [{
                type: "dynamo",
                url: "juliet/uranus/orb"
            }, {
                type: "dynamo",
                url: "juliet/ori"
            }]
        },
        mab: {
            groups: ["uranus", "moons", "minor", "inner"],
            radius: 12.5,
            label: "Mab",
            parents: [[Number.NEGATIVE_INFINITY, "uranus"]],
            trail: {
                length: void 0,
                color: [.67, .92, 1, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [12.5, 12.5, 12.5],
                shadowEntities: ["uranus"]
            },
            controllers: [{
                type: "dynamo",
                url: "mab/uranus/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        margaret: {
            groups: ["uranus", "moons", "minor", "irregular"],
            radius: 10,
            label: "Margaret",
            parents: [[Number.NEGATIVE_INFINITY, "uranus"]],
            trail: {
                length: void 0,
                color: [.67, .92, 1, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [10, 10, 10],
                shadowEntities: ["uranus"]
            },
            controllers: [{
                type: "dynamo",
                url: "margaret/uranus/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        ophelia: {
            groups: ["uranus", "moons", "minor", "inner"],
            radius: 22.4,
            label: "Ophelia",
            parents: [[Number.NEGATIVE_INFINITY, "uranus"]],
            trail: {
                length: void 0,
                color: [.67, .92, 1, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [22.4, 22.4, 22.4],
                shadowEntities: ["uranus"]
            },
            controllers: [{
                type: "dynamo",
                url: "ophelia/uranus/orb"
            }, {
                type: "dynamo",
                url: "ophelia/ori"
            }]
        },
        perdita: {
            groups: ["uranus", "moons", "minor", "inner"],
            radius: 15,
            label: "Perdita",
            parents: [[Number.NEGATIVE_INFINITY, "uranus"]],
            trail: {
                length: void 0,
                color: [.67, .92, 1, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [15, 15, 15],
                shadowEntities: ["uranus"]
            },
            controllers: [{
                type: "dynamo",
                url: "perdita/uranus/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        portia: {
            groups: ["uranus", "moons", "minor", "inner"],
            radius: 67.6,
            label: "Portia",
            parents: [[Number.NEGATIVE_INFINITY, "uranus"]],
            trail: {
                length: void 0,
                color: [.67, .92, 1, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [67.6, 67.6, 67.6],
                shadowEntities: ["uranus"]
            },
            controllers: [{
                type: "dynamo",
                url: "portia/uranus/orb"
            }, {
                type: "dynamo",
                url: "portia/ori"
            }]
        },
        prospero: {
            groups: ["uranus", "moons", "minor", "irregular"],
            radius: 25,
            label: "Prospero",
            parents: [[Number.NEGATIVE_INFINITY, "uranus"]],
            trail: {
                length: void 0,
                color: [.67, .92, 1, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [25, 25, 25],
                shadowEntities: ["uranus"]
            },
            controllers: [{
                type: "dynamo",
                url: "prospero/uranus/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        puck: {
            groups: ["uranus", "moons", "minor", "inner"],
            radius: 81,
            label: "Puck",
            parents: [[Number.NEGATIVE_INFINITY, "uranus"]],
            trail: {
                length: void 0,
                color: [.67, .92, 1, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [81, 81, 81],
                shadowEntities: ["uranus"]
            },
            controllers: [{
                type: "dynamo",
                url: "puck/uranus/orb"
            }, {
                type: "dynamo",
                url: "puck/ori"
            }]
        },
        rosalind: {
            groups: ["uranus", "moons", "minor", "inner"],
            radius: 36,
            label: "Rosalind",
            parents: [[Number.NEGATIVE_INFINITY, "uranus"]],
            trail: {
                length: void 0,
                color: [.67, .92, 1, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [36, 36, 36],
                shadowEntities: ["uranus"]
            },
            controllers: [{
                type: "dynamo",
                url: "rosalind/uranus/orb"
            }, {
                type: "dynamo",
                url: "rosalind/ori"
            }]
        },
        setebos: {
            groups: ["uranus", "moons", "minor", "irregular"],
            radius: 24,
            label: "Setebos",
            parents: [[Number.NEGATIVE_INFINITY, "uranus"]],
            trail: {
                length: void 0,
                color: [.67, .92, 1, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [24, 24, 24],
                shadowEntities: ["uranus"]
            },
            controllers: [{
                type: "dynamo",
                url: "setebos/uranus/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        stephano: {
            groups: ["uranus", "moons", "minor", "irregular"],
            radius: 16,
            label: "Stephano",
            parents: [[Number.NEGATIVE_INFINITY, "uranus"]],
            trail: {
                length: void 0,
                color: [.67, .92, 1, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf",
                scale: [16, 16, 16],
                shadowEntities: ["uranus"]
            },
            controllers: [{
                type: "dynamo",
                url: "stephano/uranus/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        sycorax: {
            groups: ["uranus", "moons", "minor", "irregular"],
            radius: 82,
            label: "Sycorax",
            parents: [[Number.NEGATIVE_INFINITY, "uranus"]],
            trail: {
                length: void 0,
                color: [.67, .92, 1, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf",
                scale: [82, 82, 82],
                shadowEntities: ["uranus"]
            },
            controllers: [{
                type: "dynamo",
                url: "sycorax/uranus/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        trinculo: {
            groups: ["uranus", "moons", "minor", "irregular"],
            radius: 9,
            label: "Trinculo",
            parents: [[Number.NEGATIVE_INFINITY, "uranus"]],
            trail: {
                length: void 0,
                color: [.67, .92, 1, .7]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf",
                scale: [9, 9, 9],
                shadowEntities: ["uranus"]
            },
            controllers: [{
                type: "dynamo",
                url: "trinculo/uranus/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        }
    })
}
, function(t, e, i) {
    "use strict";
    i.r(e);
    var s = i(5)
      , n = i(545)
      , o = i(665);
    n.Entity.register({
        sc_3d_winds: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: .002,
            extentsRadius: .0025,
            label: "3D-Winds",
            parents: [[347025366.1839032, "earth"]],
            trail: {
                length: 5573
            },
            controllers: [{
                type: "dynamo",
                url: "sc_3d_winds"
            }]
        },
        sc_ace: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: 8e-4,
            extentsRadius: .0023,
            label: "ACE",
            parents: [[115387273, "earth"]],
            trail: {
                length: 31715490
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_ace/ace.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_ace"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.YAxis
                }
            }, {
                type: "spin",
                axis: s.Vector3.YAxisNeg,
                periodInHours: .0033
            }]
        },
        sc_acrimsat: {
            groups: ["earth", "spacecraft"],
            radius: .0015,
            label: "ACRIMSAT",
            parents: [[-963797, "earth"], [459950467, ""]],
            trail: {
                length: 5933.5
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_acrimsat/acrimsat.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_acrimsat"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.YAxis
                }
            }, {
                type: "spin",
                axis: s.Vector3.YAxisNeg,
                periodInHours: .00238
            }]
        },
        sc_acs3: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: 143783e-9,
            extentsRadius: .0073102,
            label: "ACS3",
            parents: [[Number.NEGATIVE_INFINITY, "earth"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_acs3/acs3.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_acs3"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.ZAxisNeg
                },
                secondary: {
                    type: "velocity",
                    target: "sc_acs3",
                    axis: s.Vector3.YAxisNeg
                }
            }]
        },
        sc_aim: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: 7e-4,
            extentsRadius: .0014,
            label: "AIM",
            parents: [[230808524, "earth"], [731980869, ""]],
            trail: {
                length: 5788.83
            },
            controllers: [{
                type: "dynamo",
                url: "sc_aim"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        sc_aqua: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: .004,
            extentsRadius: .015,
            label: "Aqua",
            parents: [[73781738, "earth"]],
            trail: {
                length: 5933.5
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_aqua/Aqua.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_aqua"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.ZAxis
                },
                secondary: {
                    type: "velocity",
                    target: "sc_aqua",
                    axis: s.Vector3.XAxis
                }
            }]
        },
        sc_ascends: {
            groups: ["earth", "spacecraft"],
            radius: .004,
            label: "ASCENDS",
            parents: [[347025366.1839032, "earth"]],
            trail: {
                length: 5573
            },
            controllers: [{
                type: "dynamo",
                url: "sc_ascends"
            }]
        },
        sc_aura: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: .00345,
            extentsRadius: .017,
            label: "Aura",
            parents: [[143161358, "earth"]],
            trail: {
                length: 5933.5
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_aura/Aura.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_aura"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.ZAxis
                },
                secondary: {
                    type: "velocity",
                    target: "sc_aura",
                    axis: s.Vector3.XAxis
                }
            }]
        },
        sc_c_nofs: {
            groups: ["earth", "spacecraft"],
            radius: .004,
            label: "C/NOFS",
            parents: [[352800006.1854904, "earth"], [502051928.18300515, ""]],
            trail: {
                length: 5573
            },
            controllers: [{
                type: "dynamo",
                url: "sc_c_nofs"
            }]
        },
        sc_calipso: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: .00165,
            extentsRadius: .005,
            label: "CALIPSO",
            parents: [[199506047, "earth"], [744120069, ""]],
            trail: {
                length: 5933
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_calipso/calipso.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_calipso"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.ZAxis
                },
                secondary: {
                    type: "velocity",
                    target: "sc_calipso",
                    axis: s.Vector3.YAxis
                }
            }]
        },
        sc_chandra: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: .0059,
            extentsRadius: .01,
            label: "Chandra",
            parents: [[-12716935, "earth"]],
            trail: {
                length: 228505.5
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_chandra/chandra.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_chandra"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "sun",
                    axis: new s.Vector3(-.70710678118,-.70710678118,0)
                }
            }]
        },
        sc_clarreo: {
            groups: ["earth", "spacecraft"],
            radius: .004,
            label: "CLARREO",
            parents: [[347025366.1839032, "earth"]],
            trail: {
                length: 5573
            },
            controllers: [{
                type: "dynamo",
                url: "sc_clarreo"
            }]
        },
        sc_cloudsat: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: .0025,
            extentsRadius: .0025,
            label: "CloudSat",
            parents: [[199491286, "earth"], [756302469, ""]],
            trail: {
                length: 5933.5
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_cloudsat/CloudSat.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_cloudsat"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.YAxisNeg
                },
                secondary: {
                    type: "velocity",
                    target: "sc_cloudsat",
                    axis: s.Vector3.XAxis
                }
            }]
        },
        sc_cluster_ii_fm5: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: .00145,
            extentsRadius: .00435,
            label: "Rumba",
            parents: [[19105314, "earth"]],
            trail: {
                length: 195541.5
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_cluster_ii/cluster_ii.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_cluster_ii_fm5"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.YAxisNeg
                },
                secondary: {
                    type: "velocity",
                    target: "sc_cluster_ii_fm5",
                    axis: s.Vector3.ZAxis
                }
            }]
        },
        sc_cluster_ii_fm6: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: .00145,
            extentsRadius: .00435,
            label: "Salsa",
            parents: [[17028089, "earth"], [779099035, ""]],
            trail: {
                length: 195351
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_cluster_ii/cluster_ii.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_cluster_ii_fm6"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.YAxisNeg
                },
                secondary: {
                    type: "velocity",
                    target: "sc_cluster_ii_fm6",
                    axis: s.Vector3.ZAxis
                }
            }]
        },
        sc_cluster_ii_fm7: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: .00145,
            extentsRadius: .00435,
            label: "Samba",
            parents: [[17028093, "earth"]],
            trail: {
                length: 195316
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_cluster_ii/cluster_ii.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_cluster_ii_fm7"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.YAxisNeg
                },
                secondary: {
                    type: "velocity",
                    target: "sc_cluster_ii_fm7",
                    axis: s.Vector3.ZAxis
                }
            }]
        },
        sc_cluster_ii_fm8: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: .00145,
            extentsRadius: .00435,
            label: "Tango",
            parents: [[19105052, "earth"]],
            trail: {
                length: 195388
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_cluster_ii/cluster_ii.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_cluster_ii_fm8"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.YAxisNeg
                },
                secondary: {
                    type: "velocity",
                    target: "sc_cluster_ii_fm8",
                    axis: s.Vector3.ZAxis
                }
            }]
        },
        sc_cygnss_1: {
            groups: ["earth", "spacecraft"],
            radius: 8e-4,
            label: "CYGNSS 1",
            parents: [[535085801, "earth"]],
            trail: {
                length: 5573
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_cygnss/CYGNSS.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_cygnss_1"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.ZAxis
                },
                secondary: {
                    type: "velocity",
                    target: "sc_cygnss_1",
                    axis: s.Vector3.YAxisNeg
                }
            }]
        },
        sc_cygnss_2: {
            groups: ["earth", "spacecraft"],
            radius: 8e-4,
            label: "CYGNSS 2",
            parents: [[535085716, "earth"]],
            trail: {
                length: 5573
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_cygnss/CYGNSS.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_cygnss_2"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.ZAxis
                },
                secondary: {
                    type: "velocity",
                    target: "sc_cygnss_2",
                    axis: s.Vector3.YAxisNeg
                }
            }]
        },
        sc_cygnss_3: {
            groups: ["earth", "spacecraft"],
            radius: 8e-4,
            label: "CYGNSS 3",
            parents: [[535092760, "earth"]],
            trail: {
                length: 5573
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_cygnss/CYGNSS.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_cygnss_3"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.ZAxis
                },
                secondary: {
                    type: "velocity",
                    target: "sc_cygnss_3",
                    axis: s.Vector3.YAxisNeg
                }
            }]
        },
        sc_cygnss_4: {
            groups: ["earth", "spacecraft"],
            radius: 8e-4,
            label: "CYGNSS 4",
            parents: [[535085490, "earth"]],
            trail: {
                length: 5573
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_cygnss/CYGNSS.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_cygnss_4"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.ZAxis
                },
                secondary: {
                    type: "velocity",
                    target: "sc_cygnss_4",
                    axis: s.Vector3.YAxisNeg
                }
            }]
        },
        sc_cygnss_5: {
            groups: ["earth", "spacecraft"],
            radius: 8e-4,
            label: "CYGNSS 5",
            parents: [[535085366, "earth"]],
            trail: {
                length: 5573
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_cygnss/CYGNSS.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_cygnss_5"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.ZAxis
                },
                secondary: {
                    type: "velocity",
                    target: "sc_cygnss_5",
                    axis: s.Vector3.YAxisNeg
                }
            }]
        },
        sc_cygnss_6: {
            groups: ["earth", "spacecraft"],
            radius: 8e-4,
            label: "CYGNSS 6",
            parents: [[535092973, "earth"], [722736069, ""]],
            trail: {
                length: 5573
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_cygnss/CYGNSS.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_cygnss_6"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.ZAxis
                },
                secondary: {
                    type: "velocity",
                    target: "sc_cygnss_6",
                    axis: s.Vector3.YAxisNeg
                }
            }]
        },
        sc_cygnss_7: {
            groups: ["earth", "spacecraft"],
            radius: 8e-4,
            label: "CYGNSS 7",
            parents: [[535092761, "earth"]],
            trail: {
                length: 5573
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_cygnss/CYGNSS.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_cygnss_7"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.ZAxis
                },
                secondary: {
                    type: "velocity",
                    target: "sc_cygnss_7",
                    axis: s.Vector3.YAxisNeg
                }
            }]
        },
        sc_cygnss_8: {
            groups: ["earth", "spacecraft"],
            radius: 8e-4,
            label: "CYGNSS 8",
            parents: [[535085874, "earth"]],
            trail: {
                length: 5573
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_cygnss/CYGNSS.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_cygnss_8"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.ZAxis
                },
                secondary: {
                    type: "velocity",
                    target: "sc_cygnss_8",
                    axis: s.Vector3.YAxisNeg
                }
            }]
        },
        sc_dscovr: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: 9e-4,
            extentsRadius: .002,
            label: "DSCOVR",
            parents: [[476711467.18497694, "earth"]],
            trail: {
                length: 31536e3
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_dscovr/dscovr.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "animdata",
                url: "sc_dscovr/earth/all",
                dataType: "pos"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.XAxisNeg
                },
                secondary: {
                    type: "velocity",
                    target: "sc_dscovr",
                    axis: s.Vector3.ZAxisNeg
                }
            }]
        },
        sc_eo_1: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: .003,
            extentsRadius: .001,
            label: "EO-1",
            parents: [[344589947.18311954, "earth"], [544104069.186, ""]],
            trail: {
                length: 5933.33
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_eo_1/eo-1.gltf",
                rotate: [{
                    y: 45
                }],
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_eo_1"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.YAxis
                },
                secondary: {
                    type: "velocity",
                    target: "sc_eo_1",
                    axis: s.Vector3.XAxisNeg
                }
            }]
        },
        sc_euclid: {
            groups: ["earth", "spacecraft", "telescope"],
            radius: .0035,
            label: "Euclid",
            parents: [[741498789, "earth"]],
            trail: {
                length: 31536e3
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_euclid/euclid.gltf"
            },
            controllers: [{
                type: "dynamo",
                url: "sc_euclid/earth"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.YAxisNeg
                },
                secondary: {
                    type: "align",
                    target: "sun",
                    axis: s.Vector3.ZAxis,
                    targetAxis: s.Vector3.ZAxis
                }
            }]
        },
        sc_explorer_1: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: .001,
            extentsRadius: .001,
            label: "Explorer 1",
            parents: [[-1322726967, "earth"], [-939025103, ""]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_explorer_1_v2/explorer_1.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_explorer_1/earth"
            }, {
                type: "align",
                primary: {
                    type: "velocity",
                    target: "sc_explorer_1",
                    axis: s.Vector3.YAxis
                }
            }, {
                type: "spin",
                axis: s.Vector3.YAxisNeg,
                periodInHours: 22e-6
            }]
        },
        sc_face: {
            groups: ["earth", "spacecraft"],
            radius: .004,
            label: "FACE",
            parents: [[347025366.1839032, "earth"], [631022168.1838934, ""]],
            trail: {
                length: 5933.33
            },
            controllers: [{
                type: "dynamo",
                url: "sc_face"
            }]
        },
        sc_fgrst: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: .0014,
            extentsRadius: .004,
            label: "FGRST",
            parents: [[344589947.18311954, "earth"], [661006268.1833516, ""]],
            trail: {
                length: 5733
            },
            controllers: [{
                type: "dynamo",
                url: "sc_fgrst"
            }]
        },
        sc_gacm: {
            groups: ["earth", "spacecraft"],
            radius: .004,
            label: "GACM",
            parents: [[347025366.1839032, "earth"]],
            trail: {
                length: 5733
            },
            controllers: [{
                type: "dynamo",
                url: "sc_gacm"
            }]
        },
        sc_galex: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: .001,
            extentsRadius: .0014,
            label: "GALEX",
            parents: [[352800006.1854904, "earth"], [425718607.184, ""]],
            trail: {
                length: 5733
            },
            controllers: [{
                type: "dynamo",
                url: "sc_galex"
            }]
        },
        sc_geo_cape: {
            groups: ["earth", "spacecraft"],
            radius: .004,
            label: "GEO-CAPE",
            parents: [[347025366.1839032, "earth"]],
            trail: {
                length: 5733
            },
            controllers: [{
                type: "dynamo",
                url: "sc_geo_cape"
            }]
        },
        sc_geotail: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: .0018,
            extentsRadius: .003,
            label: "Geotail",
            parents: [[-234758765, "earth"], [722891591, ""]],
            trail: {
                length: 450372
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_geotail/geotail.gltf",
                shadowEntities: ["earth"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_geotail/earth/orb"
            }, {
                type: "fixed",
                orientation: new s.Quaternion(.662,.749,0,0)
            }, {
                type: "spin",
                axis: s.Vector3.YAxis,
                periodInHours: .00083333333,
                relativeToTime: 0
            }]
        },
        sc_goes_12: {
            groups: ["earth", "spacecraft"],
            radius: .003,
            label: "GOES 12",
            parents: [[344589947.18311954, "earth"], [661006268.1833516, ""]],
            trail: {
                length: 5733
            },
            controllers: [{
                type: "dynamo",
                url: "sc_goes_12"
            }]
        },
        sc_goes_13: {
            groups: ["earth", "spacecraft"],
            radius: .003,
            label: "GOES 13",
            parents: [[344589947.18311954, "earth"]],
            trail: {
                length: 5733
            },
            controllers: [{
                type: "dynamo",
                url: "sc_goes_13"
            }]
        },
        sc_goes_14: {
            groups: ["earth", "spacecraft"],
            radius: .003,
            label: "GOES 14",
            parents: [[344589947.18311954, "earth"]],
            trail: {
                length: 5733
            },
            controllers: [{
                type: "dynamo",
                url: "sc_goes_14"
            }]
        },
        sc_goes_15: {
            groups: ["earth", "spacecraft"],
            radius: .003,
            label: "GOES 15",
            parents: [[344589947.18311954, "earth"]],
            trail: {
                length: 5733
            },
            controllers: [{
                type: "dynamo",
                url: "sc_goes_15"
            }]
        },
        sc_gpm: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: .002,
            extentsRadius: .007,
            label: "GPM",
            parents: [[629484755.7856493, "earth"]],
            trail: {
                length: 5549.5
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_gpm/GPM.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_gpm"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.YAxisNeg
                },
                secondary: {
                    type: "velocity",
                    target: "sc_gpm",
                    axis: s.Vector3.ZAxis
                }
            }],
            postCreateFunction: t => {
                const e = t.addController(s.SpinController);
                e.setJoint("GPM_antenna"),
                e.setRate(s.MathUtils.degToRad(192)),
                e.setAxis(s.Vector3.YAxisNeg, !0),
                e.setClampedToRealTime(!0)
            }
        },
        sc_grace_1: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: .0015,
            extentsRadius: .0019,
            label: "GRACE-1",
            parents: [[69656411.096817, "earth"], [562382552.2587994, ""]],
            trail: {
                length: 5575
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_grace/grace.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_grace_1/earth/orb"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "sc_grace_2",
                    axis: s.Vector3.YAxisNeg
                },
                secondary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.ZAxis
                }
            }, {
                type: "coverage",
                coverage: [Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY],
                update: t => {
                    const e = t.getComponent(s.ConnectedSpriteComponent, "microwave");
                    if (!e)
                        return;
                    const i = t.getScene().getEngine()
                      , n = s.MathUtils.wrap(e.getTextureYOffset() - s.MathUtils.clamp(i.getTimeRate(), -1, 1) * i.getDeltaTime(), 0, 1);
                    e.setTextureYOffset(n);
                    const o = t.getScene().getEntity("sc_grace_2")
                      , a = null !== o && o.getPosition().distance(t.getPosition()) <= 3929;
                    a !== e.isEnabled() && e.setEnabled(a)
                }
            }],
            postCreateFunction: t => {
                const e = t.addComponent(s.ConnectedSpriteComponent, "microwave");
                e.setTextureUrl("$STATIC_ASSETS_URL/sprites/sine_wave.png"),
                e.setEntity1("sc_grace_1"),
                e.setEntity1Offset(new s.Vector3(0,-.00165,0)),
                e.setEntity2("sc_grace_2"),
                e.setEntity2Offset(new s.Vector3(0,-.00165,0)),
                e.setWidths(5e-4, 5e-4),
                e.setColorMultiplier(new s.Color(.5,1,1)),
                e.setTextureRepeat(!0),
                e.setTextureStretch(4)
            }
        },
        sc_grace_2: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: .0015,
            extentsRadius: .0019,
            label: "GRACE-2",
            parents: [[69656411.096817, "earth"], [562382552.2588, ""]],
            trail: {
                length: 5575
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_grace/grace.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_grace_2/earth/orb"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "sc_grace_1",
                    axis: s.Vector3.YAxisNeg
                },
                secondary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.ZAxis
                }
            }]
        },
        sc_grace_fo1: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: .0015,
            extentsRadius: .0019,
            label: "GRACE-FO 1",
            parents: [[580290547.185, "earth"]],
            trail: {
                length: 5575
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_grace_fo/graceFO.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_grace_fo1"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "sc_grace_fo2",
                    axis: s.Vector3.ZAxisNeg
                },
                secondary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.YAxisNeg
                }
            }, {
                type: "coverage",
                coverage: [Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY],
                update: t => {
                    const e = t.getComponent(s.ConnectedSpriteComponent, "microwave");
                    if (!e)
                        return;
                    const i = t.getScene().getEngine()
                      , n = s.MathUtils.wrap(e.getTextureYOffset() - s.MathUtils.clamp(i.getTimeRate(), -1, 1) * i.getDeltaTime(), 0, 1);
                    e.setTextureYOffset(n);
                    const o = t.getScene().getEntity("sc_grace_fo2")
                      , a = null !== o && o.getPosition().distance(t.getPosition()) <= 3929;
                    if (a !== e.isEnabled()) {
                        e.setEnabled(a);
                        const i = t.getComponent(s.ConnectedSpriteComponent, "laser1")
                          , n = t.getComponent(s.ConnectedSpriteComponent, "laser2");
                        i && i.setEnabled(a),
                        n && n.setEnabled(a)
                    }
                }
            }],
            postCreateFunction: t => {
                const e = t.addComponent(s.ConnectedSpriteComponent, "microwave");
                e.setTextureUrl("$STATIC_ASSETS_URL/sprites/sine_wave.png"),
                e.setEntity1("sc_grace_fo1"),
                e.setEntity1Offset(new s.Vector3(0,0,-.00165)),
                e.setEntity2("sc_grace_fo2"),
                e.setEntity2Offset(new s.Vector3(0,0,-.00165)),
                e.setWidths(5e-4, 5e-4),
                e.setColorMultiplier(new s.Color(.5,1,1)),
                e.setTextureRepeat(!0),
                e.setTextureStretch(4);
                const i = t.addComponent(s.ConnectedSpriteComponent, "laser1");
                i.setTextureUrl("$STATIC_ASSETS_URL/sprites/line.png"),
                i.setEntity1("sc_grace_fo1"),
                i.setEntity1Offset(new s.Vector3(3e-4,15e-5,-.00165)),
                i.setEntity2("sc_grace_fo2"),
                i.setEntity2Offset(new s.Vector3(-3e-4,15e-5,-.00165)),
                i.setWidths(2e-5, 2e-5),
                i.setColorMultiplier(new s.Color(1,.24,.64)),
                i.setTextureRepeat(!1);
                const n = t.addComponent(s.ConnectedSpriteComponent, "laser2");
                n.setTextureUrl("$STATIC_ASSETS_URL/sprites/line.png"),
                n.setEntity1("sc_grace_fo1"),
                n.setEntity1Offset(new s.Vector3(-3e-4,15e-5,-.00165)),
                n.setEntity2("sc_grace_fo2"),
                n.setEntity2Offset(new s.Vector3(3e-4,15e-5,-.00165)),
                n.setWidths(2e-5, 2e-5),
                n.setColorMultiplier(new s.Color(1,.24,.64)),
                n.setTextureRepeat(!1)
            }
        },
        sc_grace_fo2: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: .0015,
            extentsRadius: .0019,
            label: "GRACE-FO 2",
            parents: [[580290547.185, "earth"]],
            trail: {
                length: 5575
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_grace_fo/graceFO.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_grace_fo2"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "sc_grace_fo1",
                    axis: s.Vector3.ZAxisNeg
                },
                secondary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.YAxisNeg
                }
            }]
        },
        sc_grifex: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: 15e-5,
            extentsRadius: 34e-5,
            label: "GRIFEX",
            parents: [[476542806.1849232, "earth"]],
            trail: {
                length: 5706.25
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_grifex/grifex.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_grifex"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.YAxisNeg
                },
                secondary: {
                    type: "velocity",
                    target: "sc_grifex",
                    axis: s.Vector3.ZAxisNeg
                }
            }]
        },
        sc_hubble_space_telescope: {
            groups: ["earth", "spacecraft", "telescope"],
            occlusionRadius: .0066,
            extentsRadius: .0066,
            label: "Hubble",
            parents: [[-305719099.92837775, "earth"]],
            trail: {
                length: 5748.5
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_hubble/Hubble.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_hubble_space_telescope/earth/orb"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.ZAxis
                },
                secondary: {
                    type: "velocity",
                    target: "sc_hubble_space_telescope",
                    axis: s.Vector3.YAxis
                }
            }]
        },
        sc_hyspiri: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: .004,
            extentsRadius: .012,
            label: "HyspIRI",
            parents: [[347025366.1839032, "earth"]],
            trail: {
                length: 5733
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_hyspiri/HyspIRI.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_hyspiri"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.YAxisNeg
                },
                secondary: {
                    type: "velocity",
                    target: "sc_hyspiri",
                    axis: s.Vector3.ZAxis
                }
            }]
        },
        sc_ibex: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: 5e-4,
            extentsRadius: .001,
            label: "IBEX",
            parents: [[277718464.1823969, "earth"]],
            trail: {
                length: 797489.16
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_ibex/iBEX.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "animdata",
                url: "sc_ibex",
                dataType: "pos"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.YAxis
                }
            }, {
                type: "spin",
                axis: s.Vector3.YAxis,
                periodInHours: .00416
            }]
        },
        sc_icesat_2: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: .00198,
            extentsRadius: .0065,
            label: "ICESat-2",
            parents: [[590288589.182, "earth"]],
            trail: {
                length: 5653.2
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_icesatii/ICESat2.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_icesat_2"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.YAxis
                },
                secondary: {
                    type: "velocity",
                    target: "sc_icesat_2",
                    axis: s.Vector3.XAxis
                }
            }]
        },
        sc_image: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: .00113,
            extentsRadius: .006,
            label: "IMAGE",
            parents: [[7288547.186, "earth"], [188163587.1835355, ""]],
            trail: {
                length: 55541
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_image/image.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_image"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.ZAxis
                },
                secondary: {
                    type: "velocity",
                    target: "sc_image",
                    axis: s.Vector3.XAxis
                }
            }]
        },
        sc_imap: {
            groups: ["earth", "spacecraft"],
            radius: .0034,
            label: "IMAP",
            parents: [[Number.NEGATIVE_INFINITY, "earth"]],
            trail: {
                length: 31536e3
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_imap/imap.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_imap/earth"
            }, {
                type: "spin",
                axis: s.Vector3.YAxis,
                periodInHours: .00416666666
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.YAxis
                }
            }]
        },
        sc_integral: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: .0025,
            extentsRadius: .005,
            label: "INTEGRAL",
            parents: [[367498866.18276465, "earth"]],
            trail: {
                length: 229689
            },
            controllers: [{
                type: "dynamo",
                url: "sc_integral"
            }]
        },
        sc_ipex: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: 1e-4,
            extentsRadius: 15e-5,
            label: "IPEX",
            parents: [[439589738, "earth"], [475891267, ""]],
            trail: {
                length: 5862
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_ipex/IPEX.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_ipex"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.YAxisNeg
                },
                secondary: {
                    type: "velocity",
                    target: "sc_ipex",
                    axis: s.Vector3.ZAxis
                }
            }]
        },
        sc_isas: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: .001,
            extentsRadius: .0015,
            label: "ISAS",
            parents: [[-186102945.06492478, "earth"], [-183424845.06434903, ""]],
            trail: {
                length: 92680.5
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_isas/isas.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "animdata",
                url: "sc_isas",
                dataType: "pos"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.YAxisNeg
                },
                secondary: {
                    type: "velocity",
                    target: "sc_isas",
                    axis: s.Vector3.ZAxis
                }
            }]
        },
        sc_iss: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: .008,
            extentsRadius: .072,
            label: "ISS",
            parents: [[-35183336, "earth"]],
            trail: {
                length: 5573
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_iss/ISS_stationary.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_iss"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.YAxisNeg
                },
                secondary: {
                    type: "velocity",
                    target: "sc_iss",
                    axis: s.Vector3.ZAxis
                }
            }, {
                type: "align",
                joint: "20_P4_Truss",
                primary: {
                    type: "none",
                    axis: s.Vector3.XAxis
                },
                secondary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.ZAxisNeg
                }
            }, {
                type: "align",
                joint: "23_S4_Truss",
                primary: {
                    type: "none",
                    axis: s.Vector3.XAxis
                },
                secondary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.ZAxisNeg
                }
            }, {
                type: "align",
                joint: "20_P4_Truss_01",
                primary: {
                    type: "none",
                    axis: s.Vector3.YAxis
                },
                secondary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.ZAxisNeg
                }
            }, {
                type: "align",
                joint: "20_P4_Truss_02",
                primary: {
                    type: "none",
                    axis: s.Vector3.YAxis
                },
                secondary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.ZAxisNeg
                }
            }, {
                type: "align",
                joint: "32_S6_Truss_01",
                primary: {
                    type: "none",
                    axis: s.Vector3.YAxis
                },
                secondary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.ZAxisNeg
                }
            }, {
                type: "align",
                joint: "32_S6_Truss_02",
                primary: {
                    type: "none",
                    axis: s.Vector3.YAxis
                },
                secondary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.ZAxisNeg
                }
            }, {
                type: "align",
                joint: "23_S4_Truss_01",
                primary: {
                    type: "none",
                    axis: s.Vector3.YAxis
                },
                secondary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.ZAxisNeg
                }
            }, {
                type: "align",
                joint: "23_S4_Truss_02",
                primary: {
                    type: "none",
                    axis: s.Vector3.YAxis
                },
                secondary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.ZAxisNeg
                }
            }, {
                type: "align",
                joint: "08_P6_Truss_01",
                primary: {
                    type: "none",
                    axis: s.Vector3.YAxis
                },
                secondary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.ZAxisNeg
                }
            }, {
                type: "align",
                joint: "08_P6_Truss_02",
                primary: {
                    type: "none",
                    axis: s.Vector3.YAxis
                },
                secondary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.ZAxisNeg
                }
            }],
            postCreateFunction: t => {
                const e = t.addController(s.SpinController);
                e.setJoint("RapidScat_dish"),
                e.setRate(s.MathUtils.degToRad(108)),
                e.setAxis(s.Vector3.ZAxis, !0),
                e.setClampedToRealTime(!0),
                e.setCoverage(new s.Interval(Number.NEGATIVE_INFINITY,524890952));
                const i = t.addController(s.SpinController);
                i.setJoint("COWVR_top_spin"),
                i.setRate(s.MathUtils.degToRad(180)),
                i.setAxis(s.Vector3.YAxis, !0),
                i.setClampedToRealTime(!0),
                o.EntityUtils.showSubObjectDuringInterval(t, "Ecostress", 584127348, Number.POSITIVE_INFINITY),
                o.EntityUtils.showSubObjectDuringInterval(t, "EMIT", 711345507, Number.POSITIVE_INFINITY),
                o.EntityUtils.showSubObjectDuringInterval(t, "OCO3", 610718469, Number.POSITIVE_INFINITY),
                o.EntityUtils.showSubObjectDuringInterval(t, "45_RapidScat", 465418867, 575406069),
                o.EntityUtils.showSubObjectDuringInterval(t, "COWVR_TEMPEST", 693360069, Number.POSITIVE_INFINITY)
            }
        },
        sc_iss_cowvr_tempest: {
            groups: ["instrument", "sc_iss"],
            occlusionRadius: 8e-4,
            extentsRadius: .0012,
            label: "COWVR/TEMPEST",
            parents: [[693360069, "sc_iss"]],
            controllers: [{
                type: "fixed",
                orientation: s.Quaternion.Identity,
                position: new s.Vector3(.01455,-.00235,.01402),
                coverage: [693360069, Number.POSITIVE_INFINITY]
            }],
            postCreateFunction: t => {
                t.addController(s.RotateByEntityOrientationController).setCoverage(new s.Interval(693360069,Number.POSITIVE_INFINITY))
            }
        },
        sc_iss_ecostress: {
            groups: ["instrument", "sc_iss"],
            occlusionRadius: .001,
            extentsRadius: .0012,
            label: "ECOSTRESS",
            parents: [[584127348, "sc_iss"]],
            controllers: [{
                type: "fixed",
                orientation: s.Quaternion.Identity,
                position: new s.Vector3(.0200195,-.00202631,.0161099),
                coverage: [584127348, Number.POSITIVE_INFINITY]
            }],
            postCreateFunction: t => {
                t.addController(s.RotateByEntityOrientationController).setCoverage(new s.Interval(584127348,Number.POSITIVE_INFINITY))
            }
        },
        sc_iss_emit: {
            groups: ["instrument", "sc_iss"],
            occlusionRadius: 8e-4,
            extentsRadius: .0013,
            label: "EMIT",
            parents: [[711345507, "sc_iss"]],
            controllers: [{
                type: "fixed",
                orientation: s.Quaternion.Identity,
                position: new s.Vector3(.024,-.00225,.00325),
                coverage: [711345507, Number.POSITIVE_INFINITY]
            }],
            postCreateFunction: t => {
                t.addController(s.RotateByEntityOrientationController).setCoverage(new s.Interval(711345507,Number.POSITIVE_INFINITY))
            }
        },
        sc_iss_oco_3: {
            groups: ["instrument", "sc_iss"],
            occlusionRadius: 8e-4,
            extentsRadius: .0012,
            label: "OCO-3",
            parents: [[610718469, "sc_iss"]],
            controllers: [{
                type: "fixed",
                orientation: s.Quaternion.Identity,
                position: new s.Vector3(.0156458,-.00195982,.0200232),
                coverage: [610718469, Number.POSITIVE_INFINITY]
            }],
            postCreateFunction: t => {
                t.addController(s.RotateByEntityOrientationController).setCoverage(new s.Interval(610718469,Number.POSITIVE_INFINITY))
            }
        },
        sc_iss_rapidscat: {
            groups: ["instrument", "sc_iss"],
            occlusionRadius: 8e-4,
            extentsRadius: 2e-4,
            label: "RapidScat",
            parents: [[465418867.184, "sc_iss"], [575406069.184, ""]],
            controllers: [{
                type: "fixed",
                orientation: s.Quaternion.Identity,
                position: new s.Vector3(-.0100725,-.00133401,.0162145),
                coverage: [465418867.184, 575406069.184]
            }],
            postCreateFunction: t => {
                t.addController(s.RotateByEntityOrientationController).setCoverage(new s.Interval(465418867.184,575406069.184))
            }
        },
        sc_ixpe: {
            groups: ["earth", "spacecraft", "telescope"],
            occlusionRadius: .0055,
            extentsRadius: .0026,
            label: "IXPE",
            parents: [[692324766.6007013, "earth"]],
            trail: {
                length: 5400
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_ixpe/ixpe.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_ixpe"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        sc_jason_1: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: .0014,
            extentsRadius: .004,
            label: "Jason-1",
            parents: [[352800006.1854904, "earth"], [458074266.1839004, ""]],
            trail: {
                length: 6744.5
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_ostm/ostm.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "animdata",
                url: "sc_jason_1",
                dataType: "pos"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.YAxisNeg
                },
                secondary: {
                    type: "velocity",
                    target: "sc_jason_1",
                    axis: s.Vector3.ZAxisNeg
                }
            }]
        },
        sc_jason_2: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: .0014,
            extentsRadius: .004,
            label: "OSTM/Jason-2",
            parents: [[344589947.18311954, "earth"], [623851269.182, ""]],
            trail: {
                length: 6744.25
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_ostm/ostm.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_jason_2"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.YAxisNeg
                },
                secondary: {
                    type: "velocity",
                    target: "sc_jason_2",
                    axis: s.Vector3.ZAxisNeg
                }
            }]
        },
        sc_jason_3: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: .0014,
            extentsRadius: .004,
            label: "Jason-3",
            parents: [[506497796.18443054, "earth"]],
            trail: {
                length: 6721
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_ostm/ostm.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_jason_3"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.YAxisNeg
                },
                secondary: {
                    type: "velocity",
                    target: "sc_jason_3",
                    axis: s.Vector3.ZAxisNeg
                }
            }]
        },
        sc_jwst: {
            groups: ["earth", "spacecraft", "telescope"],
            radius: .01,
            label: "James Webb Space Telescope",
            parents: [[693708549.184, "earth"]],
            trail: {
                length: 31536e3
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_jwst/webb_deployed.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_jwst/earth/orb"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.YAxisNeg
                },
                secondary: {
                    type: "align",
                    target: "sun",
                    axis: s.Vector3.ZAxis,
                    targetAxis: s.Vector3.ZAxis
                }
            }, {
                type: "coverage",
                coverage: [Number.NEGATIVE_INFINITY, 694937889.184],
                enter: t => {
                    const e = t.getComponent(s.ModelComponent);
                    e && e.setUrl("$STATIC_ASSETS_URL/models/sc_jwst/webb_stowed.gltf")
                }
                ,
                exit: t => {
                    const e = t.getComponent(s.ModelComponent);
                    e && e.setUrl("$STATIC_ASSETS_URL/models/sc_jwst/webb_deployed.gltf")
                }
            }]
        },
        sc_landsat_1: {
            groups: ["earth", "spacecraft"],
            radius: .004,
            label: "Landsat 1",
            parents: [[-865949142, "earth"], [-693791978, ""]],
            trail: {
                length: 7022
            },
            controllers: [{
                type: "dynamo",
                url: "sc_landsat_1"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        sc_landsat_2: {
            groups: ["earth", "spacecraft"],
            radius: .004,
            label: "Landsat 2",
            parents: [[-787078921, "earth"], [-563241570, ""]],
            trail: {
                length: 6190
            },
            controllers: [{
                type: "dynamo",
                url: "sc_landsat_2"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        sc_landsat_3: {
            groups: ["earth", "spacecraft"],
            radius: .004,
            label: "Landsat 3",
            parents: [[-688755821, "earth"], [-514943957, ""]],
            trail: {
                length: 6189
            },
            controllers: [{
                type: "dynamo",
                url: "sc_landsat_3"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        sc_landsat_4: {
            groups: ["earth", "spacecraft"],
            radius: .004,
            label: "Landsat 4",
            parents: [[-551033969, "earth"], [45918681, ""]],
            trail: {
                length: 5928
            },
            controllers: [{
                type: "dynamo",
                url: "sc_landsat_4"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        sc_landsat_5: {
            groups: ["earth", "spacecraft"],
            radius: .004,
            label: "Landsat 5",
            parents: [[-499706458, "earth"], [423705617, ""]],
            trail: {
                length: 5923
            },
            controllers: [{
                type: "dynamo",
                url: "sc_landsat_5"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        sc_landsat_7: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: .004,
            extentsRadius: .012,
            label: "Landsat 7",
            parents: [[-22517306, "earth"]],
            trail: {
                length: 5929
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_landsat_7/LandSat7.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_landsat_7"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.YAxis
                },
                secondary: {
                    type: "velocity",
                    target: "sc_landsat_7",
                    axis: s.Vector3.ZAxisNeg
                }
            }]
        },
        sc_landsat_8: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: .004,
            extentsRadius: .0095,
            label: "Landsat 8",
            parents: [[413881382, "earth"]],
            trail: {
                length: 5928
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_landsat_8/LandSat8.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_landsat_8"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.ZAxisNeg
                },
                secondary: {
                    type: "velocity",
                    target: "sc_landsat_8",
                    axis: s.Vector3.YAxis
                }
            }]
        },
        sc_landsat_9: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: .004,
            extentsRadius: .015,
            label: "Landsat 9",
            parents: [[686043940, "earth"]],
            trail: {
                length: 5940
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_landsat_9/Landsat9.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_landsat_9"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.YAxis
                },
                secondary: {
                    type: "velocity",
                    target: "sc_landsat_9",
                    axis: s.Vector3.XAxis
                }
            }]
        },
        sc_list: {
            groups: ["earth", "spacecraft"],
            radius: .004,
            label: "LIST",
            parents: [[347025366.1839032, "earth"]],
            trail: {
                length: 5933.33
            },
            controllers: [{
                type: "dynamo",
                url: "sc_list"
            }]
        },
        sc_m_cubed: {
            groups: ["earth", "spacecraft"],
            radius: 1e-4,
            label: "M-Cubed",
            parents: [[373032066.182, "earth"]],
            trail: {
                length: 5768.333333333333
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_m_cubed/mCubed.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_m_cubed"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.YAxisNeg
                },
                secondary: {
                    type: "velocity",
                    target: "sc_m_cubed",
                    axis: s.Vector3.XAxisNeg
                }
            }]
        },
        sc_mcubed_2: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: 1e-4,
            extentsRadius: 2e-4,
            label: "MCubed-2",
            parents: [[439589738, "earth"]],
            trail: {
                length: 5861
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_mcubed_2/M-Cubed2.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_mcubed_2"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.XAxisNeg
                },
                secondary: {
                    type: "velocity",
                    target: "sc_mcubed_2",
                    axis: s.Vector3.ZAxis
                }
            }]
        },
        sc_mms_1: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: .0017,
            extentsRadius: .013,
            label: "MMS 1",
            parents: [[479519767.1855569, "earth"]],
            trail: {
                length: 85994
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_mms/MMS.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_mms_1"
            }, {
                type: "spin",
                axis: s.Vector3.YAxisNeg,
                periodInHours: .00556
            }]
        },
        sc_mms_2: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: .0017,
            extentsRadius: .013,
            label: "MMS 2",
            parents: [[479519767.1855569, "earth"]],
            trail: {
                length: 85962
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_mms/MMS.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_mms_2"
            }, {
                type: "spin",
                axis: s.Vector3.YAxisNeg,
                periodInHours: .00556
            }]
        },
        sc_mms_3: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: .0017,
            extentsRadius: .013,
            label: "MMS 3",
            parents: [[479519767.1855569, "earth"]],
            trail: {
                length: 86347
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_mms/MMS.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_mms_3"
            }, {
                type: "spin",
                axis: s.Vector3.YAxisNeg,
                periodInHours: .00556
            }]
        },
        sc_mms_4: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: .0017,
            extentsRadius: .013,
            label: "MMS 4",
            parents: [[479519767.1855569, "earth"]],
            trail: {
                length: 86024
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_mms/MMS.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_mms_4"
            }, {
                type: "spin",
                axis: s.Vector3.YAxisNeg,
                periodInHours: .00556
            }]
        },
        sc_neo_surveyor: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: .004,
            extentsRadius: .006,
            label: "NEO Surveyor",
            parents: [[874108800, "earth"]],
            trail: {
                length: 31536e3
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_neo_surveyor/neosurveyor.gltf",
                translate: new s.Vector3(0,0,-5e-4),
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_neo_surveyor/earth"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }, {
                type: "dynamo",
                url: "sc_neo_surveyor/ori"
            }]
        },
        sc_nisar: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: .006,
            extentsRadius: .017,
            label: "NISAR",
            parents: [[757339269, "earth"]],
            trail: {
                length: 5573
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_nisar/Nisar.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_nisar"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.YAxisNeg
                },
                secondary: {
                    type: "velocity",
                    target: "sc_nisar",
                    axis: s.Vector3.ZAxis
                }
            }]
        },
        sc_noaa_14: {
            groups: ["earth", "spacecraft"],
            radius: .004,
            label: "NOAA 14",
            parents: [[-157942275, "earth"], [233225989, ""]],
            trail: {
                length: 5933
            },
            controllers: [{
                type: "dynamo",
                url: "sc_noaa_14"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        sc_noaa_15: {
            groups: ["earth", "spacecraft"],
            radius: .004,
            label: "NOAA 15",
            parents: [[-51652265, "earth"]],
            trail: {
                length: 5933
            },
            controllers: [{
                type: "dynamo",
                url: "sc_noaa_15"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        sc_noaa_16: {
            groups: ["earth", "spacecraft"],
            radius: .004,
            label: "NOAA 16",
            parents: [[22819972, "earth"], [455587267, ""]],
            trail: {
                length: 5933
            },
            controllers: [{
                type: "dynamo",
                url: "sc_noaa_16"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        sc_noaa_17: {
            groups: ["earth", "spacecraft"],
            radius: .004,
            label: "NOAA 17",
            parents: [[78218948, "earth"], [418867267, ""]],
            trail: {
                length: 5933
            },
            controllers: [{
                type: "dynamo",
                url: "sc_noaa_17"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        sc_noaa_18: {
            groups: ["earth", "spacecraft"],
            radius: .004,
            label: "NOAA 18",
            parents: [[169866395, "earth"]],
            trail: {
                length: 5933
            },
            controllers: [{
                type: "dynamo",
                url: "sc_noaa_18"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        sc_noaa_19: {
            groups: ["earth", "spacecraft"],
            radius: .004,
            label: "NOAA 19",
            parents: [[287191476, "earth"]],
            trail: {
                length: 5933
            },
            controllers: [{
                type: "dynamo",
                url: "sc_noaa_19"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        sc_noaa_20: {
            groups: ["earth", "spacecraft"],
            radius: .004,
            label: "NOAA 20",
            parents: [[564276620, "earth"]],
            trail: {
                length: 5933
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_noaa_20/noaa20.gltf",
                shadowEntities: ["earth"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_noaa_20"
            }, {
                type: "align",
                primary: {
                    type: "velocity",
                    target: "sc_noaa_20",
                    axis: s.Vector3.ZAxisNeg
                },
                secondary: {
                    type: "point",
                    axis: s.Vector3.YAxis,
                    target: "earth"
                }
            }, {
                type: "align",
                joint: "Part__Panel_011001",
                primary: {
                    type: "none",
                    axis: s.Vector3.XAxis
                },
                secondary: {
                    type: "point",
                    axis: s.Vector3.ZAxisNeg,
                    target: "sun"
                }
            }]
        },
        sc_noaa_21: {
            groups: ["earth", "spacecraft"],
            radius: .004,
            label: "NOAA 21",
            parents: [[721352468, "earth"]],
            trail: {
                length: 5933
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_noaa_21/noaa21.gltf",
                shadowEntities: ["earth"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_noaa_21"
            }, {
                type: "align",
                primary: {
                    type: "velocity",
                    target: "sc_noaa_21",
                    axis: s.Vector3.ZAxisNeg
                },
                secondary: {
                    type: "point",
                    axis: s.Vector3.YAxis,
                    target: "earth"
                }
            }, {
                type: "align",
                joint: "Panels_Lo_Res002_Cylinder001",
                primary: {
                    type: "none",
                    axis: s.Vector3.XAxis
                },
                secondary: {
                    type: "point",
                    axis: s.Vector3.YAxis,
                    target: "sun"
                }
            }]
        },
        sc_nustar: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: .006,
            extentsRadius: .006,
            label: "NuSTAR",
            parents: [[392875303.185, "earth"]],
            trail: {
                length: 5798.66
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_nustar/nustar.gltf",
                shadowEntities: ["earth"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_nustar"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.ZAxisNeg
                },
                secondary: {
                    type: "align",
                    axis: s.Vector3.XAxis,
                    target: "sun",
                    targetAxis: s.Vector3.ZAxis
                }
            }]
        },
        sc_oco_2: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: .0021,
            extentsRadius: .004,
            label: "OCO-2",
            parents: [[457567050.184, "earth"]],
            trail: {
                length: 5933.333333333333
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_oco_2/oco2.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_oco_2"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.ZAxisNeg
                },
                secondary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.YAxis
                }
            }]
        },
        sc_pace: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: .002,
            extentsRadius: .004,
            label: "PACE",
            parents: [[Number.NEGATIVE_INFINITY, "earth"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_pace/pace.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_pace"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.YAxisNeg
                },
                secondary: {
                    type: "velocity",
                    target: "sc_pace",
                    axis: s.Vector3.XAxisNeg
                }
            }]
        },
        sc_path: {
            groups: ["earth", "spacecraft"],
            radius: .004,
            label: "PATH",
            parents: [[347025366.1839032, "earth"]],
            trail: {
                length: 5933
            },
            controllers: [{
                type: "dynamo",
                url: "sc_path"
            }]
        },
        sc_polar: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: .0012,
            extentsRadius: .005,
            label: "Polar",
            parents: [[-121608237.81469652, "earth"], [262612565.1855274, ""]],
            trail: {
                length: 66571
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_polar/polar.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "animdata",
                url: "sc_polar",
                dataType: "pos"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.YAxisNeg
                },
                secondary: {
                    type: "velocity",
                    target: "sc_polar",
                    axis: s.Vector3.ZAxis
                }
            }]
        },
        sc_prefire_1: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: 127431e-9,
            extentsRadius: 49617e-8,
            label: "PREFIRE-1",
            parents: [[Number.NEGATIVE_INFINITY, "earth"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_prefire/prefire.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_prefire_1"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.YAxisNeg
                },
                secondary: {
                    type: "velocity",
                    target: "sc_prefire_1",
                    axis: s.Vector3.XAxis
                }
            }]
        },
        sc_prefire_2: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: 127431e-9,
            extentsRadius: 49617e-8,
            label: "PREFIRE-2",
            parents: [[Number.NEGATIVE_INFINITY, "earth"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_prefire/prefire.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_prefire_2"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.YAxisNeg
                },
                secondary: {
                    type: "velocity",
                    target: "sc_prefire_2",
                    axis: s.Vector3.XAxis
                }
            }]
        },
        sc_quikscat: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: .0016,
            extentsRadius: .0018,
            label: "QuikSCAT",
            parents: [[344589947.18311954, "earth"], [591710469.182, ""]],
            trail: {
                length: 6061.33
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_quikscat/QuikSCAT.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_quikscat"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.ZAxis
                },
                secondary: {
                    type: "velocity",
                    target: "sc_quikscat",
                    axis: s.Vector3.XAxisNeg
                }
            }]
        },
        sc_race: {
            groups: ["earth", "spacecraft"],
            radius: 15e-5,
            label: "RACE",
            parents: [[467726467.182, "earth"], [467812867.182, ""]],
            trail: {
                length: 5933
            },
            controllers: [{
                type: "dynamo",
                url: "sc_race"
            }]
        },
        sc_raincube: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: 35e-5,
            extentsRadius: 5e-4,
            label: "RainCube",
            parents: [[608189026.1856545, "earth"], [662040069.184, ""]],
            trail: {
                length: 5743
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_raincube/Raincube.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_raincube"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.YAxisNeg
                },
                secondary: {
                    type: "velocity",
                    target: "sc_raincube",
                    axis: s.Vector3.XAxis
                }
            }]
        },
        sc_rax_2: {
            groups: ["earth", "spacecraft"],
            radius: 2e-4,
            label: "RAX-2",
            parents: [[373067348.182, "earth"], [418824067.186, ""]],
            trail: {
                length: 5743
            },
            controllers: [{
                type: "dynamo",
                url: "sc_rax_2"
            }]
        },
        sc_rbsp_a: {
            groups: ["earth", "spacecraft"],
            radius: .004,
            label: "Van Allen Probe A",
            parents: [[399585967.183, "earth"], [624628869.182, ""]],
            trail: {
                length: 32214
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_rbsp/rbsp.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_rbsp_a"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.YAxisNeg
                },
                secondary: {
                    type: "velocity",
                    target: "sc_rbsp_a",
                    axis: s.Vector3.XAxis
                }
            }]
        },
        sc_rbsp_b: {
            groups: ["earth", "spacecraft"],
            radius: .004,
            label: "Van Allen Probe B",
            parents: [[399585967.183, "earth"], [616766469.184, ""]],
            trail: {
                length: 32574
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_rbsp/rbsp.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_rbsp_b"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.YAxisNeg
                },
                secondary: {
                    type: "velocity",
                    target: "sc_rbsp_b",
                    axis: s.Vector3.XAxis
                }
            }]
        },
        sc_sac_d: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: .003,
            extentsRadius: .0045,
            label: "Aquarius",
            parents: [[360987666.185, "earth"], [486907267.185, ""]],
            trail: {
                length: 5884.25
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_sac_d/aquarius.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_sac_d"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.XAxis
                },
                secondary: {
                    type: "velocity",
                    target: "sc_sac_d",
                    axis: s.Vector3.YAxis
                }
            }]
        },
        sc_sclp: {
            groups: ["earth", "spacecraft"],
            radius: .004,
            label: "SCLP",
            parents: [[347025366.1839032, "earth"]],
            trail: {
                length: 5933
            },
            controllers: [{
                type: "dynamo",
                url: "sc_sclp"
            }]
        },
        sc_sdo: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: .0022,
            extentsRadius: .00315,
            label: "SDO",
            parents: [[505918808.18474686, "earth"]],
            trail: {
                length: 86137.66
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_sdo/sdo.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_sdo"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.YAxisNeg
                },
                secondary: {
                    type: "velocity",
                    target: "sc_sdo",
                    axis: s.Vector3.XAxis
                }
            }]
        },
        sc_sentinel_6: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: .0026,
            extentsRadius: .0031,
            label: "Sentinel-6 Michael Freilich",
            parents: [[659322339.7879795, "earth"]],
            trail: {
                length: 5933.5
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_sentinel_6/Sentinel6.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_sentinel_6"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.YAxisNeg
                },
                secondary: {
                    type: "velocity",
                    target: "sc_sentinel_6",
                    axis: s.Vector3.XAxis
                }
            }]
        },
        sc_sentinel_6b: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: .0026,
            extentsRadius: .0031,
            label: "Sentinel-6B",
            parents: [[Number.NEGATIVE_INFINITY, "earth"]],
            trail: {
                length: 5933.5
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_sentinel_6/Sentinel6.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_sentinel_6b"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.YAxisNeg
                },
                secondary: {
                    type: "velocity",
                    target: "sc_sentinel_6b",
                    axis: s.Vector3.XAxis
                }
            }]
        },
        sc_smap: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: .003,
            extentsRadius: .009,
            label: "SMAP",
            parents: [[476542806.1849232, "earth"]],
            trail: {
                length: 5906.8
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_smap/SMAP.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_smap"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.YAxisNeg
                },
                secondary: {
                    type: "velocity",
                    target: "sc_smap",
                    axis: s.Vector3.XAxis
                }
            }],
            postCreateFunction: t => {
                const e = t.addController(s.SpinController);
                e.setJoint("arm_etc"),
                e.setRate(s.MathUtils.degToRad(87.6)),
                e.setAxis(s.Vector3.YAxis, !0),
                e.setClampedToRealTime(!0)
            }
        },
        sc_soho: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: .00215,
            extentsRadius: .00425,
            label: "SOHO",
            parents: [[-128831107, "earth"]],
            trail: {
                length: 31536e3
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_soho/soho.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_soho"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.YAxisNeg
                },
                secondary: {
                    type: "velocity",
                    target: "sc_soho",
                    axis: s.Vector3.XAxis
                }
            }]
        },
        sc_sorce: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: .001,
            extentsRadius: .0022,
            label: "SORCE",
            parents: [[344589947.18311954, "earth"], [635860869.185, ""]],
            trail: {
                length: 5812.5
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_sorce/sorce.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_sorce"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.YAxisNeg
                },
                secondary: {
                    type: "velocity",
                    target: "sc_sorce",
                    axis: s.Vector3.XAxisNeg
                }
            }]
        },
        sc_spherex: {
            groups: ["earth", "spacecraft", "telescope"],
            radius: .002,
            label: "SPHEREx",
            parents: [[795026933, "earth"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_spherex/spherex.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_spherex"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.YAxisNeg
                },
                secondary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.XAxis
                }
            }]
        },
        sc_starling_1: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: 23e-5,
            extentsRadius: 76e-5,
            label: "Starling-1",
            parents: [[Number.NEGATIVE_INFINITY, "earth"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_starling/starling.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_starling_1"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.YAxisNeg
                },
                secondary: {
                    type: "velocity",
                    target: "sc_starling_1",
                    axis: s.Vector3.XAxis
                }
            }]
        },
        sc_starling_2: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: 23e-5,
            extentsRadius: 76e-5,
            label: "Starling-2",
            parents: [[Number.NEGATIVE_INFINITY, "earth"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_starling/starling.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_starling_2"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.YAxisNeg
                },
                secondary: {
                    type: "velocity",
                    target: "sc_starling_2",
                    axis: s.Vector3.XAxis
                }
            }]
        },
        sc_starling_3: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: 23e-5,
            extentsRadius: 76e-5,
            label: "Starling-3",
            parents: [[Number.NEGATIVE_INFINITY, "earth"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_starling/starling.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_starling_3"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.YAxisNeg
                },
                secondary: {
                    type: "velocity",
                    target: "sc_starling_3",
                    axis: s.Vector3.XAxis
                }
            }]
        },
        sc_starling_4: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: 23e-5,
            extentsRadius: 76e-5,
            label: "Starling-4",
            parents: [[Number.NEGATIVE_INFINITY, "earth"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_starling/starling.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_starling_4"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.YAxisNeg
                },
                secondary: {
                    type: "velocity",
                    target: "sc_starling_4",
                    axis: s.Vector3.XAxis
                }
            }]
        },
        sc_sunrise_faye: {
            groups: ["earth", "spacecraft"],
            radius: 5e-4,
            label: "SunRISE Faye",
            parents: [[Number.NEGATIVE_INFINITY, "earth"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_sunrise/sunrise.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_sunrise_faye"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.YAxis
                },
                secondary: {
                    type: "align",
                    target: "sun",
                    targetAxis: s.Vector3.ZAxis,
                    axis: s.Vector3.ZAxis
                }
            }]
        },
        sc_sunrise_jet: {
            groups: ["earth", "spacecraft"],
            radius: 5e-4,
            label: "SunRISE Jet",
            parents: [[Number.NEGATIVE_INFINITY, "earth"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_sunrise/sunrise.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_sunrise_jet"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.YAxis
                },
                secondary: {
                    type: "align",
                    target: "sun",
                    targetAxis: s.Vector3.ZAxis,
                    axis: s.Vector3.ZAxis
                }
            }]
        },
        sc_sunrise_ein: {
            groups: ["earth", "spacecraft"],
            radius: 5e-4,
            label: "SunRISE Ein",
            parents: [[Number.NEGATIVE_INFINITY, "earth"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_sunrise/sunrise.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_sunrise_ein"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.YAxis
                },
                secondary: {
                    type: "align",
                    target: "sun",
                    targetAxis: s.Vector3.ZAxis,
                    axis: s.Vector3.ZAxis
                }
            }]
        },
        sc_sunrise_edward: {
            groups: ["earth", "spacecraft"],
            radius: 5e-4,
            label: "SunRISE Edward",
            parents: [[Number.NEGATIVE_INFINITY, "earth"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_sunrise/sunrise.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_sunrise_edward"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.YAxis
                },
                secondary: {
                    type: "align",
                    target: "sun",
                    targetAxis: s.Vector3.ZAxis,
                    axis: s.Vector3.ZAxis
                }
            }]
        },
        sc_sunrise_spike: {
            groups: ["earth", "spacecraft"],
            radius: 5e-4,
            label: "SunRISE Spike",
            parents: [[Number.NEGATIVE_INFINITY, "earth"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_sunrise/sunrise.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_sunrise_spike"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.YAxis
                },
                secondary: {
                    type: "align",
                    target: "sun",
                    targetAxis: s.Vector3.ZAxis,
                    axis: s.Vector3.ZAxis
                }
            }]
        },
        sc_sunrise_bebop: {
            groups: ["earth", "spacecraft"],
            radius: 5e-4,
            label: "SunRISE Bebop",
            parents: [[Number.NEGATIVE_INFINITY, "earth"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_sunrise/sunrise.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_sunrise_bebop"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.YAxis
                },
                secondary: {
                    type: "align",
                    target: "sun",
                    targetAxis: s.Vector3.ZAxis,
                    axis: s.Vector3.ZAxis
                }
            }]
        },
        sc_suomi_npp: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: .0022,
            extentsRadius: .008,
            label: "Suomi NPP",
            parents: [[373076770, "earth"]],
            trail: {
                length: 5798.66
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_npp/NPP.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_suomi_npp"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.XAxisNeg
                },
                secondary: {
                    type: "velocity",
                    target: "sc_suomi_npp",
                    axis: s.Vector3.YAxis
                }
            }]
        },
        sc_swift: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: .0028,
            extentsRadius: .0028,
            label: "Swift",
            parents: [[344589947.18311954, "earth"]],
            trail: {
                length: 5933
            },
            controllers: [{
                type: "dynamo",
                url: "sc_swift"
            }]
        },
        sc_swot: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: .005,
            extentsRadius: .009,
            label: "SWOT",
            parents: [[347025366.1839032, "earth"]],
            trail: {
                length: 5933
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_swot_v2/swot.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_swot"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.YAxisNeg
                },
                secondary: {
                    type: "velocity",
                    target: "sc_swot",
                    axis: s.Vector3.ZAxisNeg
                }
            }]
        },
        sc_tdrs_3: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: .0085,
            extentsRadius: .0085,
            label: "TDRS 3",
            parents: [[344589947.18311954, "earth"]],
            trail: {
                length: 86137.33
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_tdrs/tdrs.gltf"
            },
            controllers: [{
                type: "dynamo",
                url: "sc_tdrs_3"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.YAxis
                },
                secondary: {
                    type: "align",
                    axis: s.Vector3.ZAxis,
                    target: "earth",
                    targetAxis: s.Vector3.ZAxis
                }
            }]
        },
        sc_tdrs_5: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: .0085,
            extentsRadius: .0085,
            label: "TDRS 5",
            parents: [[344589947.18311954, "earth"]],
            trail: {
                length: 86137.66
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_tdrs/tdrs.gltf"
            },
            controllers: [{
                type: "dynamo",
                url: "sc_tdrs_5"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.YAxis
                },
                secondary: {
                    type: "align",
                    axis: s.Vector3.ZAxis,
                    target: "earth",
                    targetAxis: s.Vector3.ZAxis
                }
            }]
        },
        sc_tdrs_6: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: .0085,
            extentsRadius: .0085,
            label: "TDRS 6",
            parents: [[344589947.18311954, "earth"]],
            trail: {
                length: 86137.66
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_tdrs/tdrs.gltf"
            },
            controllers: [{
                type: "dynamo",
                url: "sc_tdrs_6"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.YAxis
                },
                secondary: {
                    type: "align",
                    axis: s.Vector3.ZAxis,
                    target: "earth",
                    targetAxis: s.Vector3.ZAxis
                }
            }]
        },
        sc_tdrs_7: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: .0085,
            extentsRadius: .0085,
            label: "TDRS 7",
            parents: [[344589947.18311954, "earth"]],
            trail: {
                length: 86151
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_tdrs/tdrs.gltf"
            },
            controllers: [{
                type: "dynamo",
                url: "sc_tdrs_7"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.YAxis
                },
                secondary: {
                    type: "align",
                    axis: s.Vector3.ZAxis,
                    target: "earth",
                    targetAxis: s.Vector3.ZAxis
                }
            }]
        },
        sc_tdrs_8: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: .0085,
            extentsRadius: .0085,
            label: "TDRS 8",
            parents: [[344589947.18311954, "earth"]],
            trail: {
                length: 86151.2
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_tdrs/tdrs.gltf"
            },
            controllers: [{
                type: "dynamo",
                url: "sc_tdrs_8"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.YAxis
                },
                secondary: {
                    type: "align",
                    axis: s.Vector3.ZAxis,
                    target: "earth",
                    targetAxis: s.Vector3.ZAxis
                }
            }]
        },
        sc_tdrs_9: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: .0085,
            extentsRadius: .0085,
            label: "TDRS 9",
            parents: [[344589947.18311954, "earth"]],
            trail: {
                length: 86151
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_tdrs/tdrs.gltf"
            },
            controllers: [{
                type: "dynamo",
                url: "sc_tdrs_9"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.YAxis
                },
                secondary: {
                    type: "align",
                    axis: s.Vector3.ZAxis,
                    target: "earth",
                    targetAxis: s.Vector3.ZAxis
                }
            }]
        },
        sc_tdrs_10: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: .0085,
            extentsRadius: .0085,
            label: "TDRS 10",
            parents: [[344589947.18311954, "earth"]],
            trail: {
                length: 86151.2
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_tdrs/tdrs.gltf"
            },
            controllers: [{
                type: "dynamo",
                url: "sc_tdrs_10"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.YAxis
                },
                secondary: {
                    type: "align",
                    axis: s.Vector3.ZAxis,
                    target: "earth",
                    targetAxis: s.Vector3.ZAxis
                }
            }]
        },
        sc_tdrs_11: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: .0085,
            extentsRadius: .0085,
            label: "TDRS 11",
            parents: [[412868947.185, "earth"]],
            trail: {
                length: 86151
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_tdrs/tdrs.gltf"
            },
            controllers: [{
                type: "dynamo",
                url: "sc_tdrs_11"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.YAxis
                },
                secondary: {
                    type: "align",
                    axis: s.Vector3.ZAxis,
                    target: "earth",
                    targetAxis: s.Vector3.ZAxis
                }
            }]
        },
        sc_tdrs_12: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: .0085,
            extentsRadius: .0085,
            label: "TDRS 12",
            parents: [[443808067.185, "earth"]],
            trail: {
                length: 86151
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_tdrs/tdrs.gltf"
            },
            controllers: [{
                type: "dynamo",
                url: "sc_tdrs_12"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.YAxis
                },
                secondary: {
                    type: "align",
                    axis: s.Vector3.ZAxis,
                    target: "earth",
                    targetAxis: s.Vector3.ZAxis
                }
            }]
        },
        sc_tdrs_13: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: .0085,
            extentsRadius: .0085,
            label: "TDRS 13",
            parents: [[556338669.183, "earth"]],
            trail: {
                length: 86151
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_tdrs/tdrs.gltf"
            },
            controllers: [{
                type: "dynamo",
                url: "sc_tdrs_13"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.YAxis
                },
                secondary: {
                    type: "align",
                    axis: s.Vector3.ZAxis,
                    target: "earth",
                    targetAxis: s.Vector3.ZAxis
                }
            }]
        },
        sc_tempo: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: .003021525,
            extentsRadius: .00975015,
            label: "TEMPO",
            parents: [[Number.NEGATIVE_INFINITY, "earth"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_tempo/tempo.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_tempo"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.YAxis
                },
                secondary: {
                    type: "velocity",
                    target: "sc_tempo",
                    axis: s.Vector3.ZAxis
                }
            }]
        },
        sc_terra: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: .0034,
            extentsRadius: .012,
            label: "Terra",
            parents: [[344589947.18311954, "earth"]],
            trail: {
                length: 5933.33
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_terra/Terra.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_terra"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.YAxisNeg
                },
                secondary: {
                    type: "velocity",
                    target: "sc_terra",
                    axis: s.Vector3.XAxisNeg
                }
            }]
        },
        sc_tess: {
            groups: ["earth", "spacecraft", "telescope"],
            occlusionRadius: .002,
            extentsRadius: .003,
            label: "TESS",
            parents: [[577366932.3626, "earth"]],
            trail: {
                length: 591840
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_tess/TESS.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_tess/earth/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        sc_themis_a: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: 4e-4,
            extentsRadius: .0017,
            label: "THEMIS A",
            parents: [[344589947.18311954, "earth"]],
            trail: {
                length: 98428
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_themis/themis.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_themis_a"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.YAxis
                }
            }, {
                type: "spin",
                axis: s.Vector3.YAxis,
                periodInHours: 8333e-7
            }]
        },
        sc_themis_d: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: 4e-4,
            extentsRadius: .0017,
            label: "THEMIS D",
            parents: [[344589947.18311954, "earth"]],
            trail: {
                length: 114807
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_themis/themis.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_themis_d"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.YAxis
                }
            }, {
                type: "spin",
                axis: s.Vector3.YAxis,
                periodInHours: 8333e-7
            }]
        },
        sc_themis_e: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: 4e-4,
            extentsRadius: .0017,
            label: "THEMIS E",
            parents: [[344589947.18311954, "earth"]],
            trail: {
                length: 105907.5
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_themis/themis.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_themis_e"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.YAxis
                }
            }, {
                type: "spin",
                axis: s.Vector3.YAxis,
                periodInHours: 8333e-7
            }]
        },
        sc_timed: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: .0015,
            extentsRadius: .005,
            label: "TIMED",
            parents: [[344589947.18311954, "earth"]],
            trail: {
                length: 5933
            },
            controllers: [{
                type: "dynamo",
                url: "sc_timed"
            }]
        },
        sc_trmm: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: .00255,
            extentsRadius: .0073,
            label: "TRMM",
            parents: [[-66052736.817, "earth"], [482328067.186, ""]],
            trail: {
                length: 5545.6
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_trmm/TRMM.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "orbitalElements",
                eccentricity: .00111201719,
                semiMajorAxis: 6744.5,
                meanAngularMotion: .0011382582,
                meanAnomalyAtEpoch: 0,
                inclination: Math.PI / 180 * 30,
                longitudeOfAscendingNode: 0,
                argumentOfPeriapsis: 0,
                coverage: [-66052736.817, 482328067.186]
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.YAxisNeg
                },
                secondary: {
                    type: "velocity",
                    target: "sc_trmm",
                    axis: s.Vector3.XAxisNeg
                }
            }]
        },
        sc_tropics_01: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: 18e-5,
            extentsRadius: 24e-5,
            label: "TROPICS-01",
            parents: [[Number.NEGATIVE_INFINITY, "earth"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_tropics/tropics.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_tropics_01"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.YAxis
                },
                secondary: {
                    type: "velocity",
                    target: "sc_tropics_01",
                    axis: s.Vector3.ZAxis
                }
            }, {
                type: "align",
                joint: "solar_rotate",
                primary: {
                    type: "none",
                    axis: s.Vector3.YAxis
                },
                secondary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.XAxis
                }
            }],
            postCreateFunction: t => {
                const e = t.addController(s.SpinController);
                e.setJoint("microwave_radiometer"),
                e.setRate(Math.PI),
                e.setAxis(s.Vector3.ZAxis, !0),
                e.setClampedToRealTime(!0)
            }
        },
        sc_tropics_03: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: 18e-5,
            extentsRadius: 24e-5,
            label: "TROPICS-03",
            parents: [[Number.NEGATIVE_INFINITY, "earth"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_tropics/tropics.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_tropics_03"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.YAxis
                },
                secondary: {
                    type: "velocity",
                    target: "sc_tropics_03",
                    axis: s.Vector3.ZAxis
                }
            }, {
                type: "align",
                joint: "solar_rotate",
                primary: {
                    type: "none",
                    axis: s.Vector3.YAxis
                },
                secondary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.XAxis
                }
            }],
            postCreateFunction: t => {
                const e = t.addController(s.SpinController);
                e.setJoint("microwave_radiometer"),
                e.setRate(Math.PI),
                e.setAxis(s.Vector3.ZAxis, !0),
                e.setClampedToRealTime(!0)
            }
        },
        sc_tropics_05: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: 18e-5,
            extentsRadius: 24e-5,
            label: "TROPICS-05",
            parents: [[Number.NEGATIVE_INFINITY, "earth"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_tropics/tropics.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_tropics_05"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.YAxis
                },
                secondary: {
                    type: "velocity",
                    target: "sc_tropics_05",
                    axis: s.Vector3.ZAxis
                }
            }, {
                type: "align",
                joint: "solar_rotate",
                primary: {
                    type: "none",
                    axis: s.Vector3.YAxis
                },
                secondary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.XAxis
                }
            }],
            postCreateFunction: t => {
                const e = t.addController(s.SpinController);
                e.setJoint("microwave_radiometer"),
                e.setRate(Math.PI),
                e.setAxis(s.Vector3.ZAxis, !0),
                e.setClampedToRealTime(!0)
            }
        },
        sc_tropics_06: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: 18e-5,
            extentsRadius: 24e-5,
            label: "TROPICS-06",
            parents: [[Number.NEGATIVE_INFINITY, "earth"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_tropics/tropics.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_tropics_06"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.YAxis
                },
                secondary: {
                    type: "velocity",
                    target: "sc_tropics_06",
                    axis: s.Vector3.ZAxis
                }
            }, {
                type: "align",
                joint: "solar_rotate",
                primary: {
                    type: "none",
                    axis: s.Vector3.YAxis
                },
                secondary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.XAxis
                }
            }],
            postCreateFunction: t => {
                const e = t.addController(s.SpinController);
                e.setJoint("microwave_radiometer"),
                e.setRate(Math.PI),
                e.setAxis(s.Vector3.ZAxis, !0),
                e.setClampedToRealTime(!0)
            }
        },
        sc_tropics_07: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: 18e-5,
            extentsRadius: 24e-5,
            label: "TROPICS-07",
            parents: [[Number.NEGATIVE_INFINITY, "earth"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_tropics/tropics.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_tropics_07"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.YAxis
                },
                secondary: {
                    type: "velocity",
                    target: "sc_tropics_07",
                    axis: s.Vector3.ZAxis
                }
            }, {
                type: "align",
                joint: "solar_rotate",
                primary: {
                    type: "none",
                    axis: s.Vector3.YAxis
                },
                secondary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.XAxis
                }
            }],
            postCreateFunction: t => {
                const e = t.addController(s.SpinController);
                e.setJoint("microwave_radiometer"),
                e.setRate(Math.PI),
                e.setAxis(s.Vector3.ZAxis, !0),
                e.setClampedToRealTime(!0)
            }
        },
        sc_uars: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: .00535,
            extentsRadius: .00535,
            label: "UARS",
            parents: [[352800006.1854904, "earth"], [370106644.184, ""]],
            trail: {
                length: 5490
            },
            controllers: [{
                type: "animdata",
                url: "sc_uars",
                dataType: "pos"
            }]
        },
        sc_wind: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: .0012,
            extentsRadius: .0075,
            label: "WIND",
            parents: [[543931270, "earth"]],
            trail: {
                length: 16485927
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_wind/wind.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_wind/earth/orb"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.YAxisNeg
                },
                secondary: {
                    type: "velocity",
                    target: "sc_wind",
                    axis: s.Vector3.XAxisNeg
                }
            }]
        },
        sc_wise: {
            groups: ["earth", "spacecraft"],
            occlusionRadius: .00142,
            extentsRadius: .00142,
            label: "WISE",
            parents: [[314075404, "earth"], [776402558, ""]],
            trail: {
                length: 5715.4
            },
            controllers: [{
                type: "dynamo",
                url: "sc_wise"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        }
    })
}
, function(t, e, i) {
    "use strict";
    i.r(e);
    var s = i(5);
    i(545).Entity.register({
        sc_apollo_15: {
            groups: ["moon", "spacecraft"],
            radius: .004,
            label: "Apollo 15",
            parents: [[-897044358.3260887, "moon"], [-896822958.3195117, ""]],
            trail: {
                length: 6855
            },
            controllers: [{
                type: "animdata",
                url: "sc_apollo_15",
                dataType: "pos"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        sc_artemis_1: {
            groups: ["moon", "spacecraft"],
            radius: .005,
            label: "Artemis I",
            parents: [[721860361, "earth"], [724052473, ""]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_artemis_1/artemis_cmsm.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_artemis_1/earth/pos"
            }, {
                type: "align",
                primary: {
                    type: "velocity",
                    target: "sc_artemis_1",
                    axis: s.Vector3.YAxis
                },
                secondary: {
                    type: "align",
                    target: "moon",
                    axis: s.Vector3.ZAxis,
                    targetAxis: s.Vector3.ZAxis
                }
            }]
        },
        sc_capstone: {
            groups: ["moon", "spacecraft"],
            radius: 5e-4,
            label: "CAPSTONE",
            parents: [[710191748, "earth"], [721583059, "moon"]],
            trail: {
                length: void 0,
                lengthCoverages: [[4e6, Number.NEGATIVE_INFINITY, 721583059], [1210909, 721583059, Number.POSITIVE_INFINITY]]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_capstone/capstone.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_capstone/earth/orb"
            }, {
                type: "dynamo",
                url: "sc_capstone/moon/orb"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.ZAxisNeg
                },
                secondary: {
                    type: "align",
                    target: "moon",
                    axis: s.Vector3.XAxis,
                    targetAxis: s.Vector3.ZAxis
                }
            }]
        },
        sc_clementine: {
            groups: ["moon", "spacecraft"],
            radius: .002,
            label: "Clementine",
            parents: [[-187185539.81536362, "moon"], [-178496939.81459716, ""]],
            trail: {
                length: 5408.5
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_clementine/clementine.gltf",
                shadowEntities: ["moon"]
            },
            controllers: [{
                type: "animdata",
                url: "sc_clementine/moon/all",
                dataType: "pos"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.YAxisNeg
                },
                secondary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.ZAxisNeg
                }
            }]
        },
        sc_grail_a: {
            groups: ["moon", "spacecraft"],
            radius: .001,
            label: "Ebb",
            parents: [[368763e3, "moon"], [414201667.18513304, ""]],
            trail: {
                length: 41115.75
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_grail/grail_b.gltf",
                shadowEntities: ["moon"]
            },
            controllers: [{
                type: "animdata",
                url: "sc_grail_a/moon/all",
                dataType: "pos"
            }, {
                type: "align",
                primary: {
                    type: "velocity",
                    target: "sc_grail_a",
                    axis: s.Vector3.XAxisNeg
                },
                secondary: {
                    type: "point",
                    target: "moon",
                    axis: s.Vector3.ZAxis
                }
            }]
        },
        sc_grail_b: {
            groups: ["moon", "spacecraft"],
            radius: .001,
            label: "Flow",
            parents: [[368763e3, "moon"], [414201667.18513304, ""]],
            trail: {
                length: 41239.8
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_grail/grail_b.gltf",
                shadowEntities: ["moon"]
            },
            controllers: [{
                type: "animdata",
                url: "sc_grail_b/moon/all",
                dataType: "pos"
            }, {
                type: "align",
                primary: {
                    type: "velocity",
                    target: "sc_grail_b",
                    axis: s.Vector3.XAxisNeg
                },
                secondary: {
                    type: "point",
                    target: "moon",
                    axis: s.Vector3.ZAxis
                }
            }]
        },
        sc_ladee: {
            groups: ["moon", "spacecraft"],
            radius: .0012,
            label: "LADEE",
            parents: [[431798467.18253195, "moon"], [451355187.44558257, ""]],
            trail: {
                length: 7889.57
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_ladee/ladee.gltf",
                shadowEntities: ["moon"]
            },
            controllers: [{
                type: "animdata",
                url: "sc_ladee/moon/all",
                dataType: "pos"
            }, {
                type: "align",
                primary: {
                    type: "velocity",
                    target: "sc_ladee",
                    axis: s.Vector3.XAxisNeg
                },
                secondary: {
                    type: "point",
                    target: "moon",
                    axis: s.Vector3.ZAxis
                }
            }]
        },
        sc_lcross: {
            groups: ["moon", "spacecraft"],
            occlusionRadius: .0013,
            extentsRadius: .0022,
            label: "LCROSS",
            parents: [[298635466.0304444, "moon"], [308360200.75, ""]],
            trail: {
                length: 3598022
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_lcross/lcross.gltf",
                rotate: [{
                    z: -90
                }],
                shadowEntities: ["moon"]
            },
            controllers: [{
                type: "animdata",
                url: "sc_lcross/moon/all",
                dataType: "pos",
                coverage: [Number.NEGATIVE_INFINITY, 308360200.75]
            }, {
                type: "align",
                primary: {
                    type: "velocity",
                    target: "sc_lcross",
                    axis: s.Vector3.XAxisNeg
                },
                secondary: {
                    type: "point",
                    target: "moon",
                    axis: s.Vector3.ZAxis
                }
            }]
        },
        sc_lcross_impact_site: {
            groups: ["moon", "sc_lcross", "sites"],
            radius: .001,
            systemRadius: 200,
            label: "LCROSS Impact Site",
            parents: [[298635466.0304444, "moon"]],
            controllers: [{
                type: "fixed",
                llaOnSpheroid: new s.LatLonAlt(-1.4782008103461848,-.8648271467797672,0),
                coverage: [298635466.0304444, Number.POSITIVE_INFINITY]
            }]
        },
        sc_lunar_flashlight: {
            groups: ["moon", "spacecraft"],
            occlusionRadius: 25e-5,
            extentsRadius: 5e-4,
            label: "Lunar Flashlight",
            parents: [[724019554, "earth"], [737164869, ""]],
            trail: {
                length: 1e7
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_lunar_flashlight/lunar_flashlight.gltf",
                shadowEntities: ["earth"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_lunar_flashlight/earth_v3"
            }, {
                type: "align",
                primary: {
                    type: "align",
                    target: "moon",
                    axis: s.Vector3.ZAxisNeg,
                    targetAxis: s.Vector3.ZAxis
                },
                secondary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.YAxis
                }
            }]
        },
        sc_lunar_icecube: {
            groups: ["moon", "spacecraft"],
            occlusionRadius: 2e-4,
            extentsRadius: .0012,
            label: "Lunar IceCube",
            parents: [[721864426, "earth"], [734111601, "moon"]],
            trail: {
                length: void 0,
                lengthCoverages: [[3e6, Number.NEGATIVE_INFINITY, 734111601], [441920, 734111601, Number.POSITIVE_INFINITY]]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_lunar_icecube/lunar_icecube.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_lunar_icecube/earth/pos"
            }, {
                type: "dynamo",
                url: "sc_lunar_icecube/moon/orb"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.YAxis
                },
                secondary: {
                    type: "align",
                    target: "sun",
                    axis: s.Vector3.ZAxis,
                    targetAxis: s.Vector3.ZAxis
                }
            }]
        },
        sc_lunar_prospector: {
            groups: ["moon", "spacecraft"],
            occlusionRadius: 653e-6,
            extentsRadius: .0022,
            label: "Lunar Prospector",
            parents: [[-62206800, "moon"], [-13402020, ""]],
            trail: {
                length: 7260
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_lunar_prospector/lunar_prospector.gltf",
                shadowEntities: ["moon"]
            },
            controllers: [{
                type: "animdata",
                url: "sc_lunar_prospector/moon/all",
                dataType: "pos"
            }, {
                type: "align",
                primary: {
                    type: "align",
                    target: "moon",
                    axis: s.Vector3.YAxisNeg,
                    targetAxis: s.Vector3.ZAxis
                }
            }, {
                type: "spin",
                axis: s.Vector3.YAxisNeg,
                periodInHours: .008333
            }]
        },
        sc_lunar_reconnaissance_orbiter: {
            groups: ["moon", "spacecraft"],
            occlusionRadius: .00272,
            extentsRadius: .0038,
            label: "Lunar Reconnaissance Orbiter",
            parents: [[298635426.1844444, "earth"], [298929666, "moon"]],
            trail: {
                length: 7106.66,
                lengthCoverages: [[1e6, Number.NEGATIVE_INFINITY, 299040641], [7106.66, 299040641, Number.POSITIVE_INFINITY]]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_lunar_reconnaissance_orbiter/LRO.gltf",
                rotate: [{
                    z: -90
                }],
                shadowEntities: ["moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_lunar_reconnaissance_orbiter/earth/orb"
            }, {
                type: "dynamo",
                url: "sc_lunar_reconnaissance_orbiter/moon/orb"
            }, {
                type: "align",
                primary: {
                    type: "velocity",
                    target: "sc_lunar_reconnaissance_orbiter",
                    axis: s.Vector3.XAxisNeg
                },
                secondary: {
                    type: "point",
                    target: "moon",
                    axis: s.Vector3.ZAxis
                }
            }, {
                type: "dynamo",
                url: "sc_lunar_reconnaissance_orbiter/ori"
            }]
        },
        sc_smart_1: {
            groups: ["moon", "spacecraft"],
            occlusionRadius: .0015,
            extentsRadius: .00653,
            label: "SMART-1",
            parents: [[117977163.35299999, "moon"], [210585600, ""]],
            trail: {
                length: 273091
            },
            controllers: [{
                type: "fixed",
                orientation: s.Quaternion.Identity
            }, {
                type: "animdata",
                url: "sc_smart_1/moon/all",
                dataType: "pos"
            }]
        },
        sc_themis_b: {
            groups: ["moon", "spacecraft"],
            occlusionRadius: 4e-4,
            extentsRadius: .0017,
            label: "ARTEMIS P1",
            parents: [[225029706, "earth"], [362424822, "moon"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_themis/themis.gltf",
                shadowEntities: ["moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_themis_b/earth"
            }, {
                type: "dynamo",
                url: "sc_themis_b/moon"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.YAxis
                }
            }, {
                type: "spin",
                axis: s.Vector3.YAxis,
                periodInHours: 8333e-7
            }, {
                type: "coverage",
                coverage: [Number.NEGATIVE_INFINITY, 264427265],
                enter: t => {
                    const e = t.getComponent(s.DivComponent);
                    e && (e.getDiv().innerHTML = e.getDiv().innerHTML.replace("ARTEMIS P1", "THEMIS B"))
                }
                ,
                exit: t => {
                    const e = t.getComponent(s.DivComponent);
                    e && (e.getDiv().innerHTML = e.getDiv().innerHTML.replace("THEMIS B", "ARTEMIS P1"))
                }
            }]
        },
        sc_themis_c: {
            groups: ["moon", "spacecraft"],
            occlusionRadius: 4e-4,
            extentsRadius: .0017,
            label: "ARTEMIS P2",
            parents: [[225029706, "earth"], [364189900, "moon"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_themis/themis.gltf",
                shadowEntities: ["moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_themis_c/earth"
            }, {
                type: "dynamo",
                url: "sc_themis_c/moon"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.YAxis
                }
            }, {
                type: "spin",
                axis: s.Vector3.YAxis,
                periodInHours: 8333e-7
            }, {
                type: "coverage",
                coverage: [Number.NEGATIVE_INFINITY, 264427265],
                enter: t => {
                    const e = t.getComponent(s.DivComponent);
                    e && (e.getDiv().innerHTML = e.getDiv().innerHTML.replace("ARTEMIS P2", "THEMIS C"))
                }
                ,
                exit: t => {
                    const e = t.getComponent(s.DivComponent);
                    e && (e.getDiv().innerHTML = e.getDiv().innerHTML.replace("THEMIS C", "ARTEMIS P2"))
                }
            }]
        },
        sc_lunar_trailblazer: {
            groups: ["spacecraft"],
            radius: .0035,
            label: "Lunar Trailblazer",
            parents: [[793890329, "earth"], [805118518, "moon"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_lunar_trailblazer/lunartrailblazer.gltf",
                shadowEntities: ["earth", "moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_lunar_trailblazer/earth"
            }, {
                type: "dynamo",
                url: "sc_lunar_trailblazer/moon"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.ZAxis
                },
                secondary: {
                    type: "align",
                    target: "sun",
                    axis: s.Vector3.XAxis,
                    targetAxis: s.Vector3.ZAxis
                }
            }]
        }
    })
}
, function(t, e, i) {
    "use strict";
    i.r(e);
    var s = i(5);
    i(545).Entity.register({
        sc_mars_2020: {
            groups: ["mars", "spacecraft", "landers"],
            occlusionRadius: .0015,
            extentsRadius: .003,
            label: "Mars 2020",
            parents: [[649385564, "earth"], [649595376, "sun"], [666932224, "mars"], [666952859, "sc_mars_2020_landing_site"]],
            trail: {
                length: 1e7,
                lengthCoverages: [[1e7, 649385564, 666932224], [3e3, 666932224, 666953098.003], [9676800, 676629898.003, Number.POSITIVE_INFINITY]],
                updatePointPositions: !0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_mars_2020/cruise_whole/msl_cruise_stage.gltf",
                rotate: [{
                    x: -90
                }],
                shadowEntities: ["mars"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_mars_2020/earth/orb"
            }, {
                type: "dynamo",
                url: "sc_mars_2020/sun/orb"
            }, {
                type: "dynamo",
                url: "sc_mars_2020/mars/pos"
            }, {
                type: "dynamo",
                url: "sc_mars_2020/surface/lin"
            }, {
                type: "custom",
                func: t => {
                    const e = t.addController(s.TranslateController);
                    return e.setTranslation(new s.Vector3(-.125148,.026867,-.023641)),
                    e
                }
                ,
                coverage: [666952859, 666953098.003]
            }, {
                type: "dynamo",
                url: "sc_mars_2020/quat"
            }, {
                type: "dynamo",
                url: "sc_mars_2020/surface/quat_v2"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: .00833333333,
                relativeToTime: 649385564,
                coverage: [649385564, 666952859]
            }, {
                type: "rotateByEntityOrientation",
                entityForOrientation: "mars",
                coverage: [666952859, Number.POSITIVE_INFINITY]
            }, {
                type: "custom",
                func: t => {
                    const e = t.addController(s.GroundClampController);
                    return e.setDistanceFromGround(.001),
                    e.setGroundEntityRef("mars"),
                    e.setUp(s.Vector3.ZAxisNeg),
                    e.setCoverage(new s.Interval(666953086.614,Number.POSITIVE_INFINITY)),
                    e
                }
            }, {
                type: "coverage",
                coverage: [666953086.614, Number.POSITIVE_INFINITY],
                enter: t => {
                    const e = t.getComponent(s.DivComponent);
                    e && e.getDiv().innerHTML.replace("Mars 2020", "Perseverance")
                }
                ,
                exit: t => {
                    const e = t.getComponent(s.DivComponent);
                    e && e.getDiv().innerHTML.replace("Perseverance", "Mars 2020")
                }
            }, {
                type: "coverage",
                coverage: [666953098.003, 676629898.003],
                enter: t => {
                    const e = t.getComponent(s.TrailComponent);
                    null !== e && (e.setStartTime(666953098.003),
                    e.setRelativeStartTime(!1))
                }
                ,
                exit: t => {
                    const e = t.getComponent(s.TrailComponent);
                    null !== e && e.setRelativeStartTime(!0)
                }
            }, {
                type: "coverage",
                coverage: [666932224, Number.POSITIVE_INFINITY],
                enter: t => {
                    const e = t.getComponent(s.TrailComponent);
                    null !== e && e.setRelativeToEntityOrientation(!0)
                }
                ,
                exit: t => {
                    const e = t.getComponent(s.TrailComponent);
                    null !== e && e.setRelativeToEntityOrientation(!1)
                }
            }, {
                type: "coverage",
                coverage: [666953086.614, Number.POSITIVE_INFINITY],
                enter: t => {
                    const e = t.getComponent(s.ModelComponent);
                    e && (e.setUrl("$STATIC_ASSETS_URL/models/sc_mars_2020/rover/perseverance.gltf"),
                    e.setRotation(new s.Quaternion(.5,-.5,.5,-.5)),
                    e.setTranslation(new s.Vector3(0,0,.001)))
                }
                ,
                exit: t => {
                    const e = t.getComponent(s.ModelComponent);
                    e && (e.setUrl("$STATIC_ASSETS_URL/models/sc_mars_2020/cruise_whole/msl_cruise_stage.gltf"),
                    e.setRotation(new s.Quaternion(.7071067811865478,-.7071067811865472,0,0)),
                    e.setTranslation(new s.Vector3(0,0,0)))
                }
            }, {
                type: "coverage",
                coverage: [666953098.003, Number.POSITIVE_INFINITY],
                enter: t => {
                    const e = t.getComponent(s.TrailComponent);
                    null !== e && e.setIgnoreDistance(!0)
                }
                ,
                exit: t => {
                    const e = t.getComponent(s.TrailComponent);
                    null !== e && e.setIgnoreDistance(!1)
                }
            }, {
                type: "coverage",
                coverage: [666952458, 666953086.614],
                enter: t => {
                    const e = t.getComponent(s.ModelComponent);
                    null !== e && (e.setHiddenObject("solar_panels", !0),
                    e.setHiddenObject("frame_etc", !0))
                }
                ,
                exit: t => {
                    const e = t.getComponent(s.ModelComponent);
                    null !== e && (e.setHiddenObject("solar_panels", !1),
                    e.setHiddenObject("frame_etc", !1))
                }
            }]
        },
        sc_mars_2020_landing_site: {
            groups: ["mars", "sc_mars_2020", "sites"],
            radius: .001,
            systemRadius: 200,
            label: "Mars 2020 Landing Site",
            parents: [[649385563.6433017, "mars"]],
            controllers: [{
                type: "fixed",
                position: new s.Vector3(699.1286672183024,3140.822003077514,1073.1680551721952),
                orientation: s.Quaternion.Identity,
                coverage: [649385563.6433017, Number.POSITIVE_INFINITY]
            }, {
                type: "rotateByEntityOrientation",
                rotatingPosition: !0,
                rotatingOrientation: !0,
                coverage: [649385563.6433017, Number.POSITIVE_INFINITY]
            }]
        },
        sc_mars_science_laboratory: {
            groups: ["mars", "spacecraft", "landers"],
            occlusionRadius: .001515,
            extentsRadius: .004,
            label: "Mars Science Laboratory",
            parents: [[375594733, "earth"], [376039259, "sun"], [397477501, "mars"], [397502386.832, "sc_mars_science_laboratory_landing_site"]],
            trail: {
                length: 1e7,
                lengthCoverages: [[1e7, 375594733, 397501373], [3e3, 397501373, 407179186.832], [9676800, 407179186.832, Number.POSITIVE_INFINITY]],
                updatePointPositions: !0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_mars_science_laboratory/cruise/msl_cruisestage.gltf",
                rotate: [{
                    x: -90
                }],
                shadowEntities: ["mars"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_mars_science_laboratory/earth/orb"
            }, {
                type: "dynamo",
                url: "sc_mars_science_laboratory/sun/orb"
            }, {
                type: "dynamo",
                url: "sc_mars_science_laboratory/mars/orb"
            }, {
                type: "dynamo",
                url: "sc_mars_science_laboratory/edl/pos"
            }, {
                type: "custom",
                func: t => {
                    const e = t.addController(s.TranslateController);
                    return e.setTranslation(new s.Vector3(.002583,.002995,.001937)),
                    e
                }
                ,
                coverage: [397501373, 397502386.832]
            }, {
                type: "dynamo",
                url: "sc_mars_science_laboratory/surface/lin_v2"
            }, {
                type: "dynamo",
                url: "sc_mars_science_laboratory/quat"
            }, {
                type: "dynamo",
                url: "sc_mars_science_laboratory/surface/quat_v2"
            }, {
                type: "spin",
                axis: s.Vector3.ZAxis,
                periodInHours: .00833333333,
                relativeToTime: 375594733,
                coverage: [375594733, 397501866]
            }, {
                type: "rotateByEntityOrientation",
                entityForOrientation: "mars",
                rotatingOrientation: !1,
                coverage: [397501373, Number.POSITIVE_INFINITY]
            }, {
                type: "rotateByEntityOrientation",
                entityForOrientation: "mars",
                rotatingPosition: !1,
                coverage: [397502386.832, Number.POSITIVE_INFINITY]
            }, {
                type: "custom",
                func: t => {
                    const e = t.addController(s.GroundClampController);
                    return e.setDistanceFromGround(98e-5),
                    e.setGroundEntityRef("mars"),
                    e.setUp(s.Vector3.ZAxisNeg),
                    e.setCoverage(new s.Interval(397502386.832,Number.POSITIVE_INFINITY)),
                    e
                }
            }, {
                type: "coverage",
                coverage: [397502386.832, Number.POSITIVE_INFINITY],
                enter: t => {
                    const e = t.getComponent(s.DivComponent);
                    e && e.getDiv().innerHTML.replace("Mars Science Laboratory", "Curiosity")
                }
                ,
                exit: t => {
                    const e = t.getComponent(s.DivComponent);
                    e && e.getDiv().innerHTML.replace("Curiosity", "Mars Science Laboratory")
                }
            }, {
                type: "coverage",
                coverage: [397501373, Number.POSITIVE_INFINITY],
                enter: t => {
                    const e = t.getComponent(s.TrailComponent);
                    null !== e && e.setRelativeToEntityOrientation(!0)
                }
                ,
                exit: t => {
                    const e = t.getComponent(s.TrailComponent);
                    null !== e && e.setRelativeToEntityOrientation(!1)
                }
            }, {
                type: "coverage",
                coverage: [397502324, Number.POSITIVE_INFINITY],
                enter: t => {
                    const e = t.getComponent(s.ModelComponent);
                    null !== e && (e.setUrl("$STATIC_ASSETS_URL/models/sc_mars_science_laboratory/rover/curiosity_static.gltf"),
                    e.setRotation(new s.Quaternion(.5,-.5,.5,-.5)),
                    e.setTranslation(new s.Vector3(0,0,.001)))
                }
                ,
                exit: t => {
                    const e = t.getComponent(s.ModelComponent);
                    null !== e && (e.setUrl("$STATIC_ASSETS_URL/models/sc_mars_science_laboratory/cruise/msl_cruisestage.gltf"),
                    e.setRotation(new s.Quaternion(.7071067811865478,-.7071067811865472,0,0)),
                    e.setTranslation(new s.Vector3(0,0,0)))
                }
            }, {
                type: "coverage",
                coverage: [397502386.832, Number.POSITIVE_INFINITY],
                enter: t => {
                    const e = t.getComponent(s.TrailComponent);
                    null !== e && e.setIgnoreDistance(!0)
                }
                ,
                exit: t => {
                    const e = t.getComponent(s.TrailComponent);
                    null !== e && e.setIgnoreDistance(!1)
                }
            }, {
                type: "coverage",
                coverage: [397501758, 397502386.832],
                enter: t => {
                    const e = t.getComponent(s.ModelComponent);
                    null !== e && (e.setHiddenObject("solar_panels", !0),
                    e.setHiddenObject("frame_etc", !0))
                }
                ,
                exit: t => {
                    const e = t.getComponent(s.ModelComponent);
                    null !== e && (e.setHiddenObject("solar_panels", !1),
                    e.setHiddenObject("frame_etc", !1))
                }
            }]
        },
        sc_mars_science_laboratory_landing_site: {
            groups: ["mars", "sc_mars_science_laboratory", "sites"],
            occlusionRadius: .001515,
            extentsRadius: .004,
            systemRadius: 200,
            label: "Curiosity Landing Site",
            parents: [[375594732.3829685, "mars"]],
            controllers: [{
                type: "fixed",
                position: new s.Vector3(-2489.861912,2286.208595,-271.343889),
                orientation: s.Quaternion.Identity,
                coverage: [375594732.3829685, Number.POSITIVE_INFINITY]
            }, {
                type: "rotateByEntityOrientation",
                rotatingPosition: !0,
                rotatingOrientation: !0,
                coverage: [375594732.3829685, Number.POSITIVE_INFINITY]
            }]
        },
        sc_mars_exploration_rover_1: {
            groups: ["mars", "spacecraft", "landers"],
            occlusionRadius: .0013,
            extentsRadius: .0026,
            label: "Opportunity",
            parents: [[110911022.184, "earth"], [111234172, "sun"], [128262836, "mars"], [128278419, "sc_mars_exploration_rover_1_landing_site"], [581920316.8566707, ""]],
            trail: {
                length: 6720,
                lengthCoverages: [[1e7, Number.NEGATIVE_INFINITY, 128262836], [6720, 128262836, 128278523], [9676800, 137955323, 581920316.856]],
                updatePointPositions: !0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_mars_exploration_rover/cruise/mpf_mera_merb_cruise.gltf",
                rotate: [{
                    x: 90
                }],
                shadowEntities: ["mars"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_mars_exploration_rover_1/earth/orb"
            }, {
                type: "dynamo",
                url: "sc_mars_exploration_rover_1/sun/orb"
            }, {
                type: "dynamo",
                url: "sc_mars_exploration_rover_1/mars/pos"
            }, {
                type: "dynamo",
                url: "sc_mars_exploration_rover_1/edl/pos"
            }, {
                type: "dynamo",
                url: "sc_mars_exploration_rover_1/surface/lin"
            }, {
                type: "custom",
                func: t => {
                    const e = t.addController(s.RotateController)
                      , i = new s.Quaternion;
                    return i.setFromAxes(s.Vector3.YAxis, s.Vector3.XAxisNeg, void 0),
                    e.setRotation(i),
                    e.setRotatingOrientation(!1),
                    e
                }
                ,
                coverage: [128278419, 581920316.856]
            }, {
                type: "rotateByEntityOrientation",
                rotatingOrientation: !1,
                coverage: [128278419, 581920316.856]
            }, {
                type: "custom",
                func: t => {
                    const e = t.addController(s.GroundClampController);
                    return e.setGroundEntityRef("mars"),
                    e.setUp(s.Vector3.ZAxisNeg),
                    e
                }
                ,
                coverage: [128278523, 581920316.856]
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.ZAxis
                },
                secondary: {
                    type: "align",
                    target: "mars",
                    axis: s.Vector3.YAxis,
                    targetAxis: s.Vector3.ZAxis
                },
                coverage: [Number.NEGATIVE_INFINITY, 128262836]
            }, {
                type: "align",
                primary: {
                    type: "velocity",
                    target: "sc_mars_exploration_rover_1",
                    axis: s.Vector3.ZAxisNeg
                },
                secondary: {
                    type: "align",
                    target: "mars",
                    axis: s.Vector3.YAxis,
                    targetAxis: s.Vector3.ZAxis
                },
                coverage: [128262836, 128278523.336]
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity,
                coverage: [128278523, 581920316.856]
            }, {
                type: "rotateByEntityOrientation",
                rotatingPosition: !1,
                coverage: [128278523, 581920316.856]
            }, {
                type: "coverage",
                coverage: [128278419, 581920316.856],
                enter: t => {
                    const e = t.getComponent(s.TrailComponent);
                    null !== e && (e.setRelativeToEntityOrientation(!0),
                    e.setIgnoreDistance(!0))
                }
                ,
                exit: t => {
                    const e = t.getComponent(s.TrailComponent);
                    null !== e && (e.setRelativeToEntityOrientation(!1),
                    e.setIgnoreDistance(!1))
                }
            }, {
                type: "coverage",
                coverage: [128278523, 137955323],
                enter: t => {
                    const e = t.getComponent(s.TrailComponent);
                    null !== e && (e.setStartTime(128278523),
                    e.setRelativeStartTime(!1))
                }
                ,
                exit: t => {
                    const e = t.getComponent(s.TrailComponent);
                    null !== e && e.setRelativeStartTime(!0)
                }
            }, {
                type: "coverage",
                coverage: [128278523, 581920316.856],
                enter: t => {
                    const e = t.getComponent(s.ModelComponent);
                    null !== e && e.setUrl("$STATIC_ASSETS_URL/models/sc_mars_exploration_rover/rover/mer_static.gltf")
                }
                ,
                exit: t => {
                    const e = t.getComponent(s.ModelComponent);
                    null !== e && e.setUrl("$STATIC_ASSETS_URL/models/sc_mars_exploration_rover/cruise/mpf_mera_merb_cruise.gltf")
                }
            }]
        },
        sc_mars_exploration_rover_1_landing_site: {
            groups: ["mars", "sc_mars_exploration_rover_1", "sites"],
            radius: .001,
            systemRadius: 200,
            label: "Opportunity Landing Site",
            parents: [[110911022.184, "mars"]],
            controllers: [{
                type: "fixed",
                llaOnSpheroid: new s.LatLonAlt(-.034003934569818886,-.09644392740547784,0),
                coverage: [110911022.184, Number.POSITIVE_INFINITY]
            }]
        },
        sc_mars_exploration_rover_2: {
            groups: ["mars", "spacecraft", "landers"],
            occlusionRadius: .0013,
            extentsRadius: .0026,
            label: "Spirit",
            parents: [[108541883.184, "earth"], [108887371, "sun"], [126444477, "mars"], [126462105, "sc_mars_exploration_rover_2_landing_site"], [322567479.3896215, ""]],
            trail: {
                length: 6720,
                lengthCoverages: [[1e7, Number.NEGATIVE_INFINITY, 126444477], [6720, 126444477, 126462396], [9676800, 136139196, 322567479.38962]],
                updatePointPositions: !0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_mars_exploration_rover/cruise/mpf_mera_merb_cruise.gltf",
                rotate: [{
                    x: 90
                }],
                shadowEntities: ["mars"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_mars_exploration_rover_2/earth/orb"
            }, {
                type: "dynamo",
                url: "sc_mars_exploration_rover_2/sun/orb"
            }, {
                type: "dynamo",
                url: "sc_mars_exploration_rover_2/mars/pos"
            }, {
                type: "dynamo",
                url: "sc_mars_exploration_rover_2/edl/pos"
            }, {
                type: "dynamo",
                url: "sc_mars_exploration_rover_2/surface/lin"
            }, {
                type: "custom",
                func: t => {
                    const e = t.addController(s.RotateController)
                      , i = new s.Quaternion;
                    return i.setFromAxes(s.Vector3.YAxis, s.Vector3.XAxisNeg, void 0),
                    e.setRotation(i),
                    e.setRotatingOrientation(!1),
                    e
                }
                ,
                coverage: [126462105, 322567479.38962]
            }, {
                type: "rotateByEntityOrientation",
                rotatingOrientation: !1,
                coverage: [126462105, 322567479.38962]
            }, {
                type: "custom",
                func: t => {
                    const e = t.addController(s.GroundClampController);
                    return e.setGroundEntityRef("mars"),
                    e.setUp(s.Vector3.ZAxisNeg),
                    e
                }
                ,
                coverage: [126462396, 322567479.38962]
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.ZAxis
                },
                secondary: {
                    type: "align",
                    target: "mars",
                    axis: s.Vector3.YAxis,
                    targetAxis: s.Vector3.ZAxis
                },
                coverage: [Number.NEGATIVE_INFINITY, 126444477]
            }, {
                type: "align",
                primary: {
                    type: "velocity",
                    target: "sc_mars_exploration_rover_2",
                    axis: s.Vector3.ZAxisNeg
                },
                secondary: {
                    type: "align",
                    target: "mars",
                    axis: s.Vector3.YAxis,
                    targetAxis: s.Vector3.ZAxis
                },
                coverage: [126444477, 126462396]
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity,
                coverage: [126462396, 322567479.38962]
            }, {
                type: "rotateByEntityOrientation",
                rotatingPosition: !1,
                coverage: [126462396, 322567479.38962]
            }, {
                type: "coverage",
                coverage: [126462105, 322567479.38962],
                enter: t => {
                    const e = t.getComponent(s.TrailComponent);
                    null !== e && (e.setRelativeToEntityOrientation(!0),
                    e.setIgnoreDistance(!0))
                }
                ,
                exit: t => {
                    const e = t.getComponent(s.TrailComponent);
                    null !== e && (e.setRelativeToEntityOrientation(!1),
                    e.setIgnoreDistance(!1))
                }
            }, {
                type: "coverage",
                coverage: [126462396, 136139196],
                enter: t => {
                    const e = t.getComponent(s.TrailComponent);
                    null !== e && (e.setStartTime(126462396),
                    e.setRelativeStartTime(!1))
                }
                ,
                exit: t => {
                    const e = t.getComponent(s.TrailComponent);
                    null !== e && e.setRelativeStartTime(!0)
                }
            }, {
                type: "coverage",
                coverage: [126462396, 322567479.38962],
                enter: t => {
                    const e = t.getComponent(s.ModelComponent);
                    null !== e && e.setUrl("$STATIC_ASSETS_URL/models/sc_mars_exploration_rover/rover/mer_static.gltf")
                }
                ,
                exit: t => {
                    const e = t.getComponent(s.ModelComponent);
                    null !== e && e.setUrl("$STATIC_ASSETS_URL/models/sc_mars_exploration_rover/cruise/mpf_mera_merb_cruise.gltf")
                }
            }]
        },
        sc_mars_exploration_rover_2_landing_site: {
            groups: ["mars", "sc_mars_exploration_rover_2", "sites"],
            radius: .001,
            systemRadius: 200,
            label: "Spirit Landing Site",
            parents: [[108541883.184, "mars"]],
            controllers: [{
                type: "fixed",
                llaOnSpheroid: new s.LatLonAlt(-.25432749290990797,3.062677242395019,-2.614394925059969),
                coverage: [108541883.184, Number.POSITIVE_INFINITY]
            }]
        },
        sc_insight: {
            groups: ["mars", "spacecraft", "landers"],
            radius: .00306,
            label: "InSight",
            parents: [[578795968.9654216, "earth"], [579182469.185, "sun"], [596376069.183, "mars"]],
            trail: {
                length: 32137022.16,
                lengthCoverages: [[32137022.16, Number.NEGATIVE_INFINITY, 596376069.183], [14400, 596376069.183, 596529871.284], [3600, 596529871.284, 596533602], [0, 596533602, Number.POSITIVE_INFINITY]]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_insight/lander/insight.gltf",
                rotate: [{
                    y: 90
                }]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_insight/earth/pos"
            }, {
                type: "dynamo",
                url: "sc_insight/sun/orb"
            }, {
                type: "dynamo",
                url: "sc_insight/mars/orb"
            }, {
                type: "dynamo",
                url: "sc_insight_edl/mars/pos"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "mars",
                    axis: s.Vector3.ZAxisNeg
                },
                secondary: {
                    type: "align",
                    target: "mars",
                    axis: s.Vector3.YAxis,
                    targetAxis: s.Vector3.ZAxis
                },
                coverage: [578795968.9654216, 596533602]
            }, {
                type: "dynamo",
                url: "sc_insight/ori"
            }, {
                type: "dynamo",
                url: "sc_insight_edl/ori"
            }, {
                type: "fixed",
                llaOnSpheroid: new s.LatLonAlt(.07881611091588075,2.3734709256393973,-2.996371903616364),
                llaOnSpheroidEntity: "mars",
                coverage: [596533602, Number.POSITIVE_INFINITY]
            }, {
                type: "coverage",
                coverage: [596529871.284, 596533602],
                enter: t => {
                    const e = t.getComponent(s.TrailComponent);
                    null !== e && e.setRelativeToEntityOrientation(!0)
                }
                ,
                exit: t => {
                    const e = t.getComponent(s.TrailComponent);
                    null !== e && e.setRelativeToEntityOrientation(!1)
                }
            }, {
                type: "coverage",
                coverage: [578795968.9654216, 596533602],
                enter: t => {
                    const e = t.getComponent(s.ModelComponent);
                    null !== e && (e.setUrl("$STATIC_ASSETS_URL/models/sc_insight/cruise/model.gltf"),
                    e.setRotation(new s.Quaternion(Math.sqrt(.5),0,Math.sqrt(.5),0)),
                    e.setTranslation(s.Vector3.Zero))
                }
            }, {
                type: "coverage",
                coverage: [596533602, Number.POSITIVE_INFINITY],
                enter: t => {
                    const e = t.getComponent(s.ModelComponent);
                    null !== e && (e.setUrl("$STATIC_ASSETS_URL/models/sc_insight/lander/insight.gltf"),
                    e.setRotation(new s.Quaternion(Math.sqrt(.5),Math.sqrt(.5),0,0)),
                    e.setTranslation(new s.Vector3(0,0,85e-5)))
                }
            }]
        },
        sc_insight_landing_site: {
            groups: ["mars", "sc_insight", "sites"],
            radius: .001,
            systemRadius: 200,
            label: "InSight Landing Site",
            parents: [[578795968.9654216, "mars"], [596533602, ""]],
            controllers: [{
                type: "fixed",
                llaOnSpheroid: new s.LatLonAlt(.07881611091588075,2.3734709256393973,-2.996371903616364),
                coverage: [578795968.9654216, 596533602]
            }]
        },
        sc_marco_a: {
            groups: ["mars", "spacecraft"],
            radius: 44375e-8,
            label: "MarCO A",
            parents: [[578796051, "earth"], [579182469.185, "sun"], [596376069.183, "mars"], [596552080, "sun"], [631152e3, ""]],
            trail: {
                length: 6720,
                lengthCoverages: [[1e7, Number.NEGATIVE_INFINITY, 579182469.185], [6720, 579182469.185, 596552080], [1e7, 596552080, Number.POSITIVE_INFINITY]]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_marco/model.gltf"
            },
            controllers: [{
                type: "dynamo",
                url: "sc_marco_a/earth/orb"
            }, {
                type: "dynamo",
                url: "sc_marco_a/sun/1/orb"
            }, {
                type: "dynamo",
                url: "sc_marco_a/mars/orb"
            }, {
                type: "dynamo",
                url: "sc_marco_a/sun/2/orb"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.YAxis
                }
            }]
        },
        sc_marco_b: {
            groups: ["mars", "spacecraft"],
            radius: 44375e-8,
            label: "MarCO B",
            parents: [[578796051, "earth"], [579182469.185, "sun"], [596376069.183, "mars"], [596552080, "sun"], [631152e3, ""]],
            trail: {
                length: 6720,
                lengthCoverages: [[1e7, Number.NEGATIVE_INFINITY, 579182469.185], [6720, 579182469.185, 596552080], [1e7, 596552080, Number.POSITIVE_INFINITY]]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_marco/model.gltf"
            },
            controllers: [{
                type: "dynamo",
                url: "sc_marco_b/earth/orb"
            }, {
                type: "dynamo",
                url: "sc_marco_b/sun/1/orb"
            }, {
                type: "dynamo",
                url: "sc_marco_b/mars/orb"
            }, {
                type: "dynamo",
                url: "sc_marco_b/sun/2/orb"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.YAxis
                }
            }]
        },
        sc_mars_odyssey: {
            groups: ["mars", "spacecraft"],
            occlusionRadius: .0013,
            extentsRadius: .004,
            label: "Mars Odyssey",
            parents: [[39932700, "earth"], [40233664, "sun"], [57128464, "mars"]],
            trail: {
                length: 6727,
                lengthCoverages: [[1e7, Number.NEGATIVE_INFINITY, 57128464], [6727, 57128464, Number.POSITIVE_INFINITY]]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_mars_odyssey/mars_odyssey.gltf",
                shadowEntities: ["mars", "deimos", "phobos"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_mars_odyssey/earth/orb"
            }, {
                type: "dynamo",
                url: "sc_mars_odyssey/sun/orb"
            }, {
                type: "dynamo",
                url: "sc_mars_odyssey/mars/orb"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "mars",
                    axis: new s.Vector3(-.95630475596,.29237170472,0)
                },
                secondary: {
                    type: "velocity",
                    target: "sc_mars_odyssey",
                    axis: new s.Vector3(.29237170472,.95630475596,0)
                }
            }, {
                type: "dynamo",
                url: "sc_mars_odyssey/ori"
            }]
        },
        sc_mars_reconnaissance_orbiter: {
            groups: ["mars", "spacecraft"],
            radius: .0068,
            label: "Mars Reconnaissance Orbiter",
            parents: [[177122516, "earth"], [177429664, "sun"], [195285665, "mars"]],
            trail: {
                length: 6720,
                lengthCoverages: [[1e7, Number.NEGATIVE_INFINITY, 195285665], [6720, 195285665, Number.POSITIVE_INFINITY]]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_mars_reconnaissance_orbiter/MRO.gltf",
                shadowEntities: ["mars", "deimos", "phobos"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_mars_reconnaissance_orbiter/earth/orb"
            }, {
                type: "dynamo",
                url: "sc_mars_reconnaissance_orbiter/sun/orb"
            }, {
                type: "dynamo",
                url: "sc_mars_reconnaissance_orbiter/mars/orb"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "mars",
                    axis: s.Vector3.ZAxis
                },
                secondary: {
                    type: "velocity",
                    target: "sc_mars_reconnaissance_orbiter",
                    axis: s.Vector3.XAxis
                }
            }, {
                type: "dynamo",
                url: "sc_mars_reconnaissance_orbiter/ori"
            }]
        },
        sc_maven: {
            groups: ["mars", "spacecraft"],
            radius: .0057,
            label: "MAVEN",
            parents: [[438074509.3428109, "earth"], [438296467, "sun"], [464590867, "mars"]],
            trail: {
                length: 16139
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_maven/Maven.gltf",
                rotate: [{
                    x: 90
                }, {
                    z: 90
                }],
                shadowEntities: ["mars", "deimos", "phobos"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_maven/earth/orb"
            }, {
                type: "dynamo",
                url: "sc_maven/sun/orb"
            }, {
                type: "dynamo",
                url: "sc_maven/mars/orb"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.ZAxis
                }
            }, {
                type: "dynamo",
                url: "sc_maven/ori"
            }]
        },
        sc_mars_express: {
            groups: ["mars", "spacecraft"],
            radius: .006,
            label: "Mars Express",
            parents: [[107853140.59600002, "earth"], [108232264, "sun"], [125539264, "mars"]],
            trail: {
                length: 25e3,
                lengthCoverages: [[1e7, Number.NEGATIVE_INFINITY, 126749131], [12720, 126749131, Number.POSITIVE_INFINITY]]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_mars_express/mars_express.gltf",
                rotate: [{
                    x: 90
                }, {
                    z: -180
                }],
                shadowEntities: ["mars", "deimos", "phobos"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_mars_express/earth/orb"
            }, {
                type: "dynamo",
                url: "sc_mars_express/sun/orb"
            }, {
                type: "dynamo",
                url: "sc_mars_express/mars/orb"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "mars",
                    axis: s.Vector3.XAxisNeg
                }
            }, {
                type: "dynamo",
                url: "sc_mars_express/ori"
            }]
        },
        sc_phoenix: {
            groups: ["mars", "spacecraft"],
            radius: .0027,
            label: "Phoenix",
            parents: [[239496427, "earth"], [239618121, "sun"], [265008306, "mars"], [265030318, "sc_phoenix_landing_site"], [278942465, ""]],
            trail: {
                length: 45411186,
                lengthCoverages: [[45411186, Number.NEGATIVE_INFINITY, 265008306], [5e4, 265008306, 265030318], [500, 265030318, 265030769], [0, 265030769, 278942465]]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_phoenix/cruise/phoenix_cruise.gltf",
                rotate: [{
                    z: 90
                }]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_phoenix/earth/orb"
            }, {
                type: "dynamo",
                url: "sc_phoenix/sun/orb"
            }, {
                type: "dynamo",
                url: "sc_phoenix/mars/orb"
            }, {
                type: "dynamo",
                url: "sc_phoenix/phx_topo/pos"
            }, {
                type: "dynamo",
                url: "sc_phoenix/ori"
            }, {
                type: "fixed",
                position: new s.Vector3(.027059368126568832,.013878235928918032,-.04367634407940447),
                coverage: [265030769, 278942465]
            }, {
                type: "rotateByEntityOrientation",
                rotatingOrientation: !1,
                coverage: [265030769, 278942465]
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.ZAxisNeg
                }
            }, {
                type: "coverage",
                coverage: [265029904, Number.POSITIVE_INFINITY],
                enter: t => {
                    const e = t.getComponent(s.ModelComponent);
                    e && e.setUrl("$STATIC_ASSETS_URL/models/sc_phoenix/edl/phoenix_edl.gltf")
                }
                ,
                exit: t => {
                    const e = t.getComponent(s.ModelComponent);
                    e && e.setUrl("$STATIC_ASSETS_URL/models/sc_phoenix/cruise/phoenix_cruise.gltf")
                }
            }],
            postCreateFunction: t => {
                t.addParentChangedCallback(( (t, e, i) => {
                    if (null !== i) {
                        const e = i.getName()
                          , n = t.getComponent(s.TrailComponent);
                        n && ("sc_phoenix_landing_site" === e ? (n.setRelativeToEntity("mars"),
                        n.setRelativeToEntityOrientation(!0)) : (n.setRelativeToEntity(""),
                        n.setRelativeToEntityOrientation(!1)))
                    }
                }
                ))
            }
        },
        sc_phoenix_landing_site: {
            groups: ["mars", "sc_phoenix", "sites"],
            radius: .001,
            systemRadius: 200,
            label: "Phoenix Landing Site",
            parents: [[239496427, "mars"]],
            controllers: [{
                type: "fixed",
                llaOnSpheroid: new s.LatLonAlt(1.1906355815662266,-2.1947740491302206,-2.5912352775421823),
                coverage: [239496427, Number.POSITIVE_INFINITY]
            }]
        },
        sc_trace_gas_orbiter: {
            groups: ["mars", "spacecraft"],
            radius: .00875915,
            label: "Trace Gas Orbiter",
            parents: [[511257268, "earth"], [511941668, "sun"], [530107268, "mars"]],
            trail: {
                length: 6720,
                lengthCoverages: [[1e7, Number.NEGATIVE_INFINITY, 530160041], [6720, 530160041, Number.POSITIVE_INFINITY]]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_trace_gas_orbiter/TGO.gltf",
                rotate: [{
                    x: -90
                }, {
                    y: -90
                }],
                shadowEntities: ["mars", "deimos", "phobos"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_trace_gas_orbiter/earth/orb"
            }, {
                type: "dynamo",
                url: "sc_trace_gas_orbiter/sun/orb"
            }, {
                type: "dynamo",
                url: "sc_trace_gas_orbiter/mars/orb"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "mars",
                    axis: s.Vector3.YAxisNeg
                },
                secondary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.XAxisNeg
                }
            }, {
                type: "dynamo",
                url: "sc_trace_gas_orbiter/ori"
            }, {
                type: "align",
                joint: "right_array_1",
                primary: {
                    type: "none",
                    axis: s.Vector3.XAxis
                },
                secondary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.YAxis
                }
            }, {
                type: "align",
                joint: "left_array_1",
                primary: {
                    type: "none",
                    axis: s.Vector3.XAxis
                },
                secondary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.YAxis
                }
            }]
        },
        sc_mars_orbiter_mission: {
            groups: ["mars", "spacecraft"],
            radius: .00275,
            label: "Mars Orbiter Mission",
            parents: [[436917230, "earth"], [439621267, "sun"], [464758867, "mars"], [702924129, ""]],
            trail: {
                length: void 0
            },
            controllers: [{
                type: "dynamo",
                url: "sc_mars_orbiter_mission/earth/orb"
            }, {
                type: "dynamo",
                url: "sc_mars_orbiter_mission/sun/orb"
            }, {
                type: "dynamo",
                url: "sc_mars_orbiter_mission/mars/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        sc_mars_global_surveyor: {
            groups: ["mars", "spacecraft"],
            occlusionRadius: .003,
            extentsRadius: .005,
            label: "Mars Global Surveyor",
            parents: [[-72699545, "mars"], [215697664.184, ""]],
            trail: {
                length: 7068.67
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_mars_global_surveyor/mars_global_surveyor.gltf",
                shadowEntities: ["mars"]
            },
            controllers: [{
                type: "animdata",
                url: "sc_mars_global_surveyor_mission",
                dataType: "pos"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "mars",
                    axis: s.Vector3.XAxisNeg
                }
            }]
        },
        sc_mars_climate_orbiter: {
            groups: ["mars", "spacecraft"],
            radius: .0011,
            label: "Mars Climate Orbiter",
            parents: [[-33318e3, "sun"], [-8650375.816, ""]],
            trail: {
                length: 73762215
            },
            controllers: [{
                type: "animdata",
                url: "sc_mars_climate_orbiter",
                dataType: "pos"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        sc_mars_pathfinder: {
            groups: ["mars", "spacecraft"],
            radius: 33e-5,
            label: "Mars Pathfinder",
            parents: [[-91704541, "sun"], [-78692880, ""]],
            trail: {
                length: 51497488
            },
            controllers: [{
                type: "animdata",
                url: "sc_mars_pathfinder",
                dataType: "pos"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        sc_mars_pathfinder_landing_site: {
            groups: ["mars", "sc_mars_pathfinder", "sites"],
            radius: .001,
            systemRadius: 200,
            label: "Mars Pathfinder Landing Site",
            parents: [[-97045250.817, "mars"]],
            controllers: [{
                type: "fixed",
                llaOnSpheroid: new s.LatLonAlt(19.13 * Math.PI / 180,-33.22 * Math.PI / 180,0),
                coverage: [-97045250.817, Number.POSITIVE_INFINITY]
            }]
        },
        sc_mars_polar_lander: {
            groups: ["mars", "spacecraft"],
            radius: .0018,
            label: "Mars Polar Lander",
            parents: [[-31298400, "sun"], [-2476735.816, ""]],
            trail: {
                length: 41109006
            },
            controllers: [{
                type: "animdata",
                url: "sc_mars_polar_lander",
                dataType: "pos"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        sc_viking_1_orbiter: {
            groups: ["mars", "spacecraft"],
            radius: .0047,
            label: "Viking 1 Orbiter",
            parents: [[-742490410, "mars"], [-663249600, ""]],
            trail: {
                length: 88649
            },
            controllers: [{
                type: "animdata",
                url: "sc_viking_1_orbiter",
                dataType: "pos"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        sc_viking_1_lander_landing_site: {
            groups: ["mars", "sc_viking_1_lander", "sites"],
            radius: .001,
            systemRadius: 200,
            label: "Viking 1 Lander Landing Site",
            parents: [[-768926233.817, "mars"]],
            controllers: [{
                type: "fixed",
                llaOnSpheroid: new s.LatLonAlt(22.27 * Math.PI / 180,312.05 * Math.PI / 180,0),
                coverage: [-768926233.817, Number.POSITIVE_INFINITY]
            }]
        },
        sc_viking_2_orbiter: {
            groups: ["mars", "spacecraft"],
            radius: .0047,
            label: "Viking 2 Orbiter",
            parents: [[-738460186, "mars"], [-676517400, ""]],
            trail: {
                length: 98694
            },
            controllers: [{
                type: "animdata",
                url: "sc_viking_2_orbiter",
                dataType: "pos"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }]
        },
        sc_viking_2_lander_landing_site: {
            groups: ["mars", "sc_viking_2_lander", "sites"],
            radius: .001,
            systemRadius: 200,
            label: "Viking 2 Lander Landing Site",
            parents: [[-767208013.818, "mars"]],
            controllers: [{
                type: "fixed",
                llaOnSpheroid: new s.LatLonAlt(47.64 * Math.PI / 180,-225.71 * Math.PI / 180,0),
                coverage: [-767208013.818, Number.POSITIVE_INFINITY]
            }]
        }
    })
}
, function(t, e, i) {
    "use strict";
    i.r(e);
    var s = i(5);
    i(545).Entity.register({
        sc_messenger: {
            groups: ["mercury", "spacecraft"],
            occlusionRadius: .00133,
            extentsRadius: .0035,
            label: "MESSENGER",
            parents: [[144789279.39320505, "earth"], [145066469, "sun"], [175801890, "earth"], [176659095, "sun"], [214828942, "venus"], [215033751, "sun"], [234289415, "venus"], [234436749, "sun"], [253547108, "mercury"], [253671753, "sun"], [276485360, "mercury"], [276627276, "sun"], [307423681, "mercury"], [307651285, "sun"], [353474040, "mercury"], [483694028.351, ""]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_messenger/Messenger.gltf",
                rotate: [{
                    z: -90
                }, {
                    y: 90
                }],
                shadowEntities: ["mercury"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_messenger/earth/launch/orb"
            }, {
                type: "dynamo",
                url: "sc_messenger/sun/1/orb"
            }, {
                type: "dynamo",
                url: "sc_messenger/earth/flyby/orb"
            }, {
                type: "dynamo",
                url: "sc_messenger/sun/2/orb"
            }, {
                type: "dynamo",
                url: "sc_messenger/venus/flyby1/orb"
            }, {
                type: "dynamo",
                url: "sc_messenger/sun/3/orb"
            }, {
                type: "dynamo",
                url: "sc_messenger/venus/flyby2/orb"
            }, {
                type: "dynamo",
                url: "sc_messenger/sun/4/orb"
            }, {
                type: "dynamo",
                url: "sc_messenger/mercury/flyby1/orb"
            }, {
                type: "dynamo",
                url: "sc_messenger/sun/5/orb"
            }, {
                type: "dynamo",
                url: "sc_messenger/mercury/flyby2/orb"
            }, {
                type: "dynamo",
                url: "sc_messenger/sun/6/orb"
            }, {
                type: "dynamo",
                url: "sc_messenger/mercury/flyby3/orb"
            }, {
                type: "dynamo",
                url: "sc_messenger/sun/7/orb"
            }, {
                type: "dynamo",
                url: "sc_messenger/mercury/orb"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "mercury",
                    axis: s.Vector3.YAxis
                },
                secondary: {
                    type: "velocity",
                    target: "sc_messenger",
                    axis: s.Vector3.ZAxis
                }
            }, {
                type: "dynamo",
                url: "sc_messenger/ori"
            }]
        },
        sc_messenger_impact_site: {
            groups: ["mercury", "sc_messenger", "sites"],
            radius: .001,
            label: "MESSENGER Impact Site",
            parents: [[Number.NEGATIVE_INFINITY, "mercury"]],
            controllers: [{
                type: "fixed",
                llaOnSpheroid: new s.LatLonAlt(.9501527254431932,-2.615904550043192,-.910251923861324),
                coverage: [483694028.351, Number.POSITIVE_INFINITY]
            }]
        }
    })
}
, function(t, e, i) {
    "use strict";
    i.r(e);
    var s = i(5)
      , n = i(545)
      , o = i(657)
      , a = i(658);
    n.Entity.register({
        sc_juno: {
            groups: ["jupiter", "spacecraft"],
            occlusionRadius: .001732,
            extentsRadius: .01,
            label: "Juno",
            parents: [[365836752.1832, "earth"], [366088266.183, "sun"], [434433667.182, "earth"], [434793667.182, "sun"], [519652868.184, "jupiter"], [676339597, "ganymede"], [676381521, "jupiter"], [717700360, "europa"], [717727733, "jupiter"], [757191924, "io"], [757203571, "jupiter"], [760247560, "io"], [760262808, "jupiter"]],
            trail: {
                length: void 0,
                lengthCoverages: [[63072e3, Number.NEGATIVE_INFINITY, 519652868.184], [5184e3, 519652868.184, Number.POSITIVE_INFINITY]]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_juno/Juno.gltf",
                rotate: [{
                    x: 90
                }],
                shadowEntities: ["jupiter", "europa", "ganymede", "callisto", "io"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_juno/earth/launch/orb"
            }, {
                type: "dynamo",
                url: "sc_juno/sun/preflyby/orb"
            }, {
                type: "dynamo",
                url: "sc_juno/earth/flyby/orb"
            }, {
                type: "dynamo",
                url: "sc_juno/sun/postflyby/orb"
            }, {
                type: "dynamo",
                url: "sc_juno/jupiter/orb"
            }, {
                type: "dynamo",
                url: "sc_juno/ganymede/orb"
            }, {
                type: "dynamo",
                url: "sc_juno/europa/orb"
            }, {
                type: "dynamo",
                url: "sc_juno/io/1/orb"
            }, {
                type: "dynamo",
                url: "sc_juno/io/2/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity,
                coverage: [365836752.1832, Number.POSITIVE_INFINITY]
            }, {
                type: "dynamo",
                url: "sc_juno/ori"
            }, {
                type: "coverage",
                coverage: [393471366, 529749008],
                update: t => {
                    const e = t.getComponent(s.ModelComponent);
                    if (!e)
                        return;
                    const i = e.getThreeJsObjectByName("engine_cover");
                    if (!i)
                        return;
                    const n = t.getScene().getEngine().getTime()
                      , o = s.Sort.getIndex(n, l, ( (t, e) => t[1] < e))
                      , a = l[o][0]
                      , r = l[o][1]
                      , c = s.MathUtils.clamp01(((r - a) / 2 - Math.abs(n - (r + a) / 2)) / 600);
                    i.rotation.x = s.MathUtils.lerp(Math.PI, Math.PI / 8, c)
                }
                ,
                exit: t => {
                    const e = t.getComponent(s.ModelComponent);
                    if (!e)
                        return;
                    const i = e.getThreeJsObjectByName("engine_cover");
                    i && (i.rotation.x = Math.PI)
                }
            }, {
                type: "coverage",
                coverage: [399637867.183, 520959604.184],
                update: t => {
                    const e = t.getComponent(s.ParticleSprayComponent);
                    if (!e)
                        return;
                    const i = t.getScene().getEngine().getTime()
                      , n = s.Sort.getIndex(i, c, ( (t, e) => t[1] < e))
                      , o = c[n][0]
                      , a = c[n][1]
                      , r = o <= i && i < a;
                    e.setEnabled(r)
                }
                ,
                exit: t => {
                    const e = t.getComponent(s.ParticleSprayComponent);
                    e && e.setEnabled(!1)
                }
            }, {
                type: "coverage",
                coverage: [519652868.184, Number.POSITIVE_INFINITY],
                enter: t => {
                    const e = t.getComponent(s.TrailComponent);
                    e && e.setRelativeToEntity("jupiter")
                }
                ,
                exit: t => {
                    const e = t.getComponent(s.TrailComponent);
                    e && e.setRelativeToEntity("")
                }
            }],
            postCreateFunction: t => {
                const e = t.addController(o.KeyframePointingController);
                e.setKeyframes(h),
                e.setDirection(s.Vector3.ZAxis),
                e.setCoverage(new s.Interval(365836752.1832,521025625));
                const i = t.addController(a.KeyframeSpinController);
                i.setKeyframes(d),
                i.setAxis(s.Vector3.ZAxis),
                i.setCoverage(new s.Interval(365836752.1832,521025625)),
                i.setStartingAngle(-.96);
                const n = t.addComponent(s.ParticleSprayComponent);
                n.setNumberOfParticles(100),
                n.setSizeOfParticles(3e-4),
                n.setSpeedOfParticles(.01),
                n.setColorOfParticles(new s.Color(1,.75,0,.25)),
                n.setSpread(-3),
                n.setParticleSpacingRandom(!1),
                n.setLength(.003),
                n.setOriginOffset(new s.Vector3(0,0,-.0017)),
                n.setDirection(s.Vector3.ZAxisNeg),
                n.setEnabled(!1)
            }
        },
        sc_cassini: {
            groups: ["saturn", "spacecraft"],
            occlusionRadius: .0034,
            extentsRadius: .0055,
            label: "Cassini",
            parents: [[-69820368.42763124, "earth"], [-69537536.818, "sun"], [-53179136.814, "venus"], [-53092736.814, "sun"], [-16495135.816, "venus"], [-16451935.816, "sun"], [-11951935.817, "earth"], [-11660335.817, "sun"], [139219264.185, "saturn"], [558743640, ""]],
            dependents: ["sc_huygens"],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_cassini/Cassini.gltf",
                rotate: [{
                    x: -90
                }, {
                    z: 180
                }],
                shadowEntities: ["saturn", "titan", "enceladus", "mimas", "tethys"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_cassini/earth/launch/orb"
            }, {
                type: "dynamo",
                url: "sc_cassini/sun/1/orb"
            }, {
                type: "dynamo",
                url: "sc_cassini/venus/flyby1/orb"
            }, {
                type: "dynamo",
                url: "sc_cassini/sun/2/orb"
            }, {
                type: "dynamo",
                url: "sc_cassini/venus/flyby2/orb"
            }, {
                type: "dynamo",
                url: "sc_cassini/sun/3/orb"
            }, {
                type: "dynamo",
                url: "sc_cassini/earth/flyby/orb"
            }, {
                type: "dynamo",
                url: "sc_cassini/sun/4/orb"
            }, {
                type: "dynamo",
                url: "sc_cassini/saturn/orb"
            }, {
                type: "dynamo",
                url: "sc_cassini/quat"
            }, {
                type: "coverage",
                coverage: [-13098535.817, 534124760.143],
                update: t => {
                    const e = t.getComponent(s.ParticleSprayComponent);
                    if (!e)
                        return;
                    const i = t.getScene().getEngine().getTime()
                      , n = s.Sort.getIndex(i, r, ( (t, e) => t[1] < e))
                      , o = r[n][0]
                      , a = r[n][1]
                      , l = o <= i && i < a;
                    e.setEnabled(l)
                }
                ,
                exit: t => {
                    const e = t.getComponent(s.ParticleSprayComponent);
                    e && e.setEnabled(!1)
                }
            }, {
                type: "coverage",
                coverage: [157212064.184, Number.POSITIVE_INFINITY],
                enter: t => {
                    const e = t.getComponent(s.ModelComponent);
                    null !== e && e.setHiddenObject("huygens_probe", !0)
                }
                ,
                exit: t => {
                    const e = t.getComponent(s.ModelComponent);
                    null !== e && e.setHiddenObject("huygens_probe", !1)
                }
            }],
            postCreateFunction: t => {
                const e = t.addComponent(s.ParticleSprayComponent);
                e.setNumberOfParticles(50),
                e.setSizeOfParticles(3e-4),
                e.setSpeedOfParticles(.01),
                e.setColorOfParticles(new s.Color(1,.75,0,.25)),
                e.setSpread(-3),
                e.setParticleSpacingRandom(!1),
                e.setLength(.002),
                e.setOriginOffset(new s.Vector3(0,29e-5,.0033)),
                e.setDirection(s.Vector3.ZAxis),
                e.setEnabled(!1)
            }
        },
        sc_europa_clipper: {
            groups: ["jupiter", "europa", "ganymede", "callisto", "spacecraft"],
            occlusionRadius: .003,
            extentsRadius: .011,
            label: "Europa Clipper",
            parents: [[782194503, "earth"], [782641310, "sun"], [794086294, "mars"], [794230007, "sun"], [849407067, "earth"], [849810294, "sun"], [953991214, "jupiter"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_europa_clipper/europa_clipper.gltf",
                shadowEntities: ["jupiter", "earth", "mars", "europa"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_europa_clipper/earth/launch"
            }, {
                type: "dynamo",
                url: "sc_europa_clipper/sun"
            }, {
                type: "dynamo",
                url: "sc_europa_clipper/mars/flyby"
            }, {
                type: "dynamo",
                url: "sc_europa_clipper/earth/flyby"
            }, {
                type: "dynamo",
                url: "sc_europa_clipper/jupiter"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.YAxisNeg
                },
                secondary: {
                    type: "align",
                    target: "jupiter",
                    axis: s.Vector3.XAxisNeg,
                    targetAxis: s.Vector3.ZAxis
                }
            }, {
                type: "dynamo",
                url: "sc_europa_clipper/ori"
            }]
        },
        sc_galileo: {
            groups: ["jupiter", "spacecraft"],
            occlusionRadius: .003,
            extentsRadius: .0055,
            label: "Galileo",
            parents: [[-321964226.73959994, "earth"], [-321559829, "sun"], [-312199026, "venus"], [-311946958, "sun"], [-286252262, "earth"], [-285827020, "sun"], [-223105356, "earth"], [-222610262, "sun"], [-129268796, "jupiter"], [117442702, ""]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_galileo/galileo.gltf",
                shadowEntities: ["jupiter", "earth", "venus"],
                rotate: [{
                    x: -90
                }, {
                    z: 180
                }]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_galileo/earth/launch/orb"
            }, {
                type: "dynamo",
                url: "sc_galileo/sun/orb"
            }, {
                type: "dynamo",
                url: "sc_galileo/venus/flyby/orb"
            }, {
                type: "dynamo",
                url: "sc_galileo/earth/flyby1/orb"
            }, {
                type: "dynamo",
                url: "sc_galileo/earth/flyby2/orb"
            }, {
                type: "dynamo",
                url: "sc_galileo/jupiter/orb"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "mercury",
                    axis: s.Vector3.ZAxisNeg
                },
                secondary: {
                    type: "align",
                    axis: s.Vector3.YAxis,
                    target: "earth",
                    targetAxis: s.Vector3.ZAxis
                }
            }, {
                type: "dynamo",
                url: "sc_galileo/quat"
            }],
            postCreateFunction: t => {
                const e = t.addController(s.SpinController);
                e.setJoint("spinning_section"),
                e.setRate(6 * Math.PI / 60),
                e.setAxis(s.Vector3.YAxisNeg, !0)
            }
        },
        sc_galileo_probe: {
            groups: ["jupiter", "spacecraft"],
            radius: 72e-5,
            label: "Galileo Probe",
            parents: [[-321964226.73959994, "sc_galileo"], [-129268796, "jupiter"], [-128353980, ""]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_galileo_probe/galileo_probe.gltf",
                rotate: [{
                    x: -90
                }]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_galileo_probe/galileo/orb"
            }, {
                type: "dynamo",
                url: "sc_galileo_probe/jupiter/orb"
            }, {
                type: "fixed",
                position: s.Vector3.Zero,
                orientation: s.Quaternion.Identity,
                coverage: [-321964226.73959994, -141114537.48322043]
            }, {
                type: "coverage",
                coverage: [Number.NEGATIVE_INFINITY, -141114537.48322043],
                enter: t => {
                    const e = t.getComponent(s.DivComponent);
                    null !== e && e.setEnabled(!1);
                    const i = t.getComponent(s.TrailComponent);
                    null !== i && i.setEnabled(!1);
                    const n = t.getController(s.TranslateController);
                    n && n.setTranslation(new s.Vector3(0,0,.001))
                }
                ,
                exit: t => {
                    const e = t.getComponent(s.DivComponent);
                    null !== e && e.setEnabled(!0);
                    const i = t.getComponent(s.TrailComponent);
                    null !== i && i.setEnabled(!0);
                    const n = t.getController(s.TranslateController);
                    n && n.setTranslation(new s.Vector3(-16e-6,24e-6,7e-4))
                }
            }],
            postCreateFunction: t => {
                const e = t.getComponent(s.ModelComponent);
                if (!e)
                    return;
                e.setTranslation(new s.Vector3(0,0,-.001));
                const i = t.addController(s.TranslateController);
                i.setTranslation(new s.Vector3(-16e-6,24e-6,7e-4)),
                i.setRelativeToOrientation(!0),
                i.setCoverage(new s.Interval(-321964226.73959994,-128353980));
                t.addController(s.RotateByEntityOrientationController).setCoverage(new s.Interval(-321964226.73959994,-141114537.48322043));
                const n = t.addController(s.FixedController);
                n.setOrientation(new s.Quaternion(.40004226980201746,.3894033591393042,-.7928008139628516,.24453645053961984)),
                n.setCoverage(new s.Interval(-141114537.48322043,Number.POSITIVE_INFINITY))
            }
        },
        sc_huygens: {
            groups: ["saturn", "spacecraft", "titan"],
            occlusionRadius: .0013,
            extentsRadius: .0013,
            label: "Huygens",
            parents: [[157212064.184, "saturn"], [158945582, "titan"], [158974766.184, ""]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_huygens/Huygens.gltf",
                rotate: [{
                    x: -90
                }, {
                    z: 180
                }],
                shadowEntities: ["saturn", "titan", "enceladus", "mimas", "tethys"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_huygens/saturn/orb"
            }, {
                type: "dynamo",
                url: "sc_huygens/titan/orb"
            }, {
                type: "fixed",
                orientation: new s.Quaternion(.8295521744501194,.09912464029342342,-.04158756948048668,-.5479853735424731)
            }, {
                type: "custom",
                func: t => {
                    const e = t.addController(s.KeyframeController);
                    return e.addPositionKeyframe(158965616.707, new s.Vector3(-74.84608000701567,-3832.0774028380238,-305.9513410781612)),
                    e.addPositionKeyframe(158965667.7750001, new s.Vector3(-168.19015737501377,-3541.733393771429,-291.12326824195395)),
                    e.addPositionKeyframe(158965894.184, new s.Vector3(-376.8992769951708,-2686.9622048526126,-273.33138256355716)),
                    e
                }
            }, {
                type: "custom",
                func: t => {
                    const e = t.addController(s.KeyframeController);
                    return e.addPositionKeyframe(158965894.184, new s.Vector3(-376.8992769951708,-2686.9622048526126,-273.33138256355716)),
                    e.addPositionKeyframe(158974766.184, new s.Vector3(-251.2479743710496,-2548.813556954952,-266.5500089234507)),
                    e
                }
            }, {
                type: "custom",
                func: t => {
                    const e = t.addController(s.TranslateController);
                    return e.setTranslation(new s.Vector3(-.0013,0,.0011)),
                    e.setRelativeToOrientation(!0),
                    e.setCoverage(new s.Interval(157212064.184,158974766.184)),
                    e
                }
            }, {
                type: "custom",
                func: t => {
                    const e = t.addController(a.KeyframeSpinController);
                    return e.setKeyframes(u),
                    e.setAxis(s.Vector3.XAxisNeg),
                    e.setCoverage(new s.Interval(157212064.184,Number.POSITIVE_INFINITY)),
                    e
                }
            }, {
                type: "coverage",
                coverage: [158965616.707, Number.POSITIVE_INFINITY],
                enter: t => {
                    const e = t.getComponent(s.TrailComponent);
                    null !== e && e.setRelativeToEntityOrientation(!0)
                }
                ,
                exit: t => {
                    const e = t.getComponent(s.TrailComponent);
                    null !== e && e.setRelativeToEntityOrientation(!1)
                }
            }],
            postCreateFunction: t => {
                const e = t.getComponent(s.ModelComponent);
                e && e.setTranslation(new s.Vector3(.0013,0,-.0011))
            }
        },
        sc_huygens_landing_site: {
            groups: ["titan", "sc_huygens", "sites"],
            radius: .001,
            systemRadius: 200,
            label: "Huygens Landing Site",
            parents: [[157212064.184, "titan"]],
            controllers: [{
                type: "fixed",
                llaOnSpheroid: new s.LatLonAlt(-.18453331247520502,2.9263055188728955,0),
                coverage: [157212064.184, Number.POSITIVE_INFINITY]
            }]
        },
        sc_juice: {
            groups: ["jupiter", "ganymede", "spacecraft"],
            occlusionRadius: .007,
            extentsRadius: .0135,
            label: "JUICE",
            parents: [[734748207, "earth"], [735606318, "sun"], [777026548, "earth"], [778061110, "sun"], [809697014, "venus"], [810162491, "sun"], [843697642, "earth"], [844049179, "sun"], [916393497, "earth"], [916903199, "sun"], [994471790, "jupiter"], [1103217877, "ganymede"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_juice/juice.gltf",
                shadowEntities: ["ganymede", "jupiter", "earth"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_juice/earth/launch"
            }, {
                type: "dynamo",
                url: "sc_juice/sun"
            }, {
                type: "dynamo",
                url: "sc_juice/earth/flyby1"
            }, {
                type: "dynamo",
                url: "sc_juice/venus/flyby"
            }, {
                type: "dynamo",
                url: "sc_juice/earth/flyby2"
            }, {
                type: "dynamo",
                url: "sc_juice/earth/flyby3"
            }, {
                type: "dynamo",
                url: "sc_juice/jupiter"
            }, {
                type: "dynamo",
                url: "sc_juice/ganymede"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.XAxisNeg
                },
                secondary: {
                    type: "align",
                    target: "sun",
                    axis: s.Vector3.YAxisNeg,
                    targetAxis: s.Vector3.ZAxis
                }
            }, {
                type: "dynamo",
                url: "sc_juice/quat"
            }]
        },
        sc_pioneer_10: {
            groups: ["sun", "jupiter", "spacecraft"],
            occlusionRadius: .002118055,
            extentsRadius: .003,
            label: "Pioneer 10",
            parents: [[-878291717.8145751, "earth"], [-878146409, "sun"], [-824046472, "jupiter"], [-822011429, "sun"]],
            trail: {
                length: 31536e4
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_pioneer/pioneer.gltf",
                rotate: [{
                    x: 90
                }]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_pioneer_10/earth/orb"
            }, {
                type: "dynamo",
                url: "sc_pioneer_10/sun/1/orb"
            }, {
                type: "dynamo",
                url: "sc_pioneer_10/jupiter/orb"
            }, {
                type: "dynamo",
                url: "sc_pioneer_10/sun/2/orb"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.YAxis
                }
            }]
        },
        sc_pioneer_11: {
            groups: ["sun", "jupiter", "saturn", "spacecraft"],
            occlusionRadius: .002118055,
            extentsRadius: .003,
            label: "Pioneer 11",
            parents: [[-843816855.8143449, "earth"], [-843644357, "sun"], [-792658454, "jupiter"], [-790152245, "sun"], [-643302619, "saturn"], [-640194311, "sun"]],
            trail: {
                length: 31536e4
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_pioneer/pioneer.gltf",
                rotate: [{
                    x: 90
                }]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_pioneer_11/earth/orb"
            }, {
                type: "dynamo",
                url: "sc_pioneer_11/sun/1/orb"
            }, {
                type: "dynamo",
                url: "sc_pioneer_11/jupiter/orb"
            }, {
                type: "dynamo",
                url: "sc_pioneer_11/sun/2/orb"
            }, {
                type: "dynamo",
                url: "sc_pioneer_11/saturn/orb"
            }, {
                type: "dynamo",
                url: "sc_pioneer_11/sun/3/orb"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.YAxis
                }
            }]
        },
        sc_voyager_1: {
            groups: ["jupiter", "saturn", "sun", "spacecraft"],
            occlusionRadius: .00183,
            extentsRadius: .0043,
            label: "Voyager 1",
            parents: [[-704412035.617, "earth"], [-703530245, "sun"], [-660264745, "jupiter"], [-655057463, "sun"], [-606239665, "saturn"], [-600733702, "sun"]],
            trail: {
                length: 94608e4,
                lengthCoverages: [[15768e4, Number.NEGATIVE_INFINITY, 377123932.454], [94608e4, 377123932.454, Number.POSITIVE_INFINITY], [5184e3, -660264745, -655057463], [5184e3, -606239665, -600733702]]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_voyager/Voyager.gltf",
                rotate: [{
                    x: -90
                }, {
                    z: 180
                }]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_voyager_1/earth/orb"
            }, {
                type: "dynamo",
                url: "sc_voyager_1/sun/1/orb"
            }, {
                type: "dynamo",
                url: "sc_voyager_1/jupiter/orb"
            }, {
                type: "dynamo",
                url: "sc_voyager_1/sun/2/orb"
            }, {
                type: "dynamo",
                url: "sc_voyager_1/saturn/orb"
            }, {
                type: "dynamo",
                url: "sc_voyager_1/sun/3/orb"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.ZAxisNeg
                }
            }, {
                type: "dynamo",
                url: "sc_voyager_1/quat"
            }]
        },
        sc_voyager_2: {
            groups: ["jupiter", "saturn", "uranus", "neptune", "sun", "spacecraft"],
            occlusionRadius: .00183,
            extentsRadius: .0043,
            label: "Voyager 2",
            parents: [[-705788847.817, "earth"], [-704774613, "sun"], [-650828783, "jupiter"], [-642276063, "sun"], [-582886481, "saturn"], [-574538624, "sun"], [-440395228, "uranus"], [-439259319, "sun"], [-327233138, "neptune"], [-326252606, "sun"]],
            trail: {
                length: 94608e4,
                lengthCoverages: [[15768e4, Number.NEGATIVE_INFINITY, 651751314.724], [94608e4, 651751314.724, Number.POSITIVE_INFINITY], [5184e3, -650828783, -642276063], [5184e3, -582886481, -574538624], [5184e3, -440395228, -439259319], [5184e3, -327233138, -326252606]]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_voyager/Voyager.gltf",
                rotate: [{
                    x: -90
                }, {
                    z: 180
                }]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_voyager_2/earth/orb"
            }, {
                type: "dynamo",
                url: "sc_voyager_2/sun/1/orb"
            }, {
                type: "dynamo",
                url: "sc_voyager_2/jupiter/orb"
            }, {
                type: "dynamo",
                url: "sc_voyager_2/sun/2/orb"
            }, {
                type: "dynamo",
                url: "sc_voyager_2/saturn/orb"
            }, {
                type: "dynamo",
                url: "sc_voyager_2/sun/3/orb"
            }, {
                type: "dynamo",
                url: "sc_voyager_2/uranus/orb"
            }, {
                type: "dynamo",
                url: "sc_voyager_2/sun/4/orb"
            }, {
                type: "dynamo",
                url: "sc_voyager_2/neptune/orb"
            }, {
                type: "dynamo",
                url: "sc_voyager_2/sun/5/orb"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.ZAxisNeg
                }
            }, {
                type: "dynamo",
                url: "sc_voyager_2/quat"
            }]
        }
    });
    const r = [[-13098535.817, -13098146.797], [-12342535.817, -12342421.197], [-10612735.817, -10612663.357], [14274064.185, 14274070.255], [36653454.185, 36653459.605], [71128864.186, 71128875.066], [105091264.185, 105091282.755], [118339264.182, 118339287.092], [138968824.185, 138969181.735], [140692084.184, 140692123.174], [141916392.184, 141922237.024], [146548444.183, 146551498.073], [147846664.183, 147846668.693], [152302564.182, 152302569.842], [154285264.183, 154285267.193], [156518584.184, 156518669.274], [157466284.184, 157466438.074], [159139264.184, 159139404.074], [160168144.185, 160168264.795], [161978464.185, 161978469.745], [163011064.185, 163011104.295], [163869664.186, 163869667.996], [164528404.186, 164528414.466], [165853384.186, 165853391.046], [166370464.186, 166370502.696], [168008344.186, 168008476.766], [174127084.184, 174127086.454], [176341864.183, 176341881.793], [176952124.183, 176952139.533], [178261744.183, 178261753.433], [178699444.183, 178699535.673], [180420064.182, 180420240.372], [182368684.182, 182368777.962], [184039204.183, 184039282.793], [185162584.183, 185162597.343], [196273205.186, 196273208.936], [197566385.186, 197566387.476], [199978145.185, 199978148.205], [202994705.185, 202994717.245], [207734765.183, 207734800.073], [211183265.182, 211183306.302], [211500485.182, 211500537.082], [212965745.182, 212965786.692], [214371665.182, 214371670.582], [216354545.183, 216354568.983], [219456245.183, 219456251.063], [219887345.184, 219887389.034], [220835165.184, 220835169.094], [221266265.184, 221266275.434], [222644225.185, 222644240.975], [224109485.185, 224109487.885], [226090325.185, 226090329.355], [227038025.186, 227038032.946], [227469065.186, 227469075.266], [228387005.186, 228387008.496], [228846905.186, 228846923.006], [230225585.186, 230225608.176], [231577265.185, 231577300.725], [232982885.185, 232982919.625], [233930525.185, 233930529.665], [234334565.185, 234334641.855], [235309205.185, 235309210.915], [235740245.184, 235740294.424], [239704565.183, 239704568.933], [242004965.183, 242004968.253], [242979665.182, 242979748.272], [244876985.182, 244876993.442], [247203665.183, 247203671.283], [248986685.183, 248986692.503], [249417845.183, 249417942.863], [250365665.183, 250365669.503], [250801865.183, 250801924.453], [252201785.184, 252201798.884], [253728965.184, 253728983.974], [255535625.185, 255535853.415], [256682225.185, 256682228.065], [257684225.185, 257684269.165], [258146525.185, 258146533.105], [258722525.186, 258722543.076], [261147905.186, 261147925.516], [262453685.186, 262453688.326], [264259265.185, 264259272.395], [267474305.184, 267474379.954], [271073765.183, 271073780.663], [272731805.183, 272731887.753], [275208605.182, 275208611.692], [276214805.182, 276214829.892], [277127525.182, 277127545.362], [277506665.182, 277506708.062], [279455045.183, 279455100.823], [279799805.183, 279799837.073], [280747565.183, 280747571.013], [282126485.183, 282126503.483], [282471245.183, 282471256.053], [286040946.185, 286040974.915], [287532306.185, 287532308.475], [289858866.186, 289858897.046], [291603966.186, 291603971.806], [292809906.186, 292809948.366], [294188586.186, 294188602.066], [295567266.185, 295567279.505], [296945946.185, 296945956.015], [297893586.185, 297893599.995], [299272206.184, 299272220.614], [300687786.184, 300687808.034], [302066526.183, 302066563.313], [303703506.183, 303703583.793], [304824006.183, 304824009.283], [305390946.183, 305390972.583], [308925306.182, 308925311.352], [309355506.182, 309355530.682], [310684866.183, 310684869.093], [312200586.183, 312200601.223], [534124756.143, 534124760.143]]
      , l = [[393471366, 393501486], [399019747, 399883447], [400569547, 400988887], [420541747, 420794647], [454490527, 454650187], [487136707, 487309687], [519804068, 521041748], [528958868, 529749008]]
      , c = [[399637867.183, 399639659.183], [400933867.182, 400935660.182], [420714067.185, 420714072.185], [454572067.185, 454572072.185], [487231267.185, 487231272.185], [520957868.184, 520959604.184]]
      , h = [[365835906, "velocity"], [365836206, "sun"], [371908866, "sun"], [371909466, "earth"], [399631646, "earth"], [399632628, "sun"], [399635271, "sun"], [399636306, "-velocity"], [399640481, "-velocity"], [399641686, "sun"], [399700717, "sun"], [399641887, "earth"], [400927646, "earth"], [400928454, "sun"], [400931272, "sun"], [400932282, "-velocity"], [400936477, "-velocity"], [400937632, "sun"], [401003197, "sun"], [401009197, "earth"], [423014467, "earth"], [423014767, "sun"], [436924867, "sun"], [436925167, "earth"], [520954868, "earth"], [520955888, "-velocity"], [520960808, "-velocity"], [520962008, "sun"], [521018048, "sun"], [521025625, "earth"]]
      , d = [[394545667, 1 * Math.PI / 30], [394545967, 2 * Math.PI / 30], [399636967, 2 * Math.PI / 30], [399637264, 5 * Math.PI / 30], [399637866, 5 * Math.PI / 30], [399639659, 5.5 * Math.PI / 30], [399639788, 5.5 * Math.PI / 30], [399640072, 2 * Math.PI / 30], [400932921, 2 * Math.PI / 30], [400933214, 5 * Math.PI / 30], [400933866, 5 * Math.PI / 30], [400935660, 5.5 * Math.PI / 30], [400935790, 5.5 * Math.PI / 30], [400936068, 2 * Math.PI / 30], [520956548, 2 * Math.PI / 30], [520956848, 5 * Math.PI / 30], [520960088, 5 * Math.PI / 30], [520960388, 2 * Math.PI / 30], [521025625, 2 * Math.PI / 30]]
      , u = [[157212064.184, 7.5 * Math.PI / 30], [158965863.184, 7.5 * Math.PI / 30], [158966163.184, 2.6 * Math.PI / 30], [158966434.184, 0], [158966883.184, -5.6 * Math.PI / 30], [158967123.184, -9.7 * Math.PI / 30], [158967363.184, -7.3 * Math.PI / 30], [158968263.184, -2.8 * Math.PI / 30], [158973723.184, -1 * Math.PI / 30]]
}
, function(t, e, i) {
    "use strict";
    i.r(e);
    var s = i(5)
      , n = i(681);
    i(545).Entity.register({
        sc_dart: {
            groups: ["small body spacecraft", "asteroid spacecraft", "65803_didymos", "dimorphos", "spacecraft"],
            occlusionRadius: .0012,
            extentsRadius: .00625,
            label: "DART",
            parents: [[691007069, "earth"], [691418893, "sun"], [717454117, "65803_didymos"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_dart/dart.gltf",
                shadowEntities: ["earth"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_dart/earth/orb"
            }, {
                type: "dynamo",
                url: "sc_dart/sun/orb"
            }, {
                type: "dynamo",
                url: "sc_dart/65803_didymos/pos"
            }, {
                type: "custom",
                func: t => {
                    const e = t.addController(s.KeyframeController);
                    return e.addPositionKeyframe(717503237, new s.Vector3(-10320.163052194115,13421.106828492655,5349.381737812169)),
                    e.addPositionKeyframe(717506127.238318, new s.Vector3(-.9047084058613565,-.7147384471771195,-.30125475602973617)),
                    e
                }
            }, {
                type: "align",
                primary: {
                    type: "velocity",
                    target: "sc_dart",
                    axis: s.Vector3.ZAxisNeg
                },
                secondary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.YAxis
                },
                coverage: [Number.NEGATIVE_INFINITY, 717454117]
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "dimorphos",
                    axis: s.Vector3.ZAxisNeg
                },
                secondary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.YAxis
                },
                coverage: [717454117, Number.POSITIVE_INFINITY]
            }]
        },
        sc_dawn: {
            groups: ["small body spacecraft", "asteroid spacecraft", "dwarf planet spacecraft", "4_vesta", "1_ceres", "spacecraft"],
            occlusionRadius: 885e-6,
            extentsRadius: .00985,
            label: "Dawn",
            parents: [[244168849.8323595, "earth"], [244461608, "sun"], [288169447, "mars"], [288210177, "sun"], [363182466, "4_vesta"], [400075267, "sun"], [476712067, "1_ceres"], [594302469.184, ""]],
            trail: {
                length: 659889.75
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_dawn/model.gltf",
                rotate: [{
                    z: -90
                }]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_dawn/earth/orb"
            }, {
                type: "dynamo",
                url: "sc_dawn/sun/1/orb"
            }, {
                type: "dynamo",
                url: "sc_dawn/mars/orb"
            }, {
                type: "dynamo",
                url: "sc_dawn/sun/2/orb"
            }, {
                type: "dynamo",
                url: "sc_dawn/vesta/orb"
            }, {
                type: "dynamo",
                url: "sc_dawn/sun/3/orb"
            }, {
                type: "dynamo",
                url: "sc_dawn/ceres/orb"
            }, {
                type: "fixed",
                orientation: new s.Quaternion(.9999478154504517,.008904517167862874,.004868284692665544,-.0011729254143642916),
                coverage: [244168849.8323595, 244171353.18400002]
            }, {
                type: "dynamo",
                url: "sc_dawn/ori"
            }]
        },
        sc_deep_impact: {
            groups: ["small body spacecraft", "comet spacecraft", "9p_tempel_1", "103p_hartley_2", "spacecraft"],
            occlusionRadius: .00165,
            extentsRadius: .003,
            label: "Deep Impact",
            parents: [[158829812.068274, "earth"], [159287744, "sun"], [173560752, "9p_tempel_1"], [173923158, "sun"], [251798121, "earth"], [253531474, "sun"], [282984399, "earth"], [285405903, "sun"], [330384030, "earth"], [331534813, "sun"], [342017751, "103p_hartley_2"], [342368983, "sun"], [429192067, ""]],
            trail: {
                length: 47421459,
                lengthCoverages: [[362406, 173560752, 173923158], [1733353, 251798121, 253531474], [2421504, 282984399, 285405903], [1150783, 330384030, 331534813], [351232, 342017751, 342368983]]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_deep_impact/deep_impact_wo_impactor.gltf",
                rotate: [{
                    y: -90
                }]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_deep_impact/earth/launch/orb"
            }, {
                type: "dynamo",
                url: "sc_deep_impact/sun/orb"
            }, {
                type: "dynamo",
                url: "sc_deep_impact/9p_tempel_1/pos"
            }, {
                type: "dynamo",
                url: "sc_deep_impact/earth/flyby1/orb"
            }, {
                type: "dynamo",
                url: "sc_deep_impact/earth/flyby2/orb"
            }, {
                type: "dynamo",
                url: "sc_deep_impact/earth/flyby3/orb"
            }, {
                type: "dynamo",
                url: "sc_deep_impact/103p_hartley_2/pos"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }, {
                type: "dynamo",
                url: "sc_deep_impact/quat"
            }]
        },
        sc_deep_impact_impactor: {
            groups: ["small body spacecraft", "comet spacecraft", "9p_tempel_1", "sc_deep_impact", "spacecraft"],
            occlusionRadius: .001,
            extentsRadius: .001,
            label: "Deep Impact Impactor",
            parents: [[158829812.068274, "sc_deep_impact"], [173642464.18400002, "9p_tempel_1"], [173727938.18158135, ""]],
            trail: {
                length: 27830
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_deep_impact_impactor/deep_impact_impactor.gltf",
                rotate: [{
                    y: -90
                }]
            },
            controllers: [{
                type: "custom",
                func: t => {
                    const e = t.addController(s.KeyframeController);
                    return e.addPositionKeyframe(173642464.18400002, new s.Vector3(-713e-6,-55e-6,0), "sc_deep_impact", void 0, "sc_deep_impact"),
                    e.addPositionKeyframe(173656621.40411958, new s.Vector3(-123095.24746842826,-48294.70341251187,61743.99881253781), "sc_deep_impact", 173642464.18400002),
                    e.addPositionKeyframe(173727938.18158135, new s.Vector3(1.580046751199936,3.178179950746365,-.628457454223176)),
                    e
                }
            }, {
                type: "fixed",
                position: new s.Vector3(-713e-6,-55e-6,0),
                orientation: s.Quaternion.Identity,
                relativeToEntity: "sc_deep_impact",
                coverage: [158829812.068274, 173642464.18400002]
            }, {
                type: "fixed",
                orientation: new s.Quaternion(.9060465048532422,.3173702681972099,.2649483984949708,.09032269948692226),
                coverage: [173642464.18400002, Number.POSITIVE_INFINITY]
            }, {
                type: "dynamo",
                url: "sc_deep_impact_impactor/quat",
                coverage: [173642464.18400002, Number.POSITIVE_INFINITY]
            }]
        },
        sc_deep_impact_impactor_impact_site: {
            groups: ["small body sites", "comet sites", "9p_tempel_1", "sc_deep_impact", "sc_deep_impact_impactor", "sites"],
            radius: .001,
            label: "Deep Impact Impactor Impact Site",
            parents: [[173727938.18158135, "9p_tempel_1"]],
            controllers: [{
                type: "fixed",
                position: new s.Vector3(3.1153282512332603,-1.2860729555237982,-1.277920399403075),
                orientation: s.Quaternion.Identity,
                relativeToEntity: "9p_tempel_1",
                coverage: [173727938.18158135, Number.POSITIVE_INFINITY]
            }]
        },
        sc_deep_space_1: {
            groups: ["small body spacecraft", "asteroid spacecraft", "9969_braille", "spacecraft"],
            occlusionRadius: .00125,
            extentsRadius: .005,
            label: "Deep Space 1",
            parents: [[-37470248, "earth"], [-36628312, "sun"], [-13523799, "9969_braille"], [-13496699, "sun"], [54458637, "19p_borrelly"], [54476825, "sun"], [61977664.184, ""]],
            trail: {
                length: 40845609,
                lengthCoverages: [[27100, -13523799, -13496699], [18188, 54458637, 54476825]]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_deep_space_1/deep_space_1.gltf",
                rotate: [{
                    x: 90
                }, {
                    z: 90
                }]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_deep_space_1/earth/orb"
            }, {
                type: "dynamo",
                url: "sc_deep_space_1/sun/orb"
            }, {
                type: "dynamo",
                url: "sc_deep_space_1/9969_braille/pos"
            }, {
                type: "dynamo",
                url: "sc_deep_space_1/19p_borrelly/pos"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    axis: s.Vector3.XAxis,
                    target: "earth"
                },
                secondary: {
                    type: "point",
                    axis: s.Vector3.ZAxisNeg,
                    target: "sun"
                }
            }, {
                type: "dynamo",
                url: "sc_deep_space_1/quat"
            }]
        },
        sc_near_shoemaker: {
            groups: ["small body spacecraft", "asteroid spacecraft", "253_mathilde", "433_eros", "spacecraft"],
            occlusionRadius: .002,
            extentsRadius: .0034,
            label: "NEAR",
            parents: [[-122129937, "sun"], [-61397606, "earth"], [-60793811, "sun"], [-79403925, "253_mathilde"], [-79210250, "sun"], [-8425610, "433_eros"], [36675809.3654, ""]],
            trail: {
                length: 63919069,
                lengthCoverages: [[4e5, -8425610, 35279032.137], [0, 35279032.137, Number.POSITIVE_INFINITY]]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_near_shoemaker/near.gltf",
                rotate: [{
                    x: 90
                }, {
                    z: 135
                }]
            },
            controllers: [{
                type: "custom",
                func: t => {
                    const e = t.addController(s.OrbitalElementsController)
                      , i = new s.OrbitalElements;
                    return i.eccentricity = .3722732412046076,
                    i.epoch = -122129937,
                    i.semiMajorAxis = 235420679.8644008,
                    i.orbitOrientation.set(.25408339907533106, .05463135384055627, -.18986948069810847, .9467875272685549),
                    i.meanAngularMotion = 1.0085301888805118e-7,
                    i.meanAnomalyAtEpoch = -.005941352116228519,
                    e.addOrbitalElements(-122129937, i),
                    e.addOrbitalElements(-113227200, i),
                    e.setCoverage(new s.Interval(-122129937,-113227200)),
                    e
                }
            }, {
                type: "dynamo",
                url: "sc_near_shoemaker/sun/orb"
            }, {
                type: "dynamo",
                url: "sc_near_shoemaker/earth/flyby/orb"
            }, {
                type: "dynamo",
                url: "sc_near_shoemaker/253_mathilde/pos"
            }, {
                type: "dynamo",
                url: "sc_near_shoemaker/433_eros/orb"
            }, {
                type: "fixed",
                orientation: new s.Quaternion(.5052018803124495,-.11842169431143575,.7652511949887616,-.3809697770341459),
                coverage: [-122129937, -121953528.049046]
            }, {
                type: "dynamo",
                url: "sc_near_shoemaker/quat"
            }, {
                type: "fixed",
                position: new s.Vector3(.930389249841349,4.935129554115763,-4.002004469114965),
                orientation: new s.Quaternion(.11222410400554989,.7066112547219852,-.6897721372150081,.11099857612696495),
                coverage: [35279032.137, 36675809.3654]
            }, {
                type: "rotateByEntityOrientation",
                coverage: [35279032.137, 36675809.3654]
            }]
        },
        sc_near_shoemaker_landing_site: {
            groups: ["433_eros", "sc_near_shoemaker", "sites"],
            radius: .001,
            systemRadius: 200,
            label: "NEAR Shoemaker Landing Site",
            parents: [[36675809.3654, "433_eros"]],
            controllers: [{
                type: "fixed",
                position: new s.Vector3(.930389249841349,4.935129554115763,-4.002004469114965),
                orientation: new s.Quaternion(.11222410400554989,.7066112547219852,-.6897721372150081,.11099857612696495),
                relativeToEntity: "433_eros",
                coverage: [36675809.3654, Number.POSITIVE_INFINITY]
            }]
        },
        sc_lucy: {
            groups: ["small body spacecraft", "asteroid spacecraft", "52246_donaldjohanson", "3548_eurybates", "15094_polymele", "11351_leucus", "21900_orus", "617_patroclus", "menoetius", "spacecraft"],
            occlusionRadius: .002,
            extentsRadius: .007125,
            label: "Lucy",
            parents: [[687656642.763, "earth"], [687915086, "sun"], [718960993, "earth"], [719531941, "sun"], [787134972, "earth"], [787532222, "sun"], [798252820, "52246_donaldjohanson"], [798584539, "sun"], [870652086, "3548_eurybates"], [872642047, "sun"], [872642047, "15094_polymele"], [875308504, "sun"], [891166024, "11351_leucus"], [894761809, "sun"], [909384911, "21900_orus"], [912190135, "sun"], [977590306, "earth"], [978108682, "sun"], [1046169596, "617_patroclus_barycenter"], [1047892376, "sun"]],
            dependents: ["152830_dinkinesh"],
            trail: {
                length: 63919069,
                lengthCoverages: [[570948, 718960993, 719531941], [397250, 787134972, 787532222], [331719, 798252820, 798584539], [1989961, 870652086, 872642047], [2666457, 872642047, 875308504], [3595785, 891166024, 894761809], [2805224, 909384911, 912190135], [518376, 977590306, 978108682], [1722780, 1046169596, 1047892376]]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_lucy/lucy.gltf",
                rotate: [{
                    x: 90
                }, {
                    z: 90
                }]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_lucy/earth/launch/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }, {
                type: "dynamo",
                url: "sc_lucy/sun/orb"
            }, {
                type: "dynamo",
                url: "sc_lucy/earth/flyby1/orb"
            }, {
                type: "dynamo",
                url: "sc_lucy/earth/flyby2/orb"
            }, {
                type: "dynamo",
                url: "sc_lucy/52246_donaldjohanson/pos"
            }, {
                type: "dynamo",
                url: "sc_lucy/3548_eurybates/pos"
            }, {
                type: "dynamo",
                url: "sc_lucy/15094_polymele/pos"
            }, {
                type: "dynamo",
                url: "sc_lucy/11351_leucus/pos"
            }, {
                type: "dynamo",
                url: "sc_lucy/21900_orus/pos"
            }, {
                type: "dynamo",
                url: "sc_lucy/earth/flyby3/orb"
            }, {
                type: "dynamo",
                url: "sc_lucy/617_patroclus/pos"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    axis: s.Vector3.XAxis,
                    target: "earth"
                },
                secondary: {
                    type: "align",
                    axis: s.Vector3.YAxis,
                    target: "sun",
                    targetAxis: s.Vector3.ZAxis
                }
            }, {
                type: "dynamo",
                url: "sc_lucy/quat"
            }]
        },
        sc_new_horizons: {
            groups: ["small body spacecraft", "dwarf planet spacecraft", "TNO spacecraft", "134340_pluto", "486958_arrokoth", "spacecraft"],
            occlusionRadius: .00135,
            extentsRadius: .0026,
            label: "New Horizons",
            parents: [[190972278.33046317, "earth"], [191055829, "sun"], [225619606, "jupiter"], [226100665, "sun"], [490130161, "134340_pluto"], [490167848, "sun"], [598753684, "486958_arrokoth"], [600203601, "sun"]],
            trail: {
                length: 94608e3
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_new_horizons/new_horizons.gltf",
                rotate: [{
                    y: 90
                }]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_new_horizons/earth/orb"
            }, {
                type: "dynamo",
                url: "sc_new_horizons/sun/1/orb"
            }, {
                type: "dynamo",
                url: "sc_new_horizons/jupiter/orb"
            }, {
                type: "dynamo",
                url: "sc_new_horizons/sun/2/orb"
            }, {
                type: "dynamo",
                url: "sc_new_horizons/pluto/orb"
            }, {
                type: "dynamo",
                url: "sc_new_horizons/sun/3/pos"
            }, {
                type: "dynamo",
                url: "sc_new_horizons/mu69/pos"
            }, {
                type: "dynamo",
                url: "sc_new_horizons/sun/4/pos"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.YAxis
                }
            }, {
                type: "dynamo",
                url: "sc_new_horizons/ori/1"
            }, {
                type: "dynamo",
                url: "sc_new_horizons/ori/2"
            }]
        },
        sc_rosetta: {
            groups: ["small body spacecraft", "comet spacecraft", "67p_churyumov_gerasimenko", "spacecraft"],
            occlusionRadius: .0014,
            extentsRadius: .016,
            label: "Rosetta",
            parents: [[131491581.583, "earth"], [131901500, "sun"], [162704887, "earth"], [163831232, "sun"], [225623375, "mars"], [225657862, "sun"], [248111015, "earth"], [248475560, "sun"], [311055929, "earth"], [311664877, "sun"], [452394238, "67p_churyumov_gerasimenko"], [528503957.968, ""]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_rosetta/rosettaPhilae.gltf",
                rotate: [{
                    x: 180
                }, {
                    z: 90
                }]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_rosetta/earth/launch/orb"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }, {
                type: "dynamo",
                url: "sc_rosetta/sun/1/orb"
            }, {
                type: "dynamo",
                url: "sc_rosetta/earth/flyby1/orb"
            }, {
                type: "dynamo",
                url: "sc_rosetta/sun/2/orb"
            }, {
                type: "dynamo",
                url: "sc_rosetta/mars/flyby/orb"
            }, {
                type: "dynamo",
                url: "sc_rosetta/sun/3/orb"
            }, {
                type: "dynamo",
                url: "sc_rosetta/earth/flyby2/orb"
            }, {
                type: "dynamo",
                url: "sc_rosetta/sun/4/orb"
            }, {
                type: "dynamo",
                url: "sc_rosetta/earth/flyby3/orb"
            }, {
                type: "dynamo",
                url: "sc_rosetta/sun/5/orb"
            }, {
                type: "dynamo",
                url: "sc_rosetta/67p_churyumov_gerasimenko/pos"
            }, {
                type: "dynamo",
                url: "sc_rosetta/ori"
            }, {
                type: "align",
                joint: "panels_01",
                primary: {
                    type: "none",
                    axis: s.Vector3.XAxis
                },
                secondary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.ZAxis
                }
            }, {
                type: "align",
                joint: "panels_02",
                primary: {
                    type: "none",
                    axis: s.Vector3.XAxis
                },
                secondary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.ZAxis
                }
            }, {
                type: "coverage",
                coverage: [469053367.183, Number.POSITIVE_INFINITY],
                enter: t => {
                    const e = t.getComponent(s.ModelComponent);
                    null !== e && e.setHiddenObject("Philae", !0)
                }
                ,
                exit: t => {
                    const e = t.getComponent(s.ModelComponent);
                    null !== e && e.setHiddenObject("Philae", !1)
                }
            }]
        },
        sc_rosetta_impact_site: {
            groups: ["small body sites", "comet sites", "67p_churyumov_gerasimenko", "sc_rosetta", "sites"],
            radius: .001,
            label: "Rosetta Impact Site",
            parents: [[528503957.968, "67p_churyumov_gerasimenko"]],
            controllers: [{
                type: "fixed",
                position: new s.Vector3(1.7309310500292525,.3509303067271947,1.1641920075039298),
                orientation: s.Quaternion.Identity,
                relativeToEntity: "67p_churyumov_gerasimenko",
                coverage: [528503957.968, Number.POSITIVE_INFINITY]
            }]
        },
        sc_osiris_rex: {
            groups: ["small body spacecraft", "asteroid spacecraft", "101955_bennu", "spacecraft"],
            occlusionRadius: .0016,
            extentsRadius: .005,
            label: "OSIRIS-REx",
            parents: [[526676400, "earth"], [527025408, "sun"], [558938468, "earth"], [559919190, "sun"], [591770603, "101955_bennu"], [674049669, "sun"], [748358886, "earth"], [749140122, "sun"], [924136663, "99942_apophis"]],
            dependents: ["sc_osiris_rex_src"],
            trail: {
                length: 102742.5,
                lengthCoverages: [[1e7, Number.NEGATIVE_INFINITY, 599748661], [672e3, 599748661, 668095733], [1e7, 668095733, Number.POSITIVE_INFINITY]]
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_osiris_rex_v2/osiris_rex_articulated_panels.gltf",
                rotate: [{
                    x: 90
                }],
                shadowEntities: ["bennu"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_osiris_rex/earth/launch/orb"
            }, {
                type: "dynamo",
                url: "sc_osiris_rex/sun/1/orb"
            }, {
                type: "dynamo",
                url: "sc_osiris_rex/earth/flyby/orb"
            }, {
                type: "dynamo",
                url: "sc_osiris_rex/sun/2/orb"
            }, {
                type: "dynamo",
                url: "sc_osiris_rex/bennu/pos"
            }, {
                type: "dynamo",
                url: "sc_osiris_rex/sun/3/orb"
            }, {
                type: "dynamo",
                url: "sc_osiris_rex/earth/sample_return/orb"
            }, {
                type: "dynamo",
                url: "sc_osiris_rex/sun/4/orb"
            }, {
                type: "dynamo",
                url: "sc_osiris_rex/apophis"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: new s.Vector3(.175109477645991,.45028151394683397,.8755473882299549)
                },
                secondary: {
                    type: "align",
                    target: "sun",
                    axis: s.Vector3.XAxis,
                    targetAxis: s.Vector3.ZAxis
                },
                coverage: [658200668.0606446, Number.POSITIVE_INFINITY]
            }, {
                type: "dynamo",
                url: "sc_osiris_rex/ori"
            }, {
                type: "coverage",
                coverage: [748838793, Number.POSITIVE_INFINITY],
                enter: t => {
                    const e = t.getComponent(s.DivComponent);
                    null !== e && (e.getDiv().innerHTML = e.getDiv().innerHTML.replace("REx", "APEX"))
                }
                ,
                exit: t => {
                    const e = t.getComponent(s.DivComponent);
                    null !== e && (e.getDiv().innerHTML = e.getDiv().innerHTML.replace("APEX", "REx"))
                }
            }, {
                type: "custom",
                func: t => {
                    const e = t.getComponent(s.ModelComponent);
                    if (!e)
                        throw new Error;
                    return n.Animation.makeSubobjectVisibleAnimation(e, "Tagsam_housing_cover", !0, [[593036911, !1]])
                }
            }, {
                type: "custom",
                func: t => {
                    const e = t.getComponent(s.ModelComponent);
                    if (!e)
                        throw new Error;
                    return n.Animation.makeJointRotationAnimation(e, "Tagsam_rod_bottom", "z", [[595442726, 0], [595442906, -2.51758508612], [595443086, -2.51758508612], [595443266, 0], [656489486, 0], [656489846, -3.71758508612], [656502896, -3.71758508612], [656503076, 0], [657366686, 0], [657367046, -2.73771997401], [657367406, 0]])
                }
            }, {
                type: "custom",
                func: t => {
                    const e = t.getComponent(s.ModelComponent);
                    if (!e)
                        throw new Error;
                    return n.Animation.makeJointRotationAnimation(e, "Tagsam_rod_top", "z", [[593728111, 0], [593728113, .15], [595442726, .15], [595442906, 2.73247002363], [595443086, 2.73247002363], [595443266, .15], [656489486, .15], [656489846, 3.73247002363], [656502896, 3.73247002363], [656503076, .15], [657366686, .15], [657366866, 1.16136826422], [657367046, .509601235], [657367226, 1.16136826422], [657367406, .15]])
                }
            }, {
                type: "custom",
                func: t => {
                    const e = t.getComponent(s.ModelComponent);
                    if (!e)
                        throw new Error;
                    return n.Animation.makeJointRotationAnimation(e, "tagsam_head", "z", [[595442906, 0], [595442996, 1.57079632679], [595443086, 1.57079632679], [656489486, 0], [656489576, 1.57079632679], [656502806, 1.57079632679], [656502896, 0], [657366686, 0], [657367046, 1.01463145268]])
                }
            }, {
                type: "custom",
                func: t => {
                    const e = t.getComponent(s.ModelComponent);
                    if (!e)
                        throw new Error;
                    return n.Animation.makeSubobjectVisibleAnimation(e, "tagsam_head", !0, [[657367046, !1]])
                }
            }, {
                type: "custom",
                func: t => {
                    const e = t.getComponent(s.ModelComponent);
                    if (!e)
                        throw new Error;
                    return n.Animation.makeJointRotationAnimation(e, "Gimbal_Base_Right", "z", [[656501483, -70 * Math.PI / 180], [656501603, 0], [656503242, 0], [656503602, -70 * Math.PI / 180]])
                }
            }, {
                type: "custom",
                func: t => {
                    const e = t.getComponent(s.ModelComponent);
                    if (!e)
                        throw new Error;
                    return n.Animation.makeJointRotationAnimation(e, "Gimbal_Base_Left", "z", [[656501483, -70 * Math.PI / 180], [656501603, 0], [656503242, 0], [656503602, -70 * Math.PI / 180]])
                }
            }, {
                type: "custom",
                func: t => {
                    const e = t.getComponent(s.ModelComponent);
                    if (!e)
                        throw new Error;
                    return n.Animation.makeJointRotationAnimation(e, "Gimbal_Pivot_Right", "x", [[656501603, 0], [656501723, 38 * Math.PI / 180], [656503242, 38 * Math.PI / 180], [656503362, 0]])
                }
            }, {
                type: "custom",
                func: t => {
                    const e = t.getComponent(s.ModelComponent);
                    if (!e)
                        throw new Error;
                    return n.Animation.makeJointRotationAnimation(e, "Gimbal_Pivot_Left", "x", [[656501603, 0], [656501723, -38 * Math.PI / 180], [656503242, -38 * Math.PI / 180], [656503362, 0]])
                }
            }, {
                type: "custom",
                func: t => {
                    const e = t.getComponent(s.ModelComponent);
                    if (!e)
                        throw new Error;
                    return n.Animation.makeSubobjectVisibleAnimation(e, "heatshield", !0, [[748824183.985732, !1]])
                }
            }]
        },
        sc_osiris_rex_src: {
            groups: ["small body spacecraft", "asteroid spacecraft", "101955_bennu", "sample return capsule"],
            occlusionRadius: 8e-4,
            extentsRadius: 5e-4,
            label: "OSIRIS-REx SRC",
            parents: [[748824183.985732, "sc_osiris_rex"], [748832190, "earth"], [748839215, ""]],
            dependents: ["sc_osiris_rex"],
            trail: {
                length: 360
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_osiris_rex_v2/src/osiris_rex_heatshield.gltf",
                rotate: [{
                    x: 90
                }]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_osiris_rex_src/sc_osiris_rex"
            }, {
                type: "dynamo",
                url: "sc_osiris_rex_src/earth"
            }, {
                type: "fixed",
                orientation: new s.Quaternion(-.7795827954678449,-.23701239922750972,.5441503490850964,-.19994045416955505)
            }, {
                type: "coverage",
                coverage: [748838642, 748839373],
                enter: t => {
                    const e = t.getComponent(s.TrailComponent);
                    null !== e && e.setRelativeToEntityOrientation(!0)
                }
                ,
                exit: t => {
                    const e = t.getComponent(s.TrailComponent);
                    null !== e && e.setRelativeToEntityOrientation(!1)
                }
            }, {
                type: "custom",
                func: t => {
                    const e = t.addController(s.TranslateController);
                    return e.setTranslation(new s.Vector3(0,0,.0012)),
                    e.setRelativeToOrientation(!0),
                    e
                }
                ,
                coverage: [748824183.985732, 748839215]
            }],
            postCreateFunction: t => {
                const e = t.getComponent(s.ModelComponent);
                e && e.setTranslation(new s.Vector3(0,0,-.0012))
            }
        },
        sc_philae: {
            groups: ["small body spacecraft", "comet spacecraft", "67p_churyumov_gerasimenko", "spacecraft", "landers"],
            occlusionRadius: 6e-4,
            extentsRadius: .001,
            label: "Philae",
            parents: [[469053367.183, "67p_churyumov_gerasimenko"], [469078512.324, ""]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_philae/philae.gltf",
                rotate: [{
                    x: 180
                }, {
                    z: 90
                }]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_philae/67p_churyumov_gerasimenko/pos"
            }, {
                type: "fixed",
                orientation: new s.Quaternion(.05763938670269045,.04093459828351704,.6750586755218195,.7343690110337115)
            }, {
                type: "custom",
                func: t => {
                    const e = t.getComponent(s.ModelComponent);
                    if (!e)
                        throw new Error;
                    const i = new s.Vector3(.0021658104318583687,.0011575046500869896,.00011875498849156656)
                      , n = new s.Vector3(.00147,0,0)
                      , o = t.addController(s.TranslateController);
                    return o.setTranslation(i),
                    e.setTranslation(n),
                    o
                }
                ,
                coverage: [469053367.183, 469078512.324]
            }]
        },
        sc_philae_landing_site: {
            groups: ["small body sites", "comet sites", "67p_churyumov_gerasimenko", "sc_philae", "sites"],
            radius: .001,
            systemRadius: 200,
            label: "Philae Landing Site",
            parents: [[469078512.324, "67p_churyumov_gerasimenko"]],
            controllers: [{
                type: "fixed",
                position: new s.Vector3(2.4452763955965984,-.12110982508097201,-.36032099522959377),
                orientation: s.Quaternion.Identity,
                relativeToEntity: "67p_churyumov_gerasimenko",
                coverage: [469078512.324, Number.POSITIVE_INFINITY]
            }]
        },
        sc_psyche: {
            groups: ["small body spacecraft", "asteroid spacecraft", "16_psyche", "spacecraft"],
            occlusionRadius: .0031,
            extentsRadius: .025,
            label: "Psyche",
            parents: [[750482453, "earth"], [750686758, "sun"], [831828698, "mars"], [832302380, "sun"], [931665741, "16_psyche"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_psyche/psyche.gltf",
                rotate: [{
                    y: -90
                }, {
                    x: 90
                }]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_psyche/earth/orb"
            }, {
                type: "dynamo",
                url: "sc_psyche/sun/orb"
            }, {
                type: "dynamo",
                url: "sc_psyche/mars/orb"
            }, {
                type: "dynamo",
                url: "sc_psyche/16_psyche/orb"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.XAxisNeg
                }
            }, {
                type: "align",
                joint: "ArrayGimbleLeft",
                primary: {
                    type: "none",
                    axis: s.Vector3.XAxis
                },
                secondary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.YAxis
                }
            }, {
                type: "align",
                joint: "ArrayGimbleRight",
                primary: {
                    type: "none",
                    axis: s.Vector3.XAxis
                },
                secondary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.YAxis
                }
            }]
        },
        sc_stardust: {
            groups: ["small body spacecraft", "comet spacecraft", "81p_wild_2", "9p_tempel_1", "spacecraft"],
            occlusionRadius: 65e-5,
            extentsRadius: .003,
            label: "Stardust",
            parents: [[-28304869.3, "earth"], [-28038699, "sun"], [32627842, "earth"], [33120541, "sun"], [89379733, "5535_annefrank"], [89550209, "sun"], [126009572, "81p_wild_2"], [126678668, "sun"], [190336290, "earth"], [190866114, "sun"], [284944970, "earth"], [285742028, "sun"], [350896766, "9p_tempel_1"], [351068113, "sun"], [354279666, ""]],
            trail: {
                length: 62659492
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_stardust/stardust_articulated.gltf",
                shadowEntities: ["earth"],
                rotate: [{
                    x: 90
                }, {
                    z: 90
                }]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_stardust/earth/launch/orb"
            }, {
                type: "dynamo",
                url: "sc_stardust/sun/orb"
            }, {
                type: "dynamo",
                url: "sc_stardust/earth/flyby1/orb"
            }, {
                type: "dynamo",
                url: "sc_stardust/5535_annefrank/pos"
            }, {
                type: "dynamo",
                url: "sc_stardust/81p_wild_2/pos"
            }, {
                type: "dynamo",
                url: "sc_stardust/earth/flyby2/orb"
            }, {
                type: "dynamo",
                url: "sc_stardust/earth/flyby3/orb"
            }, {
                type: "dynamo",
                url: "sc_stardust/9p_tempel_1/pos"
            }, {
                type: "dynamo",
                url: "sc_stardust/quat"
            }, {
                type: "fixed",
                orientation: new s.Quaternion(.382740492391079,-.1080542417135509,-.5511677923678098,-.7335175941913997),
                coverage: [351017063, 354279666]
            }, {
                type: "coverage",
                coverage: [190576690.7833838, Number.POSITIVE_INFINITY],
                enter: t => {
                    const e = t.getComponent(s.ModelComponent);
                    if (e)
                        for (const t of o)
                            e.setHiddenObject(t, !0)
                }
                ,
                exit: t => {
                    const e = t.getComponent(s.ModelComponent);
                    if (e)
                        for (const t of o)
                            e.setHiddenObject(t, !1)
                }
            }],
            postCreateFunction: t => {
                const e = t.getComponent(s.ModelComponent);
                e && (n.Animation.makeJointRotationAnimation(e, "Stardust_capsule", "x", a(1.481785, 0, 600)),
                n.Animation.makeJointRotationAnimation(e, "Stardust_Sample_Collection1", "x", a(-Math.PI, 610, 300)),
                n.Animation.makeJointRotationAnimation(e, "Stardust_Sample_Collection2", "x", a(-Math.PI, 920, 300)))
            }
        },
        sc_stardust_src: {
            groups: ["small body spacecraft", "comet spacecraft", "81p_wild_2", "earth", "spacecraft"],
            occlusionRadius: 4e-4,
            extentsRadius: 8e-4,
            label: "Stardust SRC",
            parents: [[190576690.7833838, "sc_stardust"], [190576755.185, "earth"], [190591985.184, ""]],
            trail: {
                length: 14547
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_stardust_src/stardust_capsule.gltf",
                shadowEntities: ["earth"],
                rotate: [{
                    x: 90
                }, {
                    z: 90
                }]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_stardust_src/earth/pos"
            }, {
                type: "fixed",
                orientation: new s.Quaternion(.5761056269233067,.6860897901682099,.2627910947477326,.3582233199772653)
            }, {
                type: "coverage",
                coverage: [190591100, Number.POSITIVE_INFINITY],
                enter: t => {
                    const e = t.getComponent(s.TrailComponent);
                    null !== e && (e.setRelativeToEntityOrientation(!0),
                    e.setStartTime(1600))
                }
                ,
                exit: t => {
                    const e = t.getComponent(s.TrailComponent);
                    null !== e && (e.setRelativeToEntityOrientation(!1),
                    e.setStartTime(18e3))
                }
            }, {
                type: "custom",
                func: t => {
                    const e = t.addController(s.KeyframeController);
                    return e.addPositionKeyframe(190576690.7833838, new s.Vector3(-.0010057,0,1569e-7), "sc_stardust", void 0, "sc_stardust", void 0),
                    e.addPositionKeyframe(190576755.185, new s.Vector3(-.016734488308429718,-.019199222326278687,-.00404781848192215), "sc_stardust"),
                    e
                }
            }, {
                type: "custom",
                func: t => {
                    const e = t.addController(s.KeyframeController);
                    return e.addPositionKeyframe(190591163, new s.Vector3(-1979.4577357598625,-4478.591383446022,4136.322858267745), "earth"),
                    e.addPositionKeyframe(190591445.184, new s.Vector3(-1947.8360605285134,-4491.082890234251,4123.1018367103425), "earth"),
                    e.addPositionKeyframe(190591985.184, new s.Vector3(-1918.7633689113482,-4478.864184129612,4103.897124245734), "earth"),
                    e
                }
            }, {
                type: "rotateByEntityOrientation",
                coverage: [190591163, 190591985.184]
            }]
        }
    });
    const o = ["Stardust_capsule", "Stardust_tex_01_c", "Stardust_tex_02_c", "Stardust_tex_03_c", "Stardust_tex_02_c2", "Stardust_Sample_Collection1"];
    function a(t, e, i) {
        return [[4449664 + e, t], [4449664 + e + i, 0], [10411264 - e - i, 0], [10411264 - e, t], [81864064 + e, t], [81864064 + e + i, 0], [92664064 - e - i, 0], [92664064 - e, t], [125496064 + e, t], [125496064 + e + i, 0], [126363664 - e - i, 0], [126363664 - e, t]]
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        Animation: function() {
            return Animation
        }
    });
    var s = i(5);
    class Animation {
        static makeSubobjectVisibleAnimation(t, e, i, n) {
            n.sort(( (t, e) => t[0] - e[0]));
            const o = t.getEntity().addController(s.CoverageController);
            return o.setCoverage(new s.Interval(Number.NEGATIVE_INFINITY,Number.POSITIVE_INFINITY)),
            o.setUpdateFunction((o => {
                const a = o.getScene().getEngine().getTime()
                  , r = s.Sort.getIndex(a, n, ( (t, e) => t[0] < e));
                0 === r ? t.setHiddenObject(e, !i) : t.setHiddenObject(e, !n[r - 1][1])
            }
            )),
            o
        }
        static makeJointRotationAnimation(t, e, i, n) {
            n.sort(( (t, e) => t[0] - e[0]));
            const o = t.getEntity().addController(s.CoverageController);
            return o.setCoverage(new s.Interval(Number.NEGATIVE_INFINITY,Number.POSITIVE_INFINITY)),
            o.setUpdateFunction((o => {
                const a = t.getThreeJsObjectByName(e);
                if (null !== a) {
                    const t = o.getScene().getEngine().getTime()
                      , e = s.Sort.getIndex(t, n, ( (t, e) => t[0] < e));
                    if (0 === e)
                        a.rotation[i] = n[0][1];
                    else if (e === n.length)
                        a.rotation[i] = n[n.length - 1][1];
                    else {
                        const o = n[e - 1]
                          , r = n[e]
                          , l = (t - o[0]) / (r[0] - o[0]);
                        a.rotation[i] = s.MathUtils.lerp(o[1], r[1], l)
                    }
                }
            }
            )),
            o
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e);
    var s = i(5);
    i(545).Entity.register({
        sc_biosentinel: {
            groups: ["sun", "spacecraft"],
            occlusionRadius: 2e-4,
            extentsRadius: 5e-4,
            label: "BioSentinel",
            parents: [[721866289, "earth"], [722273637, "moon"], [722923565, "sun"]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_biosentinel/biosentinel.gltf",
                shadowEntities: ["moon"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_biosentinel/earth/orb"
            }, {
                type: "dynamo",
                url: "sc_biosentinel/moon/orb"
            }, {
                type: "dynamo",
                url: "sc_biosentinel/sun/orb"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.YAxis
                },
                secondary: {
                    type: "align",
                    target: "sun",
                    axis: s.Vector3.ZAxis,
                    targetAxis: s.Vector3.ZAxis
                }
            }]
        },
        sc_kepler_space_telescope: {
            groups: ["sun", "spacecraft", "telescope"],
            occlusionRadius: .00235,
            extentsRadius: .004,
            label: "Kepler",
            parents: [[289679042.1855, "earth"], [290348743, "sun"], [595512069.183, ""]],
            trail: {
                length: 32190048
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_kepler/Kepler.gltf"
            },
            controllers: [{
                type: "dynamo",
                url: "sc_kepler/earth/orb"
            }, {
                type: "dynamo",
                url: "sc_kepler/sun/orb"
            }, {
                type: "align",
                primary: {
                    type: "align",
                    target: "sun",
                    targetAxis: new s.Vector3(.25176480336,-.66735243742,.7009092643),
                    axis: s.Vector3.YAxis
                },
                secondary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.XAxisNeg
                }
            }]
        },
        sc_mariner_2: {
            groups: ["sun", "spacecraft"],
            occlusionRadius: .002,
            extentsRadius: .0025,
            label: "Mariner 2",
            parents: [[-1178599240.703784, "sun"], [409233667.18358755, ""]],
            trail: {
                length: 29411352
            },
            controllers: [{
                type: "animdata",
                url: "sc_mariner_2",
                dataType: "pos"
            }]
        },
        sc_parker_solar_probe: {
            groups: ["sun", "spacecraft"],
            occlusionRadius: .0015,
            extentsRadius: .003,
            label: "Parker Solar Probe",
            parents: [[587333783.3431, "earth"], [587454078, "sun"]],
            trail: {
                length: 12942631
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_parker_solar_probe/PSP.gltf"
            },
            controllers: [{
                type: "dynamo",
                url: "sc_parker_solar_probe/earth/orb"
            }, {
                type: "dynamo",
                url: "sc_parker_solar_probe/sun/orb"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.ZAxisNeg
                }
            }]
        },
        sc_spitzer: {
            groups: ["sun", "spacecraft"],
            occlusionRadius: .0085,
            extentsRadius: .004,
            label: "Spitzer",
            parents: [[115064804, "earth"], [115493678, "sun"], [633614469, ""]],
            trail: {
                length: 32167331
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_spitzer/SPITZER.gltf",
                rotate: [{
                    z: -90
                }, {
                    x: -90
                }],
                shadowEntities: ["venus", "mercury"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_spitzer/earth/orb"
            }, {
                type: "dynamo",
                url: "sc_spitzer/sun/orb"
            }, {
                type: "fixed",
                orientation: new s.Quaternion(.5258297992951877,.8139480432783324,-.1400557906856776,-.20341086625833524),
                coverage: [115064804, 174548493]
            }, {
                type: "dynamo",
                url: "sc_spitzer/quat"
            }]
        },
        sc_stereo_ahead: {
            groups: ["sun", "spacecraft"],
            occlusionRadius: .003,
            extentsRadius: .003,
            label: "STEREO Ahead",
            parents: [[215097110, "earth"], [221418192, "sun"]],
            trail: {
                length: 29809031
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_stereo_ahead/stereo_a.gltf",
                rotate: [{
                    x: 90
                }],
                shadowEntities: ["venus", "mercury"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_stereo_ahead/earth/orb"
            }, {
                type: "dynamo",
                url: "sc_stereo_ahead/sun/orb"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.ZAxis
                },
                secondary: {
                    type: "velocity",
                    target: "sc_stereo_ahead",
                    axis: s.Vector3.YAxisNeg
                }
            }]
        },
        sc_stereo_behind: {
            groups: ["sun", "spacecraft"],
            occlusionRadius: .003,
            extentsRadius: .003,
            label: "STEREO Behind",
            parents: [[215097110, "earth"], [224468337, "sun"], [527860868.182, ""]],
            trail: {
                length: 33473699
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_stereo_behind/stereo_b.gltf",
                rotate: [{
                    x: 90
                }],
                shadowEntities: ["venus", "mercury"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_stereo_behind/earth/orb"
            }, {
                type: "dynamo",
                url: "sc_stereo_behind/sun/orb"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.ZAxis
                },
                secondary: {
                    type: "velocity",
                    target: "sc_stereo_behind",
                    axis: s.Vector3.YAxisNeg
                }
            }]
        },
        sc_ulysses: {
            groups: ["sun", "spacecraft"],
            occlusionRadius: .002,
            extentsRadius: .002,
            label: "Ulysses",
            parents: [[-291488100, "sun"], [268142464.18410408, ""]],
            trail: {
                length: 140294739
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_ulysses/ulysses.gltf",
                shadowEntities: ["venus", "mercury"]
            },
            controllers: [{
                type: "animdata",
                url: "sc_ulysses",
                dataType: "pos"
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "sun",
                    axis: s.Vector3.ZAxis
                },
                secondary: {
                    type: "velocity",
                    target: "sc_ulysses",
                    axis: s.Vector3.YAxisNeg
                }
            }]
        },
        sc_wmap: {
            groups: ["sun", "spacecraft"],
            occlusionRadius: .0026,
            extentsRadius: .0026,
            label: "WMAP",
            parents: [[339422466.184, "sun"], [360158466.184, ""]],
            trail: {
                length: 31536e3
            },
            controllers: [{
                type: "animdata",
                url: "sc_wmap",
                dataType: "pos"
            }]
        }
    })
}
, function(t, e, i) {
    "use strict";
    i.r(e);
    var s = i(5);
    i(545).Entity.register({
        sc_magellan: {
            groups: ["venus", "spacecraft"],
            occlusionRadius: .0032,
            extentsRadius: .006,
            label: "Magellan",
            parents: [[-336388283.36, "sun"], [-296448521.457, "venus"], [-164631538.81763855, ""]],
            trail: {
                length: void 0
            },
            model: {
                url: "$STATIC_ASSETS_URL/models/sc_magellan/magellan.gltf",
                shadowEntities: ["venus"]
            },
            controllers: [{
                type: "dynamo",
                url: "sc_magellan/venus/orb"
            }, {
                type: "custom",
                func: t => {
                    const e = t.addController(s.OrbitalElementsController)
                      , i = new s.OrbitalElements;
                    return i.epoch = -336394683.816,
                    i.eccentricity = .1791852824104108,
                    i.semiMajorAxis = 128280596.63956015,
                    i.meanAngularMotion = 2.5073465306679634e-7,
                    i.meanAnomalyAtEpoch = 2.9229288382327625,
                    i.orbitOrientation.set(.8728453580255966, .1876084386162498, -.08948587100888229, .4415159494547423),
                    e.addOrbitalElements(-336388283.36, i),
                    e.addOrbitalElements(-296448521.457, i),
                    e
                }
            }, {
                type: "custom",
                func: t => {
                    const e = t.addController(s.OrbitalElementsController)
                      , i = new s.OrbitalElements;
                    i.epoch = -296448521.457,
                    i.eccentricity = 1.272922970547487,
                    i.semiMajorAxis = 23358.593430196037,
                    i.meanAngularMotion = .00015965302516479147,
                    i.meanAnomalyAtEpoch = -6.138103356108873,
                    i.orbitOrientation.set(-.49933963770188916, .11817755769547109, .7262027627540558, -.45751889408554064),
                    e.addOrbitalElements(-296448521.457, i),
                    e.addOrbitalElements(-296410230.351, i);
                    const n = new s.OrbitalElements;
                    return n.epoch = -295884037.7511,
                    n.eccentricity = .39186818222106645,
                    n.semiMajorAxis = 10434.012201911135,
                    n.meanAngularMotion = .000534773863104956,
                    n.meanAnomalyAtEpoch = -1.5165416917234864,
                    n.orbitOrientation.set(-.4665778554219434, .18802595119032475, .7217932088991018, -.47535871728198204),
                    e.addOrbitalElements(-296410230.351, n),
                    e.addOrbitalElements(-295884037.7511, n),
                    e
                }
            }, {
                type: "align",
                primary: {
                    type: "point",
                    target: "earth",
                    axis: s.Vector3.YAxis
                },
                secondary: {
                    type: "align",
                    axis: new s.Vector3(-Math.sqrt(.5),Math.sqrt(.5),0),
                    target: "venus",
                    targetAxis: s.Vector3.ZAxisNeg
                }
            }]
        },
        sc_venus_express: {
            groups: ["venus", "spacecraft"],
            occlusionRadius: 9e-4,
            extentsRadius: .004,
            label: "Venus Express",
            parents: [[184784702, "earth"], [185369766, "sun"], [197902579, "venus"], [473341201, ""]],
            trail: {
                length: 779592.165087551
            },
            controllers: [{
                type: "dynamo",
                url: "sc_venus_express/earth"
            }, {
                type: "dynamo",
                url: "sc_venus_express/sun"
            }, {
                type: "dynamo",
                url: "sc_venus_express/venus"
            }, {
                type: "fixed",
                orientation: s.Quaternion.Identity
            }, {
                type: "dynamo",
                url: "sc_venus_express/quat"
            }]
        }
    })
}
, function(t, e, i) {
    "use strict";
    i.r(e);
    var s = i(5);
    i(545).Entity.register({
        rose_bowl: {
            groups: ["comparison"],
            radius: .15,
            label: "Rose Bowl",
            parents: [],
            model: {
                url: "$STATIC_ASSETS_URL/models/comparison/rose_bowl/rose_bowl.gltf",
                rotate: [{
                    x: 90
                }, {
                    z: -90
                }]
            },
            controllers: [{
                type: "fixed",
                position: s.Vector3.Zero,
                orientation: s.Quaternion.Identity
            }]
        },
        school_bus: {
            groups: ["comparison"],
            radius: .0065,
            label: "School bus",
            parents: [],
            model: {
                url: "$STATIC_ASSETS_URL/models/comparison/school_bus/school_bus.gltf",
                rotate: [{
                    x: 90
                }, {
                    z: -90
                }]
            },
            controllers: [{
                type: "fixed",
                position: s.Vector3.Zero,
                orientation: s.Quaternion.Identity
            }]
        },
        scientist: {
            groups: ["comparison"],
            radius: 835e-6,
            label: "Scientist",
            parents: [],
            model: {
                url: "$STATIC_ASSETS_URL/models/comparison/scientist/scientist.gltf",
                rotate: [{
                    x: 90
                }]
            },
            controllers: [{
                type: "fixed",
                position: s.Vector3.Zero,
                orientation: s.Quaternion.Identity
            }]
        }
    })
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        RouteManager: function() {
            return RouteManager
        }
    });
    var s = i(686)
      , n = i.n(s)
      , o = i(2);
    class RouteManager extends o.BaseManager {
        constructor(t) {
            super(t),
            this._router = new (n())(null,!0),
            this._previousRoute = null,
            this._currentRoute = {},
            this._firstLoad = !0,
            this._query = {},
            this._configs = {},
            this._validQueries = [],
            this._homeRoute = "/home",
            this._queryCallbacks = {},
            this._previousView = null,
            this._currentView = null,
            this._alwaysHiddenComponents = [],
            this.bindFunctions(["navigate", "onRootRoute", "onNotFound", "leave"])
        }
        get homeRoute() {
            return this._homeRoute
        }
        get previousRoute() {
            return this._previousRoute
        }
        get currentRoute() {
            return this._currentRoute
        }
        get query() {
            return this._query
        }
        get configs() {
            return this._configs
        }
        get currentView() {
            return this._currentView
        }
        set currentView(t) {
            this._currentView = t
        }
        get previousView() {
            return this._previousView
        }
        init(t, e) {
            this._router.hooks({
                before: async e => {
                    this._previousRoute = {
                        ...this._currentRoute
                    },
                    this._currentRoute = this._router.lastRouteResolved() || {},
                    this._currentRoute.url && (this._currentRoute.url = this._currentRoute.url.replace(/(\/)+/, "/")),
                    this.addQuery(this.parseQuery(this.currentRoute.query)),
                    "function" == typeof t && await t(this._currentRoute, this._previousRoute),
                    e()
                }
                ,
                after: async () => {
                    "function" == typeof e && await e(this._currentRoute, this._previousRoute),
                    this._firstLoad = !1
                }
            }),
            this._router.on(this.onRootRoute).notFound(this.onNotFound).on("milky_way", this.onNotFound).on("observable_universe", this.onNotFound)
        }
        leave(t) {
            t.cancelToken.cancel()
        }
        onRootRoute(t) {
            this.reroute(this._homeRoute, t)
        }
        onNotFound(t) {
            let e = this._homeRoute;
            t && (e += "?" + t),
            this._router.navigate(e)
        }
        replaceState(t) {
            history.replaceState({}, "", t)
        }
        reroute(t, e="") {
            let i;
            "string" == typeof e && (e = this.parseQuery(e));
            const s = o.AppUtils.filterObject(this._configs, (t => void 0 !== t));
            i = this.buildQuery({
                ...e,
                ...s
            });
            const n = window.location.pathname;
            history.replaceState(i, "", `${n}#${t}${i}`),
            this._router.resolve()
        }
        addCancelToken(t) {
            const e = t || {};
            return e.cancelToken = new o.CancelToken,
            e
        }
        lastRouteResolved() {
            return this._router.lastRouteResolved()
        }
        lastPathResolved() {
            const t = this._router.lastRouteResolved();
            return t.query ? t.url + "?" + t.query : t.url
        }
        getOnlyURL(t) {
            let e = t;
            const i = t.split("#");
            return e = i.length > 1 ? this._cleanGETParam(i[1]) : this._cleanGETParam(i[0]),
            e
        }
        _cleanGETParam(t) {
            return t.split(/\?(.*)?$/)[0]
        }
        getValidQueries() {
            return this._validQueries
        }
        setValidQueries(t) {
            this._validQueries = t
        }
        parseQuery(t) {
            if (!t)
                return {};
            t.replace("?", "");
            return t.split("&").reduce(( (t, e) => {
                const i = e.split("=");
                if (i.length > 1) {
                    const e = decodeURIComponent(i[0].trim());
                    let s = decodeURIComponent(i[1].trim());
                    const n = {
                        lighting: ["flood", "natural", "shadow"]
                    };
                    switch (s.toLowerCase()) {
                    case "true":
                        s = !0;
                        break;
                    case "false":
                        s = !1;
                        break;
                    case "undefined":
                    case "":
                        s = void 0;
                        break;
                    case "null":
                        s = null;
                        break;
                    default:
                        {
                            const t = Number(s);
                            Number.isNaN(t) ? e in n ? n[e].includes(s) || (s = !1) : Object.keys(this.configs).includes(e) && "true" !== s && (s = !1) : s = t;
                            break
                        }
                    }
                    const o = decodeURIComponent(i[0].trim());
                    o in this._configs ? void 0 === this._configs[o] && (this._configs[o] = s) : t[o] = s
                }
                return t
            }
            ), {})
        }
        buildQuery(t) {
            let e = "";
            for (const [i,s] of Object.entries(t))
                e += "&" + i + "=" + s;
            return e = e.replace("&", "?"),
            e
        }
        addQuery(t) {
            return this._query = {
                ...this._query,
                ...t
            },
            this._query
        }
        removeQuery(t=[]) {
            return t.forEach((t => delete this._query[t])),
            this._query
        }
        addConfigs(t) {
            return this._configs = {
                ...this._configs,
                ...t
            },
            this._configs
        }
        setConfig(t, e) {
            this.configs[t] = e
        }
        removeConfigs(t=[]) {
            return t.forEach((t => delete this._configs[t])),
            this._configs
        }
        updateQuery(t) {
            t.__remove && ("all" === t.__remove ? this._query = {} : this.removeQuery(t.__remove),
            delete t.__remove);
            const e = o.AppUtils.filterObject(this._configs, (t => void 0 !== t));
            return {
                ...this.addQuery(t),
                ...e
            }
        }
        updateQueryPath(t, e="") {
            return (e || this._router.lastRouteResolved().url).replace(/(\/)(?=\/*\1)/, "") + this.buildQuery(this.updateQuery(t))
        }
        async resetView(t, e) {
            if (this._previousView = this._currentView,
            this._currentView = t,
            this._currentView !== this._previousView) {
                null !== this._previousView && await this._app.getView(this._previousView).onLeave(e),
                await this._app.getView(this._currentView).onEnter(e);
                const i = this._app.getViews();
                for (let e = i.length - 1; e >= 0; e--) {
                    const s = i[e];
                    this._app.getView(s).setEnabled(s === t)
                }
            }
        }
        async handleRoute(t, e, i) {
            e || (e = this.addCancelToken(e),
            this._currentRoute.params = e);
            let s = {};
            i && (s = this.parseQuery(i)),
            await this.resetView(t, {
                ...e,
                ...s,
                ...this._configs
            }),
            await this.goToView(t, e, {
                ...s,
                ...this._configs
            })
        }
        stillOnRoute(t) {
            const e = this._currentRoute.url.match(/^\/([^!/]*)/);
            return null !== e && void 0 !== e[1] && e[1] === t
        }
        urlChanged(t, e) {
            return this.getOnlyURL(t) !== this.getOnlyURL(e)
        }
        routeChanged(t, e) {
            if ("" === t && !e)
                return !0;
            if (!e || o.AppUtils.isEmptyObject(e))
                return !0;
            if (t.url)
                return t.url !== e.url;
            const i = o.AppUtils.deepCopy(t)
              , s = o.AppUtils.deepCopy(e);
            return !o.AppUtils.deepEqual(i, s)
        }
        queryChanged(t, e) {
            if (!e)
                return !0;
            const i = o.AppUtils.deepCopy(t)
              , s = {};
            for (const t in i)
                "function" == typeof i[t].toString && (i[t] = i[t].toString());
            return e.split("&").forEach((t => {
                const e = t.split("=");
                s[e[0]] = e[1]
            }
            )),
            !o.AppUtils.deepEqual(i, s)
        }
        async goToView(t, e, i) {
            this.routeChanged(this.currentRoute, this.previousRoute) ? await this._app.getView(t).onRouteChange({
                ...e,
                ...i
            }) : this.queryChanged(i, this.previousRoute.query) && await this._app.getView(t).onQueryChange({
                ...e,
                ...i
            })
        }
        addRoutes(t) {
            for (let e = 0; e < t.length; e++) {
                const {route: i, view: s} = t[e];
                this._router.on(i, (async (t, e) => {
                    await this.handleRoute(s, t, e)
                }
                ), {
                    before: async (t, e) => {
                        await this.before(t, e, s)
                    }
                    ,
                    leave: this.leave
                })
            }
        }
        before(t, e, i) {
            let s = {};
            this._currentRoute.query && (s = this.parseQuery(this._currentRoute.query)),
            e = this.addCancelToken(e);
            const n = this._app.getView(i)?.validateQuery({
                ...e,
                ...s
            });
            n || (e.cancelToken.cancel(),
            "function" == typeof t && t(!1)),
            "function" == typeof t && t()
        }
        subscribeToQuery(t, e) {
            if ("function" == typeof e)
                return this._queryCallbacks[t] || (this._queryCallbacks[t] = []),
                this._queryCallbacks[t].includes(e) || this._queryCallbacks[t].push(e),
                () => {
                    const i = this._queryCallbacks[t].indexOf(e);
                    this._queryCallbacks[t].splice(i, 1)
                }
        }
        start() {
            this._router.resolve(),
            this.handleEmbedQueries()
        }
        handleEmbedQueries() {
            const {hideFullScreenToggle: t, lighting: e, noKeyboard: i, search: s} = this._configs
              , n = !0 === i || !1 === s
              , o = this.app.getComponent("search")
              , a = this.app.getComponent("settings");
            let r = []
              , l = null;
            const c = this.app.getComponent("tutorialOverlay");
            if (!0 === t && a?.hideFullScreenOption?.(),
            "flood" !== e && "natural" !== e || a?.toggleLightOptions?.(e),
            n && (this._alwaysHiddenComponents.push("search"),
            o?.hide(),
            r = c?.hideTutorialSlide?.("search")),
            !0 === this._configs.hideFullScreenToggle) {
                const t = this.app.tutorials?.find((t => "settings" === t.id));
                t && (t.description = t.description.replace(t.description, t.alternateDescription))
            }
            l = this.app.setTutorialVariables?.(r.length ? r : this.app.tutorials),
            c?.setTutorials?.(l)
        }
        navigate(t, e="", i={}) {
            if (o.AppUtils.isEmptyObject(i) || "string" == typeof t && (e = o.AppUtils.cleanPathDuplicate(`${e}/${t}`),
            t = {}),
            i.__remove && (t.__remove = i.__remove),
            i.keepTime) {
                const i = this._app.getManager("time");
                this.query.time && i && (e.includes("time=") || (t.time = t.time || i.getTimeUrl()),
                e.includes("rate=") || (t.rate = t.rate || i.getTimeRate()))
            }
            return this._navigate(t, e)
        }
        _navigate(t, e="") {
            if ("string" == typeof t) {
                const i = this.lastPathResolved();
                let s = t;
                if (t.startsWith("/") || (s = "/" + t),
                t.includes(e) || (s = e + t),
                i !== s) {
                    const t = s.split("?");
                    if (t.length > 1)
                        this._query = this.parseQuery(t[1]);
                    else {
                        this._query = {};
                        const t = o.AppUtils.filterObject(this._configs, (t => void 0 !== t));
                        s += this.buildQuery(t)
                    }
                    return this._router.navigate(s),
                    !0
                }
                return !1
            }
            return this.navigate(this.updateQueryPath(t, e), e)
        }
        returnHome(t=!0) {
            const e = t ? this.buildQuery(this.query) : "";
            this.navigate(e)
        }
        async reload(t=!0, e=!1) {
            const i = await this._app.getView(this._currentView)
              , {params: s, query: n} = this._router.lastRouteResolved();
            let o = {};
            !e && n && (o = this.parseQuery(n)),
            t ? i.onQueryChange({
                ...s,
                ...o
            }) : i.onRouteChange({
                ...s,
                ...o
            })
        }
    }
}
, , function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        ContentManager: function() {
            return ContentManager
        }
    });
    var s = i(220)
      , n = i.n(s)
      , o = i(5)
      , a = i(2);
    class ContentManager extends a.BaseManager {
        constructor(t) {
            super(t),
            this._entityList = null,
            this._entitiesByCategory = {},
            this._entitiesBySubCategory = {},
            this._stories = {},
            this._storyList = null,
            this._target = null,
            this._context = {},
            this._context.events = {},
            this._context.orderedEvents = {},
            this._context.eventDesc = {},
            this._context.story = {},
            this._folders = {
                description: "/",
                event: "/",
                stories: "/"
            },
            this._categoryShapeMap = {
                Planet: {
                    shape: "circle",
                    color: "blue"
                },
                Moon: {
                    shape: "crescent",
                    color: ""
                },
                Asteroid: {
                    shape: "circle",
                    color: "brown"
                },
                Star: {
                    shape: "circle",
                    color: "yellow"
                },
                Spacecraft: {
                    shape: "hexagon",
                    color: "gray"
                }
            }
        }
        getEntityList() {
            return this._entityList
        }
        setEntityList(t) {
            for (const [e,i] of Object.entries(t))
                !0 === i.disabled && delete t[e];
            this._entityList = t,
            Object.keys(this._entityList).forEach((t => {
                const {category: e} = this._entityList[t];
                this._entitiesByCategory[e] ? this._entitiesByCategory[e].push(this._entityList[t]) : this._entitiesByCategory[e] = [this._entityList[t]];
                let {subcategory: i} = this._entityList[t];
                i && "" !== i || (i = e),
                this._entitiesBySubCategory[i] ? this._entitiesBySubCategory[i].push(this._entityList[t]) : this._entitiesBySubCategory[i] = [this._entityList[t]]
            }
            ))
        }
        getEntityInfo(t) {
            return t in this._entityList ? this._entityList[t] : null
        }
        async getEntityDesc(t) {
            let e = null;
            try {
                e = await a.AppUtils.loadJSON(this._folders.description + t + ".json")
            } catch (t) {
                e = null
            }
            return e
        }
        setFolders(t={}) {
            for (const e in t)
                Object.prototype.hasOwnProperty.call(t, e) && (t[e] = a.AppUtils.addEndToPath(t[e]),
                this._folders[e] = t[e])
        }
        getStoryList() {
            return this._storyList
        }
        setStoryList(t) {
            this._storyList = t
        }
        getStory(t) {
            if (!t)
                throw new Error("[ContentManager.getStory]: id is required.");
            if (!this._stories[t])
                throw new Error(`[ContentManager.getStory]: Cannot find story with id ${t}.`);
            return this._context.story = this._stories[t],
            this._context.story
        }
        setStories(t) {
            this._stories = t
        }
        async loadDescriptions(t, e) {
            for (let i = 0; i < t.length; i++) {
                const s = t[i]
                  , n = await this.getEntityDesc(s);
                if (e && e.isCanceled)
                    return;
                this._context[s] = n
            }
        }
        async loadEvents(t, e={}, i) {
            if (!t)
                return;
            const s = a.AppUtils.addEndToPath(this._folders.event + t);
            if (e.all && (this._target !== t || a.AppUtils.isEmptyObject(this._context.events))) {
                let o = null;
                try {
                    o = await a.AppUtils.loadJSON(s + e.all)
                } catch (t) {
                    o = null
                }
                if (i && i.isCanceled)
                    return;
                if (this._context.events = o,
                null !== this._context.events) {
                    const e = [];
                    for (const [i,s] of Object.entries(this._context.events))
                        s.start ? (s.start = n().tz(s.start, "Etc/UTC"),
                        s.end && (s.end = n().tz(s.end, "Etc/UTC")),
                        e.push(s)) : console.error("[Content Manager] Error: event missing start date " + t + " " + i);
                    e.sort(( (t, e) => t.start.valueOf() - e.start.valueOf())),
                    this._context.orderedEvents = e
                } else
                    this._context.orderedEvents = null
            }
            if (e.event) {
                const t = this._context.events[e.event]
                  , n = t && t.template ? t.template : e.event;
                let o = null;
                try {
                    o = await a.AppUtils.loadJSON(s + n)
                } catch (t) {
                    o = null
                }
                if (i && i.isCanceled)
                    return;
                this._context.eventDesc = o
            }
            this._target = t
        }
        getSpheroidLayers(t) {
            return this._entityShperoidLayersList[t]
        }
        setSpheroidLayers(t) {
            this._entityShperoidLayersList = t
        }
        getSpheroidDefaultTextureInformation(t, e=[]) {
            const i = {}
              , s = this.app.pioneer.getScene("main").getEntity(t).getComponent(o.SpheroidLODComponent);
            return s?.getTextureNames().forEach((t => {
                i[t] = {
                    url: s.getTextureUrl(t).replace("$STATIC_ASSETS_URL/maps/", ""),
                    sizes: s.getTextureSizes(t)
                }
            }
            )),
            {
                id: "default",
                title: "Default Texture",
                type: "texture",
                features: e,
                textures: i
            }
        }
        getSpheroidFeatures(t) {
            return this._entityShperoidFeaturesList[t] || []
        }
        setSpheroidFeatures(t) {
            this._entityShperoidFeaturesList = t
        }
        getSpheroidId(t) {
            const e = this._app.getManager("scene");
            let i = t.id;
            if ("Spacecraft" === t.category)
                i = e.getParent(i) || i;
            else if ("Instrument" === t.category) {
                const t = e.getParent(i);
                i = e.getParent(t) || t || i
            }
            return i
        }
        getCategoryShapeMap() {
            return this._categoryShapeMap
        }
        getColorClass(t) {
            let e = "";
            if (!this.getEntityInfo(t))
                return e;
            switch (this.getEntityInfo(t).category) {
            case "Asteroid":
                e = "asteroid";
                break;
            case "Instrument":
            case "Spacecraft":
                e = "spacecraft";
                break;
            case "Planet":
                e = t;
                break;
            case "Dwarf Planet":
                e = "dwarf-planet";
                break;
            case "Comet":
                e = "comet";
                break;
            case "Barycenter":
            case "Moon":
                e = "moon";
                break;
            case "Universe":
            case "Galaxy":
            case "Star":
                e = "sun";
                break;
            default:
                e = ""
            }
            return e
        }
        hasLanded(t) {
            if (!t.landingDate || "" === t.landingDate)
                return !1;
            if (["Lander", "Rover"].indexOf(t.subcategory) < 0)
                return !1;
            const e = this._app.getManager("time").parseTime(t.landingDate);
            return !!this._app.getManager("time").getTime().isSameOrAfter(e)
        }
        getClassName(t, e) {
            const i = this.getEntityInfo(t);
            let s = t;
            if (e)
                s += " " + e.toLowerCase().replace(/ /g, "-");
            else if (null !== i && void 0 !== i.category) {
                s += " " + i.category.toLowerCase().replace(/ /g, "-")
            }
            return s.match(/^\d/) && (s = "_" + s),
            s
        }
        hasKeyword(t, e) {
            if (void 0 !== this.getEntityInfo(t))
                return this.getEntityInfo(t).keywords.includes(e)
        }
        resetContext() {
            this._context = {},
            this._context.events = {},
            this._context.eventDesc = {},
            this._context.orderedEvents = {},
            this._context.story = {}
        }
        hideExternalLinksInText(t) {
            return t?.replaceAll(/<a.*?href=['"](https?:)?\/\/[^>]*>(.*?)<\/a>/g, "$2")
        }
        hideExternalLinkStoryList() {
            const t = this.getStoryList()
              , e = {}
              , i = t.external ? Object.keys(t.external) : [];
            for (const [s,n] of Object.entries(t))
                if ("external" !== s) {
                    e[s] = n;
                    if (Array.isArray(n)) {
                        const t = n.filter((t => !i.includes(t)));
                        t.length > 0 && (e[s] = t)
                    } else {
                        const t = Object.keys(n).filter((t => i.includes(t)));
                        for (let e = 0; e < t.length; e++)
                            delete n[t[e]]
                    }
                }
            this.setStoryList(e)
        }
        _handleError(t, e="") {
            console.error(e + t);
            let i = this.app.getManager("router").previousRoute.url;
            throw i || (i = this.app.getManager("router").homeRoute),
            t.previousRoute = i,
            t
        }
        get entitiesByCategory() {
            return this._entitiesByCategory
        }
        get entitiesBySubCategory() {
            return this._entitiesBySubCategory
        }
        get context() {
            return this._context
        }
        get events() {
            return this._context.events
        }
        get orderedEvents() {
            return this._context.orderedEvents
        }
        get eventDesc() {
            return this._context.eventDesc
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        SceneManager: function() {
            return SceneManager
        }
    });
    var s = i(220)
      , n = i.n(s)
      , o = i(5)
      , a = i(542)
      , r = i(2);
    class SceneManager extends r.BaseManager {
        constructor(t) {
            super(t),
            this._scenes = {},
            this._scene = this.add("main"),
            this._isHD = !1,
            this._hdWMTSMap = {},
            this._loadingItems = [],
            this._loadedComponents = [],
            this._wmtsServerStates = new Map,
            this._wmtsComponentStates = new Map,
            this._hdBreakpointSize = 512,
            this._maxTextureSize = 4096,
            this._eventNames.push("loading", "loaded"),
            this._initCallbacks(),
            this._isLoading = !1,
            this._entityStatuses = new o.FastMap,
            this._entityExtraOptions = void 0,
            this._entityLoadedCallbacks = [],
            this._entityWillBeUnloadedCallbacks = [],
            this._componentTypesNotVisible = new Set,
            this._hdToggleEntity = null,
            this._mobileTextureSize = 1024,
            this.bindFunctions(["addLoading", "removeLoading", "update", "toggleStarfield", "toggleHeliosphere", "toggleConstellations", "addWMTSComponent", "tileIsReady", "enableWMTSComponent", "forceTextureSizeForEntity", "toggleHDTextureForEntity", "isEntityHD"]),
            this._tempEntities = []
        }
        getHDToggleEntity() {
            return this._hdToggleEntity
        }
        add(t) {
            return "main" === t && this._scene ? this._scene : (this._scenes[t] = this.pioneer.addScene(t),
            this._scenes[t].setAmbientLightColor(new o.Color(.005,.005,.005)),
            this._scenes[t])
        }
        addEntity(t, e) {
            if (this._entityStatuses.has(t))
                throw new Error(`Error adding entity: The entity ${t} has already been added.`);
            this._entityStatuses.set(t, {
                forceVisible: !1,
                layerVisibility: this.app.getManager("layer").isEntityVisibleWithCurrentLayers(t),
                dynamic: e,
                dependentEntities: [],
                entitiesForcingThisVisible: new Set,
                visible: !0,
                componentTypesNotVisible: new Set
            })
        }
        removeEntity(t) {
            if (!this._entityStatuses.delete(t))
                throw new Error(`Error removing entity: The entity ${t} was not in the scene manager.`);
            const e = this._scene.getEntity(t);
            if (null !== e) {
                for (let t = 0, i = this._entityWillBeUnloadedCallbacks.length; t < i; t++)
                    this._entityWillBeUnloadedCallbacks[t](e);
                this._scene.removeEntity(t)
            }
        }
        getEntityStatus(t) {
            return this._entityStatuses.get(t)
        }
        addEntitiesFromSceneInfo(t) {
            const e = new Map;
            void 0 !== t.staticEntities && (1 === t.staticEntities.length && "all" === t.staticEntities[0] ? a.Entity.getEntityNamesInGroup("").forEach((t => e.set(t, !1))) : t.staticEntities.forEach((t => e.set(t, !1)))),
            void 0 !== t.staticEntityGroups && t.staticEntityGroups.forEach((t => {
                a.Entity.getEntityNamesInGroup(t).forEach((t => e.set(t, !1)))
            }
            )),
            void 0 !== t.dynamicEntities && (1 === t.dynamicEntities.length && "all" === t.dynamicEntities[0] ? a.Entity.getEntityNamesInGroup("").forEach((t => {
                e.has(t) || e.set(t, !0)
            }
            )) : t.dynamicEntities.forEach((t => {
                e.has(t) || e.set(t, !0)
            }
            ))),
            void 0 !== t.dynamicEntityGroups && t.dynamicEntityGroups.forEach((t => {
                a.Entity.getEntityNamesInGroup(t).forEach((t => {
                    e.has(t) || e.set(t, !0)
                }
                ))
            }
            ));
            const i = this.app.getManager("content");
            for (const t of e.keys())
                null === i.getEntityInfo(t) && e.delete(t);
            e.forEach(( (t, e) => this.addEntity(e, t))),
            this.setExtraEntityOptions(t.entityOptions),
            this.updateEntityLayerVisibility()
        }
        addEntityLoadedCallback(t) {
            this._entityLoadedCallbacks.push(t)
        }
        removeEntityLoadedCallback(t) {
            for (let e = 0, i = this._entityLoadedCallbacks.length; e < i; e++)
                if (this._entityLoadedCallbacks[e] === t)
                    return void this._entityLoadedCallbacks.splice(e, 1)
        }
        addEntityWillBeUnloadedCallback(t) {
            this._entityWillBeUnloadedCallbacks.push(t)
        }
        removeEntityWillBeUnloadedCallback(t) {
            for (let e = 0, i = this._entityWillBeUnloadedCallbacks.length; e < i; e++)
                if (this._entityWillBeUnloadedCallbacks[e] === t)
                    return void this._entityWillBeUnloadedCallbacks.splice(e, 1)
        }
        setEntitiesForceVisible(t, e, i=!0) {
            if (e)
                for (let t = 0, e = this._entityStatuses.getSize(); t < e; t++) {
                    this._entityStatuses.getAt(t).value.forceVisible = !1
                }
            for (let e = 0, s = t.length; e < s; e++) {
                const s = t[e]
                  , n = this._entityStatuses.get(s);
                if (void 0 === n)
                    throw new Error(`Entity ${s} was set to force load, but isn't in the scene manager. Use addEntity().`);
                n.forceVisible = i
            }
            this.update()
        }
        setExtraEntityOptions(t) {
            this._entityExtraOptions = {
                ...t
            }
        }
        updateEntityLayerVisibilityForChildren(t, e) {
            const i = this.app.getManager("layer")
              , s = this._scene.getEngine().getTime();
            for (let n = 0, o = this._entityStatuses.getSize(); n < o; n++) {
                const o = this._entityStatuses.getAt(n);
                a.Parenting.getAllAncestorsOfEntity(o.key, s).has(t) && (o.value.layerVisibility = i.isEntityVisibleWithCurrentLayers(o.key, e))
            }
        }
        updateEntityLayerVisibility(t) {
            const e = this.app.getManager("layer");
            for (let i = 0, s = this._entityStatuses.getSize(); i < s; i++) {
                const s = this._entityStatuses.getAt(i);
                s.value.layerVisibility = e.isEntityVisibleWithCurrentLayers(s.key, t)
            }
        }
        update() {
            const t = this.app.getManager("camera").cameraEntity
              , e = this.app.getManager("content");
            for (let i = 0, s = this._entityStatuses.getSize(); i < s; i++) {
                const s = this._entityStatuses.getAt(i)
                  , n = s.key
                  , o = s.value
                  , r = o.forceVisible || !o.dynamic && o.layerVisibility || o.dynamic && o.layerVisibility && this._isEntityVisibleWithinParent(n) || t?.getParent()?.getName() === n;
                let l = this._scene.getEntity(n);
                if (r && null === l) {
                    this._createEntity(n);
                    const t = a.SceneHelpers.getDependentEntities(n);
                    for (const e of t)
                        null === this._scene.getEntity(e) && this._createEntity(e)
                } else if (!r && null !== l) {
                    const i = t.getParent()?.getName()
                      , s = e.getEntityInfo(n).ignoreDependentWhenUnloading;
                    let a = !1;
                    for (let t = 0, e = o.dependentEntities.length; t < e; t++) {
                        const e = this._scene.getEntity(o.dependentEntities[t])?.getName();
                        if (e) {
                            if (e === i && s?.includes(i)) {
                                a = !1;
                                break
                            }
                            a = !0
                        }
                    }
                    if (!a) {
                        for (let t = 0, e = this._entityWillBeUnloadedCallbacks.length; t < e; t++)
                            this._entityWillBeUnloadedCallbacks[t](l),
                            l = null;
                        o.dependentEntities = [],
                        this._scene.removeEntity(n)
                    }
                }
                const c = o.forceVisible || o.layerVisibility || this._isAncestorOfCamera(t, n) || o.entitiesForcingThisVisible.size > 0;
                null !== l && o.visible !== c && this.setVisibility(c, n)
            }
        }
        _createEntity(t) {
            const e = a.Entity.create(t, this._scene, this._entityExtraOptions);
            this._entityStatuses.get(t).visible || this.setVisibility(!1, t);
            const i = a.SceneHelpers.getDependentEntities(t);
            for (const e of i) {
                let i = this._entityStatuses.get(e);
                void 0 === i && (this.addEntity(e, this._entityStatuses.get(t).dynamic),
                i = this._entityStatuses.get(e)),
                i.dependentEntities.push(t)
            }
            for (let t = 0, i = this._entityLoadedCallbacks.length; t < i; t++)
                this._entityLoadedCallbacks[t](e);
            return e
        }
        _isAncestorOfCamera(t, e) {
            let i = t;
            for (; null !== i; ) {
                if (i.getName() === e)
                    return !0;
                for (let t = 0, s = i.getNumParentingTableEntries(); t < s; t++)
                    if (i.getParentingTableEntry(t)[1] === e)
                        return !0;
                i = i.getParent()
            }
            return !1
        }
        setVisibility(t, e) {
            const i = this._entityStatuses.get(e);
            void 0 !== i && (i.visible = t);
            const s = this._scene.getEntity(e);
            if (null === s)
                return;
            const n = this.app.getManager("layer")
              , a = n.getLayer("trails").visible
              , r = n.getLayer("labels").visible;
            for (let e = 0; e < s.getNumComponents(); e++) {
                const n = s.getComponentAt(e);
                "sun" !== s.getName() && (t && n instanceof o.TrailComponent ? n.setEnabled(t && a && !i.componentTypesNotVisible.has(o.TrailComponent)) : t && n instanceof o.DivComponent ? n.setEnabled(t && r && !i.componentTypesNotVisible.has(o.DivComponent)) : n.setEnabled(t && !Array.from(i.componentTypesNotVisible).some((t => n instanceof t))))
            }
            const l = this.app.getManager("content").getEntityInfo(e);
            if (void 0 !== l.forceVisibleEntities)
                for (let i = 0, s = l.forceVisibleEntities.length; i < s; i++) {
                    const s = this._entityStatuses.get(l.forceVisibleEntities[i]);
                    if (void 0 === s)
                        throw new Error(`Entity ${e} was set to force load, but isn't in the scene manager. Use addEntity().`);
                    t ? s.entitiesForcingThisVisible.add(e) : s.entitiesForcingThisVisible.delete(e)
                }
        }
        _isEntityVisibleWithinParent(t) {
            const e = a.Parenting.getParentOfEntity(t, this._scene.getEngine().getTime())
              , i = this._scene.getEntity(e);
            if (null === i)
                return !1;
            const s = a.Entity.getEntityOptions(e);
            return (s.systemRadius || 25 * s.radius || 25 * s.extentsRadius) / i.getExtentsRadius() * i.getGreatestPixelSpaceExtentsRadius() >= 20
        }
        get(t) {
            return void 0 !== this._scenes[t] ? this._scenes[t] : null
        }
        getEntitiesNames() {
            const t = [];
            for (let e = 0; e < this._scene.getNumEntities(); e++) {
                const i = this._scene.getEntityAt(e);
                t.push(i.getName())
            }
            return t
        }
        getParent(t) {
            const e = this._scene.getEntity(t);
            if (null !== e) {
                const t = e.getParent();
                if (null !== t)
                    return t.getName()
            }
            return null
        }
        getParentList(t) {
            let e = this.getParent(t);
            const i = [];
            for (; null !== e && "" !== e; )
                i.push(e),
                e = this.getParent(e);
            return i
        }
        getDependencies(t) {
            const e = this._scene.getEntity(t)
              , i = new Set;
            if (null !== e)
                for (let t = 0; t < e.getNumParentingTableEntries(); t++) {
                    const s = e.getParentingTableEntry(t)[1];
                    "" !== s && i.add(s)
                }
            const s = a.Entity.getEntityOptions(t);
            if (void 0 !== s)
                for (const e of Object.keys(s)) {
                    const n = s[e];
                    if ("parents" === e)
                        for (let t = 0; t < n.length; t++) {
                            const e = n[t][1];
                            "" !== e && i.add(e)
                        }
                    "align" === e && (n.primary && n.primary.target && n.primary.target !== t && i.add(n.primary.target),
                    n.secondary && n.secondary.target && n.secondary.target !== t && i.add(n.secondary.target))
                }
            return Array.from(i)
        }
        async isReady(t, e) {
            e = void 0 === e ? this.pioneer.getTime() : this.app.getManager("time").momentToET(e),
            await this._scene.waitTillEntitiesInPlace([t], e)
        }
        async isListReady(t, e) {
            const i = [];
            void 0 === e && (e = [void 0]);
            for (let s = 0; s < t.length; s++)
                for (let n = 0; n < e.length; n++)
                    i.push(this.isReady(t[s], e[n]));
            await Promise.all(i)
        }
        async tileIsReady(t) {
            let e = null;
            return new Promise(( (i, s) => {
                const n = setInterval(( () => {
                    t.isEnabled() && t.getEntity().isEnabled() || (clearInterval(n),
                    s(new Error("disabled"))),
                    null === e && null !== t.getTilesLoadedPromise() && (e = t.getTilesLoadedPromise().then(( () => {
                        clearInterval(n),
                        i(!0)
                    }
                    )))
                }
                ), 30)
            }
            ))
        }
        async terrainIsReady(t) {
            let e = null;
            return new Promise((i => {
                const s = setInterval(( () => {
                    t.isEnabled() && t.getEntity().isEnabled() || (clearInterval(s),
                    i(!0)),
                    null === e && null !== t._loadedPromise && (e = t.getTilesLoadedPromise().then(( () => {
                        clearInterval(s),
                        i(!0)
                    }
                    )))
                }
                ), 30)
            }
            ))
        }
        async componentIsReady(t) {
            if (t.isEnabled() && "loaded" === t.getLoadState().state)
                return;
            return new Promise((e => {
                const i = setInterval(( () => {
                    t.isEnabled() && t.getEntity().isEnabled() || (clearInterval(i),
                    e(!0)),
                    "loaded" === t.getLoadState().state && (clearInterval(i),
                    e(!0))
                }
                ), 30)
            }
            ))
        }
        toggleStarfield(t) {
            for (let e = 0; e < 7; e++)
                this._scene.getEntity("sun").getComponent(o.StarfieldComponent, e).setEnabled(t)
        }
        toggleHeliosphere(t) {
            this._scene.getEntity("sun").getComponent(o.ModelComponent).setEnabled(t)
        }
        async toggleConstellations(t) {
            const e = this._scene.getEntity("sun");
            if (null === e)
                return;
            let i = e.getComponent(a.ConstellationsComponent);
            if (t && null === i) {
                i = e.addComponent(a.ConstellationsComponent),
                i instanceof a.ConstellationsComponent && (i.setUrl("$STATIC_ASSETS_URL/stars/constellations.bin"),
                i.setColor(new o.Color(.35,.7,1,.5))),
                await i.getLoadedPromise();
                const t = this.app.getManager("label")
                  , s = this.app.getManager("content")
                  , n = new o.Color(.35,.7,1,1)
                  , r = this.get("main").getEntity("camera").getComponent(o.CameraComponent);
                i.getNames().forEach((e => {
                    const a = `constellation_label_${e}`
                      , l = this._scene.getEntity(a)
                      , c = t.getDefaultWeight(a);
                    t.addLabel(l, c),
                    t.setLabelProps({
                        getLabelClass: t => `no-select ${s.getClassName(t, "constellation") ?? "constellation"}`,
                        handleTouch: null,
                        handleMouseEnter: t => {
                            i.setHighlight(i.getNearestConstellationIndex(new o.Vector2(t.x,t.y), r), n, 2.5)
                        }
                        ,
                        handleMouseLeave: () => {
                            i.setHighlight(void 0, n, 2.5)
                        }
                        ,
                        handleClick: null
                    }, [a])
                }
                ))
            } else if (!t && null !== i) {
                const t = this.app.getManager("label");
                i.getNames().forEach((e => {
                    const i = `constellation_label_${e}`
                      , s = this._scene.getEntity(i);
                    t.removeLabel(s)
                }
                )),
                e.removeComponent(i)
            }
        }
        isHD() {
            return this._isHD
        }
        hasHD(t) {
            const e = this._scene.getEntity(t);
            if (null === e)
                return !1;
            if (Object.prototype.hasOwnProperty.call(this._hdWMTSMap, t))
                return !0;
            if (null !== e.getParent() && Object.prototype.hasOwnProperty.call(this._hdWMTSMap, e.getParent().getName()))
                return !0;
            if (null !== e.getComponent(o.SpheroidLODComponent)) {
                const t = e.getComponent(o.SpheroidLODComponent).getTextureSizes("color");
                for (let e = 0; e < t.length; e++)
                    if (t[e] > this._hdBreakpointSize)
                        return !0
            }
            return !1
        }
        setHDBreakpoints(t, e) {
            this._hdBreakpointSize = t,
            this._maxTextureSize = e
        }
        async toggleHD() {
            this._isHD = !this._isHD,
            this._isHD || this.pioneer.getConfig().setValue("maxTextureSize", this._hdBreakpointSize);
            for (const t in this._hdWMTSMap) {
                const e = this._hdWMTSMap[t]
                  , i = this._scene.getEntity(t)
                  , s = i.getComponent(o.SpheroidLODComponent)
                  , n = i.getComponent(a.WMTSComponent, e);
                if (r.AppUtils.isMobileMode() && n.setMaxLevel(5),
                n.setEnabled(this._isHD),
                this._isHD) {
                    this.addLoading(t, "wmts"),
                    await this.pioneer.waitUntilNextFrame();
                    !0 === await this.tileIsReady(n).catch(( () => {
                        this.removeLoading(t, "wmts")
                    }
                    )) && (s.setEnabled(!1),
                    this.removeLoading(t, "wmts"))
                } else
                    s.setEnabled(!0);
                this._isHD && this.pioneer.getConfig().setValue("maxTextureSize", this._maxTextureSize)
            }
        }
        async updateHDTarget(t, e) {
            const i = this.app.getManager("content")
              , s = this.app.getManager("router").currentView;
            let n = e;
            if (this._hdToggleEntity = null,
            "Planet" === t.category || "Moon" === t.category || "Dwarf Planet" === t.category || "Star" === t.category)
                n = e;
            else {
                const t = this.getParent(e);
                if ("event" === s)
                    return void (n = this.app.getView("event")._eventInfo?.target);
                const o = await this.findClosestSpaceObjectTo(e);
                if (null !== t) {
                    const e = i.getEntityInfo(t);
                    if ("Planet" === e.category || "Moon" === e.category)
                        return void (n = t);
                    if ("Landing site" === e.category) {
                        return void (n = this.getParent(t))
                    }
                    if (o)
                        return t === o ? void (n = t) : void (n = o)
                }
            }
            null !== n && this.hasHD(n) ? this._hdToggleEntity = n : this._hdToggleEntity = null
        }
        async findClosestSpaceObjectTo(t) {
            const e = this.get("main")
              , i = a.SceneHelpers.getDependentEntities(t)
              , s = Array.from(i)
              , n = s.filter((t => this.hasHD(t)));
            return e.waitTillEntitiesInPlace(s, this.app.pioneer.getTime(), 3).then((async () => {
                let i = ""
                  , s = e.getEntity(n[0])?.getDistanceTo(e.getEntity(t), !1);
                return n.forEach((n => {
                    const o = e.getEntity(n).getDistanceTo(e.getEntity(t), !1);
                    o < s && (s = o,
                    i = n)
                }
                )),
                i
            }
            )).catch((t => {
                console.warn(t)
            }
            ))
        }
        async forceTextureSizeForEntity(t, e, i="color") {
            const s = this.app.pioneer.getScene("main").getEntity(t).getComponent(o.SpheroidLODComponent);
            null != s && s.forceTextureSize(i, e)
        }
        async isEntityHD(t) {
            const e = this.app.pioneer.getScene("main").getEntity(t).getComponent(o.SpheroidLODComponent);
            return null != e && (await e.getTexturesLoadedPromise(),
            e.getTextureCurrentSize("color", 0) > this._hdBreakpointSize)
        }
        async toggleHDTextureForEntity(t, e=null) {
            const i = await this.isEntityHD(t);
            if (null !== e && i === e)
                return e;
            const s = this.app.pioneer.getScene("main").getEntity(t).getComponent(o.SpheroidLODComponent)
              , n = null !== e ? e : !i
              , a = n ? r.AppUtils.isiPhone() ? this._mobileTextureSize : this._maxTextureSize : this._hdBreakpointSize;
            return this.addLoading(t, "spheroidLOD"),
            s.getTextureNames().forEach((e => {
                this.forceTextureSizeForEntity(t, a, e)
            }
            )),
            await s.getTexturesLoadedPromise(),
            this.removeLoading(t, "spheroidLOD"),
            n
        }
        createRing(t, e, i, {orbitPlaneEntityName: s, color: n, numCircles: r=1, numSpokes: l=0, labelPosition: c=new o.Vector3(-e,0,0), labelText: h="", isEnable: d=!0}={}) {
            const u = this._scene.addEntity(t);
            u.setPosition(o.Vector3.Zero);
            const p = this._scene.getEntity(i);
            u.setParent(p);
            const m = u.addComponent(a.DiscGridComponent);
            m.setLineWidth(6),
            m.setSize(e),
            m.setNumCircles(r),
            m.setNumSpokes(l),
            m.setIgnoreDistance(!0),
            s && this.setAlignPlane(u, s),
            n instanceof o.Color && m.setColor(n);
            const _ = this._scene.addEntity(`${t}Label`);
            _.setPosition(o.Vector3.Zero),
            _.setParent(p);
            _.addController(o.FixedController).setPosition(c);
            const g = _.addComponent(o.DivComponent);
            g.setFadeWhenCloseToCamera(!1);
            g.getDiv().classList.add("ring-label"),
            g.getDiv().innerHTML = h,
            u.setEnabled(d),
            _.setEnabled(d)
        }
        createTorus(t, e, i, s, {orbitPlaneEntityName: n, color: r, visibleDistance: l=[Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY], labelPosition: c=new o.Vector3(-i,0,0), labelText: h="", isEnable: d=!0}={}) {
            const u = this._scene.addEntity(t);
            u.setPosition(o.Vector3.Zero);
            const p = this._scene.getEntity(s);
            u.setParent(p);
            const m = u.addComponent(a.TorusComponent);
            m.setInnerRadius(e),
            m.setOuterRadius(i),
            m.setVisibleDistanceInterval(new o.Interval(...l)),
            n && this.setAlignPlane(u, n),
            r instanceof o.Color && m.setColor(r);
            const _ = this._scene.addEntity(`${t}Label`);
            _.setPosition(o.Vector3.Zero),
            _.setParent(p);
            _.addController(o.FixedController).setPosition(c);
            const g = _.addComponent(o.DivComponent);
            g.setFadeWhenCloseToCamera(!1);
            g.getDiv().classList.add("ring-label"),
            g.getDiv().innerHTML = h,
            u.setEnabled(d),
            _.setEnabled(d)
        }
        setEntityHDWMTS(t, e) {
            this._hdWMTSMap[t] = e
        }
        async enableWMTSComponent(t, e) {
            r.AppUtils.isMobileMode() && e.setMaxLevel(5);
            const i = this.get("main").getEntity(t).getComponent(o.SpheroidLODComponent);
            this.addLoading(t, "wmts"),
            e.setEnabled(!0),
            await this.pioneer.waitUntilNextFrame();
            await this.tileIsReady(e).catch(( () => {
                this.removeLoading(t, "wmts")
            }
            )) ? (i.setEnabled(!1),
            this.removeLoading(t, "wmts")) : i.setEnabled(!0)
        }
        async addWMTSComponent(t, e) {
            this.addLoading(t, "wmts");
            const i = this.app.getManager("wmts")
              , s = await i.initWMTS(t, e);
            s ? (this.removeLoading(t, "wmts"),
            await this.enableWMTSComponent(t, s)) : await this.showWMTSError(t)
        }
        async showWMTSError(t) {
            this.removeLoading(t, "wmts");
            const e = this.app.getComponent("toast")
              , i = "WMTS Data could not be loaded. Switching to " + (this.hasHD(t) ? "HD" : "standard") + " map.";
            e.setError(!0),
            e.setContent(i),
            e.show(),
            this.hasHD(t) && !this.isHD() && await this.toggleHDTextureForEntity(t)
        }
        loadWMTSFromJSON(t) {
            for (const e in t) {
                let i = "";
                for (const s in t[e])
                    if ("hd" === s || "" === i)
                        i = t[e][s],
                        this._hdWMTSMap[e] = i;
                    else {
                        const i = t[e][s]
                          , n = this._scene.getEntity(e).addComponent(a.WMTSComponent, s);
                        n.setEnabled(!1),
                        n.setEndPoint(i.endPoint),
                        n.setLayer(i.layer),
                        i.tile && n.setTileMatrixSet(i.tile);
                        const o = new Date;
                        "yesterday" === i.time ? (o.setDate(o.getDate() - 1),
                        n.setDimensionValue("Time", o.getFullYear() + "-" + String(o.getMonth() + 1).padStart(2, "0") + "-" + String(o.getDate()).padStart(2, "0"))) : "now" === i.time && n.setDimensionValue("Time", o.getFullYear() + "-" + String(o.getMonth() + 1).padStart(2, "0") + "-" + String(o.getDate()).padStart(2, "0")),
                        i.level ? n.setMaxLevel(i.level) : n.setMaxLevel(1 / 0)
                    }
            }
        }
        setAlignPlane(t, e) {
            const i = this._scene.getEntity(e)
              , s = new o.Quaternion;
            i.getController(o.DynamoController).getOrbitOrientation(s, this.app.pioneer.getTime()),
            t.setOrientation(s)
        }
        clearTempEntities() {
            const t = this.app.getManager("camera").cameraEntity;
            if (null === t || null === t.getParent())
                return;
            const e = t.getParent().getName();
            this._tempEntities = this._tempEntities.filter((t => {
                if (e === t.getName())
                    return !0;
                return this.app.getManager("label").removeLabel(t),
                this._scene.removeEntity(t?.getName()),
                !1
            }
            ))
        }
        addTempEntity(t) {
            this._tempEntities.push(t)
        }
        addLoading(t, e) {
            const i = t + "_" + e;
            this._loadingItems.indexOf(i) < 0 && this._loadingItems.push(i),
            this._loadingItems.length > 0 && (this._isLoading = !0,
            this.triggerCallbacks("loading"))
        }
        removeLoading(t, e) {
            if ("*" === t)
                for (let t = 0; t < this._loadingItems.length; t++)
                    this._loadingItems[t].includes(e) && this._loadingItems.splice(t, 1);
            else {
                const i = t + "_" + e
                  , s = this._loadingItems.indexOf(i);
                s >= 0 && this._loadingItems.splice(s, 1)
            }
            0 === this._loadingItems.length && (this._isLoading = !1,
            this.triggerCallbacks("loaded", [t]))
        }
        forceLoad(t) {
            t.setForceLoaded(!0),
            this._loadedComponents.push(t)
        }
        removeForceLoad(t) {
            this._loadedComponents = this._loadedComponents.filter((e => e !== t || (t.setForceLoaded(!1),
            !1)))
        }
        clearForceLoad() {
            for (let t = 0; t < this._loadedComponents.length; t++) {
                this._loadedComponents[t].setForceLoaded(!1)
            }
            this._loadedComponents = []
        }
        getDistance(t, e, {time: i, subtractRadius: s=!1, precision: n=0}={}) {
            const a = o.Vector3.pool.get()
              , r = this._scene.getEntity(t)
              , l = this._scene.getEntity(e);
            let c = 0;
            if (void 0 !== i) {
                const t = o.TimeUtils.unixToEt(i.valueOf() / 1e3);
                r.getPositionRelativeToEntity(a, o.Vector3.Zero, l, t)
            } else
                r.getPositionRelativeToEntity(a, o.Vector3.Zero, l);
            if (c = a.magnitude(),
            s) {
                c -= r.getExtentsRadius() + l.getExtentsRadius()
            }
            if (n > 0) {
                const t = Math.pow(10, Math.floor(Math.log10(c)) - n);
                c = Math.round(c / t) * t
            }
            return o.Vector3.pool.release(a),
            c
        }
        getSpeed(t, e, {time: i}={}) {
            const s = o.Vector3.pool.get()
              , n = this._scene.getEntity(t);
            let a = null;
            if (a = void 0 === e ? n.getParent() : this._scene.getEntity(e),
            void 0 !== i) {
                const t = this.app.getManager("time").momentToET(i);
                n.getVelocityRelativeToEntity(s, o.Vector3.Zero, a, t)
            } else
                n.getVelocityRelativeToEntity(s, o.Vector3.Zero, a);
            return o.Vector3.pool.release(s),
            s.magnitude()
        }
        getCoverage(t, e=!0) {
            const i = {
                min: r.AppUtils.constants.maxDate,
                max: r.AppUtils.constants.minDate
            }
              , s = this.pioneer.getScene("main").getEntity(t);
            let a = s.getPositionCoverage().min
              , l = s.getPositionCoverage().max;
            if (e && (a = Math.max(s.getPositionCoverage().min, s.getOrientationCoverage().min),
            l = Math.min(s.getPositionCoverage().max, s.getOrientationCoverage().max)),
            i.min = s ? Math.min(a, i.min) : i.min,
            i.max = s ? Math.max(l - .001, i.max) : i.max,
            i.min === -1 / 0 || i.min < r.AppUtils.minDate)
                i.min = n()(r.AppUtils.constants.minDate);
            else {
                i.min = Math.ceil(1e3 * i.min) / 1e3;
                let t = 1e3 * o.TimeUtils.etToUnix(i.min);
                t = Math.ceil(1e3 * t) / 1e3,
                i.min = n().tz(t, "ETC/Utc")
            }
            if (i.max === 1 / 0 || i.max > r.AppUtils.maxDate)
                i.max = n()(r.AppUtils.constants.maxDate);
            else {
                i.max = Math.floor(1e3 * i.max) / 1e3;
                let t = 1e3 * o.TimeUtils.etToUnix(i.max);
                t = Math.floor(1e3 * t) / 1e3,
                i.max = n().tz(t, "ETC/Utc")
            }
            return i
        }
        async toggleRing(t) {
            console.log("toggleRing", t)
        }
        get main() {
            return this._scene
        }
        get isLoading() {
            return this._isLoading
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        WMTSManager: function() {
            return WMTSManager
        }
    });
    i(5);
    var s = i(542)
      , n = i(2);
    class WMTSManager extends n.BaseManager {
        constructor(t) {
            super(t),
            this._wmtsComponentStates = new Map,
            this.bindFunctions(["getWMTSComponentState", "initWMTS"])
        }
        getWMTSComponentState(t) {
            return this._wmtsComponentStates.get(t)
        }
        setWMTSComponentState(t, e) {
            this._wmtsComponentStates.set(t, e)
        }
        getImageDate(t) {
            const e = new Date;
            if ("yesterday" === t)
                e.setDate(e.getDate() - 1);
            else if ("now" !== t)
                return console.warn("Invalid time parameter"),
                null;
            return e.getFullYear() + "-" + String(e.getMonth() + 1).padStart(2, "0") + "-" + String(e.getDate()).padStart(2, "0")
        }
        async verifyImageURL(t, e, i) {
            try {
                const s = new Promise(( (t, e) => {
                    setTimeout(( () => e(new Error("Image Server Timed Out"))), 5e3)
                }
                ))
                  , n = (async () => {
                    const s = (await this.app.pioneer.getDownloader().download(t + "/1.0.0/WMTSCapabilities.xml", "text", -1)).content;
                    if ("string" != typeof s)
                        throw new Error("XML is not a string");
                    const n = (new DOMParser).parseFromString(s, "application/xml").querySelector("Contents > Layer ResourceURL")?.getAttribute("template").replace("{Time}", e).replace("{TileMatrixSet}", i).replace("{TileMatrix}", "0").replace("{TileRow}", "0").replace("{TileCol}", "0");
                    if (!n)
                        throw new Error("Template URL not found");
                    const o = await fetch(n, {
                        method: "HEAD"
                    });
                    if (!o.ok)
                        throw new Error("Image URL fetch failed: " + o.status);
                    const a = o.headers.get("content-type");
                    if (!a || !a.startsWith("image/"))
                        throw new Error("Fetched resource is not an image.");
                    return !0
                }
                )();
                return await Promise.race([n, s])
            } catch (t) {
                return console.error("Error verifying WMTS layer:", t),
                !1
            }
        }
        async getValidWMTSData(t) {
            const {wmtsManifest: e, time: i, fallbacks: s} = t;
            if (!e)
                return t;
            let n;
            try {
                const t = await this.app.pioneer.getDownloader().download(e, "text", -1);
                n = JSON.parse(t.content.toString())
            } catch (t) {
                return console.error("Error downloading or parsing wmtsManifest:", t),
                null
            }
            const o = this.getImageDate(i)
              , a = n.availableDates[o];
            if (!a)
                return console.warn(`No layer info found for date ${o}`),
                null;
            const r = [t, ...s].find((t => t.layer === a.layerId)).endPoint
              , l = a.layerId;
            return await this.verifyImageURL(r, o, t.tile) ? {
                ...t,
                layer: l,
                endPoint: r
            } : (console.warn(`Invalid layer for date ${o}`),
            null)
        }
        async initWMTS(t, e) {
            const i = this.app.pioneer.getScene("main").getEntity(t);
            let n = i.getComponent(s.WMTSComponent);
            null === n && (n = i.addComponent(s.WMTSComponent, e.id)),
            n.setEnabled(!1);
            const o = await this.getValidWMTSData(e);
            if (!o)
                return i.removeComponent(n),
                this.setWMTSComponentState(t, !1),
                null;
            n.setEndPoint(o.endPoint),
            n.setLayer(o.layer),
            o.tile && n.setTileMatrixSet(o.tile);
            const a = this.getImageDate(o.time);
            return n.setDimensionValue("Time", a),
            n.setMaxLevel(o.level || 1 / 0),
            n.setMinLevel(2),
            this.setWMTSComponentState(t, !0),
            n
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        LayerManager: function() {
            return LayerManager
        }
    });
    var s = i(542)
      , n = i(5)
      , o = i(2);
    class LayerManager extends o.BaseManager {
        constructor(t) {
            super(t),
            this._sceneManager = t.getManager("scene"),
            this._contentManager = t.getManager("content"),
            this._layers = {},
            this._contextualLayersList = ["majorMoons", "minorMoons", "landers", "orbiters", "satelliteGroup", "heliosphere"],
            this._targetId = "",
            this._previousTarget = [],
            this._dependencies = new Set,
            this._previousDependencies = new Set,
            this._currentSurfaceLayer = "default",
            this.bindFunctions(["resetContextualVisibility", "toggleLayer", "changeSpheroidMap", "resetContextualLayers"]),
            this._eventNames.push("toggleLayer"),
            this._initCallbacks()
        }
        addLayer(t, {name: e="", group: i="", categories: s=[], defaultVisibility: n=!0, toggleCallback: o=[], sublayers: a=[]}) {
            void 0 === this._layers[t] && (this._layers[t] = {}),
            this._layers[t].name = e,
            this._layers[t].group = i,
            this._layers[t].defaultVisibility = n,
            this._layers[t].visible = n,
            Array.isArray(s) || (s = [s]),
            this._layers[t].categories = s,
            Array.isArray(a) || (a = [a]),
            this._layers[t].sublayers = a;
            for (let e = 0; e < a.length; e++) {
                const i = a[e];
                void 0 === this._layers[i] && (this._layers[i] = {}),
                this._layers[i].parent = t
            }
            Array.isArray(o) || (o = [o]),
            this._layers[t].toggleCallback = o
        }
        addCallback(t, e) {
            const i = this.getLayer(t);
            null !== i && i.toggleCallback.push(e)
        }
        removeCallback(t, e) {
            const i = this.getLayer(t);
            if (null === i)
                return;
            const s = i.toggleCallback.indexOf(e);
            i.toggleCallback.splice(s, 1)
        }
        getLayer(t) {
            return void 0 === this._layers[t] ? null : this._layers[t]
        }
        getCurrentSurfaceLayer() {
            return this._currentSurfaceLayer
        }
        async changeSpheroidMap(t, e, i={}) {
            if ("cmts" === e.type)
                return void console.error("This function does not yet handle CMTS texture");
            const o = this.app.getManager("scene")
              , a = this.app.getManager("wmts")
              , r = o.get("main").getEntity(t)?.getComponent(n.SpheroidLODComponent)
              , l = o.get("main").getEntity(t)?.getComponent(n.AtmosphereComponent)
              , c = o.get("main").getEntity(t)?.getComponent(s.WMTSComponent);
            this._currentSurfaceLayer = e.id,
            r && "texture" === e.type ? (!1 === a.getWMTSComponentState(t) && o.isEntityHD(t) && await o.toggleHDTextureForEntity(t, !1),
            r.setEnabled(!0),
            o.addLoading(t, "spheroidLOD"),
            Object.keys(e.textures).forEach((t => {
                const i = "$STATIC_ASSETS_URL/maps/" + e.textures[t].url;
                r.setTexture(t, i, e.textures[t].sizes)
            }
            )),
            await r.getLoadedPromise(),
            null !== c && c.setEnabled(!1),
            o.removeLoading(t, "spheroidLOD")) : "wmts" === e.type && (null === c || c.getName() !== e.id ? await o.addWMTSComponent(t, e) : !1 === c.isEnabled() && await o.enableWMTSComponent(t, c)),
            null != l && !1 !== i.atmosphere && l.setEnabled(e.features.includes("atmosphere"))
        }
        async resetSpheroidMap(t) {
            const e = this._app.pioneer.getScene("main").getEntity(t)?.getComponent(n.AtmosphereComponent);
            let i = ["shadowEntities"];
            e?.isEnabled() && (i = ["shadowEntities", "atmosphere"]);
            const s = this._app.getManager("content").getSpheroidDefaultTextureInformation(t, i);
            "default" !== s?.id && await this.changeSpheroidMap(t, s)
        }
        async toggleLayer(t, e={}, i) {
            const {spout: n, spoutFontSize: o} = this.app.getManager("router").configs;
            if (void 0 === this._layers[t])
                return;
            if (e.layerId = t,
            void 0 !== i && this._layers[t].visible === i)
                return;
            this._layers[t].visible = !this._layers[t].visible;
            for (let i = 0; i < this._layers[t].toggleCallback.length; i++) {
                (0,
                this._layers[t].toggleCallback[i])(this._layers[t].visible, e)
            }
            for (let i = 0; i < this._layers[t].sublayers.length; i++) {
                this.getLayer(this._layers[t].sublayers[i]).visible = this._layers[t].visible,
                this.triggerCallbacks("toggleLayer", [this._layers[t].sublayers[i], this._layers[t].visible, e])
            }
            this.triggerCallbacks("toggleLayer", [t, this._layers[t].visible, e]);
            const a = this.app.getManager("scene");
            if (null !== e.parentId && void 0 !== e.parentId ? a.updateEntityLayerVisibilityForChildren(e.parentId, e.satelliteGroup) : a.updateEntityLayerVisibility(e.satelliteGroup),
            !0 === n && this._layers[t].visible) {
                const e = [];
                if (await this.pioneer.waitUntilNextFrame(),
                t.toLowerCase().includes("constellations")) {
                    this.app.pioneer.getScene("main").getEntity("sun").getComponent(s.ConstellationsComponent).getNames().forEach((t => {
                        e.push(this.app.pioneer.getScene("main").getEntity(`constellation_label_${t}`))
                    }
                    ))
                }
                await this.app.getManager("spout").setUpSpoutLabels(o, e?.[0]?.id)
            }
        }
        setTarget(t) {
            if (this._previousTarget.push(this._targetId),
            this._previousDependencies = new Set([...this._previousDependencies, ...this._dependencies]),
            this._targetId = t,
            this._dependencies.clear(),
            "" !== this._targetId) {
                const t = this._sceneManager.getDependencies(this._targetId);
                this._dependencies = new Set(t)
            }
        }
        resetTarget() {
            for (let t = 0; t < this._previousTarget.length; t++) {
                const e = this._previousTarget[t]
                  , i = this.app.getManager("camera").cameraEntity;
                if (null === i || null === i.getParent())
                    return;
                if (i.getParent().getName() === e)
                    return
            }
            for (let t = 0; t < this._previousTarget.length; t++) {
                const e = this._previousTarget[t];
                this.resetContextualVisibility(e)
            }
            this._previousTarget = [],
            this._previousDependencies.clear()
        }
        resetContextualVisibility(t) {
            const e = this._sceneManager.main.getEngine().getTime();
            let i = this.getContextualLayers(t);
            for (; "" !== t && 0 === i.length; )
                t = s.Parenting.getParentOfEntity(t, e),
                i = this.getContextualLayers(t);
            let n = this._targetId;
            for (i = this.getContextualLayers(n); "" !== n && 0 === i.length; )
                n = s.Parenting.getParentOfEntity(n, e),
                i = this.getContextualLayers(n);
            if (n !== t) {
                this._contextId = t;
                for (let e = 0; e < i.length; e++) {
                    const s = i[e]
                      , n = this.getLayer(s);
                    if (void 0 !== n.parent) {
                        this.getLayer(n.parent).visible !== n.visible && this.toggleLayer(s, {
                            parentId: t,
                            group: n.group
                        })
                    } else
                        n.visible !== n.defaultVisibility && this.toggleLayer(s, {
                            parentId: t,
                            group: n.group
                        })
                }
            }
        }
        getTarget() {
            return this._targetId
        }
        getEntityLayer(t) {
            const e = this._contentManager.getEntityInfo(t);
            if (null === e)
                return null;
            const i = e.category
              , s = e.subcategory;
            return this.getLayerFromCategory(s) || this.getLayerFromCategory(i)
        }
        getLayerFromCategory(t) {
            if (!t)
                return null;
            for (const [e,i] of Object.entries(this._layers))
                if (i.categories.includes(t))
                    return this._layers[e];
            return null
        }
        getLayerFromSatelliteGroup(t) {
            if (!t)
                return null;
            for (const [e,i] of Object.entries(this._layers))
                if (i.categories.includes(t))
                    return this._layers[e];
            return null
        }
        getContextualLayers(t) {
            const e = [];
            if ("" === t)
                return e;
            const i = this.app.getManager("content")
              , n = i.getEntityInfo(t)
              , o = n?.hasMoons ? s.Entity.getEntityNamesInGroup(t + ", moons") : new Set
              , a = s.Entity.getEntityNamesInGroup(t + ", spacecraft");
            "sun" === t && !1 === e.includes("heliosphere") && e.push("heliosphere"),
            o.forEach((t => {
                const s = i.getEntityInfo(t);
                if (null !== s) {
                    switch (s.subcategory || s.category) {
                    case "Major Moon":
                        !1 === e.includes("majorMoons") && e.push("majorMoons");
                        break;
                    case "Minor Moon":
                        !1 === e.includes("minorMoons") && e.push("minorMoons")
                    }
                }
            }
            ));
            const r = this._app.pioneer.getTime();
            return a.forEach((n => {
                const o = i.getEntityInfo(n);
                if (null !== o) {
                    switch (o.subcategory || o.category) {
                    case "Orbiter":
                        !1 === e.includes("orbiters") && s.Parenting.getParentOfEntity(n, r) === t && e.push("orbiters");
                        break;
                    case "Landing Site":
                    case "Lander":
                    case "Rover":
                        !1 === e.includes("landers") && s.Parenting.getParentOfEntity(n, r) === t && e.push("landers")
                    }
                }
            }
            )),
            n?.constellation && e.push("satelliteGroup"),
            e.sort(( (t, e) => {
                const i = Object.keys(this._layers);
                return i.indexOf(t) - i.indexOf(e)
            }
            )),
            e
        }
        resetContextualLayers(t, e) {
            const i = this.getContextualLayers(t);
            this._contextualLayersList.forEach((t => {
                !1 === i.includes(t) && ("heliosphere" === t ? this.toggleLayer(t, {
                    parentId: void 0
                }, this.getLayer(t).defaultVisibility || !1) : this.toggleLayer(t, {
                    parentId: e
                }, this.getLayer(t).defaultVisibility || !1))
            }
            ))
        }
        isEntityVisibleWithCurrentLayers(t, e) {
            const i = this._contentManager.getEntityInfo(t);
            if (null !== i) {
                const t = this.getLayerFromCategory(i.category)
                  , s = this.getLayerFromCategory(i.subcategory)
                  , n = this.getLayerFromSatelliteGroup(i.constellation);
                return null !== n && i.constellation === e ? n.visible : null !== s ? s.visible : null !== t ? t.visible : null === t && null === s
            }
            return !0
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        TrailManager: function() {
            return TrailManager
        }
    });
    var s = i(5)
      , n = i(542)
      , o = i(2);
    class TrailManager extends o.BaseManager {
        constructor(t, e) {
            super(t),
            this._scene = e,
            this._ids = [],
            this._hiddenIds = [],
            this._opacity = {
                primary: .75,
                secondary: .35,
                hover: 1
            },
            this._width = {
                default: [0, 2],
                hover: [2, 4]
            },
            this._orbitLinesOpts = {
                lineWidth: {
                    default: 1.2,
                    hover: 2
                },
                glowWidth: {
                    default: 0,
                    hover: 0
                },
                alphaFade: [22, 8]
            },
            this._orbitLineEntityNames = n.Entity.getEntityNamesInGroup("planets").add("moon"),
            this._colors = {
                default: new s.Color(1,1,1,this._opacity.secondary),
                mercury: new s.Color(151 / 255,104 / 255,172 / 255,this._opacity.primary),
                venus: new s.Color(176 / 255,121 / 255,25 / 255,this._opacity.primary),
                earth: new s.Color(0,.6,.8,this._opacity.primary),
                mars: new s.Color(154 / 255,78 / 255,25 / 255,this._opacity.primary),
                jupiter: new s.Color(218 / 255,139 / 255,114 / 255,this._opacity.primary),
                saturn: new s.Color(213 / 255,193 / 255,135 / 255,this._opacity.primary),
                uranus: new s.Color(104 / 255,.8,218 / 255,this._opacity.primary),
                neptune: new s.Color(112 / 255,140 / 255,227 / 255,this._opacity.primary)
            },
            this.bindFunctions(["onHoverChange", "setUpTrail", "toggleTrails", "toggleOrbits"])
        }
        setScene(t) {
            this._scene = t
        }
        create(t) {
            if (this._scene.getEntity(t).getComponent(s.TrailComponent))
                return void console.warn("Trail already exists for", t);
            const e = this._scene.getEntity(t).addComponent(s.TrailComponent);
            return this._ids.push(t),
            e
        }
        setStartTime(t, e) {
            Array.isArray(t) || (t = [t]);
            for (let i = 0; i < t.length; i++) {
                const n = this._scene.getEntity(t[i]).getComponent(s.TrailComponent);
                n && n.setStartTime(e)
            }
        }
        setEndTime(t, e) {
            Array.isArray(t) || (t = [t]);
            for (let i = 0; i < t.length; i++) {
                const n = this._scene.getEntity(t[i]).getComponent(s.TrailComponent);
                n && n.setEndTime(e)
            }
        }
        onHoverChange(t, e, i=!1) {
            const o = this._scene.getEntity(t)
              , a = this._scene.getEntity(t).getComponent(s.TrailComponent)
              , r = o?.getComponent(n.OrbitLineComponent);
            if (!o || !a && !r)
                return;
            const l = new s.Color
              , c = a ?? r
              , h = e ? "hover" : "default";
            if (r) {
                const {lineWidth: t, glowWidth: e} = this._orbitLinesOpts;
                r.setLineWidth(t[h]),
                r.setGlowWidth(e[h])
            } else if (a) {
                const t = o.trailHover?.width?.[h] ?? this._width[h];
                a.setWidths(...t)
            }
            const {primary: d, secondary: u, hover: p} = this._opacity
              , m = e ? p : this._colors[t] ? d : u;
            l.copy(c.getColor()),
            l.a = m,
            c.setColor(l),
            i && a.setAlphaFade(l.a)
        }
        setFade(t, e) {
            Array.isArray(t) || (t = [t]);
            for (let i = 0; i < t.length; i++) {
                const n = this._scene.getEntity(t[i]).getComponent(s.TrailComponent);
                n && n.setAlphaFade(e)
            }
        }
        setWidths(t, e, i) {
            Array.isArray(t) || (t = [t]);
            for (let n = 0; n < t.length; n++) {
                const o = this._scene.getEntity(t[n]).getComponent(s.TrailComponent);
                o && o.setWidths(e, i)
            }
        }
        setMultipleWidths(t, e, i) {
            for (const n of t) {
                const t = this._scene.getEntity(n).getComponent(s.TrailComponent);
                t && t.setWidths(e, i)
            }
        }
        getColor(t) {
            const e = this._scene.getEntity(t).getComponent(s.TrailComponent);
            return e ? e.getColor() : null
        }
        setColor(t, e=null) {
            Array.isArray(t) || (t = [t]);
            for (let i = 0; i < t.length; i++) {
                const n = t[i]
                  , o = this._scene.getEntity(n).getComponent(s.TrailComponent);
                if (o) {
                    const t = e instanceof s.Color ? e : this._colors[n] || this._colors.default;
                    o.setColor(t)
                }
            }
        }
        setUpTrail(t) {
            const e = this._app.getManager("layer")
              , i = this._app.getManager("scene")
              , s = t.getName()
              , n = e.getLayer("trails")
              , o = this._orbitLineEntityNames.has(s);
            o && this.createOrbitLine(t),
            (null !== n && !n.visible || o) && i.setVisibility(!1, s)
        }
        show(t=null) {
            null === t ? t = this._hiddenIds.length > 0 ? this._hiddenIds : this._ids : Array.isArray(t) || (t = [t]);
            for (let e = 0; e < t.length; e++) {
                const i = t[e]
                  , n = this._scene.getEntity(i).getComponent(s.TrailComponent);
                if (n) {
                    const t = this._hiddenIds.indexOf(i);
                    -1 !== t && this._hiddenIds.splice(t, 1),
                    n.setEnabled(!0)
                } else
                    console.warn("TrailManager.show: Trail does not exist - ", i)
            }
        }
        hide(t=null) {
            null === t ? t = this._ids : Array.isArray(t) || (t = [t]),
            this._hiddenIds = t;
            for (let e = 0; e < t.length; e++) {
                const i = this._scene.getEntity(t[e]).getComponent(s.TrailComponent);
                i && i.setEnabled(!1)
            }
        }
        toggleTrails(t, {scene: e}={}) {
            void 0 === e && (e = this._scene);
            for (let i = 0; i < e.getNumEntities(); i++) {
                const n = e.getEntityAt(i)
                  , o = n.getComponent(s.TrailComponent);
                if (null !== o) {
                    const e = this._app.getManager("content").getEntityInfo(n.getName());
                    if (e) {
                        const i = e.category
                          , s = e.subcategory
                          , a = this._app.getManager("layer").getLayerFromCategory(s) || this._app.getManager("layer").getLayerFromCategory(i)
                          , {forceVisible: r=!1} = this.app.getManager("scene").getEntityStatus(n.getName()) || {};
                        null === a || a.visible || r ? o.setEnabled(t) : o.setEnabled(!1)
                    } else
                        o.setEnabled(t)
                }
            }
        }
        createOrbitLine(t) {
            const e = t.getComponent(s.TrailComponent);
            e && t.removeComponent(e);
            const i = t.addComponent(n.OrbitLineComponent)
              , {lineWidth: o, glowWidth: a, alphaFade: r} = this._orbitLinesOpts
              , l = this._colors[t.getName()] ?? this._colors.default;
            i.setColor(l),
            i.setPixelSpaceRadiiAlphaFade(...r),
            i.setLineWidth(o.default),
            i.setGlowWidth(a.default);
            const c = this._app.getManager("layer").getLayer("orbits").visible;
            i.setEnabled(c)
        }
        toggleOrbits(t) {
            this._orbitLineEntityNames.forEach((e => {
                this._scene.getEntity(e).getComponent(n.OrbitLineComponent)?.setEnabled(t)
            }
            ))
        }
        get ids() {
            return this._ids
        }
        set ids(t) {
            Array.isArray(t) || (t = [t]);
            for (let e = 0; e < t.length; e++) {
                const i = t[e];
                if (this._ids.includes(i))
                    continue;
                this._scene.getEntity(i).getComponent(s.TrailComponent) && this._ids.push(i)
            }
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        CameraManager: function() {
            return CameraManager
        }
    });
    var s = i(5)
      , n = i(542)
      , o = i(2);
    class CameraManager extends o.BaseManager {
        constructor(t, e) {
            super(t),
            this._viewport = null,
            this._defaultScene = e,
            this._cameraEntity = null,
            this._id = null,
            this._previousId = null,
            this._context = {
                id: ""
            },
            this._isTransitioning = !1,
            this._defaultMaxDistance = 2e18,
            this._selectionCallback = null,
            this._dynEnvMap = null,
            this._isFreeFly = !1,
            this._zoomSensitivity = {
                click: .3,
                hold: .1
            },
            this._fullLightColor = new s.Color(1,1,1,1),
            this._shadowLightColor = new s.Color(.15,.15,.15,1),
            this.bindFunctions(["zoomIn", "zoomOut", "addDynamicEnvMap", "getShadowLightColor", "getFullLightColor"])
        }
        createViewportAndCamera(t) {
            t && (this._defaultScene = t),
            null === this.pioneer.getViewport("main-viewport") && (this._viewport = this.pioneer.addViewport("main-viewport"),
            this._viewport.getDiv().style.width = "100%",
            this._viewport.getDiv().style.height = "100%",
            this._viewport.getDiv().style.left = "0",
            this._viewport.getDiv().style.top = "0"),
            null === this._defaultScene.getEntity("camera") && (this._cameraEntity = this._defaultScene.addEntity("camera")),
            this._cameraEntity.setOrientation(s.Quaternion.Identity);
            let e = this._cameraEntity.getComponent(s.CameraComponent);
            null === e && (e = this._cameraEntity.addComponent(s.CameraComponent)),
            this._viewport.setCamera(e),
            this._cameraLight = this._cameraEntity.getComponent(s.LightSourceComponent),
            null === this._cameraLight && (this._cameraLight = this._cameraEntity.addComponent(s.LightSourceComponent),
            this._cameraLight.setEnabled(!1),
            this.toggleCameraLight(!0, this._shadowLightColor)),
            null === this._dynEnvMap && (this._dynEnvMap = this._cameraEntity.addComponent(s.DynamicEnvironmentMapComponent))
        }
        getContext() {
            return this._context
        }
        getIsTransitioning() {
            return this._isTransitioning
        }
        setIsTransitioning(t) {
            this._isTransitioning = t
        }
        waitForTransitionComplete() {
            return new Promise((t => {
                let e = setInterval(( () => {
                    this._isTransitioning || (clearInterval(e),
                    e = null,
                    t(!0))
                }
                ), 1e3)
            }
            ))
        }
        setContext(t) {
            this._context = t,
            this._previousId = this._id,
            this._id = this._context.id;
            const e = new CustomEvent("cameraupdate",{
                detail: {
                    target: this._id,
                    context: this._context
                }
            });
            window.dispatchEvent(e)
        }
        getCurrentId() {
            return this._id
        }
        getShadowLightColor() {
            return this._shadowLightColor
        }
        getFullLightColor() {
            return this._fullLightColor
        }
        get defaultScene() {
            return this._defaultScene
        }
        get cameraEntity() {
            return this._cameraEntity
        }
        get cameraLight() {
            return this._cameraLight
        }
        get dynamicEnvMap() {
            return this._dynEnvMap
        }
        toggleCameraLight(t, e) {
            null !== this._cameraLight && (this._cameraLight.setEnabled(t),
            void 0 !== e && this._cameraLight.setColor(e))
        }
        updateLighting(t) {
            "flood" === t ? this.toggleCameraLight(!0, this._fullLightColor) : "natural" === t ? this.toggleCameraLight(!1) : "shadow" === t && this.toggleCameraLight(!0, this._shadowLightColor)
        }
        getSelectionCallback() {
            return this._selectionCallback
        }
        setSelectionCallback(t) {
            "function" == typeof t && (this._selectionCallback = t)
        }
        enterFreeFly() {
            this._isFreeFly = !0,
            this._cameraEntity.clearControllers(),
            this._cameraEntity.addController(s.FreeFlyController),
            this._cameraEntity.addController(s.LookController),
            this._cameraEntity.addController(s.RollController)
        }
        toggleFreeFly() {
            this._isFreeFly ? this.exitFreeFly() : this.enterFreeFly()
        }
        async goToEntity(t, {camera: e, scene: i, destination: o, distance: a, cinematic: r=!1, minRadius: l=.001, maxRadius: c=this._defaultMaxDistance, duration: h=.75, destinationUp: d, zoom: u=!0, select: p=!0, slowWhenCloseToParent: m=!0, useSpheroidRadiusForDistance: _=!1, roll: g=!1, keyframes: y, transitionFunction: f}={}) {
            const b = e || this._cameraEntity
              , T = i || this._defaultScene;
            if (this._id = t,
            await T.waitTillEntitiesInPlace([t]),
            this._isTransitioning = !0,
            void 0 !== o) {
                const e = new s.Vector3;
                e.sub(b.getPosition(), o);
                const i = b.getParent();
                if (null !== i) {
                    const n = i.getName();
                    if (!isNaN(e.magnitude())) {
                        const t = s.MathUtils.clamp01(e.magnitude() / b.getPosition().magnitude());
                        h = Math.max(h / 5, h * t)
                    }
                    if (!isNaN(e.magnitude()) && e.magnitude() <= .001 && t === n)
                        return void (this._isTransitioning = !1)
                }
            }
            try {
                if (void 0 !== y) {
                    b.clearControllers();
                    const t = b.addController(s.OrbitKeyframeController);
                    if (y.position)
                        for (let e = 0; e < y.position.length; e++) {
                            const i = y.position[e];
                            t.setPositionKeyframe(i.frame, i.position, i.relativeTo)
                        }
                    if (y.up)
                        for (let e = 0; e < y.up.length; e++) {
                            const i = y.up[e];
                            t.setUpKeyframe(i.frame, i.up)
                        }
                    if (y.focus)
                        for (let e = 0; e < y.focus.length; e++) {
                            const i = y.focus[e];
                            t.setFocusKeyframe(i.frame, i.name)
                        }
                    await t.getEndPromise(),
                    b.clearControllers()
                }
                if (await n.Cameras.goToEntity(b, T.getEntity(t), {
                    destination: o,
                    distance: a,
                    up: !1,
                    duration: h,
                    destinationUp: d,
                    zoom: u,
                    transitionFunction: f
                }),
                p) {
                    const t = b.addController(s.SelectController);
                    null !== this._selectionCallback && t.setCallback(this._selectionCallback)
                }
                const e = b.getController(s.OrbitController);
                e instanceof s.OrbitController && e.slowWhenCloseToParent(m);
                const i = b.getController(s.ZoomController);
                if (i && i instanceof s.ZoomController && (i.setDistanceClamp(new s.Interval(l,c)),
                i.setUseSpheroidRadiusForDistance(_)),
                g) {
                    b.getController(s.RollController)instanceof s.RollController || b.addController(s.RollController)
                }
                if (r) {
                    const t = b.getController(s.AlignController)
                      , e = b.addController(s.SpinController, "", t);
                    e instanceof s.SpinController && (e.setAxis(s.Vector3.ZAxis, !0),
                    e.setRate(.01),
                    e.setUsingRealTime(!0),
                    e.setRotatingPosition(!0));
                    const i = b.addController(s.TapController);
                    i instanceof s.TapController && i.setTapCallback(( () => {
                        b.removeController(e),
                        b.removeController(i)
                    }
                    ))
                }
            } catch (t) {
                t && console.error(t)
            } finally {
                this._isTransitioning = !1
            }
        }
        async followTheEntity(t, e, i, o) {
            const a = this._defaultScene.getEntity(t)
              , r = this._defaultScene.getEntity(e);
            this.cameraEntity.clearControllers();
            const l = new s.Vector3;
            a.getPositionRelativeToEntity(l, s.Vector3.Zero, r);
            const c = 1.25 * a.getExtentsRadius()
              , h = l.magnitude()
              , d = Math.atan(c / h)
              , u = 5 * a.getExtentsRadius()
              , p = h + u
              , m = Math.tan(d) * p;
            l.normalize(l);
            const _ = new s.Vector3(0,0,1)
              , g = a.getParent();
            if (g)
                if (g.getOrientation().getAxis(_, 2),
                g.getName() === e) {
                    const t = new s.Quaternion
                      , i = this.pioneer.getScene("main").getEntity(e).getController(s.DynamoController);
                    i && (i.getOrbitOrientation(t, this.pioneer.getTime()),
                    t.getAxis(_, 2)),
                    _.isNaN() && _.copy(new s.Vector3(0,0,1))
                } else
                    g.getOrientation().getAxis(_, 2);
            _.normalize(_),
            l.magnitude() < 1e-4 && (a.getOrientation().getAxis(l, 0),
            l.normalize(l)),
            _.mult(_, m),
            l.mult(l, u),
            l.add(l, _),
            _.normalize(_);
            const y = this.cameraEntity.addController(s.FixedController);
            y.setPosition(l);
            const f = new s.Vector3
              , b = new s.Vector3;
            f.neg(l),
            f.normalize(f),
            b.setNormalTo(f, _);
            const T = new s.Quaternion;
            T.setFromAxes(void 0, f, b),
            y.setOrientation(T),
            n.Cameras.focusOnEntity(this.cameraEntity, r, {
                up: !1
            });
            const v = this.cameraEntity.addController(s.TransitionController);
            v.setTransitionTime(o),
            v.setParent(i);
            const {_easeOutExpoTransition: S} = this.app.cameraScripts;
            S && v.setTransitionFunction(S),
            await v.getEndPromise(),
            this.cameraEntity.clearControllers();
            this.cameraEntity.addController(s.OrbitController).setDragSensitivity(5e-4),
            this.cameraEntity.addController(s.FixedToParentController),
            this.cameraEntity.addController(s.RollController);
            const E = 1e3
              , C = a.getExtentsRadius()
              , x = Math.max(a.getExtentsRadius() * E, r.getExtentsRadius() * E, C * E)
              , w = new s.Interval(C,x);
            this.cameraEntity.addController(s.ZoomController).setDistanceClamp(w);
            const I = this.cameraEntity.addController(s.SelectController);
            null !== this._selectionCallback && I.setCallback(this._selectionCallback),
            n.Cameras.focusOnEntity(this.cameraEntity, r, {
                up: !1
            })
        }
        async goToBetweenPos(t, {duration: e, destination: i, destinationUp: o, transitionFunction: a, zoomInterval: r}) {
            const l = this._cameraEntity;
            l.clearControllers();
            const c = l.addController(s.FixedController);
            c.setPosition(i);
            const h = new s.Vector3
              , d = new s.Vector3;
            h.neg(i),
            h.normalize(h),
            d.setNormalTo(h, o);
            const u = new s.Quaternion;
            u.setFromAxes(void 0, h, d),
            c.setOrientation(u),
            n.Cameras.focusOnEntity(l, t, {
                up: !1,
                orbiter: !1
            });
            const p = l.addController(s.TransitionController);
            p.setTransitionTime(e),
            p.setParent(t.getName()),
            a && p.setTransitionFunction(a),
            await p.getEndPromise(),
            l.clearControllers();
            const m = l.addController(s.SelectController);
            null !== this._selectionCallback && m.setCallback(this._selectionCallback),
            l.addController(s.OrbitController),
            l.addController(s.RollController);
            const _ = l.addController(s.ZoomController);
            r && _.setDistanceClamp(r),
            n.Cameras.focusOnEntity(l, t, {
                up: !1,
                orbiter: !1
            })
        }
        zoom(t, e=this._cameraEntity) {
            let i = e.getPosition().magnitude();
            Number.isNaN(i) && (i = 1),
            i *= t;
            const n = s.Vector3.pool.get();
            n.normalize(e.getPosition()),
            n.mult(n, i),
            e.setPosition(n),
            s.Vector3.pool.release(n)
        }
        zoomIn(t=!1) {
            let e = 1;
            const i = t ? this._zoomSensitivity.hold : this._zoomSensitivity.click;
            e /= Math.pow(2, i),
            this.zoom(e)
        }
        zoomOut(t=!1) {
            let e = 1;
            const i = t ? this._zoomSensitivity.hold : this._zoomSensitivity.click;
            e *= Math.pow(2, i),
            this.zoom(e)
        }
        get defaultMaxDistance() {
            return this._defaultMaxDistance
        }
        set defaultMaxDistance(t) {
            this._defaultMaxDistance = t
        }
        addDynamicEnvMap(t) {
            if (!this.dynamicEnvMap)
                return;
            const e = t.getComponent(s.ModelComponent);
            null !== e && e.setDynamicEnvironmentMapComponent(this.dynamicEnvMap)
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        CameraScripts: function() {
            return CameraScripts
        }
    });
    var s = i(5)
      , n = i(542)
      , o = i(2);
    class CameraScripts extends o.BaseManager {
        constructor(t) {
            super(t),
            this._cameraManager = null,
            this._customSystemDistances = {
                mercury: 425648,
                venus: 862136,
                earth: 1040264,
                mars: 8e4,
                jupiter: 7157638,
                saturn: 4869142,
                uranus: 1886367,
                neptune: 2407045,
                "134340_pluto": 122231,
                "136199_eris": 180309,
                "1_ceres": 87225,
                "136108_haumea": 126609,
                "136472_makemake": 118584
            },
            this._onCameraTransition = null,
            this._easeInOutExpoTransition = this._easeInOutExpoTransition.bind(this),
            this._easeOutExpoTransition = this._easeOutExpoTransition.bind(this)
        }
        setCameraManager(t) {
            this._cameraManager = t
        }
        get scene() {
            return this._scene
        }
        set scene(t) {
            this._scene = t
        }
        get cameraEntity() {
            return this._cameraEntity
        }
        set cameraEntity(t) {
            this._cameraEntity = t
        }
        getNormalToEcliptic(t, e) {
            const i = new s.Quaternion;
            this._cameraManager.pioneer.getScene("main").getEntity(e).getController(s.DynamoController).getOrbitOrientation(i, this._cameraManager.pioneer.getTime()),
            i.getAxis(t, 2)
        }
        isBarycenter(t) {
            return !!t.includes("_barycenter")
        }
        removeBarycenter(t) {
            return this.isBarycenter(t) ? t.replace("_barycenter", "") : t
        }
        async lookAtSurfaceLatLon(t, e=0, i=0, {scene: o, cinematic: a=!1, duration: r=1.5, distance: l=1.3}={}) {
            this._cameraManager.setContext({
                id: "id",
                context: CameraScripts.CONTEXT.LOOK_SURFACE_LAT_LON
            }),
            void 0 === o && (o = this._scene);
            const c = o.getEntity(t)
              , h = c.getComponent(s.SpheroidComponent);
            if (null === h)
                return;
            let d = new s.Vector3;
            const u = new s.LatLonAlt;
            u.lat = s.MathUtils.degToRad(e),
            u.lon = s.MathUtils.degToRad(i),
            u.alt = 0,
            h.xyzFromLLA(d, u);
            const p = new s.Vector3;
            c.getOrientation().getAxis(p, 2),
            d.normalize(d),
            d.rotate(c.getOrientation(), d);
            let m = c.getOcclusionRadius();
            null !== h && (m = c.getComponent(s.SpheroidComponent).getEquatorialRadius());
            const _ = 1.2 * m
              , g = 15 * m
              , y = new s.Quaternion;
            y.setFromAxes(void 0, d, p);
            let f = n.Cameras.getDistanceToFitEntities(this._cameraEntity, y, c, [c]);
            f *= l,
            d.mult(d, f),
            await this._cameraManager.goToEntity(t, {
                destination: d,
                cinematic: a,
                minRadius: _,
                destinationUp: p,
                duration: r / 2,
                maxRadius: g
            })
        }
        async goToCelestialObject(t, {scene: e, starId: i="sun", cinematic: o=!0, duration: a=1.5, distance: r=1.3, verticalOffset: l=0, horizontalOffset: c=0}={}) {
            this._cameraManager.setContext({
                id: t,
                context: CameraScripts.CONTEXT.CELESTIAL_OBJECT
            }),
            void 0 === e && (e = this._scene);
            const h = e.getEntity(t)
              , d = e.getEntity(i);
            let u = new s.Vector3;
            h.getPositionRelativeToEntity(u, s.Vector3.Zero, d),
            0 === u.magnitude() && (u = new s.Vector3(0,1,0));
            const p = new s.Vector3;
            h.getOrientation().getAxis(p, 2),
            u.neg(u),
            u.normalize(u);
            let m = h.getOcclusionRadius();
            const _ = h.getComponent(s.SpheroidComponent);
            null !== _ && (m = _.getEquatorialRadius());
            const g = 1.2 * m
              , y = new s.Vector3;
            y.cross(u, p),
            y.normalize(y);
            const f = new s.Quaternion;
            f.setFromAxisAngle(y, s.MathUtils.degToRad(l)),
            u.rotate(f, u),
            f.setFromAxisAngle(p, s.MathUtils.degToRad(c)),
            u.rotate(f, u);
            const b = new s.Quaternion;
            b.setFromAxes(void 0, u, p);
            let T = n.Cameras.getDistanceToFitEntities(this._cameraEntity, b, h, [h]);
            T *= r,
            u.mult(u, T),
            await this._cameraManager.goToEntity(t, {
                distance: T,
                duration: a / 2
            }),
            await this._cameraManager.goToEntity(t, {
                destination: u,
                cinematic: o,
                minRadius: g,
                destinationUp: p,
                duration: a / 2
            })
        }
        _easeOutExpoTransition(t, e, i, n, o, a) {
            const r = s.Vector3.pool.get()
              , l = s.Quaternion.pool.get()
              , c = 1 - Math.pow(1 - a, 4);
            r.lerp(e, i, c),
            l.slerp(n, o, c),
            this._onCameraTransition?.(c),
            t.setPosition(r),
            t.setOrientation(l),
            s.Vector3.pool.release(r),
            s.Quaternion.pool.release(l)
        }
        _easeInOutExpoTransition(t, e, i, n, o, a) {
            const r = s.Vector3.pool.get()
              , l = s.Quaternion.pool.get()
              , c = ((a *= 2) <= 1 ? Math.pow(a, 4) : 2 - Math.pow(2 - a, 4)) / 2;
            r.lerp(e, i, c),
            l.slerp(n, o, c),
            this._onCameraTransition?.(c),
            t.setPosition(r),
            t.setOrientation(l),
            s.Vector3.pool.release(r),
            s.Quaternion.pool.release(l)
        }
        async goToSpacecraft(t, {scene: e, starId: i="sun", planeId: o="earth", distance: a, cinematic: r=!0, duration: l=1.5, verticalOffset: c=0, horizontalOffset: h=0}={}) {
            this._cameraManager.setContext({
                id: t,
                context: CameraScripts.CONTEXT.SPACECRAFT
            }),
            void 0 === e && (e = this._scene);
            const d = this._app.getManager("content").getEntityInfo(t)?.customDistance || a;
            await e.waitTillEntitiesInPlace([t]);
            const u = e.getEntity(t)
              , p = 1.2 * u.getOcclusionRadius()
              , m = new s.Vector3;
            m.normalize(u.getPosition());
            const _ = new s.Vector3
              , g = u.getParent();
            g && (g.getName() === i && null !== e.getEntity(o) ? (this.getNormalToEcliptic(_, o),
            _.isNaN() && _.copy(new s.Vector3(0,0,1))) : g.getOrientation().getAxis(_, 2)),
            _.normalize(_),
            m.magnitude() < 1e-4 && (u.getOrientation().getAxis(m, 0),
            m.normalize(m));
            const y = new s.Vector3;
            y.cross(m, _),
            y.normalize(y);
            const f = new s.Quaternion;
            f.setFromAxisAngle(y, s.MathUtils.degToRad(c)),
            m.rotate(f, m),
            f.setFromAxisAngle(_, s.MathUtils.degToRad(h)),
            m.rotate(f, m);
            let b = 0;
            if (void 0 !== d)
                b = d;
            else {
                const t = new s.Quaternion;
                t.setFromAxes(void 0, m, _);
                b = 1.3 * n.Cameras.getDistanceToFitEntities(this._cameraEntity, t, u, [u])
            }
            m.mult(m, b),
            await this._cameraManager.goToEntity(t, {
                distance: b
            }),
            await this._cameraManager.goToEntity(t, {
                destination: m,
                cinematic: r,
                minRadius: p,
                destinationUp: _,
                duration: l
            })
        }
        async goToInstrument(t, {scene: e, distance: i, duration: n=1.5, upVector: o="z-axis", forwardVector: a="y-axis"}={}) {
            this._cameraManager.setContext({
                id: t,
                context: CameraScripts.CONTEXT.INSTRUMENT
            }),
            void 0 === e && (e = this._scene);
            const r = this._app.getManager("content").getEntityInfo(t)?.customDistance || i
              , l = e.getEntity(t)
              , c = l.getParent();
            await e.waitTillEntitiesInPlace([c.getName(), t]);
            const h = l.getOcclusionRadius()
              , d = c.getOcclusionRadius()
              , u = 1.2 * h
              , p = new s.Vector3;
            l.getPositionRelativeToEntity(p, s.Vector3.Zero, c);
            const m = new s.Vector3
              , _ = a.endsWith("y-axis") ? 1 : a.endsWith("z-axis") ? 2 : 0;
            c.getOrientation().getAxis(m, _),
            a.startsWith("-") && m.mult(m, -1),
            p.mult(m, -1);
            const g = new s.Vector3;
            let y = a.endsWith("y-axis") ? 2 : 1;
            o.endsWith("x-axis") ? y = 0 : o.endsWith("z-axis") && (y = 2),
            c.getOrientation().getAxis(g, y),
            o.startsWith("-") && g.mult(g, -1);
            let f = 4 * u;
            void 0 !== r && (f = r),
            p.mult(p, f),
            await this._cameraManager.goToEntity(c.getName(), {
                destinationUp: g,
                distance: 1.2 * d
            }),
            await this._cameraManager.goToEntity(t, {
                destination: p,
                minRadius: u,
                destinationUp: g,
                duration: n
            })
        }
        async compareObjects(t, e, {cameraLeft: i, cameraRight: s, cameraLeftPosition: n, cameraRightPosition: o, cameraUp: a, scene: r, minRadius: l, maxRadius: c, duration: h=.75}) {
            this._cameraManager.setContext({
                id: t,
                context: CameraScripts.CONTEXT.COMPARE,
                to: e
            });
            const d = new CustomEvent("cameracompare",{
                detail: {
                    left: t,
                    right: e
                }
            });
            window.dispatchEvent(d);
            const u = this._cameraManager.goToEntity(t, {
                minRadius: l,
                maxRadius: c,
                camera: i,
                destination: n,
                destinationUp: a,
                scene: r,
                select: !1,
                duration: h,
                zoom: !0,
                cinematic: !0
            })
              , p = this._cameraManager.goToEntity(e, {
                minRadius: l,
                maxRadius: c,
                camera: s,
                destination: o,
                destinationUp: a,
                scene: r,
                select: !1,
                duration: h,
                zoom: !0,
                cinematic: !0
            });
            await Promise.all([u, p])
        }
        async showLocation(t, e, i, o="northPole", {duration: a=2, otherEntityNames: r=[], distance: l, rotateByScreenRatio: c=!0}={}) {
            this._cameraManager.setContext({
                id: "",
                targetEntityName: t,
                context: CameraScripts.CONTEXT.LOCATION,
                options: {
                    otherEntityNames: r
                }
            });
            const h = this._scene.getEntity(t)
              , d = this._scene.getEntity(e)
              , u = this._scene.getEntity(i);
            if (null === h || null === d || null === u)
                return;
            const p = [];
            p.push(h),
            p.push(d),
            p.push(u);
            for (let t = 0, e = r.length; t < e; t++) {
                const e = this._scene.getEntity(r[t]);
                null !== e && p.push(e)
            }
            const m = new s.Vector3;
            "northPole" === o ? d.getOrientation().getAxis(m, 2) : "planeNormal" === o && (m.cross(d.getPosition(), d.getVelocity()),
            m.normalize(m));
            const _ = new s.Vector3;
            _.neg(m);
            const g = new s.Vector3;
            h.getPositionRelativeToEntity(g, s.Vector3.Zero, u),
            g.normalize(g),
            g.setNormalTo(_, g),
            g.neg(g);
            const y = this._cameraEntity.getComponent(s.CameraComponent);
            c && y.getHorizontalFieldOfView() > y.getVerticalFieldOfView() && g.cross(g, _);
            const f = new s.Quaternion;
            f.setFromAxes(void 0, _, g);
            let b = l || n.Cameras.getDistanceToFitEntities(this._cameraEntity, f, h, p);
            y.getHorizontalFieldOfView() < y.getVerticalFieldOfView() && (b *= 1.3 * y.getVerticalFieldOfView()),
            b *= 2,
            m.setMagnitude(m, b),
            null === this._cameraEntity.getParent() && await this._cameraManager.goToEntity(t, {
                distance: b
            });
            const T = {
                up: [{
                    frame: a,
                    up: g
                }],
                position: [{
                    frame: a,
                    position: m,
                    relativeTo: h.getName()
                }],
                focus: [{
                    frame: a,
                    name: t
                }]
            };
            await this._cameraManager.goToEntity(t, {
                keyframes: T,
                destination: m,
                destinationUp: g,
                cinematic: !1,
                duration: .2
            })
        }
        async alignObjects(t, e, {verticalOffset: i=0, horizontalOffset: n=0, duration: o=1.5, transitionDuration: a, alignDuration: r, distance: l=1, cinematic: c=!1, useEase: h=!0}={}) {
            this._cameraManager.setContext({
                id: "",
                targetEntityName: t,
                context: CameraScripts.CONTEXT.ALIGN_OBJECTS,
                focus: e
            });
            const d = this._scene.getEntity(t)
              , u = this._scene.getEntity(e);
            await this._scene.waitTillEntitiesInPlace([t, e]);
            const p = d.getOcclusionRadius()
              , m = new s.Vector3
              , _ = this._cameraManager.pioneer.getTime();
            d.getPositionRelativeToEntity(m, s.Vector3.Zero, u, _),
            m.isNaN() ? m.copy(new s.Vector3(0,-1,0)) : m.normalize(m),
            m.mult(m, l);
            const g = new s.Vector3;
            u.getOrientation().getAxis(g, 2);
            const y = new s.Vector3;
            y.cross(m, g),
            y.normalize(y);
            const f = new s.Quaternion;
            f.setFromAxisAngle(y, s.MathUtils.degToRad(i)),
            m.rotate(f, m),
            f.setFromAxisAngle(g, s.MathUtils.degToRad(n)),
            m.rotate(f, m),
            await this._cameraManager.goToEntity(t, {
                distance: l,
                destinationUp: g,
                duration: a || .5 * o,
                transitionFunction: h ? this._easeOutExpoTransition : void 0
            }),
            await this._cameraManager.goToEntity(t, {
                destination: m,
                cinematic: c,
                minRadius: p,
                destinationUp: g,
                duration: r || .5 * o,
                transitionFunction: h ? this._easeOutExpoTransition : void 0
            })
        }
        async alignSpacecraftPlanet(t, {duration: e=1.5, minRadius: i=50, distanceMultiplier: n=3}={}) {
            this._cameraManager.setContext({
                id: t,
                context: CameraScripts.CONTEXT.ALIGN_SPACECRAFT
            });
            const o = this._scene.getEntity(t);
            let a = o.getParent();
            for (; null !== a && null === a.getComponent(s.SpheroidComponent) && null === a.getComponent(s.ModelComponent); )
                a = a.getParent();
            let r = a.getOcclusionRadius();
            const l = a.getComponent(s.SpheroidComponent);
            null !== l && (r = l.getEquatorialRadius());
            const c = new s.Vector3;
            o.getPositionRelativeToEntity(c, s.Vector3.Zero, a),
            c.normalize(c),
            c.magnitude() < 1e-4 && (o.getOrientation().getAxis(c, 0),
            c.normalize(c)),
            c.mult(c, Math.max(i, n * r));
            const h = new s.Vector3;
            a.getOrientation().getAxis(h, 2),
            await this._cameraManager.goToEntity(a.getName()),
            await this._cameraManager.goToEntity(t, {
                destination: c,
                cinematic: !1,
                minRadius: Math.min(r, i),
                destinationUp: h,
                duration: e
            })
        }
        async viewFromSide(t, {planeId: e="earth", distance: i, cinematic: n=!1, duration: o=.75, verticalOffset: a=0, horizontalOffset: r=0, forwardVector: l="x-axis", upVector: c=""}={}) {
            const h = this._scene.getEntity(t)
              , d = this._scene.getEntity(e) || h.getParent();
            await this._scene.waitTillEntitiesInPlace([t, e]);
            const u = h.getOcclusionRadius()
              , p = 1.2 * u
              , m = new s.Vector3
              , _ = new s.Vector3;
            let g = 0;
            "z-axis" === l ? g = 2 : "y-axis" === l && (g = 1),
            h.getOrientation().getAxis(_, g),
            _.normalize(_);
            const y = new s.Vector3;
            h.getPositionRelativeToEntity(y, s.Vector3.Zero, d),
            y.normalize(y),
            m.cross(_, y),
            m.normalize(m),
            m.mult(m, -1);
            const f = new s.Vector3;
            if (c) {
                let t = 1;
                c.includes("x-axis") ? t = 0 : c.includes("z-axis") && (t = 2),
                h.getOrientation().getAxis(f, t),
                c.startsWith("-") && f.mult(f, -1)
            } else
                h.getPositionRelativeToEntity(f, h, d),
                f.normalize(f);
            const b = new s.Vector3;
            if (b.cross(m, f),
            b.normalize(b),
            f.cross(b, m),
            0 !== a) {
                const t = new s.Quaternion
                  , e = s.MathUtils.degToRad(a);
                t.setFromAxisAngle(b, e),
                m.rotate(t, m)
            }
            if (f.cross(b, m),
            0 !== r) {
                const t = new s.Quaternion
                  , e = s.MathUtils.degToRad(r);
                t.setFromAxisAngle(f, e),
                m.rotate(t, m)
            }
            b.cross(m, f),
            b.normalize(b),
            void 0 === i ? m.mult(m, 10 * u) : m.mult(m, i),
            await this._cameraManager.goToEntity(t, {
                destination: m,
                cinematic: n,
                minRadius: p,
                destinationUp: f,
                duration: o
            })
        }
        async spacecraftLookAtTarget(t, e) {
            this._cameraManager.setContext({
                id: t,
                context: CameraScripts.CONTEXT.LOOK_AT,
                target: e
            })
        }
        async spacecraftLockedOnTarget(t, e) {
            this._cameraManager.setContext({
                id: t,
                context: CameraScripts.CONTEXT.LOCKED_ON,
                target: e
            })
        }
        async goToSystemSideway(t, {distance: e, minDistance: i=0, duration: o=1, otherEntityNames: a=[], includeChildren: r=!0, angleInDegree: l=0, cinematic: c=!1}={}) {
            this._cameraManager.setContext({
                id: t,
                context: CameraScripts.CONTEXT.SYSTEM
            });
            const h = this._scene.getEntity(t)
              , d = this.isBarycenter(t) ? this.removeBarycenter(t) : t
              , u = d in this._customSystemDistances ? this._customSystemDistances[d] : 0
              , p = [h];
            for (let t = 0; t < a.length; t++)
                p.push(this._scene.getEntity(a[t]));
            if (r)
                for (let t = 0; t < h.getNumChildren(); t++) {
                    const e = h.getChild(t);
                    null === e.getComponent(s.CameraComponent) && (e.getName().startsWith("sc") || e.getPosition().isNaN() || p.push(e))
                }
            const m = new s.Vector3;
            m.normalize(h.getVelocity());
            const _ = new s.Vector3;
            _.normalize(h.getPosition()),
            _.setNormalTo(m, _);
            const g = new s.Vector3;
            g.cross(_, m);
            const y = new s.Vector3;
            y.mult(m, -1),
            y.addMult(y, g, Math.tan(s.MathUtils.degToRad(l)));
            let f = h.getOcclusionRadius();
            const b = h.getComponent(s.SpheroidComponent);
            if (null !== b)
                f = b.getEquatorialRadius();
            else if (this.isBarycenter(t)) {
                const e = this.removeBarycenter(t)
                  , i = this._scene.getEntity(e).getComponent(s.SpheroidComponent);
                null !== b && (f = i.getEquatorialRadius())
            }
            const T = 1.2 * f;
            let v = e;
            if (void 0 === v) {
                const t = new s.Quaternion;
                t.setFromAxes(_, y, void 0),
                v = n.Cameras.getDistanceToFitEntities(this._cameraEntity, t, h, p),
                v *= 1.3
            }
            v = Math.max(u, v);
            const S = this._cameraEntity.getComponent(s.CameraComponent);
            S.getHorizontalFieldOfView() < S.getVerticalFieldOfView() && (v *= 1.3 * S.getVerticalFieldOfView()),
            y.setMagnitude(y, v),
            await this._cameraManager.goToEntity(t, {
                destination: y,
                cinematic: c,
                minRadius: T,
                destinationUp: g,
                duration: o
            })
        }
        async goToSystem(t, e={}) {
            if ("inner_solar_system" === t)
                Object.assign(e, {
                    distance: 7e8,
                    angle: 25,
                    planeId: "earth"
                }),
                await this._goToSystem("sun", e);
            else if ("outer_solar_system" === t)
                Object.assign(e, {
                    distance: 1e10,
                    angle: 25,
                    planeId: "earth"
                }),
                await this._goToSystem("sun", e);
            else {
                const i = this.isBarycenter(t) ? this.removeBarycenter(t) : t
                  , s = i in this._customSystemDistances ? this._customSystemDistances[i] : 0
                  , n = this._app.getManager("content").getEntityInfo(t)
                  , o = "planeId"in e ? e.planeId : n?.planeEntity || "";
                Object.assign(e, {
                    minDistance: s,
                    planeId: o
                }),
                await this._goToSystem(t, e)
            }
        }
        async _goToSystem(t, {distance: e, angle: i=25, minDistance: o=0, duration: a=1, planeId: r="", otherEntityNames: l=[], includeChildren: c=!0, isRelativeToPreviousCamera: h=!0}={}) {
            this._cameraManager.setContext({
                id: t,
                context: CameraScripts.CONTEXT.SYSTEM
            }),
            this.app.getManager("camera").setIsTransitioning(!0);
            const d = this._scene.getEntity(t)
              , u = [d];
            for (let t = 0; t < l.length; t++)
                u.push(this._scene.getEntity(l[t]));
            if (c)
                for (let t = 0; t < d.getNumChildren(); t++) {
                    const e = d.getChild(t);
                    null === e.getComponent(s.CameraComponent) && (e.getName().startsWith("sc") || e.getPosition().isNaN() || u.push(e))
                }
            const p = new s.Vector3
              , m = new s.Vector3;
            h ? (this._cameraEntity.getPositionRelativeToEntity(m, s.Vector3.Zero, d),
            m.isNaN() ? (p.copy(new s.Vector3(0,-1,0)),
            p.mult(p, 1e10)) : p.copy(m)) : (p.normalize(d.getPosition()),
            p.mult(p, -1));
            const _ = new s.Vector3;
            "" !== r && null !== this._scene.getEntity(r) ? (this.getNormalToEcliptic(_, r),
            _.isNaN() && _.copy(new s.Vector3(0,0,1))) : d.getOrientation().getAxis(_, 2);
            const g = new s.Vector3;
            g.cross(p, _),
            g.normalize(g),
            p.setNormalTo(_, p),
            p.normalize(p);
            const y = new s.Quaternion;
            y.setFromAxisAngle(g, s.MathUtils.degToRad(i)),
            p.rotate(y, p);
            let f = d.getOcclusionRadius();
            const b = d.getComponent(s.SpheroidComponent);
            if (null !== b)
                f = b.getEquatorialRadius();
            else if (this.isBarycenter(t)) {
                const e = this.removeBarycenter(t)
                  , i = this._scene.getEntity(e).getComponent(s.SpheroidComponent);
                null !== b && (f = i.getEquatorialRadius())
            }
            const T = 1.2 * f;
            let v = e;
            if (void 0 === v) {
                const t = new s.Quaternion;
                t.setFromAxes(g, p, void 0),
                v = n.Cameras.getDistanceToFitEntities(this._cameraEntity, t, d, u),
                v *= 1.3
            }
            v = Math.max(o, v);
            const S = this._cameraEntity.getComponent(s.CameraComponent);
            if (S.getHorizontalFieldOfView() < S.getVerticalFieldOfView() && (v *= 1.3 * S.getVerticalFieldOfView()),
            h) {
                const e = new s.Vector3;
                this._cameraEntity.getPositionRelativeToEntity(m, s.Vector3.Zero, d),
                m.isNaN() ? (e.copy(new s.Vector3(0,-1,0)),
                e.setNormalTo(_, e),
                e.mult(e, 1e10),
                e.rotate(y, e)) : e.copy(m),
                await this._cameraManager.goToEntity(t, {
                    destination: e,
                    destinationUp: _,
                    duration: a
                })
            } else
                await this._cameraManager.goToEntity(t, {
                    distance: e,
                    duration: a / 2
                });
            p.mult(p, v),
            await this._cameraManager.goToEntity(t, {
                destination: p,
                cinematic: !1,
                minRadius: T,
                destinationUp: _,
                duration: a
            }),
            this.app.getManager("camera").setIsTransitioning(!1)
        }
        async goToCenter(t, e, i, n={}) {
            this._cameraManager.setContext({
                id: "centerSystem",
                context: CameraScripts.CONTEXT.CENTER_SYSTEM
            });
            const o = new s.Vector3
              , a = this._scene.getEntity(e)
              , r = new s.Vector3
              , l = [];
            for (let e = 0; e < t.length; e++) {
                const n = this._scene.getEntity(t[e]);
                l.push(n),
                n.getPositionRelativeToEntity(r, s.Vector3.Zero, a, i),
                o.addMult(o, r, 1 / t.length)
            }
            let c = this._scene.getEntity("center");
            null === c && (c = this._scene.addEntity("center"),
            c.setOrientation(s.Quaternion.Identity)),
            c.setParent(a),
            c.setPosition(o),
            await this._scene.getLoadedPromise(),
            n.otherEntityNames = t,
            await this._goToSystem(c.getName(), n)
        }
        async showLocationCenter(t, e, i, n, o, a, r={}) {
            this._cameraManager.setContext({
                id: "centerLocation",
                context: CameraScripts.CONTEXT.CENTER_LOCATION
            });
            const l = new s.Vector3
              , c = this._scene.getEntity(e)
              , h = new s.Vector3
              , d = [];
            for (let e = 0; e < t.length; e++) {
                const n = this._scene.getEntity(t[e]);
                d.push(n),
                n.getPositionRelativeToEntity(h, s.Vector3.Zero, c, i),
                l.addMult(l, h, 1 / t.length)
            }
            let u = this._scene.getEntity("center");
            null === u && (u = this._scene.addEntity("center"),
            u.setOrientation(s.Quaternion.Identity)),
            u.setParent(c),
            u.setPosition(l),
            await this._scene.getLoadedPromise(),
            r.otherEntityNames = t,
            await this.showLocation(u.getName(), n, o, a, r)
        }
        async showLocationInParentSystem(t, e={}) {
            const i = this._app.getManager("content");
            let s = this._app.getManager("scene").getParent(t);
            s = "Landing site" === i.getEntityInfo(s).category ? this._app.getManager("scene").getParent(s) : s,
            await this.showLocation(t, s, s, "northPole", e)
        }
        async showLocationInSolarSystem(t, e={}) {
            let i = this._scene.getEntity(t).getParent();
            if ("sun" !== i.getName())
                for (; "sun" !== i.getParent().getName(); )
                    i = i.getParent();
            else
                i = this._scene.getEntity("earth");
            await this.showLocation(t, i.getName(), "sun", "planeNormal", e)
        }
    }
    CameraScripts.CONTEXT = {
        CELESTIAL_OBJECT: 0,
        SPACECRAFT: 1,
        ALIGN_SPACECRAFT: 2,
        LOCATION: 3,
        SYSTEM: 4,
        COMPARE: 5,
        LOOK_AT: 6,
        LOCKED_ON: 7,
        INSTRUMENT: 8,
        ALIGN_OBJECTS: 9,
        CENTER_SYSTEM: 10,
        CENTER_LOCATION: 11,
        LOOK_SURFACE_LAT_LON: 12
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        ERTManager: function() {
            return ERTManager
        }
    });
    var s = i(2);
    class ERTManager extends s.BaseManager {
        constructor(t, {isERT: e=!1, ertTarget: i="", sceneMgr: s=null}={}) {
            super(t),
            this._isERT = e,
            this._ertTarget = i,
            this._sceneMgr = s,
            this.getNow = this.getNow.bind(this)
        }
        isERT() {
            return this._isERT
        }
        setERT(t) {
            this._isERT = t
        }
        getERTTarget() {
            return this._ertTarget
        }
        setERTTarget(t) {
            this._ertTarget = t
        }
        getERTScene() {
            return this._sceneMgr
        }
        setERTScene(t) {
            this._sceneMgr = t
        }
        getERTOffset() {
            if (null !== this._sceneMgr) {
                return this._sceneMgr.getDistance(this._ertTarget, "earth", {
                    subtractRadius: !0
                }) / s.AppUtils.constants.speedOfLight
            }
            return console.warn("Clock: could not get scene manager."),
            0
        }
        getERTFromTime(t) {
            const e = this.getERTOffset();
            return t.add(e, "s"),
            t
        }
        getTimeFromERT(t) {
            const e = this.getERTOffset();
            return t.subtract(e, "s"),
            t
        }
        getNow(t) {
            return this._isERT ? this.getTimeFromERT(t) : t
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        TimeManager: function() {
            return TimeManager
        }
    });
    var s = i(5)
      , n = i(220)
      , o = i.n(n)
      , a = i(2);
    class TimeManager extends a.BaseManager {
        constructor(t) {
            super(t),
            this._dateFormats = {
                utc: {
                    full: "YYYY-MM-D HH[:]mm[:]ss",
                    datetime: "YYYY-MM-D HH[:]mm",
                    date: "YYYY MMMM D",
                    time: "HH[:]mm[:]ss",
                    url: "YYYY-MM-DDTHH:mm:ss.SSSZ"
                },
                local: {
                    full: "M/D/YY hh[:]mm[:]ss",
                    datetime: "M/D/YY hh[:]mm",
                    date: "MMMM D, YYYY",
                    time: "hh[:]mm[:]ss",
                    meridiem: "a"
                }
            },
            this._timeLimits = {
                min: null,
                max: null
            },
            this._defaultLimits = {
                min: null,
                max: null
            },
            this._startTime = null,
            this._forcedPause = !1,
            this._isUTC = !0,
            this._ertMgr = null,
            this._rate = 0,
            this._defaultRate = 1,
            this._utcTimezone = "Etc/UTC",
            this._localTimezone = o().tz.guess(),
            this._previousTimeRate = this.pioneer.getTimeRate(),
            this._timezone = this._utcTimezone,
            this._eventNames.push("update", "change", "timezone", "ratechange", "forcedpause", "forcedpauseresume", "getnow"),
            this._initCallbacks(),
            this.setToNow(),
            this.pioneer.addCallback(( () => {
                const t = this.pioneer.getTime()
                  , e = this.pioneer.getTimeRate();
                this._time = o().tz(1e3 * s.TimeUtils.etToUnix(t), this._timezone);
                let i = o().tz(1e3 * s.TimeUtils.etToUnix(t + e / this.pioneer.getFPS()), this._timezone);
                isNaN(i) && (i = this._time),
                this._timeLimits.max && i.valueOf() > this._timeLimits.max.valueOf() ? (console.warn("[Time Manager]: Clock has reached maximum limit."),
                this._onLimitReach("max")) : this._timeLimits.min && i.valueOf() < this._timeLimits.min.valueOf() ? (console.warn("[Time Manager]: Clock has reached minimum limit."),
                this._onLimitReach("min")) : this._timeLimits.max && i.valueOf() < this._timeLimits.max.valueOf() && this._timeLimits.min && i.valueOf() > this._timeLimits.min.valueOf() && this._forcedPause && (this._forcedPause = !1,
                0 === this.getTimeRate() && (this.play(),
                this.triggerCallbacks("forcedpauseresume", [this._time]))),
                this.triggerCallbacks("update", [this._time])
            }
            ), !0)
        }
        _onLimitReach(t) {
            0 !== this.getTimeRate() && (this._forcedPause = !0,
            this.pause(),
            this._previousTimeRate = 0,
            this.triggerCallbacks("forcedpause", [this._time, t])),
            this.setTime(this._timeLimits[t])
        }
        setERTManager(t) {
            this._ertMgr = t
        }
        isNow() {
            return 1 === this._rate && Math.abs(this._time.valueOf() - this.getNow().valueOf()) < 1e3
        }
        getNow() {
            let t = o()().tz(this._timezone);
            for (let e = this._callbacks.getnow.length - 1; e >= 0; e--) {
                t = (0,
                this._callbacks.getnow[e])(t)
            }
            return t
        }
        setToNow() {
            this.setTime(this.getNow())
        }
        setStartTime(t) {
            this._startTime = t
        }
        setToStart() {
            null !== this._startTime && this.setTime(this._startTime)
        }
        getTime() {
            return this._time
        }
        setTime(t) {
            t = this.parseTime(t);
            const e = this.momentToET(t);
            this.pioneer.setTime(e),
            this._time = o().tz(1e3 * s.TimeUtils.etToUnix(this.pioneer.getTime()), this._timezone),
            this.triggerCallbacks("change", [this._time])
        }
        parseTime(t, e="url") {
            let i = this._isUTC
              , s = o().ISO_8601;
            if ("string" == typeof t && "" !== t) {
                const n = /^(?:[1-9]\d{3}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1\d|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[1-9]\d(?:0[48]|[2468][048]|[13579][26])|(?:[2468][048]|[13579][26])00)-02-29)T(?:[01]\d|2[0-3]):[0-5]\d(?:|:[0-5]\d)(?:\.\d{1,6})?(?:|Z|[+-][01]\d:[0-5]\d)$/;
                i = null !== t.match(n);
                const o = i ? "utc" : "local"
                  , a = this.getDateFormat(e, o);
                a && (s = a)
            } else
                "number" == typeof t && (i = !0);
            return i ? o().utc(t) : o().tz(t, s, !0, this._localTimezone)
        }
        etToMoment(t) {
            if (!isFinite(t))
                return null;
            const e = o().tz(1e3 * s.TimeUtils.etToUnix(t), "Etc/UTC");
            return e.isValid() ? e : null
        }
        momentToET(t) {
            const e = t.valueOf() / 1e3
              , i = s.TimeUtils.unixToEt(e);
            return Math.round(1e3 * i) / 1e3
        }
        getTimezone() {
            return this._timezone
        }
        getUTCTimezone() {
            return this._utcTimezone
        }
        getLocalTimezone() {
            return this._localTimezone
        }
        isUTC() {
            return this._isUTC
        }
        setDisplayUTC(t) {
            this._isUTC = t,
            this._timezone = this._isUTC ? this._utcTimezone : this._localTimezone,
            this.triggerCallbacks("timezone", [t])
        }
        getDateFormats() {
            return this._dateFormats
        }
        setDateFormats(t) {
            for (const [e,i] of Object.entries(t))
                void 0 !== this._dateFormats[e] ? Object.assign(this._dateFormats[e], i) : this._dateFormats[e] = i
        }
        getDateFormat(t, e) {
            return e || (e = this._isUTC ? "utc" : "local"),
            this._dateFormats[e][t]
        }
        setDateFormat(t, e) {
            this._dateFormats[t] = e
        }
        getLimits() {
            return this._timeLimits
        }
        setLimits(t) {
            this._timeLimits.min = t.min.clone(),
            this._timeLimits.max = t.max.clone()
        }
        getDefaultLimits() {
            return this._defaultLimits
        }
        setDefaultLimits(t) {
            this._defaultLimits.min = t.min.clone(),
            this._defaultLimits.max = t.max.clone()
        }
        resetLimits() {
            this._timeLimits.min = this._defaultLimits.min.clone(),
            this._timeLimits.max = this._defaultLimits.max.clone()
        }
        setMin(t) {
            this._timeLimits.min = o().tz(t, this._timezone)
        }
        resetMin() {
            this._timeLimits.min = this._defaultLimits.min.clone()
        }
        setMax(t) {
            this._timeLimits.max = o().tz(t, this._timezone)
        }
        resetMax() {
            this._timeLimits.max = this._defaultLimits.max.clone()
        }
        getTimeUrl(t) {
            let e;
            return e = t ? o().utc(o().tz(t, this._timezone)) : o().utc(this._time),
            e.utc().format(this._dateFormats.utc.url)
        }
        getDefaultTimeRate() {
            return this._defaultRate
        }
        setDefaultTimeRate(t) {
            this._defaultRate = t
        }
        resetTimeRate() {
            this.setTimeRate(this._defaultRate)
        }
        getTimeRate() {
            return this.pioneer.getTimeRate()
        }
        setTimeRate(t) {
            this._rate = t,
            this.pioneer.setTimeRate(t),
            this.triggerCallbacks("ratechange", [this._rate])
        }
        play() {
            const t = 0 === this._previousTimeRate ? this._defaultRate : this._previousTimeRate;
            this.setTimeRate(t)
        }
        pause() {
            this._previousTimeRate = this.getTimeRate(),
            this.setTimeRate(0)
        }
        getMidTime(t, e) {
            const i = (t.unix() + e.unix()) / 2;
            return o()(i, "X")
        }
        getEventNames() {
            return this._eventNames
        }
        isWithinLimits(t) {
            return this._timeLimits.min && t.isBefore(this._timeLimits.min) ? -1 : this._timeLimits.max && t.isAfter(this._timeLimits.max) ? 1 : 0
        }
        get timeLimits() {
            return this._timeLimits
        }
        get forcedPause() {
            return this._forcedPause
        }
        get previousTimeRate() {
            return this._previousTimeRate
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        ComparisonManager: function() {
            return ComparisonManager
        }
    });
    var s = i(2)
      , n = i(5)
      , o = i(542);
    class ComparisonManager extends s.BaseManager {
        constructor(t) {
            super(t),
            this._viewportLeft = null,
            this._viewportRight = null,
            this._sceneLeft = null,
            this._sceneRight = null,
            this._anchorEntityLeft = null,
            this._anchorEntityRight = null,
            this._entityLeft = null,
            this._entityRight = null,
            this._sunLeft = null,
            this._sunRight = null,
            this._activeViewports = [],
            this._customRotations = {
                rose_bowl: [["x", 45], ["z", 180]],
                sc_juno: [["x", 45], ["z", 180]],
                saturn: [["x", 25]],
                sc_lucy: [["z", -90], ["y", -25]],
                sc_ixpe: [["z", -90], ["y", 180]],
                sc_hubble_space_telescope: [["x", 90], ["z", 90]],
                sc_jwst: [["x", 180], ["y", 180]],
                sc_psyche: [["x", 90], ["z", 90]],
                sc_stardust: [["x", 90]],
                sc_osiris_rex_src: [["x", 90]],
                sc_stardust_src: [["z", 90]],
                sc_acs3: [["x", 90]]
            },
            this._zoomSensitivity = {
                click: .3,
                hold: .1
            },
            this.bindFunctions(["_adjustZoomFromViewport", "zoomIn", "zoomOut"]),
            this._sceneLeft = this.pioneer.addScene("comparisonLeft"),
            this._sceneLeft.setAmbientLightColor(new n.Color(.005,.005,.005)),
            this._sceneRight = this.pioneer.addScene("comparisonRight"),
            this._sceneRight.setAmbientLightColor(new n.Color(.005,.005,.005)),
            o.Entity.create("observable_universe", this._sceneLeft),
            o.Entity.create("milky_way", this._sceneLeft),
            o.Entity.create("observable_universe", this._sceneRight),
            o.Entity.create("milky_way", this._sceneRight),
            this._sunLeft = o.Entity.create("sun", this._sceneLeft, {
                nameSuffix: "_compare"
            }),
            this._sunRight = o.Entity.create("sun", this._sceneRight, {
                nameSuffix: "_compare"
            }),
            this._anchorEntityLeft = this._sceneLeft.addEntity("anchorLeft"),
            this._anchorEntityLeft.setParent(this._sceneLeft.getEntity("sun_compare")),
            this._anchorEntityLeft.setPosition(new n.Vector3(1e8,0,0)),
            this._anchorEntityLeft.setOrientation(n.Quaternion.Identity),
            this._anchorEntityRight = this._sceneRight.addEntity("anchorRight"),
            this._anchorEntityRight.setParent(this._sceneRight.getEntity("sun_compare")),
            this._anchorEntityRight.setPosition(new n.Vector3(1e8,0,0)),
            this._anchorEntityRight.setOrientation(n.Quaternion.Identity),
            this._cameraEntityLeft = this._sceneLeft.addEntity("cameraLeft"),
            this._cameraEntityLeft.setParent(this._anchorEntityLeft),
            this._cameraLeft = this._cameraEntityLeft.addComponent(n.CameraComponent),
            this._cameraLightLeft = this._cameraEntityLeft.addComponent(n.LightSourceComponent),
            this._cameraLightLeft.setEnabled(!1),
            this._cameraEntityRight = this._sceneRight.addEntity("cameraRight"),
            this._cameraEntityRight.setParent(this._anchorEntityRight),
            this._cameraRight = this._cameraEntityRight.addComponent(n.CameraComponent),
            this._cameraLightRight = this._cameraEntityRight.addComponent(n.LightSourceComponent),
            this._cameraLightRight.setEnabled(!1),
            this._viewportLeft = this.pioneer.addViewport("left-viewport"),
            this._viewportLeft.getDiv().className = "compare-viewport left-desktop",
            this._viewportLeft.setEnabled(!1),
            this._viewportLeft.setCamera(this._cameraLeft),
            this._viewportRight = this.pioneer.addViewport("right-viewport"),
            this._viewportRight.getDiv().className = "compare-viewport right-desktop",
            this._viewportRight.setEnabled(!1),
            this._viewportRight.setCamera(this._cameraRight),
            this.pioneer.addCallback(this._adjustZoomFromViewport.bind(this), !0)
        }
        get entityLeft() {
            return this._entityLeft
        }
        get entityRight() {
            return this._entityRight
        }
        zoomIn(t=!1) {
            let e = 1;
            const i = t ? this._zoomSensitivity.hold : this._zoomSensitivity.click;
            e /= Math.pow(2, i);
            const s = this.app.getManager("camera");
            s.zoom(e, this._cameraEntityLeft),
            s.zoom(e, this._cameraEntityRight)
        }
        zoomOut(t=!1) {
            let e = 1;
            const i = t ? this._zoomSensitivity.hold : this._zoomSensitivity.click;
            e *= Math.pow(2, i);
            const s = this.app.getManager("camera");
            s.zoom(e, this._cameraEntityLeft),
            s.zoom(e, this._cameraEntityRight)
        }
        async compare(t, e) {
            const i = this.app.getManager("scene");
            this._entityLeft && this._entityLeft.getName() !== t && (this._sceneLeft.removeEntity(this._entityLeft),
            i.removeLoading(this._entityLeft.getName(), "compare"),
            this._entityLeft = null),
            this._entityRight && this._entityRight.getName() !== e && (this._sceneRight.removeEntity(this._entityRight),
            i.removeLoading(this._entityRight.getName(), "compare"),
            this._entityRight = null);
            const s = this.app.getManager("content")
              , a = this.app.getManager("label");
            if (!this._entityLeft) {
                this._entityLeft = o.Entity.create(t, this._sceneLeft),
                this._entityLeft.clearParentingTableEntries(),
                this._entityLeft.clearControllers(),
                this._entityLeft.setParent(this._anchorEntityLeft),
                this._entityLeft.setPosition(n.Vector3.Zero);
                const e = new n.Quaternion;
                this._getCustomRotation(e, t, "left"),
                this._entityLeft.setOrientation(e),
                this._entityLeft.getComponent(n.DivComponent).setFadeWhenCloseToEntity("sun"),
                a.setLabelProps({
                    getLabelClass: t => `no-select ${s.getClassName(t, "") ?? ""}`,
                    handleTouch: null,
                    handleClick: null
                }, [t], this._sceneLeft, this._cameraEntityLeft)
            }
            if (!this._entityRight) {
                this._entityRight = o.Entity.create(e, this._sceneRight),
                this._entityRight.clearParentingTableEntries(),
                this._entityRight.clearControllers(),
                this._entityRight.setParent(this._anchorEntityRight),
                this._entityRight.setPosition(n.Vector3.Zero);
                const t = new n.Quaternion;
                this._getCustomRotation(t, e, "right"),
                this._entityRight.setOrientation(t),
                this._entityRight.getComponent(n.DivComponent).setFadeWhenCloseToEntity("sun"),
                a.setLabelProps({
                    getLabelClass: t => `no-select ${s.getClassName(t, "") ?? ""}`,
                    handleTouch: null,
                    handleClick: null
                }, [e], this._sceneRight, this._cameraEntityRight)
            }
            if (this._updateSuns(),
            !this._viewportLeft.isEnabled()) {
                for (let t = 0, e = this.pioneer.getNumViewports(); t < e; t++) {
                    const e = this.pioneer.getViewportAt(t);
                    e.isEnabled() && (this._activeViewports.push(t),
                    e.setEnabled(!1))
                }
                this._viewportLeft.setEnabled(!0),
                this._viewportRight.setEnabled(!0),
                this.setCameraLight(!0);
                const t = new CustomEvent("comparisonenter",{
                    detail: {}
                });
                window.dispatchEvent(t)
            }
            const r = o.Cameras.getDistanceToFitEntities(this._cameraEntityLeft, n.Quaternion.Identity, this._entityLeft, [this._entityLeft])
              , l = o.Cameras.getDistanceToFitEntities(this._cameraEntityRight, n.Quaternion.Identity, this._entityRight, [this._entityRight]);
            let c = Math.max(l, r);
            c *= 1.6;
            const h = new n.Vector3;
            h.setMagnitude(n.Vector3.YAxisNeg, c);
            const d = new n.Vector3;
            d.setMagnitude(n.Vector3.YAxisNeg, c),
            this._cameraEntityLeft.clearControllers(),
            this._cameraEntityRight.clearControllers();
            const u = new CustomEvent("cameracompare",{
                detail: {
                    left: t,
                    right: e
                }
            });
            window.dispatchEvent(u);
            const p = this.app.getManager("camera")
              , m = p.goToEntity("anchorLeft", {
                minRadius: .5 * c,
                maxRadius: 10 * c,
                camera: this._cameraEntityLeft,
                destination: h,
                destinationUp: n.Vector3.ZAxis,
                scene: this._sceneLeft,
                select: !1,
                zoom: !0,
                cinematic: !0
            })
              , _ = p.goToEntity("anchorRight", {
                minRadius: .5 * c,
                maxRadius: 10 * c,
                camera: this._cameraEntityRight,
                destination: d,
                destinationUp: n.Vector3.ZAxis,
                scene: this._sceneRight,
                select: !1,
                zoom: !0,
                cinematic: !0
            });
            await Promise.all([m, _]),
            i.addLoading(this._entityLeft.getName(), "compare"),
            i.addLoading(this._entityRight.getName(), "compare"),
            await Promise.all([this._entityLeft.getLoadedPromise(), this._entityRight.getLoadedPromise()]),
            i.removeLoading(this._entityLeft.getName(), "compare"),
            i.removeLoading(this._entityRight.getName(), "compare")
        }
        setCameraLight(t, e) {
            this._cameraLightLeft.setEnabled(t),
            this._cameraLightRight.setEnabled(t),
            void 0 !== e && (this._cameraLightLeft.setColor(e),
            this._cameraLightRight.setColor(e)),
            this._updateSuns()
        }
        exit() {
            this._entityLeft && (this._sceneLeft.removeEntity(this._entityLeft),
            this._entityLeft = null),
            this._entityRight && (this._sceneRight.removeEntity(this._entityRight),
            this._entityRight = null);
            this.app.getManager("scene").removeLoading("*", "compare"),
            this._viewportLeft.setEnabled(!1),
            this._viewportRight.setEnabled(!1);
            for (let t = 0; t < this._activeViewports.length; t++) {
                const e = this._activeViewports[t];
                this.pioneer.getViewportAt(e).setEnabled(!0)
            }
            this._activeViewports = [];
            const t = new CustomEvent("comparisonexit",{
                detail: {}
            });
            window.dispatchEvent(t)
        }
        _updateSuns() {
            const t = "sun" !== this._entityLeft?.getName() && (!this._cameraLightLeft.isEnabled() || this._cameraLightLeft.getColor().min() < 1)
              , e = "sun" !== this._entityRight?.getName() && (!this._cameraLightRight.isEnabled() || this._cameraLightRight.getColor().min() < 1);
            this._sunLeft.getComponent(n.SpheroidLODComponent).setEnabled(t),
            this._sunLeft.getComponent(n.AtmosphereComponent).setEnabled(t),
            this._sunLeft.getComponent(n.SpriteComponent).setEnabled(t),
            this._sunLeft.getComponent(n.LightSourceComponent).setEnabled(t),
            this._sunRight.getComponent(n.SpheroidLODComponent).setEnabled(e),
            this._sunRight.getComponent(n.AtmosphereComponent).setEnabled(e),
            this._sunRight.getComponent(n.SpriteComponent).setEnabled(e),
            this._sunRight.getComponent(n.LightSourceComponent).setEnabled(e)
        }
        _adjustZoomFromViewport() {
            if (!this._viewportLeft.isEnabled())
                return;
            if (!this._viewportRight.isEnabled())
                return;
            let t = this._cameraEntityLeft.getPosition().magnitude();
            Number.isNaN(t) && (t = 1);
            const e = this.app.pioneer.getInput().getActiveViewport();
            e && "right-viewport" === e.getName() && (t = this._cameraEntityRight.getPosition().magnitude(),
            Number.isNaN(t) && (t = 1));
            const i = n.Vector3.pool.get();
            i.setMagnitude(this._cameraEntityLeft.getPosition(), t);
            const s = n.Vector3.pool.get();
            s.setMagnitude(this._cameraEntityRight.getPosition(), t),
            this._cameraEntityLeft.setPosition(i),
            this._cameraEntityRight.setPosition(s),
            n.Vector3.pool.release(i),
            n.Vector3.pool.release(s)
        }
        _getCustomRotation(t, e, i) {
            if (t.set(1, 0, 0, 0),
            void 0 !== this._customRotations[e]) {
                const i = this._customRotations[e];
                for (let e = 0, s = i.length; e < s; e++) {
                    let s;
                    if ("x" === i[e][0])
                        s = n.Vector3.XAxis;
                    else if ("y" === i[e][0])
                        s = n.Vector3.YAxis;
                    else {
                        if ("z" !== i[e][0])
                            throw new Error(`Invalid model rotate axis "${i[e][0]}".`);
                        s = n.Vector3.ZAxis
                    }
                    let o = i[e][1];
                    o = n.MathUtils.degToRad(o);
                    const a = new n.Quaternion;
                    a.setFromAxisAngle(s, o),
                    t.mult(t, a)
                }
            }
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        SearchManager: function() {
            return SearchManager
        }
    });
    var s = i(698)
      , n = i(2);
    class SearchManager extends n.BaseManager {
        constructor(t, e={}) {
            super(t),
            this._maxEntries = 10,
            this._fuse = null,
            this._database = null,
            this._options = {
                threshold: .4,
                keys: [{
                    name: "id",
                    weight: .99
                }, {
                    name: "name",
                    weight: .98
                }],
                includeScore: !0,
                includeMatches: !0,
                ignoreLocation: !0,
                ...e
            }
        }
        setOptions(t) {
            Object.assign(this._options, t),
            this._fuse = new s.default(this._database,this._options)
        }
        setDatabase(t, e={}) {
            t ? (Object.assign(this._options, e),
            this._database = Object.keys(t).filter((e => !1 !== t[e].searchable)).map((e => {
                const i = t[e].keywords || [];
                return i.map((t => ({
                    value: t
                }))),
                t[e].keywords = i,
                t[e]
            }
            )),
            Array.isArray(this._database) ? this._fuse = new s.default(this._database,this._options) : console.error("[SearchManager.setDatabase] Database is not an array.")) : console.error("[SearchManager.setDatabase] Missing database.")
        }
        getEntry(t) {
            return this._database.find((e => e.id === t))
        }
        find(t, e=this._maxEntries) {
            if ("" === t || null == t || !this._fuse)
                return null;
            let i = this._fuse.search(t);
            return i = i.slice(0, e),
            i
        }
    }
}
, , function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        TitleManager: function() {
            return TitleManager
        }
    });
    var s = i(2);
    class TitleManager extends s.BaseManager {
        constructor(t, e) {
            super(t),
            this._options = e,
            this._currentTitle = null,
            this._fullTitle = null,
            this._parseFn = this._options.parseFn ?? null
        }
        updateTitle(t) {
            const {prefix: e, suffix: i} = this._options || {};
            this._currentTitle = this._parseRoute(t),
            this._fullTitle = `${e} - ${this._currentTitle} - ${i}`,
            document.title = this._fullTitle
        }
        _parseRoute(t) {
            return this._parseFn ? this._parseFn(t) : "Home"
        }
        setParseFunction(t) {
            "function" == typeof t && (this._parseFn = t)
        }
        get currentTitle() {
            return this._currentTitle
        }
        get fullTitle() {
            return this._fullTitle
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        SpoutManager: function() {
            return SpoutManager
        }
    });
    var s = i(5)
      , n = (i(542),
    i(2));
    class SpoutManager extends n.BaseManager {
        constructor(t) {
            super(t),
            this._scene = this.app.pioneer.getScene("main"),
            this._defaultTarget = this.getSpoutCameraTargetEntity(this.app.getManager("router").currentRoute.params),
            this._defaultTargetRadius = this._defaultTarget ? this._scene.getEntity(this._defaultTarget)?.getExtentsRadius() : this._scene.getEntity("earth").getExtentsRadius()
        }
        async enableSpout(t=!1, e=2048, i=2 * this._defaultTargetRadius, n=this._defaultTarget, o=25, a=0, r=!1) {
            const l = this.app.pioneer.getViewport("spoutViewport") || this.app.pioneer.addViewport("spoutViewport");
            l.getDiv().style.display = "none",
            l.getDiv().style.width = "100%",
            l.getDiv().style.height = "100%";
            const c = this._scene.getEntity(n) || this._scene.getEntity("earth")
              , h = this.setUpSpoutCamera(t, c, r, a)
              , d = h.getComponent(s.SpoutComponent) ?? h.addComponent(s.SpoutComponent);
            l.setCamera(d),
            d.setRenderWidth(e),
            this._scene.setAmbientLightColor(new s.Color(1,1,1)),
            !0 === t && (d.setForGlobe(!0, i || 2 * c.getExtentsRadius()),
            d.setNearDistance(.5 * c.getExtentsRadius()),
            c.getComponent(s.AtmosphereComponent)?.setExcludedFromCamera(d, !0)),
            await this.setUpSpoutLabels(o, c)
        }
        setUpSpoutCamera(t, e=this._defaultTarget, i=!1, n=0) {
            let o;
            if (!0 === t) {
                o = this._scene.getEntity("spoutCamera") || this._scene.addEntity("spoutCamera"),
                o.clearControllers(),
                o.setParent(e),
                o.setPosition(s.Vector3.Zero),
                o.setOrientation(s.Quaternion.Identity);
                const t = o.addController(s.AlignController);
                t.setPrimaryAlignType("align"),
                t.setPrimaryAxis(s.Vector3.ZAxis),
                t.setPrimaryTargetAxis(s.Vector3.ZAxis),
                i ? t.setPrimaryTargetEntity(e.getName()) : t.setPrimaryTargetEntity("camera");
                const a = new s.Vector3;
                s.Geometry.getXYZFromLLAOnSphere(a, new s.LatLonAlt(0,s.MathUtils.degToRad(180 + n),1), 1),
                t.setSecondaryAlignType("align"),
                t.setSecondaryAxis(s.Vector3.XAxis),
                t.setSecondaryTargetEntity("camera"),
                t.setSecondaryTargetAxis(a)
            } else
                o = this._scene.getEntity("camera");
            return o
        }
        async setUpSpoutLabels(t=25, e=null) {
            let i = e;
            i || (i = await this.getSpoutCameraTargetEntity(this.app.getManager("router").currentRoute.params) || "sun"),
            this._scene.waitTillEntitiesInPlace([i], this.app.pioneer.getTime(), 10).then(( () => {
                for (let e = 0; e < this._scene.getNumEntities(); e++) {
                    const i = this._scene.getEntityAt(e)
                      , n = i.getComponent(s.DivComponent);
                    if (n instanceof s.DivComponent) {
                        const e = i.getComponent(s.LabelComponent) ?? i.addComponent(s.LabelComponent);
                        e.setText(n.getDiv().querySelector(".text")?.innerHTML || n.getDiv()?.textContent || ""),
                        e.setColor(new s.Color(1,1,1,1)),
                        e.setFontSize(t),
                        e.setAlignment(new s.Vector2(0,.5)),
                        e.setPixelOffset(new s.Vector2(-t / 4,-1)),
                        n.setEnabled(!1)
                    }
                }
                return !0
            }
            )).catch((t => {
                console.log(t)
            }
            ))
        }
        async getSpoutCameraTargetEntity(t) {
            let e = null;
            const i = this.app.getManager("content");
            if (t) {
                const s = "feature"in t && "moons" === t.feature ? t.child : t.spaceObject
                  , o = this.pioneer.getScene("main").getEntity(s) ?? this.pioneer.getScene("main").getEntity("earth")
                  , a = i.getEntityInfo(s) || {}
                  , r = await i.getEntityDesc(s)
                  , l = s && this.pioneer.getScene("main").getEntity(s)?.getParent()?.getName();
                switch (a.category) {
                case "Spacecraft":
                    e = n.AppUtils.isFutureMission(r?.dates?.start) ? "earth" : o?.getParent()?.getName(),
                    a.keywords.includes("lander") && o.getParent().getName().includes("landing_site") && (e = this.pioneer.getScene("main").getEntity(s)?.getParent()?.getParent()?.getName());
                    break;
                case "Landing site":
                    e = l;
                    break;
                default:
                    e = s
                }
            }
            return e
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        CameraFollowManager: function() {
            return CameraFollowManager
        }
    });
    var s = i(542)
      , n = i(5)
      , o = i(2)
      , a = i(220)
      , r = i.n(a);
    class CameraFollowManager extends o.BaseManager {
        constructor(t, e={}) {
            super(t),
            this._options = {
                placeholder: "Search target to follow...",
                maxFeatured: 5,
                hideSearchDelay: 1e3,
                cameraDuration: 1.5,
                ...e
            },
            this._isEnabled = null,
            this.followId = null,
            this.followName = null,
            this.optionElement = null,
            this.search = null,
            this._returnToPreviousCamView = null,
            this._hideSearchTimeout = null,
            this._prevValues = {
                weights: {},
                occRadii: {},
                labelsClickable: {},
                occlusion: {},
                timeLimits: {
                    min: null,
                    max: null
                }
            },
            this._resizeObserver = new ResizeObserver(( () => {
                this.setYawPitchLimits()
            }
            )),
            this._offsetObserver = new MutationObserver((t => {
                t.forEach((t => {
                    "class" === t.attributeName && this.setYawPitchLimits()
                }
                ))
            }
            )),
            this._sumParent = this._createSumParent(),
            this._createReframeElement(),
            this._eventNames.push("cameraFollowStart", "cameraFollowStop", "cameraFollowUndo", "cameraFollowSelect"),
            this._initCallbacks(),
            this.bindFunctions(["update", "setSearchOptions", "updateOccludedEntities"]),
            this.pioneer.addCallback(this.update, !0);
            const i = this.app.getManager("router");
            i.setValidQueries([...i.getValidQueries(), "followId"])
        }
        setFollowVars(t) {
            const e = this.app.getManager("content")
              , {input: i} = this.search?._children || {}
              , {altName: s, displayName: n, iauName: o} = e.getEntityInfo(t) ?? {}
              , a = s || n || o || "";
            i && (i.value = a),
            this.followId = t,
            this.followEntity = t ? this.app.scene.getEntity(t) : null,
            this.followName = a
        }
        setToastContent({reset: t=!1}={}) {
            const e = this.app.getComponent("toast");
            if (t)
                return e.hide(),
                void e.setContent("");
            const i = `<span class="content-text">Camera is following ${["Sun", "Moon", "ISS"].includes(this.followName) ? "the " : ""}${this.followName}</span>`;
            e.setContent(`<div>${i}<button class="clickable undo" aria-label="Undo camera follow">Undo</button></div>`);
            const {toastContent: s} = e._children;
            s.querySelector("button")?.addEventListener("click", ( () => {
                this.triggerCallbacks("cameraFollowUndo", [this])
            }
            ))
        }
        showToast() {
            this.app.getComponent("toast").show()
        }
        validateTimeLimits() {
            const t = this.app.getManager("time")
              , e = t.getTime()
              , {currentView: i} = this.app.getManager("router")
              , {min: s, max: n} = this.targetEntity?.getPositionCoverage() || {}
              , {min: o, max: a} = this.followEntity?.getPositionCoverage() || {};
            if (!(s && n && o && a))
                return {
                    isValid: !1
                };
            let l = t.etToMoment(s)
              , c = t.etToMoment(n)
              , h = t.etToMoment(o)
              , d = t.etToMoment(a);
            l = null == l ? t.getDefaultLimits().min : l,
            c = null == c ? t.getDefaultLimits().max : c,
            h = null == h ? t.getDefaultLimits().min : h,
            d = null == d ? t.getDefaultLimits().max : d;
            if ("event" === i && this.app.getView("event")._eventName) {
                const {min: e, max: i} = t.getLimits() || {};
                l = e,
                c = i
            }
            const u = r().max(h, l)
              , p = r().min(d, c);
            if (h.valueOf() > c.valueOf() || d.valueOf() < l.valueOf())
                return this.app.getComponent("clock")?.setLimitMessage(null, "Entity timelines do not overlap"),
                this.setEnabled(!1, {
                    removeQueries: ["followId"]
                }),
                {
                    isValid: !1
                };
            if (e.valueOf() < h.valueOf() || e.valueOf() > d.valueOf()) {
                const e = t.getTimeUrl(u);
                this.app.getManager("router").navigate({
                    time: e
                })
            }
            return {
                isValid: !0,
                minTime: u,
                maxTime: p
            }
        }
        async follow(t) {
            const {currentRoute: e, previousRoute: i} = this.app.getManager("router")
              , {params: s} = i || {}
              , {params: o} = e || {}
              , {spaceObject: a} = s || {}
              , {spaceObject: r} = o || {}
              , {cameraDuration: l} = this._options;
            this._isEnabled = !0,
            !this.search && this.initSearch(),
            this.followId && this.setLabelWeight(this.followId, !0),
            a && a !== r && this.setTargetNotClickable(a, !0),
            this.app.getManager("scene").setEntitiesForceVisible([t]),
            this.setFollowVars(t);
            const c = this.followEntity?.getComponent(n.DivComponent);
            c.setFadeWhenCloseToEntity(!1),
            this.triggerCallbacks("cameraFollowSelect", [t, this]),
            this.setToastContent(),
            this._offsetObserver.observe(document.body, {
                attributes: !0
            }),
            this._resizeObserver.observe(document.body),
            await this.entitiesInPlace();
            const {isValid: h, minTime: d, maxTime: u} = this.validateTimeLimits();
            if (!h || !this.isEnabled)
                return;
            this.setParentsChangedCallbacks();
            const p = () => {
                const t = this.app.getManager("time");
                t.pause(),
                this.followName && this.showToast(),
                this.animateCamera(l).then(( () => (t.play(),
                !!this._isEnabled && (this.setTimeLimits({
                    minTime: d,
                    maxTime: u
                }),
                this.setYawPitchLimits(),
                this.setLabelWeight(this.followId),
                this.updateOccludedEntities(),
                this.setTargetNotClickable(this.targetId),
                !0)))).catch((t => t))
            }
              , {isLoaded: m, onLoaded: _} = this.app.getComponent("cameraViewBlock");
            m ? p() : _.push(p)
        }
        unfollow() {
            const {previousRoute: t, currentView: e} = this.app.getManager("router")
              , {params: i} = t || {}
              , {spaceObject: s} = i || {};
            this.setToastContent({
                reset: !0
            }),
            this.setLabelWeight(this.followId, !0),
            this.updateOccludedEntities({
                reset: !0
            }),
            this.setTargetNotClickable(s, !0);
            const n = this.app.scene.getEntity(s);
            this.setParentsChangedCallbacks({
                targetEntity: n,
                reset: !0
            }),
            this.setFollowVars(null),
            this.setSearchOptions({
                reset: !0
            }),
            this._offsetObserver.disconnect(),
            this._resizeObserver.disconnect()
        }
        animateCamera(t) {
            this._sumParent.clearControllers();
            const e = this.targetEntity?.getExtentsRadius() || .1
              , i = this._sumParent.addController(s.PositionSumController);
            i.addEntity(this.targetId, 1, 0),
            i.addEntity(this.followId, 0, -e);
            const o = this._sumParent.addController(n.AlignController);
            o.setPrimaryAlignType("point"),
            o.setPrimaryAxis(n.Vector3.YAxis),
            o.setPrimaryTargetEntity(this.targetId);
            const a = this._sumParent.addController(n.TransitionController);
            a.setTransitionTime(t),
            a.setParent(this.targetId);
            const {_easeOutExpoTransition: r} = this.app.cameraScripts;
            a.setTransitionFunction(r);
            return this.app.getManager("camera").followTheEntity(this.targetId, this.followId, this._sumParent.getName(), t)
        }
        setParentsChangedCallbacks({targetEntity: t=this.targetEntity, reset: e=!1}={}) {
            if (e)
                return t?.removeParentChangedCallback(this.updateOccludedEntities),
                void this.followEntity?.removeParentChangedCallback(this.updateOccludedEntities);
            t?.addParentChangedCallback(this.updateOccludedEntities),
            this.followEntity?.addParentChangedCallback(this.updateOccludedEntities)
        }
        setLabelWeight(t, e=!1, i="201") {
            if (!t)
                return;
            const s = this.app.getManager("label")
              , n = s.getDefaultWeight(t);
            0 === n && (s._weights[t] = {}),
            e ? this._prevValues.weights[t] && (s.setWeight(t, this._prevValues.weights[t]),
            delete this._prevValues.weights[t]) : (s.setWeight(t, i),
            this._prevValues.weights[t] = n)
        }
        updateOccludedEntities({reset: t=!1}={}) {
            const e = !t && this.getEntitiesToUnocclude();
            this.setOcclusionProps(e)
        }
        getEntitiesToUnocclude() {
            const t = [this.followId];
            return [...new Set(t)].filter(Boolean)
        }
        setOcclusionProps(t) {
            const {occlusion: e} = this._prevValues;
            Object.keys(e).forEach((t => {
                const i = this.app.scene.getEntity(t);
                i?.setCanOcclude(e[t]),
                i?.getComponent(n.DivComponent).setCanBeOccluded(e[t])
            }
            )),
            this._prevValues.occlusion = {},
            t?.length && t.forEach((t => {
                const e = this.app.scene.getEntity(t);
                e && (this._prevValues.occlusion[t] = e.canOcclude(),
                e?.getComponent(n.DivComponent).setCanBeOccluded(!1))
            }
            ))
        }
        setTargetNotClickable(t, e=!1) {
            const i = this.app.getManager("label")
              , s = i._labels[t];
            if (!s)
                return;
            const {labelsClickable: n} = this._prevValues;
            e ? void 0 !== n[t] && (i.setLabelClickable(t, n[t]),
            delete n[t]) : (n[t] = s.isClickable,
            i.setLabelClickable(t, !1))
        }
        _createReframeElement() {
            const {staticElement: t} = this.app;
            t.querySelector(".follow-reframe") || (this._reframeElement = document.createElement("div"),
            this._reframeElement.classList.add("follow-reframe"),
            t.appendChild(this._reframeElement))
        }
        _createSumParent() {
            const t = s.Entity.createFromOptions("follow_sum_parent", {
                parents: []
            }, this.app.scene);
            return t.setPosition(n.Vector3.Zero),
            t.setOrientation(n.Quaternion.Identity),
            t
        }
        initSearch(t) {
            if (!this.search) {
                this.search = this.app.getComponent("cameraFollowSearch"),
                this.search.element.addEventListener("click", (t => {
                    t.stopPropagation()
                }
                ));
                const {placeholder: t} = this._options
                  , {input: e} = this.search._children;
                e && e.setAttribute("placeholder", t);
                const i = "related";
                this.search._config.infoText.default = i,
                this.search.setState({
                    searchInfo: i
                }),
                this.search.element.classList.add("camera-follow")
            }
            t && (t.appendChild(this.search.element),
            this.search.setParent(t))
        }
        showSearch() {
            this.stopHideTimeout(),
            this.search?.show(),
            this.search?.open()
        }
        hideSearch() {
            this.search?.hide(),
            this.search?.close()
        }
        setTimeLimits({minTime: t, maxTime: e, reset: i=!1}={}) {
            const s = this.app.getManager("time");
            if (i) {
                const {min: t, max: e} = this._prevValues.timeLimits;
                null !== t && null !== e && (s.setMin(t),
                s.setMax(e))
            } else {
                const {min: i, max: n} = s.getLimits();
                this._prevValues.timeLimits = {
                    min: i,
                    max: n
                },
                s.setMin(t),
                s.setMax(e)
            }
        }
        setYawPitchLimits() {
            const t = document.body.classList.contains("offset-right")
              , e = document.body.classList.contains("offset-up")
              , i = this.app.scene.getEntity("camera")
              , s = i.getComponent(n.CameraComponent)
              , o = s.getHorizontalFieldOfView()
              , a = s.getVerticalFieldOfView()
              , r = i.getController(n.OrbitController);
            if (!r)
                return;
            const l = t ? .05 * o : 0
              , c = e ? .2 * a : 0
              , h = -.5 * Math.PI
              , d = .45 * o
              , u = .4 * a
              , p = h - d + l
              , m = h + d - l
              , _ = -u + c
              , g = u - c;
            r.setYawAngleLimits(new n.Interval(p,m)),
            r.setPitchAngleLimits(new n.Interval(_,g))
        }
        async setSearchOptions({targetId: t=this.targetId, followId: e=this.followId, reset: i=!1}={}) {
            if (i)
                return void this.search?.setExcludeResults([]);
            await this.entitiesInPlace();
            const s = [t, e].filter(Boolean)
              , {maxFeatured: n} = this._options
              , o = []
              , a = this.app.getManager("router");
            let r;
            if (a && "event" === a.currentView) {
                const t = a.currentRoute.params.child;
                r = this._app.getManager("content").events[t]?.target || void 0
            }
            const l = this.app.getManager("time")
              , c = l.getTime()
              , h = l.momentToET(c)
              , d = this.targetEntity || this.app.scene.getEntity(t)
              , u = this.followEntity ? d.getLowestCommonAncestorAtTime(this.followEntity, h)?.getName() : d.getParentAtTime(h)
              , p = this.app.getManager("content");
            let m = [];
            if ("sun" !== t) {
                const t = await p.getEntityDesc(u).catch(( () => ({})));
                t && t.featuredMoons && (m = t.featuredMoons)
            }
            if (!s.length || !this.isEnabled)
                return;
            const {currentView: _} = this.app.getManager("router")
              , {_entityDesc: g, _eventDesc: y} = this.app.getView(_)
              , {related: f=[]} = g || {}
              , {related: b=[]} = y || {}
              , {featuredMoons: T=[]} = g || {};
            o.push(r, u, ...b, ...f, ...T, ...m),
            "sun" !== t && o.push("sun");
            const v = [...new Set(o)].filter((i => ![t, e].includes(i))).slice(0, n).map((t => {
                const {id: e, iauName: i, displayName: s} = this.app.getManager("content")?.getEntityInfo(t) || {}
                  , n = s || i;
                return !(!e || !n) && {
                    text: n,
                    url: `/${e}`
                }
            }
            )).filter(Boolean);
            this.search?.setExcludeResults(s),
            this.search?.setupFeaturedSuggestion(v)
        }
        async entitiesInPlace() {
            const t = [this.targetId, this.followId].filter(Boolean);
            await this.app.scene.waitTillEntitiesInPlace(t)
        }
        update() {
            const t = !this._pioneer.getInput().getDraggedOffset().isZero();
            if (!this.followId)
                return;
            const {staticElement: e} = this.app;
            e.classList.toggle("follow-dragging", t),
            t && this.showToast()
        }
        setEnabled(t, {resetLimits: e=!0, removeQueries: i=["followId", "time", "rate"]}={}) {
            const s = this._isEnabled;
            this._isEnabled = t;
            const {currentRoute: n, currentView: o} = this.app.getManager("router")
              , {params: a} = n || {};
            if (!this.search && this.initSearch(),
            t) {
                (!this.followId || s) && this.showSearch(),
                this.triggerCallbacks("cameraFollowStart", [this])
            } else
                s && (this.followId && this.unfollow(),
                e && this.setTimeLimits({
                    reset: !0
                }),
                Array.isArray(i) && this.app.getManager("router").navigate({
                    __remove: i
                }),
                this.hideSearch(),
                this.triggerCallbacks("cameraFollowStop", [this]))
        }
        setHideTimeout() {
            this.stopHideTimeout(),
            this._hideSearchTimeout = setTimeout(( () => {
                this.hideSearch(),
                this.stopHideTimeout()
            }
            ), this._options.hideSearchDelay)
        }
        stopHideTimeout() {
            clearTimeout(this._hideSearchTimeout),
            this._hideSearchTimeout = null
        }
        get targetId() {
            const {currentView: t} = this.app.getManager("router")
              , {_target: e} = this.app.getView(t);
            return e
        }
        get targetEntity() {
            return this.app.scene.getEntity(this.targetId)
        }
        get followInnerHtml() {
            return this.followName ? `Following <span class='camera-follow-name'>${this.followName}</span>` : "Follow Target"
        }
        get isEnabled() {
            return this._isEnabled
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        AutoplayManager: function() {
            return AutoplayManager
        }
    });
    var s = i(220)
      , n = i.n(s)
      , o = (i(5),
    i(2));
    class AutoplayManager extends o.BaseManager {
        constructor(t, e) {
            super(t),
            this._url = e,
            this._isPlaying = !1,
            this._interval = 1e4,
            this._intervalTimer = null,
            this._slides = [],
            this._slideTimer = null,
            this._currentIndex = -1,
            this._resetStates = {
                lighting: "shadow",
                rate: 1,
                hd: !1
            },
            this._eventNames.push("autoplaychange"),
            this._initCallbacks(),
            this.bindFunctions(["startAutoplay", "stopAutoplay"])
        }
        async init() {
            try {
                this._slides = await o.AppUtils.loadJSON(this._url)
            } catch (t) {
                console.error(t),
                this._slides = []
            }
        }
        get interval() {
            return this._interval
        }
        set interval(t) {
            this._isValidTime(t) && (this._interval = 1e3 * t)
        }
        _isValidTime(t) {
            return "" !== t && !isNaN(Number(t)) && Number(t) > 0
        }
        async startAutoplay(t) {
            this._isPlaying = !0,
            this.triggerCallbacks("autoplaychange", [!0]),
            this._app.getManager("time").resetLimits(),
            await this.playNextSlide(t),
            this._triggerInterval(t)
        }
        _triggerInterval(t) {
            clearInterval(this._intervalTimer),
            this._intervalTimer = null,
            this._isPlaying && (this._intervalTimer = setInterval((async () => {
                t?.isCanceled ? await this.stopAutoplay() : await this.playNextSlide(t)
            }
            ), this._interval))
        }
        async playNextSlide(t) {
            this._currentIndex++,
            this._currentIndex >= this._slides.length && (this._currentIndex = 0),
            await this.playSlide(this._currentIndex, t)
        }
        async playSlide(t, e) {
            if (!this._isPlaying || !this._slides[t] || !this._slides[t].id)
                return;
            this._slideTimer && clearTimeout(this._slideTimer),
            clearInterval(this._intervalTimer),
            this._intervalTimer = null;
            const i = this._app.getManager("time")
              , s = this._app.getManager("content")
              , a = this._app.getManager("scene")
              , r = this.app.getManager("camera")
              , l = this._app.getManager("layer");
            let c;
            if (i.resetTimeRate(),
            r.updateLighting(this._resetStates.lighting),
            t - 1 >= 0 && "object" === this._slides[t - 1].type) {
                const e = s.getEntityInfo(this._slides[t - 1].id)
                  , i = s.getSpheroidId(e);
                void 0 !== this._slides[t - 1].hd && await a.toggleHDTextureForEntity(i, this._resetStates.hd),
                void 0 !== this._slides[t - 1].surfaceMapTiling && await l.resetSpheroidMap(i)
            }
            if ("event" === this._slides[t].type) {
                if (!this._slides[t].target)
                    return void this._triggerInterval(e);
                if (c = s.getEntityInfo(this._slides[t].target),
                !c)
                    return void this._triggerInterval(e);
                if (await s.loadEvents(this._slides[t].target, {
                    all: "all_events"
                }, e),
                e?.isCanceled)
                    return void await this.stopAutoplay();
                const n = s.context.events[this._slides[t].id];
                if (!n)
                    return void this._triggerInterval(e);
                if (await s.loadEvents(this._slides[t].target, {
                    event: this._slides[t].id
                }, e),
                e?.isCanceled)
                    return void await this.stopAutoplay();
                const a = o.AppUtils.deepCopy(s.context.eventDesc)
                  , r = {
                    ...n,
                    ...a
                };
                if (i.setTime(n.start),
                await this._updateCamera(c, r),
                e?.isCanceled)
                    return void await this.stopAutoplay();
                const l = r.rate || this._slides[t].rate;
                void 0 !== l && i.setTimeRate(l)
            } else {
                if (c = s.getEntityInfo(this._slides[t].id),
                !c)
                    return void this._triggerInterval(e);
                if (await s.loadDescriptions([this._slides[t].id]),
                e?.isCanceled)
                    return void await this.stopAutoplay();
                const o = s.context[this._slides[t].id];
                if (this._slides[t].time)
                    i.setTime(this._slides[t].time);
                else if (o?.dates?.end && o?.dates?.start) {
                    this.app.getManager("scene").setEntitiesForceVisible([this._slides[t].id], !0);
                    let e = i.getDefaultLimits().min.clone();
                    await a.get("main").getEntity(this._slides[t].id).getLoadedPromise();
                    const s = a.getCoverage(this._slides[t].id);
                    null !== s.min && (e = n().max(e, s.min));
                    const r = i.parseTime(o.dates.start);
                    e = n().max(r, e),
                    i.setTime(e)
                } else
                    i.setToNow();
                if (await this._updateCamera(c),
                e?.isCanceled)
                    return void await this.stopAutoplay();
                this._slides[t].rate && i.setTimeRate(this._slides[t].rate)
            }
            const h = s.getSpheroidId(c);
            if (void 0 !== this._slides[t].hd)
                await a.toggleHDTextureForEntity(h, this._slides[t].hd);
            else if (!0 === this._slides[t].surfaceMapTiling) {
                const t = s.getSpheroidLayers(h);
                if (t) {
                    const e = t.find((t => "wmts" === t.type));
                    try {
                        e && await this._app.getManager("layer").changeSpheroidMap(h, e)
                    } catch (t) {
                        console.error(t)
                    }
                }
            }
            this._isValidTime(this._slides[t].duration) && (this._slideTimer = setTimeout(( () => this._triggerInterval(e)), 1e3 * this._slides[t].duration)),
            this._slides[t].lighting && r.updateLighting(this._slides[t].lighting),
            this._slides[t].duration || this._isPlaying && this._triggerInterval(e)
        }
        async _updateCamera(t, e={}) {
            const i = t.category.toLowerCase()
              , {target: s, related: n} = e
              , o = this._app.getManager("content").hasLanded(t);
            if (this.app.getManager("scene").setEntitiesForceVisible([...n || [], ...s ? [s] : [], ...null !== t.id ? [t.id] : []], !0),
            "spacecraft" === i)
                if (o)
                    await this._app.cameraScripts.alignSpacecraftPlanet(t.id);
                else if (s) {
                    const {duration: i, distance: n, horizontalOffset: o, verticalOffset: a} = e;
                    await this._app.cameraScripts.alignObjects(t.id, s, {
                        duration: i,
                        distance: n,
                        horizontalOffset: o,
                        verticalOffset: a,
                        ...this._slides[this._currentIndex].cameraOptions
                    })
                } else
                    await this._app.cameraScripts.goToSpacecraft(t.id, this._slides[this._currentIndex].cameraOptions);
            else
                "landing site" === i ? await this._app.cameraScripts.alignSpacecraftPlanet(t.id, this._slides[this._currentIndex].cameraOptions) : "instrument" === i ? await this._app.cameraScripts.goToInstrument(t.id, this._slides[this._currentIndex].cameraOptions) : await this._app.cameraScripts.goToCelestialObject(t.id, this._slides[this._currentIndex].cameraOptions)
        }
        async stopAutoplay() {
            if (clearInterval(this._intervalTimer),
            this._intervalTimer = null,
            clearTimeout(this._slideTimer),
            this._slideTimer = null,
            !this._isPlaying && -1 === this._currentIndex)
                return;
            this._isPlaying = !1,
            this.triggerCallbacks("autoplaychange", [!1]);
            const t = this._app.getManager("router")
              , e = this._app.getManager("time")
              , i = this.app.getManager("scene")
              , s = this.app.getManager("camera")
              , n = this.app.getManager("content")
              , o = this._app.getManager("layer");
            if (this._currentIndex >= 0 && "object" === this._slides[this._currentIndex].type) {
                const t = this._slides[this._currentIndex]
                  , e = n.getEntityInfo(t.id)
                  , s = n.getSpheroidId(e);
                void 0 !== t.hd && i.toggleHDTextureForEntity(s, this._resetStates.hd),
                void 0 !== t.surfaceMapTiling && !0 !== t.surfaceMapTiling && await o.resetSpheroidMap(s)
            }
            i.setEntitiesForceVisible([], !0),
            e.setTimeRate("rate"in t.query ? t.query.rate : this._resetStates.rate),
            "time"in t.query ? e.setTime(t.query.time) : e.setToNow(),
            s.updateLighting(this._resetStates.lighting),
            this._currentIndex = -1
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        BaseView: function() {
            return BaseView
        }
    });
    var s = i(220)
      , n = i.n(s)
      , o = i(542)
      , a = i(2)
      , r = i(5);
    class BaseView extends a.BaseComponent {
        constructor(t, e, i=[]) {
            super(t, e),
            this._components = [...i],
            this._validQueries = [],
            this._rules = {},
            this._target = null,
            this._enabled = !1,
            this.bindFunctions(["resize", "updateVisibility", "toggleViewUI"])
        }
        get app() {
            return super.app
        }
        _showControls() {}
        _hideControls() {}
        _shouldHideControls() {
            return !1
        }
        updateVisibility() {
            this._app.getManager("layer").getLayer("ui").visible && (this._shouldHideControls() ? this._hideControls() : this._showControls())
        }
        resize() {
            this.updateVisibility()
        }
        toggleViewUI() {}
        _shouldResetStatus() {
            return this._app.getManager("layer").getLayer("ui").visible
        }
        _resetStatus(t=[]) {
            if (this._shouldResetStatus()) {
                const e = Object.keys(this._app.getComponents());
                for (let i = e.length - 1; i >= 0; i--) {
                    const s = e[i];
                    t.includes(s) || this._app.getComponent(s).setEnabled(this._components.includes(s))
                }
            }
        }
        registerCallbacks() {
            this._app.getManager("layer").addCallback("ui", this.toggleViewUI)
        }
        removeCallbacks() {
            this._app.getManager("layer").removeCallback("ui", this.toggleViewUI)
        }
        async onEnter(t, e=[]) {
            if (t.cancelToken.isCanceled)
                return;
            this._resetStatus(e),
            window.addEventListener("resize", this.resize),
            this.registerCallbacks();
            const i = this._app.getManager("router").currentView + "-view";
            document.body.classList.add(i),
            this._app.getManager("router").configs.locked && (document.body.classList.add("locked"),
            this._app.getManager("label").setClickable(!1),
            this._app.getManager("selection").setClickable(!1))
        }
        async onRouteChange(t) {
            if (await this.before(t),
            t.cancelToken.isCanceled)
                return;
            if (this._reset(t),
            await this._updateResources(t),
            t.cancelToken.isCanceled)
                return;
            if (t.setTimeLimits = !0,
            await this.processQuery(t),
            await this._updateComponentsVisibility(t),
            t.cancelToken.isCanceled)
                return;
            await this._checkReady(t);
            try {
                await this._updateCamera(t),
                this._updateLoading(t)
            } finally {
                await this.after(t)
            }
            const {spout: e} = this.app.getManager("router").configs;
            if (!0 === e) {
                const {spoutGlobe: e, spoutRenderWidth: i, spoutGlobeDistance: s, spoutTarget: n, spoutFontSize: o, spoutLonAngleOffset: a, spoutAlignToNorthPole: r} = this.app.getManager("router").configs
                  , l = n || await this.app.getManager("spout").getSpoutCameraTargetEntity(t);
                this.app.getManager("spout").enableSpout(e, i, s, l, o, a, r)
            }
        }
        async onQueryChange(t) {
            t.cancelToken.isCanceled || await this.processQuery(t)
        }
        validateQuery(t) {
            const e = {
                ...t
            }
              , i = Object.keys(e)
              , s = {}
              , n = {}
              , o = this._app.getManager("router");
            for (let t = i.length - 1; t >= 0; t--) {
                const a = i[t];
                if (!(a in this._rules)) {
                    delete e[a];
                    continue
                }
                const r = this._rules[a];
                if (!("function" == typeof r.value ? r.value(e[a]) : r.value === e[a])) {
                    if (n[a] = e[a],
                    "function" == typeof this._rules.redirect)
                        return this._rules.redirect(e[a]),
                        !1;
                    if ("route"in r)
                        return o.navigate(r.route),
                        !1;
                    "default"in r && (s[a] = r.default)
                }
            }
            return a.AppUtils.isEmptyObject(s) ? !!a.AppUtils.isEmptyObject(n) || (this._handleError(`validateQuery: Invalid input - ${JSON.stringify(n)}`),
            !1) : (o.navigate({
                ...e,
                ...s
            }),
            !1)
        }
        async processQuery(t) {
            this._updateTimeRate(t),
            await this._updateTime(t);
            const e = this._app.getManager("router")
              , i = e.parseQuery(e.previousRoute?.query);
            for (const s of Object.keys(e._queryCallbacks)) {
                const n = t[s]
                  , o = i[s];
                (n || o) && e._queryCallbacks[s].forEach((t => t(n, o)))
            }
            const s = this._app.getManager("layer")
              , n = this._app.getComponent("layerPanel")
              , o = {
                layerUI: "ui",
                layerTrails: "trails",
                layerOrbits: "orbits",
                layerLabels: "labels",
                layerIcons: "icons",
                layerPlanets: "planets",
                layerAsteroids: "asteroids",
                layerComets: "comets",
                layerDwarfPlanets: "dwarfPlanets",
                layerConstellations: "constellations",
                layerSpacecraft: "spacecraft"
            };
            for (const e in o)
                if (e in t) {
                    const i = o[e];
                    "disable" === t[e] ? n?.setCategoryEnabled(i, !1) : n?.isCategoryEnabled(i) && ("show" === t[e] ? s.getLayer(i).visible || n.toggleLayer(i) : "hide" === t[e] && s.getLayer(i).visible && n.toggleLayer(i))
                }
            this.app.getManager("title")?.updateTitle(e.currentRoute)
        }
        _handleError(t="") {
            const e = new Error(t);
            console.error(e);
            if (null !== this._app.getManager("router")) {
                let t = this._app.getManager("router").previousRoute.url;
                t || (t = this._app.getManager("router").homeRoute),
                this._app.getManager("router").navigate(t)
            }
        }
        onLeave(t) {
            window.removeEventListener("resize", this.resize),
            this.removeCallbacks();
            const e = this._app.getManager("router").previousView + "-view";
            document.body.classList.remove(e),
            this._app.getManager("selection").unselect(),
            this._app.getManager("scene").clearForceLoad(),
            this._validQueries.length && this._app.getManager("router").navigate({
                __remove: this._validQueries
            })
        }
        _reset(t) {
            this._app.getManager("scene").clearForceLoad()
        }
        async _updateResources(t) {}
        _updateTimeRate(t) {
            const e = this._app.getManager("time");
            "rate"in t ? e.setTimeRate(parseInt(t.rate)) : e.resetTimeRate()
        }
        async _updateTime(t) {
            const e = this._app.getManager("time")
              , i = this._app.getManager("router").currentRoute.url.includes("story");
            let s = 0;
            if (i && this._storyId) {
                s = this._app.getManager("content").getStory(this._storyId).slides.length
            }
            if ((!this._target && s > 1 || i && !this._target && !this._storyId) && (e.resetMin(),
            e.resetMax()),
            this._target)
                await this._updateTimeForTarget(t);
            else if (t.time) {
                this._app.getManager("time").parseTime(t.time).isValid() ? this._app.getManager("time").setTime(t.time) : this._app.getManager("router").navigate({
                    __remove: ["time"]
                })
            } else
                this._app.getManager("time").setToNow()
        }
        async _updateTimeForTarget(t, e=!0) {
            const i = this._app.getManager("time");
            let s = i.timeLimits.min.clone()
              , o = i.timeLimits.max.clone();
            if (t.setTimeLimits) {
                const t = i.getDefaultLimits();
                s = t.min.clone(),
                o = t.max.clone(),
                e && await this._app.getManager("scene").get("main").getEntity(this._target).getLoadedPromise();
                const a = this._app.getManager("scene").getCoverage(this._target);
                if (null !== a.min && (s = n().max(s, a.min)),
                null !== a.max && (o = n().min(o, a.max)),
                this._entityDesc?.dates?.start) {
                    const t = i.parseTime(this._entityDesc.dates.start);
                    s = n().max(t, s)
                }
                if (this._entityDesc?.dates?.end) {
                    const t = i.parseTime(this._entityDesc.dates.end);
                    o = n().min(t, o)
                }
                if (s.isAfter(o)) {
                    console.error("Start date provided is after end date.");
                    const t = this._app.getManager("router");
                    return this._app.getComponent("clock")?.setLimitMessage(1, "time limit error"),
                    void setTimeout(( () => t.navigate("/")), 1e3)
                }
                i.setMax(o),
                i.setMin(s)
            }
            if (!t.time && this._eventInfo?.start) {
                const t = i.parseTime(this._eventInfo.start);
                i.setTime(n().max(t, s))
            } else if (t.time) {
                const e = i.parseTime(t.time);
                e.isAfter(o) ? (i.setTime(o),
                i.setTimeRate(0),
                this._app.getComponent("clock")?.setLimitMessage(1)) : e.isBefore(s) ? (i.setTime(s),
                this._app.getComponent("clock")?.setLimitMessage(-1)) : i.setTime(e)
            } else {
                const t = this._app.getManager("time").getNow();
                t.isAfter(o) || t.isBefore(s) ? i.setTime(s) : i.setToNow()
            }
        }
        async _updateComponentsVisibility(t) {
            await this._updateComponents(t),
            t.cancelToken.isCanceled || this.updateVisibility()
        }
        async _updateComponents(t) {}
        async _updateCamera(t) {}
        _updateLoading(t) {
            if (null !== this._target) {
                const t = []
                  , e = [r.ModelComponent, o.WMTSComponent, r.SpheroidLODComponent]
                  , i = this._app.getManager("scene")
                  , s = this._app.getManager("content").getEntityInfo(this._target)?.category;
                s && "Instrument" === s && i.addLoading(i._scene.getEntity(this._target).getParent().getName(), "view"),
                i.addLoading(this._target, "view");
                for (let s = 0; s < e.length; s++) {
                    const n = i.get("main").getEntity(this._target).getComponent(e[s]);
                    null !== n && (i.forceLoad(n),
                    t.push(i.componentIsReady(n)))
                }
                Promise.all(t).then(( () => {
                    s && "Instrument" === s && i.removeLoading(i._scene.getEntity(this._target).getParent().getName(), "view"),
                    i.removeLoading(this._target, "view")
                }
                ))
            }
        }
        async _checkReady(t) {
            if (null === this._target)
                return;
            const e = [];
            let i = this._target;
            for (; "sun" !== i; ) {
                e.push(i);
                const t = this._app.getManager("scene").get("main").getEntity(i)?.getParent();
                if (!t)
                    break;
                i = t.getName()
            }
            await this._app.pioneer.getScene("main").waitTillEntitiesInPlace(e),
            await this._app.pioneer.waitUntilNextFrame()
        }
        async before(t) {}
        after(t) {
            this._app.getManager("layer").resetTarget(),
            this._app.getManager("scene").clearTempEntities()
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        BaseApp: function() {
            return BaseApp
        }
    });
    var s = i(220)
      , n = i.n(s)
      , o = i(5)
      , a = i(542)
      , r = (i(705),
    i(719))
      , l = i(720)
      , c = i(721)
      , h = i(2);
    class BaseApp {
        static setAppClass() {
            BaseApp._appClass = this
        }
        constructor(t) {
            window.app = this,
            this._pioneer = null,
            this._scene = null,
            this._router = null,
            this._element = null,
            this._dynamicElement = null,
            this._timeInfo = {},
            this._sceneInfo = void 0,
            this._cameraScripts = new h.CameraScripts(this),
            this._componentInfo = [],
            this._componentTypes = t,
            this._managers = {},
            this._components = {},
            this._views = {},
            this._viewInfo = [],
            this._viewClasses = {},
            this._updates = [],
            this.isTouch = null,
            this.canHover = null,
            this._isSearching = null,
            this._touchStartPos = {
                x: 0,
                y: 0
            },
            this._dragging = !1,
            this._entityInfo = r,
            this.bindFunctions(["resize", "onTouchStart", "onTouchMove", "onTouchEnd", "update"]),
            this._touchCount = 0,
            this._scrollable = !1,
            this._touchMax = !1,
            window.addEventListener("touchstart", this.onTouchStart, !1),
            window.addEventListener("touchmove", this.onTouchMove, {
                passive: !1
            }),
            window.addEventListener("touchend", this.onTouchEnd);
            const e = window.innerHeight;
            document.documentElement.style.setProperty("--vh", `${e}px`),
            window.addEventListener("resize", this.resize, !1),
            this.resize()
        }
        async init() {
            this._element = document.getElementById("ui"),
            this._dynamicElement = document.getElementById("dynamic-ui"),
            this._staticElement = document.getElementById("static-ui");
            const t = document.getElementById("pioneer");
            t.style.position = "absolute",
            this._pioneer = new o.Engine(t),
            "string" == typeof window.config.staticAssetsUrl && this._pioneer.getDownloader().setReplacement("STATIC_ASSETS_URL", window.config.staticAssetsUrl),
            "string" == typeof window.config.dynamicAssetsUrl && this._pioneer.getDownloader().setReplacement("DYNAMIC_ASSETS_URL", window.config.dynamicAssetsUrl),
            "string" == typeof window.config.animdataUrl && this._pioneer.getDownloader().setReplacement("ANIMDATA_URL", window.config.animdataUrl),
            this._pioneer.getConfig().setValue("fontFamily", "Raleway"),
            this._pioneer.getConfig().setValue("fontSize", 16),
            this._pioneer.getConfig().setValue("pbr", !0),
            this._pioneer.setTime(o.TimeUtils.now()),
            this._pioneer.setTimeRate(1),
            await this.createManagers(),
            await this.createComponents(),
            this.setUpRoutes(),
            this.setUpUpdates(),
            this.getManager("router").start();
            const {spout: e} = this.getManager("router").configs;
            if (!0 === e) {
                const {spoutGlobe: t, spoutRenderWidth: e, spoutGlobeDistance: i, spoutTarget: s, spoutFontSize: n, spoutLonAngleOffset: o, spoutAlignToNorthPole: a} = this.getManager("router").configs
                  , r = s || await this.getManager("spout").getSpoutCameraTargetEntity(this.getManager("router").currentRoute.params);
                this.getManager("spout").enableSpout(t, e, i, r, n, o, a)
            }
        }
        get pioneer() {
            return this._pioneer
        }
        get scene() {
            return this._scene
        }
        set scene(t) {
            this._scene = t
        }
        get cameraScripts() {
            return this._cameraScripts
        }
        get dynamicElement() {
            return this._dynamicElement
        }
        get staticElement() {
            return this._staticElement
        }
        get sceneInfo() {
            return this._sceneInfo
        }
        get element() {
            return this._element
        }
        set element(t) {
            this._element = t
        }
        get isSearching() {
            return this._isSearching
        }
        set isSearching(t) {
            this._isSearching = t
        }
        addManager(t, e, ...i) {
            return void 0 === this._managers[t] && (this._managers[t] = new e(this,...i)),
            this._managers[t]
        }
        removeManager(t) {
            void 0 !== this._managers[t] && (this._managers[t].destroy(),
            delete this._managers[t])
        }
        getManager(t) {
            return void 0 !== this._managers[t] ? this._managers[t] : null
        }
        async createManagers() {
            const t = h.Types.get("TimeManager")
              , e = this.addManager("time", t)
              , i = n().tz("1949-12-31", "Etc/UTC")
              , s = n().tz("2049-12-31", "Etc/UTC");
            e.setDefaultLimits({
                min: i,
                max: s
            }),
            e.setLimits({
                min: i,
                max: s
            });
            const o = this.addManager("content", h.ContentManager);
            o.setEntityList(r),
            o.setSpheroidLayers(l.default),
            o.setSpheroidFeatures(c.default),
            o.setFolders({
                description: "descriptions/",
                event: "events/",
                stories: "stories/"
            });
            const a = this.addManager("scene", h.SceneManager);
            this._scene = a.main;
            const d = this.addManager("layer", h.LayerManager);
            d.addLayer("ui", {
                name: "User Interface"
            }),
            d.addLayer("trails", {
                name: "Trails"
            }),
            d.addLayer("orbits", {
                name: "Orbits"
            }),
            d.addLayer("labels", {
                name: "Labels"
            }),
            d.addLayer("icons", {
                name: "Icons"
            }),
            d.addLayer("planets", {
                name: "Planets",
                categories: "Planet"
            }),
            d.addLayer("asteroids", {
                name: "Asteroids",
                categories: "Asteroid",
                defaultVisibility: !1
            }),
            d.addLayer("comets", {
                name: "Comets",
                categories: "Comet",
                defaultVisibility: !1
            }),
            d.addLayer("dwarfPlanets", {
                name: "Dwarf Planets",
                categories: "Dwarf Planet",
                defaultVisibility: !1
            }),
            d.addLayer("spacecraft", {
                name: "Spacecraft",
                categories: "Spacecraft",
                sublayers: ["orbiters", "landers", "satelliteGroup"]
            }),
            d.addLayer("majorMoons", {
                name: "Major Moons",
                categories: "Major Moon",
                group: "moons"
            }),
            d.addLayer("minorMoons", {
                name: "Minor Moons",
                categories: "Minor Moon",
                defaultVisibility: !1,
                group: "moons"
            }),
            d.addLayer("orbiters", {
                name: "Orbiters",
                categories: "Orbiter",
                group: "spacecraft"
            }),
            d.addLayer("satelliteGroup", {
                name: "Satellite Group",
                categories: ["CYGNSS", "TROPICS", "STARLING", "PREFIRE"],
                group: "spacecraft",
                defaultVisibility: !0
            }),
            d.addLayer("landers", {
                name: "Landers",
                categories: ["Lander", "Rover", "Landing site"],
                group: "spacecraft"
            }),
            d.addLayer("starfield", {
                name: "Star Field",
                defaultVisibility: !1
            }),
            d.addLayer("heliosphere", {
                name: "Heliosphere",
                defaultVisibility: !1
            }),
            d.addLayer("constellations", {
                name: "Constellations",
                categories: "Constellations",
                defaultVisibility: !1
            });
            const u = this.addManager("camera", h.CameraManager, this._scene);
            this._cameraScripts.setCameraManager(u),
            u.createViewportAndCamera(this._scene),
            this.addManager("search", h.SearchManager, {
                keys: [{
                    name: "iauName",
                    weight: .99
                }, {
                    name: "displayName",
                    weight: .98
                }, {
                    name: "altName",
                    weight: .98
                }, {
                    name: "keywords",
                    weight: .3
                }, {
                    name: "category",
                    weight: .3
                }]
            }),
            this.addManager("comparison", h.ComparisonManager),
            this.addManager("wmts", h.WMTSManager);
            const p = h.Types.get("LabelManager")
              , m = this.addManager("label", p, this._scene, this._pioneer.getViewportAt(0));
            m.initLabelWeights(o.getEntityList());
            const _ = h.Types.get("SelectionManager")
              , g = this.addManager("selection", _, this._scene);
            g.init3Dcallback(u),
            m.registerCallback("labelclicked", g.setSuppress);
            const y = this.addManager("router", h.RouteManager);
            y.setValidQueries(["time", "rate"]),
            y.init(),
            y.addConfigs({
                embed: void 0,
                kiosk: void 0,
                logo: void 0,
                detailPanel: void 0,
                content: void 0,
                featured: void 0,
                menu: void 0,
                locked: void 0,
                surfaceMapTiling: void 0,
                hd: void 0,
                lighting: void 0,
                hideExternalLinks: void 0,
                hideFullScreenToggle: void 0,
                maxSessionTime: void 0,
                maxInactivityTime: void 0,
                forceRestart: void 0,
                noKeyboard: void 0,
                search: void 0,
                collapseSettingsOptions: void 0,
                shareButton: void 0,
                spout: void 0,
                spoutGlobe: void 0,
                spoutRenderWidth: void 0,
                spoutGlobeDistance: void 0,
                spoutTarget: void 0,
                spoutFontSize: void 0,
                spoutLonAngleOffset: void 0,
                spoutAlignToNorthPole: void 0,
                interactPrompt: void 0
            });
            const f = h.Types.get("TrailManager")
              , b = this.addManager("trail", f, this._scene);
            m.registerCallback("hoverchange", b.onHoverChange),
            this.addManager("spout", h.SpoutManager),
            d.addCallback("trails", b.toggleTrails),
            d.addCallback("orbits", b.toggleOrbits),
            d.addCallback("labels", m.toggleLabels),
            d.addCallback("icons", m.toggleIcons),
            d.addCallback("starfield", a.toggleStarfield),
            d.addCallback("heliosphere", a.toggleHeliosphere),
            d.addCallback("constellations", a.toggleConstellations),
            this.addViews(),
            this.setUpViewportAndCamera(),
            await this.setUpScene(),
            await this.setUpManagers(),
            await this.setUpComponents(),
            this.addShortcuts(),
            this._pioneer.addCallback(this.update, !0)
        }
        async setUpManagers() {
            const t = this.scene
              , e = this.getManager("trail")
              , i = this.getManager("time");
            let {limits: s} = this._timeInfo;
            s ? (s.min = "min"in s && "-Infinity" !== s.min ? this.getManager("time").parseTime(s.min) : n()(h.AppUtils.constants.minDate),
            s.max = "max"in s && "Infinity" !== s.max ? this.getManager("time").parseTime(s.max) : n()(h.AppUtils.constants.maxDate)) : s = {
                min: n()(h.AppUtils.constants.minDate),
                max: n()(h.AppUtils.constants.maxDate)
            },
            i.setDefaultLimits(s),
            i.setLimits(s),
            this.getManager("selection").setScene(t),
            e.setScene(t),
            e.ids = Array.from(this.getManager("scene").getEntitiesNames()),
            e.setColor(e.ids)
        }
        async addComponent(t, e, ...i) {
            if (void 0 !== this._components[t])
                throw new Error(`Component ${t} was already added.`);
            const s = new e(this,...i);
            return this._components[t] = s,
            await s.init(),
            s
        }
        async addComponentWithPlaceholder(t, e=document, i=null) {
            if (t.args || (t.args = []),
            t.options || (t.options = {}),
            !i) {
                const s = Array.from(e.getElementsByTagName(t.type.name));
                if (!(i = s.find((e => e instanceof HTMLElement && e.id === t.name))) && s[0]instanceof HTMLElement && (i = s[0]),
                !i)
                    return Promise.reject(new Error(`addComponentWithPlaceholder: There is no placeholder element for ${t.type}`))
            }
            Object.assign(t.options, h.AppUtils.convertObjType({
                ...i.dataset
            }));
            const s = await this.addComponent(t.name, t.type, ...t.args, t.options);
            return s.setParent(i.parentElement, i),
            s
        }
        removeComponent(t) {
            return void 0 !== this._components[t] && (this._components[t].destroy(),
            delete this._components[t],
            !0)
        }
        removeComponents() {
            for (let t = 0; t < this._componentInfo.length; t++)
                this.removeComponent(this._componentInfo[t].name)
        }
        getComponent(t) {
            return void 0 !== this._components[t] ? this._components[t] : null
        }
        getComponents() {
            return this._components
        }
        async createComponents() {
            const t = [{
                name: "loadIcon",
                type: "LoadIcon"
            }, {
                name: "overlay",
                type: "Overlay",
                options: {
                    isOpenButtonVisible: !1
                }
            }];
            for (let e = 0; e < t.length; e++) {
                const {name: i, type: s, hasPlaceholder: n, args: o, options: a, postCreationFunction: r} = t[e]
                  , l = h.Types.get(s)
                  , c = await l.create(this, i, l, n, o, a);
                r && r(this, c)
            }
        }
        addShortcuts() {
            const t = this.getComponent("searchDesktop");
            t && document.addEventListener("keyup", (e => {
                "KeyF" === e.code && (this.isSearching || (t.open(),
                t._children.input.focus()))
            }
            ))
        }
        async setUpComponents() {
            this.dynamicElement.innerHTML = this.constructor.html;
            for (let t = 0; t < this._componentInfo.length; t++) {
                const {name: e, type: i, hasPlaceholder: s, args: n, options: o, postCreationFunction: a} = this._componentInfo[t]
                  , r = h.Types.get(i)
                  , l = await r.create(this, e, r, s, n, o);
                a && a(this, l)
            }
        }
        getViews() {
            return this._views
        }
        addViews() {
            for (let t = 0; t < this._viewInfo.length; t++) {
                const e = this._viewInfo[t];
                this.addView(e.name, this._viewClasses[e.class], this._element, e.components)
            }
        }
        removeViews() {
            for (const t in this._views)
                this.removeView(t)
        }
        getView(t) {
            return void 0 !== this._views[t] ? this._views[t] : null
        }
        addView(t, e, ...i) {
            return void 0 === this._views[t] && (this._views[t] = new e(this,...i)),
            this._views[t]
        }
        removeView(t) {
            void 0 !== this._views[t] && delete this._views[t]
        }
        async setUpScene() {
            if (void 0 === this._sceneInfo)
                return void console.error("App._sceneInfo needs to be set.");
            this.getManager("camera").defaultMaxDistance = this._sceneInfo.zoomMax || 2e18;
            const t = this.getManager("scene");
            t.addEntitiesFromSceneInfo(this._sceneInfo);
            const e = this.getManager("label")
              , i = this.getManager("trail")
              , s = this.getManager("camera");
            t.addEntityLoadedCallback(e.setUpLabel),
            t.addEntityLoadedCallback(i.setUpTrail),
            t.addEntityLoadedCallback(e.setUpIcon),
            t.addEntityLoadedCallback(s.addDynamicEnvMap),
            t.addEntityLoadedCallback((t => {
                ("sc_mars_science_laboratory" === t.getName() || "sc_mars_2020" === t.getName()) && t.getComponent(o.DivComponent).setFadeWhenCloseToEntity("mars")
            }
            )),
            t.addEntityWillBeUnloadedCallback(e.removeLabel),
            t.update(),
            this.scene = this.getManager("scene").main,
            this.scene.getEntity("sun").getComponent(o.ModelComponent)?.setEnabled(!1)
        }
        setUpViewportAndCamera() {
            const t = this.getManager("scene").main
              , e = this.getManager("camera");
            e.createViewportAndCamera(t),
            this.cameraScripts.scene = t,
            this.cameraScripts.cameraEntity = e.cameraEntity
        }
        setUpUpdates() {
            this.addUpdate(this.getManager("scene").update),
            this.addUpdate(this.getManager("label").update),
            this.addUpdate(this.getManager("camera").update)
        }
        addUpdate(t) {
            "function" == typeof t && this._updates.push(t)
        }
        removeUpdate(t) {
            const e = this._updates.indexOf(t);
            e < 0 || this._updates.splice(e, 1)
        }
        update() {
            for (let t = 0; t < this._updates.length; t++) {
                (0,
                this._updates[t])()
            }
        }
        bindFunctions(t=[]) {
            const e = this;
            for (let i = 0; i < t.length; i++) {
                const s = t[i];
                e[s] = e[s].bind(this)
            }
        }
        endLoadingScreen() {
            const t = document.getElementById("loading-screen");
            if (t) {
                const e = 400;
                t.style.transition = `opacity ${e / 1e3}s ease-out`,
                t.style.opacity = "0",
                setTimeout(( () => {
                    t.remove()
                }
                ), e)
            }
        }
        setUpRoutes() {}
        isDragging() {
            return this._dragging
        }
        isTouchMax() {
            return this._touchMax
        }
        resize() {
            const t = window.innerHeight;
            document.documentElement.style.setProperty("--vh", `${t}px`),
            document.body.style.height = t + "px";
            const e = h.AppUtils.isTouch()
              , i = h.AppUtils.canHover();
            this.isTouch !== e && (document.body.classList.toggle("touch", e),
            this.isTouch = e),
            this.canHover !== i && (document.body.classList.toggle("hover", i),
            this.canHover = i),
            setTimeout(( () => {
                if (t !== window.innerHeight) {
                    const t = window.innerHeight;
                    document.documentElement.style.setProperty("--vh", `${t}px`),
                    document.body.style.height = t + "px"
                }
            }
            ), 1e3)
        }
        onTouchStart(t) {
            this._touchCount++,
            this._touchMax = this._touchCount > 1;
            const e = t.changedTouches[0];
            this._touchStartPos.x = e.pageX,
            this._touchStartPos.y = e.pageY,
            this._dragging = !1,
            this._scrollable = !1;
            let i = t.target;
            for (; null !== i.parentElement; ) {
                if (i.classList.contains("scrollable")) {
                    this._scrollable = !0;
                    break
                }
                i = i.parentElement
            }
        }
        onTouchMove(t) {
            const e = t.changedTouches[0];
            Math.max(Math.abs(e.pageX - this._touchStartPos.x), Math.abs(e.pageY - this._touchStartPos.y)) > 5 && (this._dragging = !0),
            this._scrollable || t.preventDefault()
        }
        onTouchEnd(t) {
            this._touchCount--,
            0 === t.touches.length && (this._touchMax = !1),
            this._dragging = !1,
            this._scrollable = !1
        }
        getPioneerVersion() {
            return this.pioneer.getVersion()
        }
        getEyesVersion() {
            return h.EyesVersion
        }
    }
    window.addEventListener("load", (async () => {
        try {
            (new BaseApp._appClass).init()
        } catch (t) {
            throw document.body.innerHTML = "",
            t
        }
    }
    )),
    BaseApp._appClass = BaseApp,
    window.Pioneer = o,
    window.PioneerScripts = a
}
, function(t, e, i) {
    "use strict";
    i.r(e);
    i(706),
    i(707),
    i(708),
    i(709),
    i(710),
    i(711),
    i(712),
    i(713),
    i(714),
    i(715),
    i(716),
    i(717),
    i(718)
}
, function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t) {
    "use strict";
    t.exports = JSON.parse('{"observable_universe":{"id":"observable_universe","displayName":"Observable universe","category":"Universe","searchable":false},"milky_way":{"id":"milky_way","displayName":"Milky way","category":"Galaxy","searchable":false},"sun":{"id":"sun","iauName":"Sun","category":"Star","subcategory":"Yellow Dwarf Star","planeEntity":"earth","keywords":["star","solar system"]},"mercury":{"id":"mercury","iauName":"Mercury","category":"Planet","subcategory":"Terrestrial","keywords":["terrestrial planet","solar system","planets"]},"venus":{"id":"venus","iauName":"Venus","category":"Planet","subcategory":"Terrestrial","keywords":["terrestrial planet","solar system","planets"]},"earth":{"id":"earth","iauName":"Earth","category":"Planet","subcategory":"Terrestrial","hasMoons":true,"planeEntity":"moon","keywords":["terrestrial planet","solar system","planets"]},"mars":{"id":"mars","iauName":"Mars","category":"Planet","subcategory":"Terrestrial","hasMoons":true,"keywords":["terrestrial planet","solar system","planets"]},"jupiter":{"id":"jupiter","iauName":"Jupiter","category":"Planet","subcategory":"Gas Giant","hasMoons":true,"keywords":["gas giant","solar system","planets"]},"saturn":{"id":"saturn","iauName":"Saturn","category":"Planet","subcategory":"Gas Giant","hasMoons":true,"keywords":["gas giant","solar system","planets"]},"neptune":{"id":"neptune","iauName":"Neptune","category":"Planet","subcategory":"Ice Giant","hasMoons":true,"keywords":["ice giant","solar system","planets"]},"uranus":{"id":"uranus","iauName":"Uranus","category":"Planet","subcategory":"Ice Giant","hasMoons":true,"keywords":["gas giant","solar system","planets","1781"]},"134340_pluto":{"id":"134340_pluto","iauName":"134340 Pluto","displayName":"Pluto","category":"Dwarf Planet","keywords":["dwarf planet","solar system","dwarf planet","trans-neptunian object","plutoid","kuiper belt object","plutino","synchronous","1930"]},"134340_pluto_barycenter":{"id":"134340_pluto_barycenter","displayName":"Pluto system","hasMoons":true,"comparisonFeature":false,"category":"Dwarf Planet","subcategory":"Barycenter","planeEntity":"134340_pluto","forceVisibleEntities":["134340_pluto"],"keywords":["barycenter"]},"617_patroclus_barycenter":{"id":"617_patroclus_barycenter","displayName":"Patroclus barycenter","category":"Asteroid","subcategory":"Barycenter","comparisonFeature":false,"forceVisibleEntities":["617_patroclus","menoetius"]},"21_lutetia":{"id":"21_lutetia","iauName":"21 Lutetia","displayName":"Lutetia","category":"Asteroid","keywords":["asteroid","asteroids","Rosetta"]},"253_mathilde":{"id":"253_mathilde","iauName":"253 Mathilde","displayName":"Mathilde","category":"Asteroid","keywords":["asteroid","asteroids"]},"11351_leucus":{"id":"11351_leucus","iauName":"11351 Leucus","displayName":"Leucus","category":"Asteroid","keywords":["asteroid","asteroids"]},"15094_polymele":{"id":"15094_polymele","iauName":"15094 Polymele","displayName":"Polymele","category":"Asteroid","keywords":["asteroid","asteroids"]},"21900_orus":{"id":"21900_orus","iauName":"21900 Orus","displayName":"Orus","category":"Asteroid","keywords":["asteroid","asteroids"]},"3548_eurybates":{"id":"3548_eurybates","iauName":"3548 Eurybates","displayName":"Eurybates","category":"Asteroid","keywords":["asteroid","asteroids"]},"5535_annefrank":{"id":"5535_annefrank","iauName":"5535 Annefrank","displayName":"Annefrank","category":"Asteroid","keywords":["asteroid","asteroids"]},"52246_donaldjohanson":{"id":"52246_donaldjohanson","iauName":"52246 Donaldjohanson","displayName":"Donaldjohanson","category":"Asteroid","keywords":["asteroid","asteroids"]},"617_patroclus":{"id":"617_patroclus","iauName":"617 Patroclus","displayName":"Patroclus","category":"Asteroid","keywords":["asteroid","asteroids"]},"951_gaspra":{"id":"951_gaspra","iauName":"951 Gaspra","displayName":"Gaspra","category":"Asteroid","keywords":["asteroid","asteroids"]},"2867_steins":{"id":"2867_steins","iauName":"2867 Steins","displayName":"Steins","category":"Asteroid","keywords":["asteroid","asteroids"]},"ariel":{"id":"ariel","iauName":"Ariel","category":"Moon","subcategory":"Major Moon","keywords":["major moon","solar system","uranus","moons","prograde","synchronous","1851"]},"90377_sedna":{"id":"90377_sedna","iauName":"90377 Sedna","displayName":"Sedna","category":"Dwarf Planet","keywords":["dwarf planet","asteroids"]},"99942_apophis":{"id":"99942_apophis","iauName":"99942 Apophis","displayName":"Apophis","category":"Asteroid","keywords":["asteroid","asteroids"]},"486958_arrokoth":{"id":"486958_arrokoth","iauName":"486958 Arrokoth","displayName":"Arrokoth","category":"Asteroid","subcategory":"Kuiper Belt Object","keywords":["mu69","asteroid","asteroids","tno","cubewano","distant minor planet","pt1","1110113y","ultima thule","2014","kuiper belt object"]},"101955_bennu":{"id":"101955_bennu","iauName":"101955 Bennu","displayName":"Bennu","category":"Asteroid","subcategory":"B-Type Asteroid","keywords":["asteroid","asteroids","apollo","neo","pha","1999 rq36","1999","b-type"]},"152830_dinkinesh":{"id":"152830_dinkinesh","iauName":"152830 Dinkinesh","displayName":"Dinkinesh","category":"Asteroid","keywords":["asteroid","asteroids"]},"16_psyche":{"id":"16_psyche","iauName":"16 Psyche","displayName":"16 Psyche","category":"Asteroid","subcategory":"M-Type Asteroid","keywords":["asteroid","asteroids","m-type"]},"1_ceres":{"id":"1_ceres","iauName":"1 Ceres","displayName":"Ceres","category":"Dwarf Planet","keywords":["dwarf planet","asteroids","asteroid belt","a899 of","1943 xb","1801"]},"2_pallas":{"id":"2_pallas","iauName":"2 Pallas","displayName":"Pallas","category":"Asteroid","keywords":["asteroid","asteroids"]},"3_juno":{"id":"3_juno","iauName":"3 Juno","displayName":"Juno","category":"Asteroid","keywords":["asteroid","asteroids"]},"216_kleopatra":{"id":"216_kleopatra","iauName":"216 Kleopatra","displayName":"Kleopatra","category":"Asteroid","keywords":["asteroid","asteroids"]},"243_ida":{"id":"243_ida","iauName":"243 Ida","displayName":"Ida","category":"Asteroid","keywords":["asteroid","asteroids"],"hasMoons":true},"1566_icarus":{"id":"1566_icarus","iauName":"1566 Icarus","displayName":"Icarus","category":"Asteroid","keywords":["asteroid","asteroids"]},"1620_geographos":{"id":"1620_geographos","iauName":"1620 Geographos","displayName":"Geographos","category":"Asteroid","keywords":["asteroid","asteroids"]},"1862_apollo":{"id":"1862_apollo","iauName":"1862 Apollo","displayName":"Apollo","category":"Asteroid","keywords":["asteroid","asteroids"]},"1981_midas":{"id":"1981_midas","iauName":"1981 Midas","displayName":"Midas","category":"Asteroid","keywords":["asteroid","asteroids"]},"2063_bacchus":{"id":"2063_bacchus","iauName":"2063 Bacchus","displayName":"Bacchus","category":"Asteroid","keywords":["asteroid","asteroids"]},"2101_adonis":{"id":"2101_adonis","iauName":"2101 Adonis","displayName":"Adonis","category":"Asteroid","keywords":["asteroid","asteroids"]},"2102_tantalus":{"id":"2102_tantalus","iauName":"2102 Tantalus","displayName":"Tantalus","category":"Asteroid","keywords":["asteroid","asteroids"]},"2135_aristaeus":{"id":"2135_aristaeus","iauName":"2135 Aristaeus","displayName":"Aristaeus","category":"Asteroid","keywords":["asteroid","asteroids"]},"2340_hathor":{"id":"2340_hathor","iauName":"2340 Hathor","displayName":"Hathor","category":"Asteroid","keywords":["asteroid","asteroids"]},"3122_florence":{"id":"3122_florence","iauName":"3122 Florence","displayName":"Florence","category":"Asteroid","keywords":["asteroid","asteroids"]},"3200_phaethon":{"id":"3200_phaethon","iauName":"3200 Phaethon","displayName":"Phaethon","category":"Asteroid","keywords":["asteroid","asteroids"]},"3362_khufu":{"id":"3362_khufu","iauName":"3362 Khufu","displayName":"Khufu","category":"Asteroid","keywords":["asteroid","asteroids"]},"4015_wilson-harrington":{"id":"4015_wilson-harrington","iauName":"4015 Wilson-Harrington","displayName":"Wilson-Harrington","category":"Asteroid","keywords":["asteroid","asteroids"]},"4179_toutatis":{"id":"4179_toutatis","iauName":"4179 Toutatis","displayName":"Toutatis","category":"Asteroid","keywords":["asteroid","asteroids"]},"4183_cuno":{"id":"4183_cuno","iauName":"4183 Cuno","displayName":"Cuno","category":"Asteroid","keywords":["asteroid","asteroids"]},"4450_pan":{"id":"4450_pan","iauName":"4450 Pan","displayName":"Pan","category":"Asteroid","keywords":["asteroid","asteroids","minor moon","saturn"]},"4486_mithra":{"id":"4486_mithra","iauName":"4486 Mithra","displayName":"Mithra","category":"Asteroid","keywords":["asteroid","asteroids"]},"4769_castalia":{"id":"4769_castalia","iauName":"4769 Castalia","displayName":"Castalia","category":"Asteroid","keywords":["asteroid","asteroids"]},"5011_ptah":{"id":"5011_ptah","iauName":"5011 Ptah","displayName":"Ptah","category":"Asteroid","keywords":["asteroid","asteroids"]},"6239_minos":{"id":"6239_minos","iauName":"6239 Minos","displayName":"Minos","category":"Asteroid","keywords":["asteroid","asteroids"]},"6489_golevka":{"id":"6489_golevka","iauName":"6489 Golevka","displayName":"Golevka","category":"Asteroid","keywords":["asteroid","asteroids"]},"9969_braille":{"id":"9969_braille","iauName":"9969 Braille","displayName":"Braille","category":"Asteroid","keywords":["asteroid","asteroids"]},"12923_zephyr":{"id":"12923_zephyr","iauName":"12923 Zephyr","displayName":"Zephyr","category":"Asteroid","keywords":["asteroid","asteroids"]},"14827_hypnos":{"id":"14827_hypnos","iauName":"14827 Hypnos","displayName":"Hypnos","category":"Asteroid","keywords":["asteroid","asteroids"]},"25143_itokawa":{"id":"25143_itokawa","iauName":"25143 Itokawa","displayName":"Itokawa","category":"Asteroid","keywords":["asteroid","asteroids"]},"37655_illapa":{"id":"37655_illapa","iauName":"37655 Illapa","displayName":"Illapa","category":"Asteroid","keywords":["asteroid","asteroids"]},"65803_didymos":{"id":"65803_didymos","iauName":"65803 Didymos","displayName":"Didymos","category":"Asteroid","keywords":["asteroid","asteroids"],"hasMoons":true},"69230_hermes":{"id":"69230_hermes","iauName":"69230 Hermes","displayName":"Hermes","category":"Asteroid","keywords":["asteroid","asteroids"]},"136199_eris":{"id":"136199_eris","iauName":"136199 Eris","displayName":"Eris","category":"Dwarf Planet","keywords":["asteroid","asteroids","dwarf planet","tno","plutoid","sdo","binary","dysnomia","2005"]},"136108_haumea":{"id":"136108_haumea","iauName":"136108 Haumea","displayName":"Haumea","category":"Dwarf Planet","keywords":["asteroid","asteroids","dwarf planet","plutoid","tno","cubewano","trinary","2003 el61","2004"],"hasMoons":true},"136472_makemake":{"id":"136472_makemake","iauName":"136472 Makemake","displayName":"Makemake","category":"Dwarf Planet","keywords":["asteroid","asteroids","dwarf planet","cubewano","scattered-near","kuiper belt","2005 fy9","2005"]},"162173_ryugu":{"id":"162173_ryugu","iauName":"162173 Ryugu","displayName":"Ryugu","category":"Asteroid","keywords":["asteroid","asteroids","neo","pha","b-type","c-type"]},"4_vesta":{"id":"4_vesta","iauName":"4 Vesta","displayName":"Vesta","category":"Asteroid","subcategory":"Protoplanet","keywords":["asteroid","asteroids","main belt","vesta family","1807","protoplanet"]},"433_eros":{"id":"433_eros","iauName":"433 Eros","displayName":"Eros","category":"Asteroid","subcategory":"S-Type Asteroid","keywords":["asteroid","asteroids","neo","1898","prograde"]},"callisto":{"id":"callisto","iauName":"Callisto","category":"Moon","subcategory":"Major Moon","keywords":["major moon","solar system","jupiter","moons","main group","galilean moons","prograde","synchronous","1610"]},"sc_chandra":{"id":"sc_chandra","iauName":"Chandra X-ray Observatory","category":"Spacecraft","subcategory":"Orbiter","keywords":["telescope","orbiter","earth","Columbia","X-ray","astrophysics"]},"charon":{"id":"charon","iauName":"Charon","category":"Moon","subcategory":"Major Moon","keywords":["major moon","solar system","pluto","moons","prograde","synchronous","1978"]},"67p_churyumov_gerasimenko":{"id":"67p_churyumov_gerasimenko","iauName":"67P/Churyumov-Gerasimenko","displayName":"67P/Churyumov-Gerasimenko","category":"Comet","subcategory":"Short-Period Comet","keywords":["comet","comets","jupiter-family","1969 r1","1969 iv","1969h","1975 p1","1976 vii","1975i","1982 viii","1982f","1989 vi","1988i","1969","chury","short-period"]},"1p_halley":{"id":"1p_halley","iauName":"1P/Halley","displayName":"Halley","category":"Comet","subcategory":"Short-Period Comet","keywords":["comet","comets","short-period","1p/halley"]},"103p_hartley_2":{"id":"103p_hartley_2","iauName":"103P/Hartley","displayName":"Hartley 2","category":"Comet","keywords":["comet"]},"1i_oumuamua":{"id":"1i_oumuamua","iauName":"1I/\'Oumuamua","displayName":"Oumuamua","category":"Comet","keywords":["comet","comets","1i/oumuamua"]},"9p_tempel_1":{"id":"9p_tempel_1","iauName":"9P/Tempel 1","displayName":"Tempel 1","category":"Comet","subcategory":"Jupiter-Family Comet","keywords":["comet","comets","periodic","jupiter-family","9p/tempel","1867"]},"19p_borrelly":{"id":"19p_borrelly","iauName":"19P/Borrelly","displayName":"Borrelly","category":"Comet","subcategory":"Jupiter-Family Comet","keywords":["comet","comets","periodic","jupiter-family","19p/borrelly","Deep Space 1"]},"81p_wild_2":{"id":"81p_wild_2","iauName":"81P/Wild 2","displayName":"Wild 2","category":"Comet","subcategory":"Short-Period Comet","keywords":["comet","comets","81p/wild","1978 xi","1984 xiv","1990 xxviii","1978"]},"adrastea":{"id":"adrastea","iauName":"Adrastea","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"aegaeon":{"id":"aegaeon","iauName":"Aegaeon","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"aegir":{"id":"aegir","iauName":"Aegir","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"aitne":{"id":"aitne","iauName":"Aitne","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"albiorix":{"id":"albiorix","iauName":"Albiorix","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"amalthea":{"id":"amalthea","iauName":"Amalthea","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"ananke":{"id":"ananke","iauName":"Ananke","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"anthe":{"id":"anthe","iauName":"Anthe","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"aoede":{"id":"aoede","iauName":"Aoede","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"arche":{"id":"arche","iauName":"Arche","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"atlas":{"id":"atlas","iauName":"Atlas","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"autonoe":{"id":"autonoe","iauName":"Autonoe","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"bebhionn":{"id":"bebhionn","iauName":"Bebhionn","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"belinda":{"id":"belinda","iauName":"Belinda","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","uranus","moons"]},"bergelmir":{"id":"bergelmir","iauName":"Bergelmir","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"bestla":{"id":"bestla","iauName":"Bestla","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"bianca":{"id":"bianca","iauName":"Bianca","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","uranus","moons"]},"c_2010_x1":{"id":"c_2010_x1","iauName":"C/2010 X1","displayName":"Elenin","category":"Comet","keywords":["comet"]},"c_2012_s1":{"id":"c_2012_s1","iauName":"C/2012 S1","displayName":"ISON","category":"Comet","keywords":["comet"]},"c_2025_n1":{"id":"c_2025_n1","iauName":"3I/ATLAS","displayName":"3I/ATLAS (C/2025 N1)","category":"Comet","keywords":["comet","comets","periodic","c_2025_n1"],"hasEvents":true},"caliban":{"id":"caliban","iauName":"Caliban","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","uranus","moons"]},"callirrhoe":{"id":"callirrhoe","iauName":"Callirrhoe","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"calypso":{"id":"calypso","iauName":"Calypso","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"carme":{"id":"carme","iauName":"Carme","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"carpo":{"id":"carpo","iauName":"Carpo","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"chaldene":{"id":"chaldene","iauName":"Chaldene","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"cordelia":{"id":"cordelia","iauName":"Cordelia","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","uranus","moons"]},"cressida":{"id":"cressida","iauName":"Cressida","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","uranus","moons"]},"cupid":{"id":"cupid","iauName":"Cupid","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","uranus","moons"]},"cyllene":{"id":"cyllene","iauName":"Cyllene","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"dactyl":{"id":"dactyl","iauName":"243 Ida I Dactyl","displayName":"Dactyl","category":"Moon","subcategory":"Major Moon","keywords":["asteroid","minor moon","ida"]},"daphnis":{"id":"daphnis","iauName":"Daphnis","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"deimos":{"id":"deimos","iauName":"Deimos","category":"Moon","subcategory":"Major Moon","keywords":["major moon","solar system","mars","moons","synchronous","1877"]},"desdemona":{"id":"desdemona","iauName":"Desdemona","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","uranus","moons"]},"despina":{"id":"despina","iauName":"Despina","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","neptune","moons"]},"dia":{"id":"dia","iauName":"Dia","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"dimorphos":{"id":"dimorphos","iauName":"Dimorphos","category":"Moon","subcategory":"Major Moon","keywords":["minor moon","solar system","65803 Didymos","asteroid"]},"dione":{"id":"dione","iauName":"Dione","category":"Moon","subcategory":"Major Moon","keywords":["major moon","solar system","saturn","moons","inner moons","prograde","synchronous","1684"]},"sc_dscovr":{"id":"sc_dscovr","iauName":"DSCOVR","category":"Spacecraft","subcategory":"Orbiter","keywords":["earth","orbiter","Deep Space Climate Observatory"]},"eirene":{"id":"eirene","iauName":"Eirene","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"elara":{"id":"elara","iauName":"Elara","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"enceladus":{"id":"enceladus","iauName":"Enceladus","category":"Moon","subcategory":"Major Moon","keywords":["major moon","solar system","saturn","moons","inner moons","prograde","synchronous","1789"]},"epimetheus":{"id":"epimetheus","iauName":"Epimetheus","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"erinome":{"id":"erinome","iauName":"Erinome","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"erriapus":{"id":"erriapus","iauName":"Erriapus","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"ersa":{"id":"ersa","iauName":"Ersa","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"euanthe":{"id":"euanthe","iauName":"Euanthe","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"eukelade":{"id":"eukelade","iauName":"Eukelade","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"eupheme":{"id":"eupheme","iauName":"Eupheme","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"euporie":{"id":"euporie","iauName":"Euporie","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"europa":{"id":"europa","iauName":"Europa","category":"Moon","subcategory":"Major Moon","keywords":["major moon","solar system","jupiter","moons","main group","galilean moons","prograde","synchronous","1610"],"ignoreDependentWhenUnloading":["sc_juno"]},"eurydome":{"id":"eurydome","iauName":"Eurydome","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"farbauti":{"id":"farbauti","iauName":"Farbauti","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"fenrir":{"id":"fenrir","iauName":"Fenrir","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"galatea":{"id":"galatea","iauName":"Galatea","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","neptune","moons"]},"ganymede":{"id":"ganymede","iauName":"Ganymede","category":"Moon","subcategory":"Major Moon","keywords":["major moon","solar system","jupiter","moons","main group","galilean moons","prograde","synchronous","1610"],"ignoreDependentWhenUnloading":["sc_juno"]},"greip":{"id":"greip","iauName":"Greip","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"c_1995_o1":{"id":"c_1995_o1","iauName":"C/1995 O1","displayName":"Hale-Bopp","category":"Comet","subcategory":"Long-Period Comet","keywords":["comet","solar system","The Great Comet of 1997","C/1995 O1","1995"]},"ferdinand":{"id":"ferdinand","iauName":"Ferdinand","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","uranus","moons"]},"fornjot":{"id":"fornjot","iauName":"Fornjot","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"francisco":{"id":"francisco","iauName":"Francisco","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","uranus","moons"]},"halimede":{"id":"halimede","iauName":"Halimede","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","neptune","moons"]},"harpalyke":{"id":"harpalyke","iauName":"Harpalyke","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"hati":{"id":"hati","iauName":"Hati","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"hegemone":{"id":"hegemone","iauName":"Hegemone","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"helene":{"id":"helene","iauName":"Helene","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"helike":{"id":"helike","iauName":"Helike","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"hermippe":{"id":"hermippe","iauName":"Hermippe","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"herse":{"id":"herse","iauName":"Herse","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"hiiaka":{"id":"hiiaka","iauName":"Hi\'iaka","displayName":"Hi\'iaka","category":"Moon","subcategory":"Major Moon","keywords":["asteroid","minor moon","haumea"]},"himalia":{"id":"himalia","iauName":"Himalia","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"hippocamp":{"id":"hippocamp","iauName":"Hippocamp","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","neptune","moons"]},"hydra":{"id":"hydra","iauName":"Hydra","category":"Moon","subcategory":"Major Moon","keywords":["major moon","solar system","pluto","moons","outer moons"]},"hyperion":{"id":"hyperion","iauName":"Hyperion","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons","outer moons","prograde","1848"]},"hyrrokkin":{"id":"hyrrokkin","iauName":"Hyrrokkin","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"iapetus":{"id":"iapetus","iauName":"Iapetus","category":"Moon","subcategory":"Major Moon","keywords":["major moon","solar system","saturn","moons","outer moons","prograde","synchronous","1671"]},"io":{"id":"io","iauName":"Io","category":"Moon","subcategory":"Major Moon","keywords":["major moon","solar system","jupiter","moons","main group","galilean moons","prograde","synchronous","1610"],"ignoreDependentWhenUnloading":["sc_juno"]},"ijiraq":{"id":"ijiraq","iauName":"Ijiraq","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"iocaste":{"id":"iocaste","iauName":"Iocaste","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"isonoe":{"id":"isonoe","iauName":"Isonoe","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"janus":{"id":"janus","iauName":"Janus","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"jarnsaxa":{"id":"jarnsaxa","iauName":"Jarnsaxa","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"juliet":{"id":"juliet","iauName":"Juliet","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","uranus","moons"]},"jupiter_li":{"id":"jupiter_li","iauName":"Jupiter LI","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"jupiter_lii":{"id":"jupiter_lii","iauName":"Jupiter LII","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"jupiter_liv":{"id":"jupiter_liv","iauName":"Jupiter LIV","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"jupiter_lix":{"id":"jupiter_lix","iauName":"Jupiter LIX","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"jupiter_lv":{"id":"jupiter_lv","iauName":"Jupiter LV","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"jupiter_lvi":{"id":"jupiter_lvi","iauName":"Jupiter LVI","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"jupiter_lxi":{"id":"jupiter_lxi","iauName":"Jupiter LXI","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"jupiter_lxiii":{"id":"jupiter_lxiii","iauName":"Jupiter LXIII","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"jupiter_lxiv":{"id":"jupiter_lxiv","iauName":"Jupiter LXIV","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"jupiter_lxix":{"id":"jupiter_lxix","iauName":"Jupiter LXIX","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"jupiter_lxvi":{"id":"jupiter_lxvi","iauName":"Jupiter LXVI","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"jupiter_lxvii":{"id":"jupiter_lxvii","iauName":"Jupiter LXVI","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"jupiter_lxviii":{"id":"jupiter_lxviii","iauName":"Jupiter LXVIII","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"jupiter_lxx":{"id":"jupiter_lxx","iauName":"Jupiter LXX","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"jupiter_lxxii":{"id":"jupiter_lxxii","iauName":"Jupiter LXXII","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"kale":{"id":"kale","iauName":"Kale","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"kallichore":{"id":"kallichore","iauName":"Kallichore","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"kalyke":{"id":"kalyke","iauName":"Kalyke","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"kari":{"id":"kari","iauName":"Kari","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"kerberos":{"id":"kerberos","iauName":"Kerberos","category":"Moon","subcategory":"Major Moon","keywords":["major moon","solar system","pluto","moons"]},"kiviuq":{"id":"kiviuq","iauName":"Kiviuq","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"kore":{"id":"kore","iauName":"Kore","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"laomedeia":{"id":"laomedeia","iauName":"Laomedeia","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","neptune","moons"]},"larissa":{"id":"larissa","iauName":"Larissa","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","neptune","moons"]},"leda":{"id":"leda","iauName":"Leda","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"loge":{"id":"loge","iauName":"Loge","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"lysithea":{"id":"lysithea","iauName":"Lysithea","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"mab":{"id":"mab","iauName":"Mab","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","uranus","moons"]},"margaret":{"id":"margaret","iauName":"Margaret","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","uranus","moons"]},"megaclite":{"id":"megaclite","iauName":"Megaclite","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons","jupiter xix","S/2000 J 8"]},"menoetius":{"id":"menoetius","iauName":"Menoetius","displayName":"Menoetius","category":"Asteroid","keywords":["asteroid","asteroids","solar system","617 Patroclus"]},"methone":{"id":"methone","iauName":"Methone","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"metis":{"id":"metis","iauName":"Metis","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"mimas":{"id":"mimas","iauName":"Mimas","category":"Moon","subcategory":"Major Moon","keywords":["major moon","solar system","saturn","moons","inner moons","prograde","synchronous","1789","death star"]},"miranda":{"id":"miranda","iauName":"Miranda","category":"Moon","subcategory":"Major Moon","keywords":["major moon","solar system","uranus","moons","prograde","synchronous","1948"]},"mneme":{"id":"mneme","iauName":"Mneme","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"moon":{"id":"moon","iauName":"Moon","category":"Moon","subcategory":"Major Moon","keywords":["major moon","solar system","earth","moons","synchronous"]},"mundilfari":{"id":"mundilfari","iauName":"Mundilfari","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"naiad":{"id":"naiad","iauName":"Naiad","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","neptune","moons"]},"namaka":{"id":"namaka","iauName":"Namaka","displayName":"Namaka","category":"Moon","subcategory":"Major Moon","keywords":["asteroid","minor moon","haumea"]},"narvi":{"id":"narvi","iauName":"Narvi","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"nix":{"id":"nix","iauName":"Nix","category":"Moon","subcategory":"Major Moon","keywords":["major moon","solar system","pluto","moons"]},"nereid":{"id":"nereid","iauName":"Nereid","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","neptune","moons","irregular moons","prograde","1949"]},"neso":{"id":"neso","iauName":"Neso","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","neptune","moons"]},"oberon":{"id":"oberon","iauName":"Oberon","category":"Moon","subcategory":"Major Moon","keywords":["major moon","solar system","uranus","moons","prograde","synchronous","1787"]},"ophelia":{"id":"ophelia","iauName":"Ophelia","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","uranus","moons"]},"orthosie":{"id":"orthosie","iauName":"Orthosie","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"paaliaq":{"id":"paaliaq","iauName":"Paaliaq","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"pallene":{"id":"pallene","iauName":"Pallene","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"pan":{"id":"pan","iauName":"Pan","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"pandia":{"id":"pandia","iauName":"Pandia","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"pandora":{"id":"pandora","iauName":"Pandora","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"pasiphae":{"id":"pasiphae","iauName":"Pasiphae","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"pasithee":{"id":"pasithee","iauName":"Pasithee","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"perdita":{"id":"perdita","iauName":"Perdita","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","uranus","moons"]},"philophrosyne":{"id":"philophrosyne","iauName":"Philophrosyne","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"phobos":{"id":"phobos","iauName":"Phobos","category":"Moon","subcategory":"Major Moon","keywords":["major moon","solar system","mars","moons","synchronous","1877"]},"phoebe":{"id":"phoebe","iauName":"Phoebe","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons","norse group","retrograde","1899"]},"polydeuces":{"id":"polydeuces","iauName":"Polydeuces","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"portia":{"id":"portia","iauName":"Portia","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","uranus","moons"]},"praxidike":{"id":"praxidike","iauName":"Praxidike","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"prometheus":{"id":"prometheus","iauName":"Prometheus","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"prospero":{"id":"prospero","iauName":"Prospero","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","uranus","moons"]},"proteus":{"id":"proteus","iauName":"Proteus","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","neptune","moons","regular moons","prograde","synchronous","1989"]},"psamathe":{"id":"psamathe","iauName":"Psamathe","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","neptune","moons"]},"puck":{"id":"puck","iauName":"Puck","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","uranus","moons"]},"rhea":{"id":"rhea","iauName":"Rhea","category":"Moon","subcategory":"Major Moon","keywords":["major moon","solar system","saturn","moons","outer moons","prograde","synchronous","1672"]},"rosalind":{"id":"rosalind","iauName":"Rosalind","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","uranus","moons"]},"s_2003_j_10":{"id":"s_2003_j_10","iauName":"S/2003 J 10","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"s_2003_j_12":{"id":"s_2003_j_12","iauName":"S/2003 J 12","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"s_2003_j_16":{"id":"s_2003_j_16","iauName":"S/2003 J 16","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"s_2003_j_2":{"id":"s_2003_j_2","iauName":"S/2003 J 2","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"s_2003_j_23":{"id":"s_2003_j_23","iauName":"S/2003 J 23","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"s_2003_j_24":{"id":"s_2003_j_24","iauName":"S/2003 J 24","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"s_2003_j_4":{"id":"s_2003_j_4","iauName":"S/2003 J 4","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"s_2003_j_9":{"id":"s_2003_j_9","iauName":"S/2003 J 9","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"s_2004_s_7":{"id":"s_2004_s_7","iauName":"S/2004 S 7","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2004_s_12":{"id":"s_2004_s_12","iauName":"S/2004 S 12","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2004_s_13":{"id":"s_2004_s_13","iauName":"S/2004 S 13","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2004_s_17":{"id":"s_2004_s_17","iauName":"S/2004 S 17","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2004_s_21":{"id":"s_2004_s_21","iauName":"S/2004 S 21","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2004_s_24":{"id":"s_2004_s_24","iauName":"S/2004 S 24","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2004_s_28":{"id":"s_2004_s_28","iauName":"S/2004 S 28","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2004_s_31":{"id":"s_2004_s_31","iauName":"S/2004 S 31","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2004_s_36":{"id":"s_2004_s_36","iauName":"S/2004 S 36","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2004_s_37":{"id":"s_2004_s_37","iauName":"S/2004 S 37","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2004_s_39":{"id":"s_2004_s_39","iauName":"S/2004 S 39","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2004_s_40":{"id":"s_2004_s_40","iauName":"S/2004 S 40","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2004_s_41":{"id":"s_2004_s_41","iauName":"S/2004 S 41","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2004_s_42":{"id":"s_2004_s_42","iauName":"S/2004 S 42","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2004_s_43":{"id":"s_2004_s_43","iauName":"S/2004 S 43","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2004_s_44":{"id":"s_2004_s_44","iauName":"S/2004 S 44","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2004_s_45":{"id":"s_2004_s_45","iauName":"S/2004 S 45","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2004_s_46":{"id":"s_2004_s_46","iauName":"S/2004 S 46","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2004_s_47":{"id":"s_2004_s_47","iauName":"S/2004 S 47","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2004_s_48":{"id":"s_2004_s_48","iauName":"S/2004 S 48","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2004_s_49":{"id":"s_2004_s_49","iauName":"S/2004 S 49","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2004_s_50":{"id":"s_2004_s_50","iauName":"S/2004 S 50","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2004_s_51":{"id":"s_2004_s_51","iauName":"S/2004 S 51","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2004_s_52":{"id":"s_2004_s_52","iauName":"S/2004 S 52","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2004_s_53":{"id":"s_2004_s_53","iauName":"S/2004 S 53","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2005_s_4":{"id":"s_2005_s_4","iauName":"S/2005 S 4","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2005_s_5":{"id":"s_2005_s_5","iauName":"S/2005 S 5","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2006_s_1":{"id":"s_2006_s_1","iauName":"S/2006 S 1","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2006_s_10":{"id":"s_2006_s_10","iauName":"S/2006 S 10","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2006_s_11":{"id":"s_2006_s_11","iauName":"S/2006 S 11","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2006_s_12":{"id":"s_2006_s_12","iauName":"S/2006 S 12","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2006_s_13":{"id":"s_2006_s_13","iauName":"S/2006 S 13","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2006_s_14":{"id":"s_2006_s_14","iauName":"S/2006 S 14","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2006_s_15":{"id":"s_2006_s_15","iauName":"S/2006 S 15","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2006_s_16":{"id":"s_2006_s_16","iauName":"S/2006 S 16","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2006_s_17":{"id":"s_2006_s_17","iauName":"S/2006 S 17","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2006_s_18":{"id":"s_2006_s_18","iauName":"S/2006 S 18","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2006_s_19":{"id":"s_2006_s_19","iauName":"S/2006 S 19","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2006_s_20":{"id":"s_2006_s_20","iauName":"S/2006 S 20","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2006_s_3":{"id":"s_2006_s_3","iauName":"S/2006 S 3","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2006_s_9":{"id":"s_2006_s_9","iauName":"S/2006 S 9","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2007_s_2":{"id":"s_2007_s_2","iauName":"S/2007 S 2","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2007_s_3":{"id":"s_2007_s_3","iauName":"S/2007 S 3","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2007_s_5":{"id":"s_2007_s_5","iauName":"S/2007 S 5","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2007_s_6":{"id":"s_2007_s_6","iauName":"S/2007 S 6","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2007_s_7":{"id":"s_2007_s_7","iauName":"S/2007 S 7","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2007_s_8":{"id":"s_2007_s_8","iauName":"S/2007 S 8","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2007_s_9":{"id":"s_2007_s_9","iauName":"S/2007 S 9","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2009_s_1":{"id":"s_2009_s_1","iauName":"S/2009 S 1","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2011_j_3":{"id":"s_2011_j_3","iauName":"S/2011 J 3","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"s_2016_j_3":{"id":"s_2016_j_3","iauName":"S/2016 J 3","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"s_2016_j_4":{"id":"s_2016_j_4","iauName":"S/2016 J 4","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"s_2018_j_2":{"id":"s_2018_j_2","iauName":"S/2018 J 2","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"s_2018_j_3":{"id":"s_2018_j_3","iauName":"S/2018 J 3","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"s_2018_j_4":{"id":"s_2018_j_4","iauName":"S/2018 J 4","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"s_2019_s_1":{"id":"s_2019_s_1","iauName":"S/2019 S 1","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2019_s_10":{"id":"s_2019_s_10","iauName":"S/2019 S 10","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2019_s_11":{"id":"s_2019_s_11","iauName":"S/2019 S 11","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2019_s_12":{"id":"s_2019_s_12","iauName":"S/2019 S 12","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2019_s_13":{"id":"s_2019_s_13","iauName":"S/2019 S 13","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2019_s_14":{"id":"s_2019_s_14","iauName":"S/2019 S 14","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2019_s_15":{"id":"s_2019_s_15","iauName":"S/2019 S 15","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2019_s_16":{"id":"s_2019_s_16","iauName":"S/2019 S 16","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2019_s_17":{"id":"s_2019_s_17","iauName":"S/2019 S 17","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2019_s_18":{"id":"s_2019_s_18","iauName":"S/2019 S 18","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2019_s_19":{"id":"s_2019_s_19","iauName":"S/2019 S 19","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2019_s_2":{"id":"s_2019_s_2","iauName":"S/2019 S 2","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2019_s_20":{"id":"s_2019_s_20","iauName":"S/2019 S 20","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2019_s_21":{"id":"s_2019_s_21","iauName":"S/2019 S 21","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2019_s_3":{"id":"s_2019_s_3","iauName":"S/2019 S 3","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2019_s_4":{"id":"s_2019_s_4","iauName":"S/2019 S 4","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2019_s_5":{"id":"s_2019_s_5","iauName":"S/2019 S 5","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2019_s_6":{"id":"s_2019_s_6","iauName":"S/2019 S 6","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2019_s_7":{"id":"s_2019_s_7","iauName":"S/2019 S 7","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2019_s_8":{"id":"s_2019_s_8","iauName":"S/2019 S 8","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2019_s_9":{"id":"s_2019_s_9","iauName":"S/2019 S 9","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2020_s_1":{"id":"s_2020_s_1","iauName":"S/2020 S 1","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2020_s_10":{"id":"s_2020_s_10","iauName":"S/2020 S 10","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2020_s_2":{"id":"s_2020_s_2","iauName":"S/2020 S 2","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2020_s_3":{"id":"s_2020_s_3","iauName":"S/2020 S 3","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2020_s_4":{"id":"s_2020_s_4","iauName":"S/2020 S 4","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2020_s_5":{"id":"s_2020_s_5","iauName":"S/2020 S 5","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2020_s_6":{"id":"s_2020_s_6","iauName":"S/2020 S 6","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2020_s_7":{"id":"s_2020_s_7","iauName":"S/2020 S 7","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2020_s_8":{"id":"s_2020_s_8","iauName":"S/2020 S 8","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2020_s_9":{"id":"s_2020_s_9","iauName":"S/2020 S 9","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2021_j_1":{"id":"s_2021_j_1","iauName":"S/2021 J 1","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"s_2021_j_2":{"id":"s_2021_j_2","iauName":"S/2021 J 2","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"s_2021_j_3":{"id":"s_2021_j_3","iauName":"S/2021 J 3","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"s_2021_j_4":{"id":"s_2021_j_4","iauName":"S/2021 J 4","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"s_2021_j_5":{"id":"s_2021_j_5","iauName":"S/2021 J 5","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"s_2021_j_6":{"id":"s_2021_j_6","iauName":"S/2021 J 6","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"s_2022_j_1":{"id":"s_2022_j_1","iauName":"S/2022 J 1","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"s_2022_j_2":{"id":"s_2022_j_2","iauName":"S/2022 J 2","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"s_2022_j_3":{"id":"s_2022_j_3","iauName":"S/2022 J 3","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"sao":{"id":"sao","iauName":"Sao","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","neptune","moons"]},"gridr":{"id":"gridr","iauName":"Gridr","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons","S/2004 S20","saturn liv"]},"angrboda":{"id":"angrboda","iauName":"Angrboda","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons","S/2004 S22","saturn lv"]},"skrymir":{"id":"skrymir","iauName":"Skrymir","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons","S/2004 S23","saturn lvi"]},"gerd":{"id":"gerd","iauName":"Gerd","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons","S/2004 S25","saturn lvii"]},"saturn_lviii":{"id":"saturn_lviii","iauName":"Saturn LVIII","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"eggther":{"id":"eggther","iauName":"Eggther","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons","S/2004 S27","saturn lix"]},"saturn_lx":{"id":"saturn_lx","iauName":"Saturn LX","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"beli":{"id":"beli","iauName":"Beli","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons","S/2004 S30","saturn lxi"]},"gunnlod":{"id":"gunnlod","iauName":"Gunnlod","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons","S/2004 S32","saturn lxii"]},"thiazzi":{"id":"thiazzi","iauName":"Thiazzi","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons","S/2004 S33","saturn lxiii"]},"saturn_lxiv":{"id":"saturn_lxiv","iauName":"Saturn LXIV","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"alvaldi":{"id":"alvaldi","iauName":"Alvaldi","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons","S/2004 S35","saturn lxv"]},"geirrod":{"id":"geirrod","iauName":"Geirrod","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons","S/2004 S38","saturn lxvi"]},"setebos":{"id":"setebos","iauName":"Setebos","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","uranus","moons"]},"siarnaq":{"id":"siarnaq","iauName":"Siarnaq","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"sinope":{"id":"sinope","iauName":"Sinope","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"skathi":{"id":"skathi","iauName":"Skathi","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"skoll":{"id":"skoll","iauName":"Skoll","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"sponde":{"id":"sponde","iauName":"Sponde","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"stephano":{"id":"stephano","iauName":"Stephano","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","uranus","moons"]},"styx":{"id":"styx","iauName":"Styx","category":"Moon","subcategory":"Major Moon","keywords":["major moon","solar system","pluto","moons"]},"surtur":{"id":"surtur","iauName":"Surtur","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"suttungr":{"id":"suttungr","iauName":"Suttungr","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"sycorax":{"id":"sycorax","iauName":"Sycorax","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","uranus","moons"]},"tarqeq":{"id":"tarqeq","iauName":"Tarqeq","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"tarvos":{"id":"tarvos","iauName":"Tarvos","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"taygete":{"id":"taygete","iauName":"Taygete","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"telesto":{"id":"telesto","iauName":"Telesto","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"tethys":{"id":"tethys","iauName":"Tethys","category":"Moon","subcategory":"Major Moon","keywords":["major moon","solar system","saturn","moons","inner moons","prograde","synchronous","1684"]},"thalassa":{"id":"thalassa","iauName":"Thalassa","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","neptune","moons"]},"thebe":{"id":"thebe","iauName":"Thebe","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"thelxinoe":{"id":"thelxinoe","iauName":"Thelxinoe","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"themisto":{"id":"themisto","iauName":"Themisto","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"thrymr":{"id":"thrymr","iauName":"Thrymr","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"thyone":{"id":"thyone","iauName":"Thyone","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"titan":{"id":"titan","iauName":"Titan","category":"Moon","subcategory":"Major Moon","keywords":["major moon","solar system","saturn","moons","outer moons","prograde","synchronous","1655"]},"titania":{"id":"titania","iauName":"Titania","category":"Moon","subcategory":"Major Moon","keywords":["major moon","solar system","uranus","moons","prograde","synchronous","1787"]},"trinculo":{"id":"trinculo","iauName":"Trinculo","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","uranus","moons"]},"triton":{"id":"triton","iauName":"Triton","category":"Moon","subcategory":"Major Moon","keywords":["major moon","solar system","neptune","moons","irregular moons","retrograde","synchronous","1846"]},"umbriel":{"id":"umbriel","iauName":"Umbriel","category":"Moon","subcategory":"Major Moon","keywords":["major moon","solar system","uranus","moons","prograde","synchronous","1851"]},"ymir":{"id":"ymir","iauName":"Ymir","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"sc_ace":{"id":"sc_ace","iauName":"ACE","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_acrimsat":{"id":"sc_acrimsat","iauName":"ACRIMSAT","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_acs3":{"id":"sc_acs3","iauName":"ACS3","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"],"disabled":false},"sc_aqua":{"id":"sc_aqua","iauName":"Aqua","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_artemis_1":{"id":"sc_artemis_1","iauName":"Artemis I","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","moon","orbiter"]},"sc_aura":{"id":"sc_aura","iauName":"Aura","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_biosentinel":{"id":"sc_biosentinel","iauName":"BioSentinel","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","moon","orbiter"]},"sc_calipso":{"id":"sc_calipso","iauName":"CALIPSO","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_capstone":{"id":"sc_capstone","iauName":"CAPSTONE","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","moon","orbiter"]},"sc_cassini":{"id":"sc_cassini","iauName":"Cassini","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","saturn"],"hasEvents":true},"sc_clementine":{"id":"sc_clementine","iauName":"Clementine","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","moon","orbiter"]},"sc_cloudsat":{"id":"sc_cloudsat","iauName":"CloudSat","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_cluster_ii_fm5":{"id":"sc_cluster_ii_fm5","iauName":"Rumba","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_cluster_ii_fm6":{"id":"sc_cluster_ii_fm6","iauName":"Salsa","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_cluster_ii_fm7":{"id":"sc_cluster_ii_fm7","iauName":"Samba","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_cluster_ii_fm8":{"id":"sc_cluster_ii_fm8","iauName":"Tango","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_cygnss_1":{"id":"sc_cygnss_1","iauName":"CYGNSS 1","category":"Spacecraft","subcategory":"Orbiter","constellation":"CYGNSS","keywords":["spacecraft","earth","orbiter"]},"sc_cygnss_2":{"id":"sc_cygnss_2","iauName":"CYGNSS 2","category":"Spacecraft","subcategory":"Orbiter","constellation":"CYGNSS","keywords":["spacecraft","earth","orbiter"]},"sc_cygnss_3":{"id":"sc_cygnss_3","iauName":"CYGNSS 3","category":"Spacecraft","subcategory":"Orbiter","constellation":"CYGNSS","keywords":["spacecraft","earth","orbiter"]},"sc_cygnss_4":{"id":"sc_cygnss_4","iauName":"CYGNSS 4","category":"Spacecraft","subcategory":"Orbiter","constellation":"CYGNSS","keywords":["spacecraft","earth","orbiter"]},"sc_cygnss_5":{"id":"sc_cygnss_5","iauName":"CYGNSS 5","category":"Spacecraft","subcategory":"Orbiter","constellation":"CYGNSS","keywords":["spacecraft","earth","orbiter"]},"sc_cygnss_6":{"id":"sc_cygnss_6","iauName":"CYGNSS 6","category":"Spacecraft","subcategory":"Orbiter","constellation":"CYGNSS","keywords":["spacecraft","earth","orbiter"]},"sc_cygnss_7":{"id":"sc_cygnss_7","iauName":"CYGNSS 7","category":"Spacecraft","subcategory":"Orbiter","constellation":"CYGNSS","keywords":["spacecraft","earth","orbiter"]},"sc_cygnss_8":{"id":"sc_cygnss_8","iauName":"CYGNSS 8","category":"Spacecraft","subcategory":"Orbiter","constellation":"CYGNSS","keywords":["spacecraft","earth","orbiter"]},"sc_dart":{"id":"sc_dart","iauName":"DART","category":"Spacecraft","subcategory":"Impactor","altName":"boom","keywords":["spacecraft","65803_didymos","dimorphos","asteroid"],"hasEvents":true},"sc_dawn":{"id":"sc_dawn","iauName":"Dawn","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","vesta","ceres","small body mission"],"related":{"asteroid":["4_vesta","1_ceres"]},"hasEvents":true},"sc_deep_impact":{"id":"sc_deep_impact","iauName":"Deep Impact","category":"Spacecraft","subcategory":"Flyby","altName":"DI","keywords":["spacecraft","tempel 1","small body mission"],"related":{"comet":["9p_temp_1"]},"hasEvents":true},"sc_deep_impact_impactor":{"id":"sc_deep_impact_impactor","iauName":"Deep Impact Impactor","category":"Spacecraft","subcategory":"Impactor","altName":"DII","keywords":["spacecraft","tempel 1","small body mission"],"related":{"comet":["9p_temp_1"]},"hasEvents":true},"sc_deep_impact_impactor_impact_site":{"id":"sc_deep_impact_impactor_impact_site","displayName":"Deep Impact Impactor Impact Site","category":"Landing site","comparisonFeature":false},"sc_deep_space_1":{"id":"sc_deep_space_1","iauName":"Deep Space 1","category":"Spacecraft","subcategory":"Flyby","altName":"DS1","keywords":["spacecraft","9660 Braille","19p/Borrelly","small body mission"],"related":{"asteroid":["9969_braille"],"comet":["19p_borrelly"]},"hasEvents":true},"sc_eo_1":{"id":"sc_eo_1","iauName":"EO-1","category":"Spacecraft","subcategory":"Orbiter","altName":"Earth Observing-1","keywords":["spacecraft","earth","orbiter"]},"sc_euclid":{"id":"sc_euclid","iauName":"Euclid","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter","telescope"],"disabled":false},"sc_europa_clipper":{"id":"sc_europa_clipper","iauName":"Europa Clipper","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter","europa"],"disabled":false,"hasEvents":true},"sc_explorer_1":{"id":"sc_explorer_1","iauName":"Explorer 1","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_galileo":{"id":"sc_galileo","iauName":"Galileo","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","outer planet mission","orbiter","jupiter"],"hasEvents":true},"sc_galileo_probe":{"id":"sc_galileo_probe","iauName":"Galileo Probe","category":"Spacecraft","subcategory":"Lander","keywords":["spacecraft","outer planet mission","orbiter","jupiter"],"hasEvents":true},"sc_geotail":{"id":"sc_geotail","iauName":"Geotail","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_gpm":{"id":"sc_gpm","iauName":"GPM","category":"Spacecraft","subcategory":"Orbiter","altName":"Global Precipitation Measurement","keywords":["spacecraft","earth","orbiter"]},"sc_grace_1":{"id":"sc_grace_1","iauName":"GRACE-1","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_grace_2":{"id":"sc_grace_2","iauName":"GRACE-2","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_grace_fo1":{"id":"sc_grace_fo1","iauName":"GRACE-FO1","category":"Spacecraft","subcategory":"Orbiter","altName":"GRACE Follow-On","keywords":["spacecraft","earth","orbiter"]},"sc_grace_fo2":{"id":"sc_grace_fo2","iauName":"GRACE-FO2","category":"Spacecraft","subcategory":"Orbiter","altName":"GRACE Follow-On","keywords":["spacecraft","earth","orbiter"]},"sc_grail_a":{"id":"sc_grail_a","iauName":"GRAIL A","category":"Spacecraft","subcategory":"Orbiter","altName":"Ebb","keywords":["spacecraft","moon","orbiter","ebb"]},"sc_grail_b":{"id":"sc_grail_b","iauName":"GRAIL B","category":"Spacecraft","subcategory":"Orbiter","altName":"Flow","keywords":["spacecraft","moon","orbiter","flow"]},"sc_grifex":{"id":"sc_grifex","iauName":"GRIFEX","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_hubble_space_telescope":{"id":"sc_hubble_space_telescope","iauName":"Hubble Space Telescope","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter","telescope","1990"]},"sc_huygens":{"id":"sc_huygens","iauName":"Huygens","category":"Spacecraft","subcategory":"Lander","keywords":["spacecraft","titan","cassini","lander"],"hasEvents":true},"sc_ibex":{"id":"sc_ibex","iauName":"IBEX","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_icesat_2":{"id":"sc_icesat_2","iauName":"ICESat-2","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_image":{"id":"sc_image","iauName":"IMAGE","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_imap":{"id":"sc_imap","iauName":"IMAP","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter","L1"]},"sc_insight":{"id":"sc_insight","iauName":"InSight","category":"Spacecraft","subcategory":"Lander","keywords":["spacecraft","mars","lander","seismic","2018"],"landingDate":"2018-11-26T19:45:00"},"sc_ipex":{"id":"sc_ipex","iauName":"IPEX","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_isas":{"id":"sc_isas","iauName":"ISAS","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_iss":{"id":"sc_iss","iauName":"International Space Station","category":"Spacecraft","subcategory":"Orbiter","altName":"ISS","keywords":["iss","international","international space","station","earth","orbiter","1998","emit","ecostress","oco-3"],"customDistance":0.1},"sc_iss_cowvr_tempest":{"id":"sc_iss_cowvr_tempest","iauName":"COWVR/TEMPEST","category":"Instrument","cameraOptions":{"forwardVector":"-y-axis"},"comparisonFeature":false,"keywords":["spacecraft","earth","iss","orbiter"]},"sc_iss_ecostress":{"id":"sc_iss_ecostress","iauName":"ECOSTRESS","category":"Instrument","cameraOptions":{"forwardVector":"-y-axis"},"comparisonFeature":false,"keywords":["spacecraft","earth","iss","orbiter"]},"sc_iss_emit":{"id":"sc_iss_emit","iauName":"EMIT","category":"Instrument","cameraOptions":{"forwardVector":"y-axis","distance":0.006},"comparisonFeature":false,"altName":"Earth Surface Mineral Dust Source Investigation","keywords":["spacecraft","earth","iss","orbiter"]},"sc_iss_oco_3":{"id":"sc_iss_oco_3","iauName":"OCO-3","category":"Instrument","cameraOptions":{"forwardVector":"-y-axis"},"comparisonFeature":false,"altName":"Orbiting Carbon Observatory 3","keywords":["spacecraft","earth","iss","orbiter"]},"sc_iss_rapidscat":{"id":"sc_iss_rapidscat","iauName":"RapidScat","category":"Instrument","cameraOptions":{"upVector":"-y-axis","forwardVector":"x-axis","distance":0.007},"comparisonFeature":false,"keywords":["spacecraft","earth","iss","orbiter"]},"sc_ixpe":{"id":"sc_ixpe","iauName":"IXPE","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter","telescope","2021","x-ray","imaging x-ray polarimetry explorer","cosmic x-rays"]},"sc_jason_1":{"id":"sc_jason_1","iauName":"Jason-1","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_jason_2":{"id":"sc_jason_2","iauName":"Jason-2/OSTM","category":"Spacecraft","subcategory":"Orbiter","altName":"OSTM","keywords":["spacecraft","earth","orbiter","jason-2"]},"sc_jason_3":{"id":"sc_jason_3","iauName":"Jason-3","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_juice":{"id":"sc_juice","iauName":"Juice","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","jupiter","orbiter"]},"sc_juno":{"id":"sc_juno","iauName":"Juno","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","jupiter","orbiter","gravity","magnetic field","atmosphere","junocam","bruh","2011"],"customDistance":0.04,"hasEvents":true},"sc_jwst":{"id":"sc_jwst","iauName":"James Webb Space Telescope","category":"Spacecraft","subcategory":"Orbiter","altName":"James Webb Space Telescope","keywords":["spacecraft","earth","orbiter","telescope","jwst"],"hasEvents":true},"sc_kepler_space_telescope":{"id":"sc_kepler_space_telescope","iauName":"Kepler","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter","telescope"]},"sc_ladee":{"id":"sc_ladee","iauName":"LADEE","category":"Spacecraft","subcategory":"Orbiter","altName":"Lunar Atmosphere and Dust Environment Explorer","keywords":["spacecraft","moon","orbiter"]},"sc_landsat_7":{"id":"sc_landsat_7","iauName":"Landsat 7","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_landsat_8":{"id":"sc_landsat_8","iauName":"Landsat 8","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_landsat_9":{"id":"sc_landsat_9","iauName":"Landsat 9","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_lcross":{"id":"sc_lcross","iauName":"LCROSS","category":"Spacecraft","subcategory":"Orbiter","altName":"Lunar Crater Observation and Sensing Satellite","keywords":["spacecraft","moon","orbiter"],"hasEvents":true},"sc_lucy":{"id":"sc_lucy","iauName":"Lucy","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"],"hasEvents":true},"sc_lunar_flashlight":{"id":"sc_lunar_flashlight","iauName":"Lunar Flashlight","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","moon","orbiter"]},"sc_lunar_icecube":{"id":"sc_lunar_icecube","iauName":"Lunar IceCube","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","moon","orbiter"]},"sc_lunar_prospector":{"id":"sc_lunar_prospector","iauName":"Lunar Prospector","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","moon","orbiter"]},"sc_lunar_reconnaissance_orbiter":{"id":"sc_lunar_reconnaissance_orbiter","iauName":"Lunar Reconnaissance Orbiter","category":"Spacecraft","subcategory":"Orbiter","altName":"LRO","keywords":["spacecraft","moon","orbiter","lro","temperature","imaging","albedo","polar","2009"]},"sc_lunar_trailblazer":{"id":"sc_lunar_trailblazer","iauName":"Lunar Trailblazer","category":"Spacecraft","subcategory":"Orbiter","altName":"","keywords":["spacecraft","moon","orbiter","lunar","trailblazer","water"],"disabled":true},"sc_lunir":{"id":"sc_lunir","iauName":"Lunar Reconnaissance Orbiter","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","moon","orbiter","artemis"],"disabled":true},"sc_magellan":{"id":"sc_magellan","iauName":"Magellan","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","inner planet mission","venus"]},"sc_marco_a":{"id":"sc_marco_a","iauName":"MarCO A","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","insight","cubesat"]},"sc_marco_b":{"id":"sc_marco_b","iauName":"MarCO B","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","insight","cubesat"]},"sc_mars_2020":{"id":"sc_mars_2020","iauName":"Mars 2020 (Perseverance)","category":"Spacecraft","subcategory":"Rover","altName":"Percy","keywords":["spacecraft","mars","lander","rover","perseverance","mars 2020","mars2020","m2020"],"landingDate":"2021-02-18T20:55:00"},"sc_mars_2020_landing_site":{"id":"sc_mars_2020_landing_site","displayName":"Perseverance Rover landing site","category":"Landing site","comparisonFeature":false},"sc_mars_exploration_rover_1_landing_site":{"id":"sc_mars_exploration_rover_1_landing_site","displayName":"Opportunity Rover landing site","category":"Landing site","comparisonFeature":false},"sc_mars_exploration_rover_1":{"id":"sc_mars_exploration_rover_1","iauName":"Mars Exploration Rover B (Opportunity)","displayName":"Opportunity","category":"Spacecraft","subcategory":"Rover","keywords":["spacecraft","mars","lander","rover","opportunity","meridiani planum","2003","MER-B","MER-1","mer b"],"landingDate":"2004-01-25T04:54:00"},"sc_mars_exploration_rover_2_landing_site":{"id":"sc_mars_exploration_rover_2_landing_site","displayName":"Spirit Rover landing site","category":"Landing site","comparisonFeature":false},"sc_mars_exploration_rover_2":{"id":"sc_mars_exploration_rover_2","iauName":"Mars Exploration Rover A (Spirit)","displayName":"Spirit","category":"Spacecraft","subcategory":"Rover","keywords":["spacecraft","mars","lander","rover","spirit","MER-A","MER-2","mer a"],"landingDate":"2004-01-25T04:54:00"},"sc_mars_express":{"id":"sc_mars_express","iauName":"Mars Express","category":"Spacecraft","subcategory":"Orbiter","altName":"MEX","keywords":["spacecraft","mars","orbiter","water","geology","atmosphere","surface","relay","2003"]},"sc_mars_global_surveyor":{"id":"sc_mars_global_surveyor","iauName":"Mars Global Surveyor","category":"Spacecraft","subcategory":"Orbiter","altName":"MGS","keywords":["spacecraft","mars","MGS"]},"sc_mars_odyssey":{"id":"sc_mars_odyssey","iauName":"Mars Odyssey","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","mars","orbiter","elements","minerals","hydrogen","water","polar","radiation","relay","2001"]},"sc_mars_reconnaissance_orbiter":{"id":"sc_mars_reconnaissance_orbiter","iauName":"Mars Reconnaissance Orbiter","category":"Spacecraft","subcategory":"Orbiter","altName":"MRO","keywords":["spacecraft","mars","orbiter","mro","water","dust","atmosphere","relay","2005"]},"sc_mars_science_laboratory_landing_site":{"id":"sc_mars_science_laboratory_landing_site","displayName":"Curiosity Rover landing site","category":"Landing site","comparisonFeature":false},"sc_mars_science_laboratory":{"id":"sc_mars_science_laboratory","iauName":"Mars Science Laboratory (Curiosity)","displayName":"Mars Science Laboratory (Curiosity)","category":"Spacecraft","subcategory":"Rover","altName":"MSL","keywords":["spacecraft","mars","lander","rover","msl","curiosity","microbes","habitability","2011"],"landingDate":"2012-08-06T05:32:00"},"sc_maven":{"id":"sc_maven","iauName":"MAVEN","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","mars","orbiter","atmosphere","ionosphere","solar wind","relay","2013"]},"sc_messenger":{"id":"sc_messenger","iauName":"MESSENGER","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","mercury","orbiter"]},"sc_messenger_impact_site":{"id":"sc_messenger_impact_site","displayName":"MESSENGER Impact Site","category":"Landing site","comparisonFeature":false},"sc_mcubed_2":{"id":"sc_mcubed_2","iauName":"MCubed-2","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_mms_1":{"id":"sc_mms_1","iauName":"MMS 1","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_mms_2":{"id":"sc_mms_2","iauName":"MMS 2","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_mms_3":{"id":"sc_mms_3","iauName":"MMS 3","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_mms_4":{"id":"sc_mms_4","iauName":"MMS 4","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_near_shoemaker":{"id":"sc_near_shoemaker","iauName":"NEAR Shoemaker","category":"Spacecraft","subcategory":"Flyby","keywords":["spacecraft","eros","orbiter"],"related":{"asteroid":["433_eros"]},"hasEvents":true},"sc_neo_surveyor":{"id":"sc_neo_surveyor","iauName":"NEO Surveyor","category":"Spacecraft","subcategory":"Orbiter","keywords":["earth","orbiter","asteroids"],"hasEvents":true},"sc_new_horizons":{"id":"sc_new_horizons","iauName":"New Horizons","category":"Spacecraft","subcategory":"Flyby","keywords":["spacecraft","pluto","flyby","imager","spectrometer","ultraviolet","solar wind","extended mission","2006"],"hasEvents":true},"sc_nisar":{"id":"sc_nisar","iauName":"NISAR","category":"Spacecraft","subcategory":"Orbiter","keywords":["orbiter","earth"],"disabled":false},"sc_nustar":{"id":"sc_nustar","iauName":"NuSTAR","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","telescope","X-ray","astrophysics"]},"sc_oco_2":{"id":"sc_oco_2","iauName":"OCO-2","category":"Spacecraft","subcategory":"Orbiter","altName":"Orbiting Carbon Observatory 2","keywords":["spacecraft","earth","orbiter"]},"sc_osiris_rex":{"id":"sc_osiris_rex","iauName":"OSIRIS-APEX","category":"Spacecraft","subcategory":"Orbiter","altName":"ORX","keywords":["spacecraft","bennu","apex","osiris-apex","lander","sample return","asteroids","chemistry","mineralogy","2016"],"related":{"asteroid":["101955_bennu","99942_apophis"]},"hasEvents":true},"sc_osiris_rex_src":{"id":"sc_osiris_rex_src","iauName":"OSIRIS-REx Sample Return Capsule","category":"Spacecraft","subcategory":"Flyby","altName":"ORX SRC","keywords":["spacecraft","Bennu","orbiter","sc_osiris_rex","SRC","sample return"],"related":{"asteroid":["101955_bennu"]},"hasEvents":true},"sc_pace":{"id":"sc_pace","iauName":"PACE","altName":"Plankton, Aerosol, Cloud, ocean Ecosystem","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"],"disabled":false},"sc_parker_solar_probe":{"id":"sc_parker_solar_probe","iauName":"Parker Solar Probe","category":"Spacecraft","subcategory":"Orbiter","altName":"PSP","keywords":["spacecraft","psp"]},"sc_philae":{"id":"sc_philae","iauName":"Philae","category":"Spacecraft","subcategory":"Lander","keywords":["spacecraft","67P/Churyumov-Gerasimenko","lander","Rosetta"],"related":{"comet":["67p_churyumov_gerasimenko"]},"hasEvents":true},"sc_phoenix":{"id":"sc_phoenix","iauName":"Phoenix","category":"Spacecraft","subcategory":"Lander","altName":"PHX","keywords":["spacecraft","mars","lander"],"landingDate":"2008-05-25T23:53:44"},"sc_phoenix_landing_site":{"id":"sc_phoenix_landing_site","displayName":"Phoenix landing site","category":"Landing site","comparisonFeature":false},"sc_pioneer_10":{"id":"sc_pioneer_10","iauName":"Pioneer 10","category":"Spacecraft","subcategory":"Flyby","keywords":["spacecraft","jupiter","callisto","ganymede","europa","io","flyby","outer planets","interstellar","1972"],"hasEvents":true},"sc_pioneer_11":{"id":"sc_pioneer_11","iauName":"Pioneer 11","category":"Spacecraft","subcategory":"Flyby","keywords":["spacecraft","jupiter","callisto","ganymede","io","europa","amalthea","saturn","iapetus","phoebe","hyperion","epimetheus","atlas","dione","mimas","janus","tethys","enceladus","calypso","rhea","titan","flyby","magnetic field","solar wind","outer planets","interstellar","1973"],"hasEvents":true},"sc_polar":{"id":"sc_polar","iauName":"Polar","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_prefire_1":{"id":"sc_prefire_1","iauName":"PREFIRE-1","category":"Spacecraft","subcategory":"Orbiter","constellation":"PREFIRE","keywords":["spacecraft","earth","orbiter"]},"sc_prefire_2":{"id":"sc_prefire_2","iauName":"PREFIRE-2","category":"Spacecraft","subcategory":"Orbiter","constellation":"PREFIRE","keywords":["spacecraft","earth","orbiter"]},"sc_psyche":{"id":"sc_psyche","iauName":"Psyche","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","16 Psyche","orbiter"],"related":{"asteroid":["16_psyche"]},"hasEvents":true},"sc_quikscat":{"id":"sc_quikscat","iauName":"QuikSCAT","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_raincube":{"id":"sc_raincube","iauName":"RainCube","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","cubesat"]},"sc_rbsp_a":{"id":"sc_rbsp_a","iauName":"Van Allen Probe A","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_rbsp_b":{"id":"sc_rbsp_b","iauName":"Van Allen Probe B","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_sac_d":{"id":"sc_sac_d","iauName":"Aquarius","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_rosetta":{"id":"sc_rosetta","iauName":"Rosetta","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","small body mission","67P/Churyumov-Gerasimenko"],"related":{"comet":["67p_churyumov_gerasimenko"]},"hasEvents":true},"sc_sdo":{"id":"sc_sdo","iauName":"Solar Dynamics Observatory","category":"Spacecraft","subcategory":"Orbiter","altName":"SDO","keywords":["spacecraft","earth","orbiter"]},"sc_sentinel_6":{"id":"sc_sentinel_6","iauName":"Sentinel-6 Michael Freilich","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter","2020","sea level","jason","jason-cs","copernicus","topex/poseidon"]},"sc_smap":{"id":"sc_smap","iauName":"SMAP","category":"Spacecraft","subcategory":"Orbiter","altName":"Soil Moisture Active Passive","keywords":["spacecraft","earth","orbiter"]},"sc_soho":{"id":"sc_soho","iauName":"SOHO","category":"Spacecraft","subcategory":"Orbiter","altName":"Solar and Heliospheric Observatory","keywords":["spacecraft","sun","orbiter"]},"sc_sorce":{"id":"sc_sorce","iauName":"SORCE","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_spherex":{"id":"sc_spherex","iauName":"SPHEREx","category":"Spacecraft","subcategory":"Orbiter","disabled":false,"keywords":["spacecraft","earth","orbiter","observatory","telescope"]},"sc_spitzer":{"id":"sc_spitzer","iauName":"Spitzer Space Telescope","category":"Spacecraft","subcategory":"Orbiter","altName":"SIRTF","keywords":["spacecraft","sun","orbiter","sirtf","space infrared telescope facility","spitzer space telescope","2003"]},"sc_stardust":{"id":"sc_stardust","iauName":"Stardust","category":"Spacecraft","subcategory":"Flyby","keywords":["spacecraft","Wild-2","orbiter"],"related":{"comet":["81p_wild_2"]},"hasEvents":true},"sc_stardust_src":{"id":"sc_stardust_src","iauName":"Stardust Sample Return Capsule","category":"Spacecraft","subcategory":"Flyby","keywords":["spacecraft","Wild-2","orbiter"],"related":{"comet":["81p_wild_2"]}},"sc_starling_1":{"id":"sc_starling_1","iauName":"Starling-1","category":"Spacecraft","subcategory":"Orbiter","constellation":"STARLING","keywords":["spacecraft","earth","orbiter"],"disabled":false},"sc_starling_2":{"id":"sc_starling_2","iauName":"Starling-2","category":"Spacecraft","subcategory":"Orbiter","constellation":"STARLING","keywords":["spacecraft","earth","orbiter"],"disabled":false},"sc_starling_3":{"id":"sc_starling_3","iauName":"Starling-3","category":"Spacecraft","subcategory":"Orbiter","constellation":"STARLING","keywords":["spacecraft","earth","orbiter"],"disabled":false},"sc_starling_4":{"id":"sc_starling_4","iauName":"Starling-4","category":"Spacecraft","subcategory":"Orbiter","constellation":"STARLING","keywords":["spacecraft","earth","orbiter"],"disabled":false},"sc_stereo_ahead":{"id":"sc_stereo_ahead","iauName":"STEREO Ahead","category":"Spacecraft","subcategory":"Orbiter","altName":"STA","keywords":["spacecraft","sun","orbiter","solar terrestrial relations observatory","stereoscopic","coronal mass ejections","cme","2006"]},"sc_stereo_behind":{"id":"sc_stereo_behind","iauName":"STEREO Behind","category":"Spacecraft","subcategory":"Orbiter","altName":"STB","keywords":["spacecraft","sun","orbiter","solar terrestrial relations observatory","stereoscopic","coronal mass ejections","cme","2006"]},"sc_tdrs_3":{"id":"sc_tdrs_3","iauName":"TDRS-3","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","orbiter"]},"sc_tdrs_5":{"id":"sc_tdrs_5","iauName":"TDRS-5","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","orbiter"]},"sc_tdrs_6":{"id":"sc_tdrs_6","iauName":"TDRS-6","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","orbiter"]},"sc_tdrs_7":{"id":"sc_tdrs_7","iauName":"TDRS-7","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","orbiter"]},"sc_tdrs_8":{"id":"sc_tdrs_8","iauName":"TDRS-8","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","orbiter"]},"sc_tdrs_9":{"id":"sc_tdrs_9","iauName":"TDRS-9","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","orbiter"]},"sc_tdrs_10":{"id":"sc_tdrs_10","iauName":"TDRS-10","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","orbiter"]},"sc_tdrs_11":{"id":"sc_tdrs_11","iauName":"TDRS-11","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","orbiter"]},"sc_tdrs_12":{"id":"sc_tdrs_12","iauName":"TDRS-12","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","orbiter"]},"sc_tdrs_13":{"id":"sc_tdrs_13","iauName":"TDRS-13","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","orbiter"]},"sc_suomi_npp":{"id":"sc_suomi_npp","iauName":"Suomi NPP","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_swot":{"id":"sc_swot","iauName":"SWOT","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_tempo":{"id":"sc_tempo","iauName":"TEMPO","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_terra":{"id":"sc_terra","iauName":"Terra","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_tess":{"id":"sc_tess","iauName":"TESS","category":"Spacecraft","subcategory":"Orbiter","altName":"Transiting Exoplanet Survey Satellite","keywords":["spacecraft","earth","telescope","transiting exoplanet survey satellite","orbiter","2018","exoplanets"]},"sc_themis_a":{"id":"sc_themis_a","iauName":"THEMIS-A","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_themis_b":{"id":"sc_themis_b","iauName":"ARTEMIS P1","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","moon","orbiter"]},"sc_themis_c":{"id":"sc_themis_c","iauName":"ARTEMIS P2","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","moon","orbiter"]},"sc_themis_d":{"id":"sc_themis_d","iauName":"THEMIS-D","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_themis_e":{"id":"sc_themis_e","iauName":"THEMIS-E","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_trace_gas_orbiter":{"id":"sc_trace_gas_orbiter","iauName":"Trace Gas Orbiter","category":"Spacecraft","subcategory":"Orbiter","altName":"TGO","keywords":["spacecraft","mars","orbiter","tgo","atmosphere","relay","2016"]},"sc_trmm":{"id":"sc_trmm","iauName":"TRMM","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_tropics_03":{"id":"sc_tropics_03","iauName":"TROPICS-03","category":"Spacecraft","subcategory":"Orbiter","constellation":"TROPICS","keywords":["spacecraft","earth","orbiter"],"disabled":false},"sc_tropics_05":{"id":"sc_tropics_05","iauName":"TROPICS-05","category":"Spacecraft","subcategory":"Orbiter","constellation":"TROPICS","keywords":["spacecraft","earth","orbiter"],"disabled":false},"sc_tropics_06":{"id":"sc_tropics_06","iauName":"TROPICS-06","category":"Spacecraft","subcategory":"Orbiter","constellation":"TROPICS","keywords":["spacecraft","earth","orbiter"],"disabled":false},"sc_tropics_07":{"id":"sc_tropics_07","iauName":"TROPICS-07","category":"Spacecraft","subcategory":"Orbiter","constellation":"TROPICS","keywords":["spacecraft","earth","orbiter"],"disabled":false},"sc_tropics_01":{"id":"sc_tropics_01","iauName":"TROPICS-01","category":"Spacecraft","subcategory":"Orbiter","constellation":"TROPICS","keywords":["spacecraft","earth","orbiter","tropics pathfinder","pathfinder"],"disabled":false},"sc_ulysses":{"id":"sc_ulysses","iauName":"Ulysses","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","sun","orbiter"]},"sc_voyager_1":{"id":"sc_voyager_1","iauName":"Voyager 1","category":"Spacecraft","subcategory":"Flyby","keywords":["spacecraft","jupiter","saturn","flyby","imaging","vger","radio science","infrared","ultraviolet","magnetometer","plasma","1977"],"hasEvents":true},"sc_voyager_2":{"id":"sc_voyager_2","iauName":"Voyager 2","category":"Spacecraft","subcategory":"Flyby","keywords":["spacecraft","jupiter","saturn","uranus","vger","neptune","flyby","imaging","radio science","infrared","ultraviolet","magnetometer","plasma","1977"],"hasEvents":true},"sc_wind":{"id":"sc_wind","iauName":"WIND","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","solar wind","earth","orbiter"]},"valetudo":{"id":"valetudo","iauName":"Valetudo","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"scientist":{"id":"scientist","displayName":"Scientist","category":"Human","searchable":false},"school_bus":{"id":"school_bus","displayName":"School Bus","category":"Vehicle","searchable":false},"rose_bowl":{"id":"rose_bowl","displayName":"Stadium","category":"Building","searchable":false}}')
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    e.default = {
        earth: [{
            id: "viirs",
            title: "High-quality global mosaic from yesterday",
            description: "This daily global mosaic is from the Visible Infrared Imaging Radiometer Suite (VIIRS), which is one of the key instruments onboard the Suomi National Polar-Orbiting Partnership (Suomi NPP) spacecraft.",
            type: "wmts",
            features: ["shadowEntities", "atmosphere"],
            endPoint: "assets/wmts_xml",
            layer: "VIIRS_SNPP_CorrectedReflectance_TrueColor",
            tile: "250m",
            time: "yesterday",
            wmtsManifest: "$DYNAMIC_ASSETS_URL/earth/data/visibleEarth/dataset_manifest.json",
            fallbacks: [{
                endPoint: "assets/wmts_xml_noaa_20",
                layer: "VIIRS_NOAA20_CorrectedReflectance_TrueColor"
            }, {
                endPoint: "assets/wmts_xml_noaa_21",
                layer: "VIIRS_NOAA21_CorrectedReflectance_TrueColor"
            }]
        }],
        mars: [{
            id: "vikingMosaic",
            title: "Global mosaic from the Viking missions to Mars",
            description: "The two Mars Viking Orbiters imaged the entire surface of Mars at a resolution of 150 to 300 meters.",
            type: "wmts",
            features: ["shadowEntities", "atmosphere"],
            endPoint: "https://trek.nasa.gov/tiles/Mars/EQ/corrected/Mars_Viking_MDIM21_ClrMosaic_global_232m",
            layer: "Mars_Viking_MDIM21_ClrMosaic_global_232m"
        }],
        moon: [{
            id: "lroMosaic",
            title: "Global mosaic from the Lunar Reconnaissance Orbiter mission",
            description: "The wide-angle camera on LRO mapped the entire moon at 100 meters/pixel.",
            type: "wmts",
            features: ["shadowEntities"],
            endPoint: "https://trek.nasa.gov/tiles/Moon/EQ/corrected/LRO_WAC_Mosaic_Global_303ppd_v02",
            layer: "LRO_WAC_Mosaic_Global_303ppd_v02"
        }],
        titan: [{
            id: "surface",
            title: "Surface imagery of Titan from Cassini's Imaging Science Subsystem camera",
            description: "This global mosaic is at 4 km/pixel, combining one hundred flybys of Titan by the Cassini mission",
            type: "texture",
            features: ["shadowEntities"],
            textures: {
                color: {
                    url: "titan/surface_$SIZE_$FACE.png",
                    sizes: [16, 512, 2048]
                }
            }
        }, {
            id: "radar",
            title: "Radar Map of Titan's Surface",
            description: "This 351 meters/pixel map incorporates 104 Titan flybys by the Cassini mission.",
            type: "texture",
            features: ["shadowEntities"],
            textures: {
                color: {
                    url: "titan/radar_$SIZE_$FACE.png",
                    sizes: [16, 512, 2048, 4096]
                }
            }
        }],
        venus: [{
            id: "surface",
            title: "Radar Map of the Surface of Venus",
            description: "The Magellan mission used radar to see beneath the smog of Venus.",
            type: "texture",
            features: ["shadowEntities"],
            textures: {
                color: {
                    url: "venus/surface_$SIZE_$FACE.png",
                    sizes: [16, 512, 1024]
                }
            }
        }]
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    e.default = {
        jupiter: [{
            id: "magnetosphere",
            title: "Jupiter's Magnetic Field",
            description: "DESCRIPTION"
        }, {
            id: "auroras",
            title: "Jupiter's Auroras",
            description: "DESCRIPTION"
        }, {
            id: "radiationBelt",
            title: "Jupiter's Radiation Belt",
            description: "DESCRIPTION"
        }],
        saturn: [{
            id: "magnetosphere",
            title: "Saturn's Magnetic Field",
            description: "DESCRIPTION"
        }]
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        Types: function() {
            return n
        }
    });
    var s = i(2);
    const n = new Map;
    n.set("TimeManager", s.TimeManager),
    n.set("SelectionManager", s.SelectionManager),
    n.set("LabelManager", s.LabelManager),
    n.set("TitleManager", s.TitleManager),
    n.set("TrailManager", s.TrailManager),
    n.set("CameraFollowManager", s.CameraFollowManager),
    n.set("AutoplayManager", s.AutoplayManager),
    n.set("LoadIcon", s.LoadIcon),
    n.set("Overlay", s.Overlay),
    n.set("Settings", s.Settings),
    n.set("Breadcrumb", s.Breadcrumb),
    n.set("Clock", s.Clock),
    n.set("ClockShortcut", s.ClockShortcut),
    n.set("Story", s.Story),
    n.set("LayerPanel", s.LayerPanel),
    n.set("Search", s.Search),
    n.set("Carousel", s.Carousel),
    n.set("TutorialOverlay", s.TutorialOverlay),
    n.set("CarouselPanel", s.CarouselPanel),
    n.set("ShareModal", s.ShareModal),
    n.set("TimeController", s.TimeController),
    n.set("KioskBase", s.KioskBase),
    n.set("Toast", s.Toast)
}
, function(t, e, i) {
    "use strict";
    i.r(e);
    i(724),
    i(725),
    i(726),
    i(727),
    i(728),
    i(729),
    i(730),
    i(731),
    i(732),
    i(733),
    i(734)
}
, function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t, e, i) {
    "use strict";
    i.r(e);
    var s = i(1)
      , n = i(736);
    e.default = [{
        type: "Breadcrumb",
        name: "breadcrumb",
        options: {
            params: {
                title: "Eyes on the Solar System"
            }
        }
    }, {
        type: "Clock",
        name: "clock",
        hasPlaceholder: !1
    }, {
        type: "Clock",
        name: "storyClock",
        hasPlaceholder: !0
    }, {
        type: "Clock",
        name: "kioskSessionClock",
        hasPlaceholder: !1,
        options: {
            allowEdit: !1,
            isDateVisible: !1,
            isMeridiemVisible: !1,
            isKioskSessionTimer: !0
        }
    }, {
        type: "Clock",
        name: "eventsReplayClock",
        hasPlaceholder: !1,
        options: {
            allowEdit: !1,
            isDateVisible: !1,
            isTimeVisible: !0,
            isMeridiemVisible: !0
        }
    }, {
        type: "ClockShortcut",
        name: "clockShortcut"
    }, {
        type: "CollapsibleMenu",
        name: "collapsibleMenu"
    }, {
        type: "Settings",
        name: "settings"
    }, {
        type: "ContentPanel",
        name: "contentPanel"
    }, {
        type: "MobileExpandButton",
        name: "mobileExpandButton"
    }, {
        type: "TimeControls",
        name: "timeControls",
        hasPlaceholder: !1
    }, {
        type: "EventsTimeline",
        name: "eventsTimeline",
        hasPlaceholder: !1
    }, {
        type: "Telescope",
        name: "telescope"
    }, {
        type: "Story",
        name: "story"
    }, {
        type: "KioskMode",
        name: "kioskMode"
    }, {
        type: "LayerPanel",
        name: "layerPanel",
        options: {
            layers: [["ui"], ["planets", "asteroids", "comets", "dwarfPlanets", "constellations"], ["spacecraft"], ["trails", "orbits", "labels", "icons"]]
        }
    }, {
        type: "ShareModal",
        name: "shareModal",
        options: {
            config: {
                shareBtnParent: {
                    selector: ".main-menu .menu-content",
                    wideSelector: "nav.top-right-nav",
                    threshold: 1025
                },
                linkAltText: "Eyes on the Solar System - Home",
                linkImageSrc: "https://eyes.nasa.gov/apps/solar-system/og_img.jpg",
                controls: n.default
            },
            paramsToKeep: ["to", "x", "y", "z", "id"]
        }
    }, {
        type: "InfoPanel",
        name: "infoPanel",
        hasPlaceholder: !1
    }, {
        type: "DistancePanel",
        name: "distancePanel",
        hasPlaceholder: !0
    }, {
        type: "Comparison",
        name: "comparison",
        postCreationFunction: (t, e) => {
            t.getComponent("settings")?.registerCallback("unitchange", e.unitchange)
        }
    }, {
        type: "Search",
        name: "searchDesktop",
        options: {
            config: {
                stopOnExactMatch: !0,
                searchType: "desktop"
            }
        },
        postCreationFunction: (t, e) => {
            e.onResize = () => {
                s.AppUtils.isMobileMode() ? e.hide() : e.show()
            }
        }
    }, {
        type: "Search",
        name: "searchMobile",
        hasPlaceholder: !1,
        options: {
            alwaysOpen: !0,
            magClass: "mag-close",
            searchClass: "search-open",
            config: {
                stopOnExactMatch: !0,
                searchType: "mobile"
            }
        },
        postCreationFunction: (t, e) => {
            e.onResize = () => {
                s.AppUtils.isMobileMode() ? e.show() : e.hide()
            }
        }
    }, {
        type: "Search",
        name: "distanceSourceSearch",
        hasPlaceholder: !1,
        options: {
            alwaysOpen: !0,
            magClass: "mag-close",
            searchClass: "search-open",
            config: {
                stopOnExactMatch: !0,
                allowDetail: !1,
                searchType: "distanceSource",
                maxEntries: 8,
                onSearchFocus: t => {
                    t.eraseInput(),
                    t.app.getComponent("distancePanel")?.setIsSearching?.(!0)
                }
                ,
                onReset: t => {
                    const {defaultText: e} = t._config
                      , {input: i} = t._children;
                    e && (i.value = e),
                    t.app.getComponent("distancePanel")?.setIsSearching?.(!1)
                }
            }
        }
    }, {
        type: "Search",
        name: "distanceTargetSearch",
        hasPlaceholder: !1,
        options: {
            alwaysOpen: !0,
            magClass: "mag-close",
            searchClass: "search-open",
            config: {
                stopOnExactMatch: !0,
                allowDetail: !1,
                searchType: "distanceTarget",
                maxEntries: 6,
                onSearchFocus: t => {
                    t.eraseInput(),
                    t.app.getComponent("distancePanel")?.setIsSearching?.(!0)
                }
                ,
                onReset: t => {
                    const {defaultText: e} = t._config
                      , {input: i} = t._children;
                    e && (i.value = e),
                    t.app.getComponent("distancePanel")?.setIsSearching?.(!1)
                }
            }
        }
    }, {
        type: "Search",
        name: "cameraFollowSearch",
        hasPlaceholder: !1,
        options: {
            alwaysOpen: !0,
            magClass: "mag-close",
            searchClass: "search-open",
            config: {
                maxSuggestions: 5,
                stopOnExactMatch: !1,
                allowFeatured: !0,
                allowDetail: !1,
                allowInfo: !0,
                searchType: "cameraFollow",
                maxEntries: 6,
                onSearchFocus: t => {
                    t.eraseInput();
                    const e = t.app.getManager("cameraFollow");
                    e.showSearch(),
                    e.setSearchOptions()
                }
            }
        }
    }, {
        type: "Toast",
        name: "toast",
        options: {
            hideDelay: void 0
        }
    }, {
        type: "Menu",
        name: "menu"
    }, {
        type: "FeaturedStoriesPanel",
        name: "featuredStoriesPanel",
        options: {
            isVisible: !0
        }
    }]
}
, function(t, e, i) {
    "use strict";
    i.r(e);
    const s = [{
        groupName: "User Interface",
        isAdvanced: !1,
        items: [{
            name: "Show Interact Prompt on Load",
            description: "When the app is first loading, show an overlay to prompt the user to view and start interacting",
            query: "interactPrompt",
            type: "checkbox",
            inputDefault: !1,
            appQueryDefault: !1
        }, {
            name: "Show Featured Stories/Events",
            description: "Shows the featured stories panel on the left side of the home page",
            query: "featured",
            type: "checkbox",
            inputDefault: !0,
            appQueryDefault: !0
        }]
    }, {
        groupName: "3D",
        isAdvanced: !1,
        items: [{
            name: "Enable Surface Texture Tiling",
            description: "When zooming into 3D spherical surfaces, dynamically loads texture tiles in greater detail. Currently available for Earth/Moon/Mars only",
            query: "surfaceMapTiling",
            type: "checkbox",
            inputDefault: !1,
            appQueryDefault: !1
        }, {
            name: "Enable HD Textures",
            description: "Loads high-definition textures, where available, for 3D entities",
            query: "hd",
            type: "checkbox",
            inputDefault: !1,
            appQueryDefault: !1
        }]
    }, {
        groupName: "Kiosk/Museum Mode",
        isAdvanced: !0,
        items: [{
            name: "Force Restart Session",
            description: "At the end of a session, a forced restart means there is no option to continue the session. Requires a session time greater than zero",
            query: "forceRestart",
            type: "checkbox",
            onChange: t => {
                if (t) {
                    const t = document.getElementById("input-maxSessionTime");
                    "0" === t.value && (t.value = "1",
                    t.dispatchEvent(new Event("change",{
                        bubbles: !0
                    })))
                }
            }
            ,
            inputDefault: !1,
            appQueryDefault: !1
        }, {
            name: "Session Time (minutes)",
            description: "Specifies the maximum duration of an individual session, represented by a countdown clock. A value of zero disables the session time limit",
            query: "maxSessionTime",
            type: "number",
            onChange: t => {
                if ("0" === t) {
                    const t = document.getElementById("input-forceRestart");
                    t.checked = !1,
                    t.dispatchEvent(new Event("change",{
                        bubbles: !0
                    }))
                }
            }
            ,
            values: [0, 1 / 0, .1],
            inputDefault: 0,
            greyValue: 0,
            appQueryDefault: 0
        }, {
            name: "Inactivity Time (minutes)",
            description: "Specifies the time of inactivity before auto-play is triggered. A value of zero disables auto-play",
            query: "maxInactivityTime",
            type: "number",
            values: [0, 1 / 0, .1],
            inputDefault: 0,
            greyValue: 0,
            appQueryDefault: 0
        }]
    }, {
        groupName: "Spout",
        isAdvanced: !0,
        items: [{
            name: "Enable Spout Projection",
            description: "Enables Spout projection onto a 3D sphere with relevant third party software",
            query: "spout",
            type: "checkbox",
            inputDefault: !1,
            appQueryDefault: !1
        }]
    }];
    e.default = s
}
, function(t) {
    "use strict";
    t.exports = JSON.parse('{"limits":{"min":"1949-12-31T00:00:00Z","max":"2049-12-31T00:00:00Z"}}')
}
, function(t) {
    "use strict";
    t.exports = JSON.parse('{"zoomMax":0,"staticEntityGroups":["stars","planets"],"dynamicEntities":["all"],"entityOptions":{"milkyWaySprite":true,"heliosphere":true},"meta":{"titlePrefix":"Eyes on the Solar System","titleSuffix":"NASA/JPL","url":"https://eyes.nasa.gov/apps/solar-system","description":"Eyes on the Solar System lets you explore the planets, their moons, asteroids, comets and the spacecraft exploring them from 1950 to 2050.  You are in control of time and space!  Using real trajectory data you can recreate famous moments in solar system exploration, or preview exciting adventures yet to come."}}')
}
, function(t) {
    "use strict";
    t.exports = JSON.parse('[{"class":"HomeView","name":"home","components":["clock","clockShortcut","settings","menu","layerPanel","breadcrumb","searchDesktop","searchMobile","mobileExpandButton","featuredStoriesPanel","overlay","infoPanel","shareModal","collapsibleMenu","timeControls","kioskMode","kioskSessionClock"]},{"class":"ObjectView","name":"object","components":["clock","clockShortcut","cameraFollowSearch","settings","menu","layerPanel","breadcrumb","searchDesktop","searchMobile","overlay","loadIcon","contentPanel","eventsTimeline","infoPanel","shareModal","collapsibleMenu","timeControls","kioskMode","kioskSessionClock","toast"]},{"class":"StoryView","name":"story","components":["clock","clockShortcut","settings","layerPanel","shareModal","breadcrumb","story","overlay","infoPanel","collapsibleMenu","timeControls","kioskMode","kioskSessionClock","menu"]},{"class":"CompareView","name":"compare","components":["settings","breadcrumb","loadIcon","comparison","infoPanel","shareModal","overlay","kioskMode","kioskSessionClock","menu"]},{"class":"EventView","name":"event","components":["clock","clockShortcut","cameraFollowSearch","settings","menu","layerPanel","breadcrumb","searchDesktop","searchMobile","overlay","loadIcon","contentPanel","eventsTimeline","infoPanel","shareModal","collapsibleMenu","timeControls","kioskMode","kioskSessionClock","toast"]},{"class":"TelescopeView","name":"telescope","components":["menu","telescope","breadcrumb","searchDesktop","searchMobile","overlay","loadIcon","infoPanel","shareModal","kioskMode","kioskSessionClock"]},{"class":"FeatureView","name":"feature","components":["clock","clockShortcut","settings","menu","layerPanel","breadcrumb","searchDesktop","searchMobile","overlay","loadIcon","contentPanel","infoPanel","shareModal","collapsibleMenu","timeControls","kioskMode","kioskSessionClock"]},{"class":"DistanceView","name":"distance","components":["clock","clockShortcut","settings","layerPanel","breadcrumb","distancePanel","distanceSourceSearch","distanceTargetSearch","collapsibleMenu","timeControls","shareModal","kioskMode","kioskSessionClock"]}]')
}
, function(t, e, i) {
    "use strict";
    i.r(e);
    var s = i(741)
      , n = i(746)
      , o = i(887)
      , a = i(888)
      , r = i(889)
      , l = i(1043)
      , c = i(1044)
      , h = i(1045);
    e.default = {
        CompareView: s.CompareView,
        EventView: n.EventView,
        FeatureView: o.FeatureView,
        HomeView: a.HomeView,
        ObjectView: r.ObjectView,
        StoryView: l.StoryView,
        TelescopeView: c.TelescopeView,
        DistanceView: h.DistanceView
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        CompareView: function() {
            return CompareView
        }
    });
    var s = i(742)
      , n = i(1)
      , o = i(745);
    const a = {
        metric: {
            radius: {
                unit: "KM",
                small: {
                    unit: "M",
                    multiplier: n.AppUtils.conversionTable.kmToM
                }
            }
        },
        imperial: {
            radius: {
                unit: "MI",
                multiplier: n.AppUtils.conversionTable.kmToMi,
                small: {
                    unit: "FT",
                    multiplier: n.AppUtils.conversionTable.kmToFt
                }
            }
        }
    };
    class CompareView extends s.default {
        constructor(...t) {
            super(...t),
            this._validQueries.push("id"),
            this._rules.spaceObject = {
                value: t => null !== this._app.getManager("content").getEntityInfo(t)
            },
            this.defaultConfig = null,
            this._category = "",
            this._compare = null,
            this.bindFunctions(["togglePhotoMode"])
        }
        async onEnter(t) {
            await super.onEnter(t),
            this._app.getComponent("menu")?.setEnabled(n.AppUtils.isMobileMode())
        }
        async _updateResources(t) {
            this._app.getManager("layer").setTarget("");
            const e = this._app.getManager("content").getEntityInfo(t.spaceObject);
            this._category = e.category
        }
        async processQuery(t) {
            await super.processQuery(t);
            const {spaceObject: e, id: i} = t;
            let s = o.default;
            this._category && o[this._category] && (s = o[this._category]),
            s = s.filter((t => t !== e));
            const n = i || s[0];
            e !== this._compare && this._app.getComponent("comparison").clearLeftPanelText(e),
            this._compare = e,
            this._compareTo = n,
            this._entityInfo = this._app.getManager("content").getEntityInfo(this._compare),
            this._compareEntityInfo = this._app.getManager("content").getEntityInfo(this._compareTo),
            this._app.getComponent("comparison").clearRightPanelText(n),
            await this._app.getManager("comparison").compare(e, n),
            this._app.getComponent("comparison").setup({
                list: s,
                name: e,
                compare: n,
                unitConverter: a,
                ...t
            })
        }
        async _updateComponents(t) {
            super._updateComponents(t);
            const e = this._app.getManager("router").currentRoute.url.match(/[^/]+/g);
            this._app.getComponent("breadcrumb").onRouteChange({
                ...t,
                routeParts: e
            }),
            this._app.getComponent("settings").toggleLightOptions("flood");
            const i = this._app.getComponent("settings");
            if (i) {
                const t = i.getConfig();
                this.defaultConfig = n.AppUtils.deepCopy(t),
                t.advancedSettings = !1,
                t.allowGuidedCamera = !1,
                t.allowZoom = !0,
                t.allowLayers = !1,
                t.allowInfoPanel = !1,
                t.allowToggleUnit = !0,
                t.allowPhotoMode = !0,
                t.zoomIn = this._app.getManager("comparison").zoomIn,
                t.zoomOut = this._app.getManager("comparison").zoomOut,
                i.setConfig(t)
            }
            this._app.getComponent("settings").getState("isPhotoMode") && this._app.getComponent("settings").togglePhotoMode()
        }
        togglePhotoMode(t) {
            t ? (this._app.getComponent("settings").collapse(),
            this._app.getComponent("comparison").hide()) : this._app.getComponent("comparison").show()
        }
        onLeave(t) {
            super.onLeave(t),
            this._app.getManager("comparison").exit(),
            this._compare = null;
            const e = this._app.getComponent("settings");
            e && this.defaultConfig && (this.defaultConfig.zoomIn = this._app.getManager("camera").zoomIn,
            this.defaultConfig.zoomOut = this._app.getManager("camera").zoomOut,
            e.setConfig(this.defaultConfig))
        }
        resize() {
            super.resize(),
            this._app.getComponent("menu")?.setEnabled(n.AppUtils.isMobileMode())
        }
        registerCallbacks() {
            super.registerCallbacks(),
            this._app.getComponent("settings").registerCallback("photomodechange", this.togglePhotoMode)
        }
        removeCallbacks() {
            super.removeCallbacks(),
            this._app.getComponent("settings").removeCallback("photomodechange", this.togglePhotoMode)
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        default: function() {
            return ExtendedBaseView
        }
    });
    var s = i(1)
      , n = i(743);
    class ExtendedBaseView extends s.BaseView {
        constructor(...t) {
            super(...t),
            this._collapsibleItemOptions = [{
                itemTitle: "Time Controls",
                componentNames: ["timeControls", "clock"],
                positionIndex: 0,
                dimensions: {
                    width: {
                        min: 320,
                        max: 600
                    },
                    height: {
                        min: 0,
                        max: 120,
                        active: 140
                    }
                }
            }],
            this._collapsibleItems = null,
            this._offsetPanel = null,
            this.embedQueries = {
                hd: null,
                surfaceMapTiling: null,
                hideExternalLinks: null,
                hideFullScreenToggle: null,
                kiosk: null
            },
            this.kioskValues = {
                lighting: "flood",
                hideExternalLinks: !0,
                hideFullScreenToggle: !0,
                search: !1
            },
            this.bindFunctions(["setViewportOffset", "_updateCollapsibleMenu", "_loaded"])
        }
        async onEnter(t) {
            this._offsetPanel || this.setViewportOffset(!1);
            const {menu: e, featured: i, noKeyboard: n, search: o, content: a, shareButton: r} = this._app.getManager("router").configs;
            for (const t in this.embedQueries)
                this.embedQueries[t] = this._app.getManager("router").configs[t];
            if (!0 === t.kiosk)
                for (const t in this.kioskValues)
                    this._app.getManager("router").configs[t] = this.kioskValues[t],
                    this.embedQueries[t] = this.kioskValues[t];
            if (!1 === e && (this.disableUIComponent("menu"),
            s.AppUtils.isMobileMode() || this._app.getComponent("searchDesktop")?.show()),
            !1 === i && this.disableUIComponent("featuredStoriesPanel"),
            !0 === n || !1 === o) {
                const t = ["searchDesktop", "searchMobile"];
                for (let e = 0; e < t.length; e++)
                    this.disableUIComponent(t[e])
            }
            !1 === a && this.disableUIComponent("contentPanel"),
            !1 === r && this.disableUIComponent("shareModal"),
            !0 === this.embedQueries.hideExternalLinks && this._app.getManager("content").hideExternalLinkStoryList(),
            this._updateCollapsibleMenu(),
            await super.onEnter(t)
        }
        disableUIComponent(t) {
            const e = this._components.indexOf(t);
            e > -1 && (this._components.splice(e, 1),
            this._app.removeComponent(t))
        }
        async onLeave(t) {
            this._offsetPanel && this.setViewportOffset(!1, !0);
            const e = this._app.getComponent("clockShortcut");
            e.setCallback(null),
            e.hide(),
            await super.onLeave(t)
        }
        registerCallbacks() {
            super.registerCallbacks(),
            this._offsetPanel?.registerCallback("expandtoggle", this.setViewportOffset),
            this._app.getManager("scene").registerCallback("loaded", this._loaded)
        }
        removeCallbacks() {
            super.removeCallbacks(),
            this._offsetPanel?.removeCallback("expandtoggle", this.setViewportOffset),
            this._app.getManager("scene").removeCallback("loaded", this._loaded)
        }
        _reset() {
            super._reset(),
            this._app.getComponent("timeControls")?.setCanUpdate(!1)
        }
        async processQuery(t) {
            await super.processQuery(t)
        }
        async _updateComponents(t) {
            const e = !this._app.getManager("router").configs.locked && this._isSpacecraft && this._scOrderedEvents?.length > 1
              , i = this._components.indexOf("eventsTimeline");
            e && -1 === i ? (this._components.push("eventsTimeline"),
            this.app.getComponent("eventsTimeline").setEnabled(!0)) : !e && i > -1 && this._components.splice(i, 1);
            const s = this.app.getManager("router")
              , {previousView: n, currentView: o} = s
              , {params: a} = s.previousRoute;
            (a?.spaceObject !== t.spaceObject || n !== o) && this._updateCollapsibleMenu(),
            t.spaceObject && !0 === this.embedQueries.hd && this._app.getComponent("contentPanel").onChildParentChange(t.spaceObject, this._app.getManager("content").getEntityInfo(t.spaceObject)),
            this._handleInfoPanelEmbedQueries(t),
            !0 === t.kiosk && this._app.getManager("router").removeConfigs(Object.keys(this.kioskValues));
            if (this._components.includes("timeControls")) {
                const t = this._app.getComponent("timeControls");
                this._collapsibleItems = await Promise.all(this._collapsibleItems).then((t => t.filter((t => t)))),
                this._target ? this._app.scene.getEntity(this._target).getLoadedPromise().then(( () => (t.setCanUpdate(!0),
                !0))).catch((t => {
                    throw t
                }
                )) : t.setCanUpdate(!0)
            }
            await this._app.getComponent("settings").setConfig({
                orientation: {
                    tabletPortrait: {
                        ori: "horizontal"
                    },
                    smallLandscape: {
                        ori: "horizontal"
                    },
                    tabletLandscape: {
                        ori: "horizontal"
                    }
                }
            })
        }
        _loaded(t) {
            n.default.embedLoading && (n.default.updateEmbedLoadPercent(100),
            n.default.showEmbedViewButton())
        }
        _updateLoading(t) {
            super._updateLoading(t);
            const {_isLoading: e} = this._app.getManager("scene");
            e || this._loaded()
        }
        _updateCollapsibleMenu() {
            const t = this._app.getComponent("collapsibleMenu")
              , e = this._components.includes("collapsibleMenu");
            t && (t.removeAllItems(),
            e && (this._collapsibleItems = this._collapsibleItemOptions.map((e => e.componentNames.every((t => this._components.includes(t))) && t.addItem(e)))))
        }
        _handleInfoPanelEmbedQueries(t) {
            if (this._components.includes("infoPanel")) {
                const t = this._app.getComponent("infoPanel");
                if (Object.keys(t._children).length > 0) {
                    const e = t._children;
                    if (e)
                        for (const t in e)
                            !0 === this.embedQueries.hideExternalLinks && e[t].innerHTML?.match(/\/?http[^"]*/) && (e[t].innerHTML = e[t].innerHTML.replace(/\/?http[^"]*/, ""),
                            e[t].innerHTML = e[t].innerHTML.replace("You can also check out this video tutorial.", ""),
                            e[t].innerHTML = e[t].innerHTML.replace('<div class="videoWrapper" style="', '<div class="videoWrapper" style="display: none; ')),
                            !0 === this.embedQueries.hideFullScreenToggle && (e[t].innerHTML = e[t].innerHTML.replace("expand to full screen,", ""))
                }
            }
        }
        _showControls() {
            const t = this._app.getComponent("settings")
              , e = this._app.getComponent("collapsibleMenu");
            this._app.getComponent("clock").show(),
            this._app.getComponent("clockShortcut").show(),
            e.show(),
            t.show(),
            document.getElementById("float-mid-bottom").classList.remove("hidden"),
            document.getElementById("float-mid-bottom").classList.add("active");
            const {embed: i, content: n, locked: o} = this._app.getManager("router").configs;
            if (!1 !== n && s.AppUtils.isMobileMode() ? this._app.getComponent("mobileExpandButton")?.show() : this._app.getComponent("mobileExpandButton")?.hide(),
            i && (t.collapse(),
            e.collapse()),
            o) {
                this._app.getComponent("searchDesktop")?.hide();
                const t = this._app.getComponent("menu");
                t?.hide(),
                t?.setEnabled(!1)
            }
        }
        _hideControls() {
            if (s.AppUtils.isMobileMode()) {
                this._app.getComponent("clock").hide(),
                this._app.getComponent("clockShortcut").hide(),
                this._app.getComponent("collapsibleMenu").hide(),
                this._app.getComponent("settings").hide(),
                document.getElementById("float-mid-bottom").classList.add("hidden"),
                document.getElementById("float-mid-bottom").classList.remove("active");
                const t = this._app.getComponent("eventsTimeline");
                this._app.getComponent("contentPanel")?.getState("isOverlay") && t.hide()
            }
        }
        toggleViewUI() {
            const t = document.getElementById("extended-controls")
              , {visible: e} = this._app.getManager("layer").getLayer("ui")
              , i = ["breadcrumb", "settings", "layerPanel", "kioskMode", "kioskSessionClock"];
            e ? (this._components.forEach((t => {
                "contentPanel" === t ? this._app.getComponent(t).show() : this._app.getComponent(t).setEnabled(!0)
            }
            )),
            t && t.classList.remove("hidden"),
            this.updateVisibility()) : (this._components.forEach((t => {
                i.includes(t) || this._app.getComponent(t).setEnabled(!1),
                "settings" === t && this._app.getComponent(t).collapse(),
                "layerPanel" !== t && "contentPanel" !== t || this._app.getComponent(t).hide()
            }
            )),
            t && t.classList.add("hidden"));
            this.setViewportOffset(e, !0)
        }
        get shouldOffsetRight() {
            return s.AppUtils.isDesktop()
        }
        get shouldOffsetUp() {
            return !s.AppUtils.isDesktop()
        }
        setViewportOffset(t, e=!1) {
            const {visible: i} = this._app.getManager("layer").getLayer("ui");
            let s = this._offsetPanel?.isEnabled() && this._offsetPanel?.getState?.("isVisible");
            null !== this._offsetPanel?.getState?.("isExpanded") && (s = s && this._offsetPanel?.getState?.("isExpanded"));
            const n = e ? s : (t && this._offsetPanel?.getState?.("isExpanded") && i) ?? s
              , o = this.shouldOffsetRight && n
              , a = this.shouldOffsetUp && n;
            document.body.classList.toggle("offset-right", o),
            document.body.classList.toggle("offset-up", a)
        }
        resize() {
            this.setViewportOffset(),
            super.resize()
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e);
    var s = i(744)
      , n = i(719);
    class PreloadManager {
        constructor() {
            if (!PreloadManager.instance) {
                this._isTouch = "ontouchstart"in window || window.navigator.maxTouchPoints > 0,
                this._canHover = !matchMedia("(hover: none)").matches,
                this._embedEl = document.getElementById("embed-overlay"),
                this._loadingScreenEl = document.getElementById("loading-screen"),
                this._storyList = s,
                this._entityInfo = n;
                const t = (window.location.hash.split("#/")[1] ?? "").split("?");
                this._urlParams = new URLSearchParams(t[1]),
                this._hashRoute = t[0],
                this._isEmbed() || this._isInteractPrompt() ? (this._showEmbedScreen(),
                this._loadingScreenEl?.remove()) : (this._showLoadingScreen(),
                this._embedEl?.remove()),
                PreloadManager.instance = this
            }
            return PreloadManager.instance
        }
        _isEmbed() {
            return "true" === this._urlParams.get("embed")
        }
        _isInteractPrompt() {
            return "true" === this._urlParams.get("interactPrompt")
        }
        _showLoadingScreen() {
            if (!this._loadingScreenEl)
                return;
            const t = document.createElement("div");
            t.id = "loading-screen-wrapper",
            this._loadingScreenEl.appendChild(t);
            const e = document.createElement("div");
            e.id = "loading-screen-stars1",
            t.appendChild(e);
            const i = document.createElement("div");
            i.id = "loading-screen-stars2",
            t.appendChild(i);
            const s = document.createElement("div");
            s.id = "loading-screen-logo",
            t.appendChild(s);
            const n = document.createElement("div");
            n.id = "loading-screen-container",
            t.appendChild(n);
            const o = document.createElement("div");
            o.id = "loading-screen-text",
            o.innerText = "Loading",
            n.appendChild(o);
            const a = document.createElement("div");
            a.id = "loading-screen-bar",
            n.appendChild(a);
            let r = "";
            for (let t = 0; t < 8; t++)
                r += `${parseInt(Math.random() * window.innerWidth)}px ${parseInt(Math.random() * window.innerHeight)}px hsl(0deg, 0%, ${parseInt(80 * Math.random()) + 20}%), `;
            document.getElementById("loading-screen-stars1").style.boxShadow = r.slice(0, -2);
            let l = "";
            for (let t = 0; t < 24; t++)
                l += `${parseInt(Math.random() * window.innerWidth)}px ${parseInt(Math.random() * window.innerHeight)}px hsl(0deg, 0%, ${parseInt(80 * Math.random()) + 20}%), `;
            document.getElementById("loading-screen-stars1").style.boxShadow = l.slice(0, -2),
            this._loadingScreenEl.classList.add("show")
        }
        _showEmbedScreen() {
            if (!this._embedEl)
                return;
            const t = document.createElement("div");
            t.className = "embed-wrapper",
            this._embedEl.appendChild(t);
            const e = document.createElement("img");
            e.src = "./assets/svg/embed_interact.svg",
            e.className = "embed-interact",
            t.appendChild(e);
            const i = document.createElement("span");
            i.className = "interact-text",
            i.innerHTML = (this._isTouch ? "touch" : "click") + " & drag<br>to rotate",
            t.appendChild(i);
            const s = document.createElement("button");
            s.className = "clickable view-btn",
            s.innerText = "View 3D",
            t.appendChild(s);
            const n = document.createElement("span");
            n.className = "loader-text";
            const o = this._getTitleFromURL()
              , a = o?.length > 20
              , r = a ? "<br>" : " "
              , l = o && "Home" !== o ? `Loading${r}${o}${r}in 3D` : "Loading 3D";
            a ? n.innerHTML = l : n.innerText = l,
            t.appendChild(n);
            const c = document.createElement("div");
            c.className = "embed-loader",
            t.appendChild(c),
            this._embedEl.classList.add("show", "loading"),
            this._embedEl.offsetWidth,
            this.updateEmbedLoadPercent(10)
        }
        showEmbedInteraction() {
            const t = e => {
                e.preventDefault(),
                this._embedEl.className = "",
                document.removeEventListener("touchstart", t),
                document.removeEventListener("mousedown", t)
            }
            ;
            this._embedEl.classList.remove("view"),
            this._embedEl.classList.add("interact"),
            this._isTouch && document.addEventListener("touchstart", t),
            this._canHover && document.addEventListener("mousedown", t)
        }
        showEmbedViewButton() {
            this._embedEl.classList.remove("loading"),
            this._embedEl.classList.add("view");
            const t = e => {
                e.preventDefault(),
                document.removeEventListener("touchend", t),
                document.removeEventListener("mouseup", t),
                this.showEmbedInteraction()
            }
            ;
            this._isTouch && document.addEventListener("touchend", t),
            this._canHover && document.addEventListener("mouseup", t)
        }
        _getTitleFromURL() {
            if ("home" === this._hashRoute)
                return "Home";
            let t = this._hashRoute;
            const e = "story/"
              , i = "/moons"
              , s = "/telescope"
              , n = "/events"
              , o = "/compare";
            if (this._hashRoute.includes(e)) {
                const t = this._hashRoute.split(e)[1]
                  , i = this._storyList.stories[t]
                  , s = this._urlParams.get("slide")
                  , n = s ? s.replace("slide_", "") : 1;
                if (i?.title && n)
                    return `${i.title} - Slide ${n}`
            }
            if (this._hashRoute.includes(i)) {
                const e = this._hashRoute.split(i)
                  , s = e[1].slice(1)
                  , n = this._getNameFromEntityInfo(s);
                if (n)
                    return n;
                t = e[0];
                const o = this._getNameFromEntityInfo(t);
                if (o)
                    return `${o}'${o.endsWith("s") ? "" : "s"} Moons`
            }
            if (this._hashRoute.includes(s)) {
                t = this._hashRoute.split(s)[0];
                const e = this._getNameFromEntityInfo(t);
                if (e)
                    return `${e} Telescope Mode`
            }
            if (this._hashRoute.includes(n)) {
                const e = this._hashRoute.split(n);
                t = e[0];
                const i = this._getNameFromEntityInfo(t);
                if (i) {
                    return e[1].slice(1) ? `${i} Event` : null
                }
            }
            if (this._hashRoute.includes(o)) {
                t = this._hashRoute.split(o)[0];
                const e = this._getNameFromEntityInfo(t)
                  , i = this._getNameFromEntityInfo(this._urlParams.get("id"));
                if (e)
                    return i ? `${e} compared to ${i}` : `${e} Comparison`
            }
            return this._getNameFromEntityInfo(t) || "Home"
        }
        _getNameFromEntityInfo(t) {
            const {altName: e, displayName: i, iauName: s} = this._entityInfo[t] || {};
            return e || i || s
        }
        hideLoadingScreen() {
            if (!this._loadingScreenEl)
                return;
            this._loadingScreenEl.classList.remove("show");
            this._loadingScreenEl.style.transition = "opacity 0.4s ease-out",
            this._loadingScreenEl.style.opacity = "0",
            setTimeout(( () => {
                this._loadingScreenEl.remove()
            }
            ), 400)
        }
        updateEmbedLoadPercent(t) {
            this._embedEl.style.setProperty("--load-percent", `${t}%`)
        }
        get embedLoading() {
            return this._embedEl?.classList.contains("loading")
        }
    }
    const o = new PreloadManager;
    e.default = {
        hideLoadingScreen: o.hideLoadingScreen.bind(o),
        showEmbedViewButton: o.showEmbedViewButton.bind(o),
        updateEmbedLoadPercent: o.updateEmbedLoadPercent.bind(o),
        get embedLoading() {
            return o.embedLoading
        }
    }
}
, function(t) {
    "use strict";
    t.exports = JSON.parse('{"stories":{"annular_solar_eclipse":{"id":"annular_solar_eclipse","title":"2023 Annular Solar Eclipse","subtitle":"October 14, 2023","icon":"assets/images/cards/annular_eclipse.png"},"total_solar_eclipse":{"id":"total_solar_eclipse","title":"2024 Total Solar Eclipse","subtitle":"April 8, 2024","icon":"assets/images/cards/total_eclipse.png"},"voyager_grand_tour":{"id":"voyager_grand_tour","title":"Voyager\'s Grand Tour","subtitle":"1977 - Today","icon":"assets/images/cards/voyager_story_icon.png"},"enceladus_discovery":{"id":"enceladus_discovery","title":"Discovery at Enceladus","subtitle":"Cassini","icon":"assets/images/cards/enceladus.png"},"psp_perihelion":{"id":"psp_perihelion","title":"Parker Solar Probe Perihelion","subtitle":"Closest Approach to the Sun","icon":"assets/images/cards/psp_perihelion_100.png"}},"external":{"mars2020":{"id":"mars2020","title":"Entry, Descent, and Landing","subtitle":"Perseverance","link":"https://eyes.nasa.gov/apps/mars2020/","icon":"assets/images/cards/perseverance.png"},"asteroids_missions":{"id":"asteroids_missions","title":"Asteroid and Comet Missions","subtitle":"Eyes on Asteroids","link":"https://eyes.nasa.gov/apps/asteroids/#/story/asteroids_missions","icon":"assets/images/cards/asteroid.png"},"experience_curiosity":{"id":"experience_curiosity","title":"Experience Curiosity","subtitle":"Interactive","link":"https://eyes.nasa.gov/curiosity/","icon":"assets/images/cards/curiosity.png"},"experience_insight":{"id":"experience_insight","title":"Experience Insight","subtitle":"Interactive","link":"https://eyes.nasa.gov/apps/experience-insight/InSight.html","icon":"assets/images/cards/insight.png"}},"internal":{"psp_perihelion":{"id":"psp_perihelion","title":"Parker Solar Probe Perihelion","subtitle":"December 24th, 2024","internal":true,"link":"sc_parker_solar_probe?rate=1&time=2024-12-24T11:27:38.887+00:00","icon":"assets/images/cards/psp_perihelion_100.png"},"prefire_launch":{"id":"prefire_launch","title":"PREFIRE Cubesats Launched","subtitle":"May/June 2024","internal":true,"link":"sc_prefire_1","icon":"assets/images/cards/prefire_ad.png"},"clipper_launch":{"id":"clipper_launch","title":"Europa Clipper Launch","subtitle":"Mission Launch October 14th, 2024","internal":true,"link":"sc_europa_clipper","icon":"assets/images/cards/clipper_icon.png"},"clipper_mars_assist":{"id":"clipper_mars_assist","title":"Europa Clipper Mars Gravity Assist","subtitle":"Mars Flyby on March 1st, 2025","internal":true,"link":"sc_europa_clipper/events/mars_flyby?rate=120&time=2025-03-01T17:10:05.000+00:00","icon":"assets/images/cards/clipper_icon.png"},"artemis":{"id":"artemis","title":"Artemis I","subtitle":"Fly Along Live!","internal":true,"link":"sc_artemis_1","icon":"assets/images/cards/artemis_icon.png"},"dinkinesh":{"id":"dinkinesh","title":"Lucy\'s First Asteroid Flyby","subtitle":"November 1, 2023","internal":true,"link":"sc_lucy/events/lucy_dinkinesh_flyby?time=2023-11-01T16:54:45.000+00:00","icon":"assets/images/cards/lucy_dinki.png"},"donaldjohanson":{"id":"donaldjohanson","title":"Lucy\'s Second Asteroid Flyby","subtitle":"April 20th, 2025","internal":true,"link":"sc_lucy/events/lucy_donaldjohanson_flyby?time=2025-04-20T17:51:00.000+00:00","icon":"assets/images/cards/lucy_dinki.png"},"comet_3i_mars_flyby":{"id":"comet_3i_mars_flyby","title":"Comet 3I/ATLAS Mars Flyby","subtitle":"October 3rd, 2025","internal":true,"link":"c_2025_n1/events/mars_flyby?rate=3000&time=2025-10-03T03:59:09.564+00:00","icon":"assets/images/cards/event_3i_atlas.webp"},"ORX_SRC":{"id":"ORX_SRC","title":"OSIRIS-REx Sample Return Capsule","subtitle":"Return to Earth September 24, 2023","internal":true,"link":"sc_osiris_rex_src","icon":"assets/images/cards/ORX_SRC_v2.png"},"spherex_launch":{"id":"spherex_launch","title":"SPHEREx Launch","subtitle":"Mission Launch March 11th, 2025","internal":true,"link":"sc_spherex","icon":"assets/images/cards/spherex_100.png"},"nisar_launch":{"id":"nisar_launch","title":"NISAR Mission","subtitle":"Mission Launch July 30th, 2025","internal":true,"link":"sc_nisar","icon":"assets/images/cards/nisar_100.png"},"imap_launch":{"id":"imap_launch","title":"IMAP Mission","subtitle":"Mission Launch September 24th, 2025","internal":true,"link":"sc_imap","icon":"assets/images/cards/imap_launch_100.webp"},"psyche_launch":{"id":"psyche_launch","title":"Psyche Launch","subtitle":"Mission Launch October 13, 2023","internal":true,"link":"sc_psyche","icon":"assets/images/cards/psyche_outline.png"}},"featured":["comet_3i_mars_flyby","imap_launch","nisar_launch","psp_perihelion"]}')
}
, function(t) {
    "use strict";
    t.exports = JSON.parse('{"Planet":["mercury","venus","earth","sun","moon","mars","1_ceres","jupiter","saturn","uranus","neptune","134340_pluto"],"Moon":["mercury","moon","phobos","1_ceres","io","europa","ganymede","callisto","enceladus","titan","134340_pluto"],"Asteroid":["101955_bennu","16_psyche","433_eros","4_vesta","1p_halley","67p_churyumov_gerasimenko","81p_wild_2","9p_tempel_1","c_1995_o1"],"Comet":["101955_bennu","16_psyche","433_eros","4_vesta","1p_halley","67p_churyumov_gerasimenko","81p_wild_2","9p_tempel_1","c_1995_o1"],"DwarfPlanet":["earth","moon","1_ceres","io","europa","titan","134340_pluto","136472_makemake","136108_haumea","136199_eris"],"Spacecraft":["sc_hubble_space_telescope","sc_jwst","scientist","school_bus","rose_bowl","sc_parker_solar_probe","sc_osiris_rex","sc_juno","sc_new_horizons","sc_voyager_1"],"default":["sun","mercury","venus","earth","moon","mars","4_vesta","jupiter","saturn","uranus","neptune","134340_pluto"]}')
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        EventView: function() {
            return EventView
        }
    });
    var s = i(1)
      , n = i(742)
      , o = i(747)
      , a = i.n(o);
    class EventView extends n.default {
        constructor(...t) {
            super(...t),
            this._rules.spaceObject = {
                value: t => null !== this._app.getManager("content").getEntityInfo(t)
            },
            this._entityInfo = null,
            this._entityDesc = null,
            this._scEvents = null,
            this._scOrderedEvents = null,
            this._eventName = null,
            this._eventInfo = null,
            this._eventDesc = null,
            this._isSpacecraft = !0,
            this._hasLoaded = !1,
            this._onLoaded = null,
            this._onAfter = null,
            this.bindFunctions(["_backToLive"])
        }
        async onEnter(t) {
            this._app.getComponent("clockShortcut").setCallback(this._backToLive),
            this._offsetPanel = this._app.getComponent("contentPanel"),
            await super.onEnter(t)
        }
        async onLeave(t) {
            this._app.getManager("layer").toggleLayer("heliosphere", {
                parentId: "sun"
            }, !1),
            this.app.getManager("cameraFollow").setEnabled(!1, {
                resetCam: !1,
                resetLimits: !1,
                removeQueries: !1
            }),
            await super.onLeave(t),
            this._app.getComponent("timeControls")._cMenuParent.setExpanded(!0)
        }
        async onQueryChange(t) {
            await super.onQueryChange(t);
            const e = this._app.getComponent("contentPanel");
            await e.onQueryChange(t)
        }
        registerCallbacks() {
            super.registerCallbacks();
            const t = this._app.getComponent("contentPanel");
            t && (t.registerCallback("visiblechange", this.updateVisibility),
            t.registerCallback("expandtoggle", this.updateVisibility),
            t.registerCallback("overlay", this.updateVisibility))
        }
        removeCallbacks() {
            super.removeCallbacks();
            const t = this._app.getComponent("contentPanel");
            t && (t.removeCallback("visiblechange", this.updateVisibility),
            t.removeCallback("expandtoggle", this.updateVisibility),
            t.removeCallback("overlay", this.updateVisibility))
        }
        _reset(t) {
            super._reset(t),
            this._entityInfo = null,
            this._entityDesc = null,
            this._scEvents = null,
            this._scOrderedEvents = null,
            this._eventName = null,
            this._eventInfo = null,
            this._eventDesc = null,
            this._hasLoaded = !1,
            this._onLoaded = null,
            this._target = t.spaceObject
        }
        async _updateResources(t) {
            if (this._app.getManager("layer").setTarget(this._target),
            this._app.getManager("selection").selectEntity(this._target),
            this._entityInfo = this._app.getManager("content").getEntityInfo(this._target),
            null === this._entityInfo)
                return void this._handleError(`EventView._updateResources: Cannot find entity named ${this._target}.`);
            if (this._app.getManager("content").resetContext(),
            this._hasLoaded = !1,
            await this._app.getManager("content").loadEvents(this._target, {
                all: "all_events"
            }),
            t.cancelToken.isCanceled)
                return;
            if (null === this._app.getManager("content").context.events)
                return void this._handleError(`EventView._updateResources: Cannot find events list of ${this._target}.`);
            if (this._scEvents = s.AppUtils.deepCopy(this._app.getManager("content").context.events),
            null !== this._app.getManager("content").context.orderedEvents && (this._scOrderedEvents = s.AppUtils.deepCopy(this._app.getManager("content").context.orderedEvents)),
            await this._app.getManager("content").loadDescriptions([this._target]),
            t.cancelToken.isCanceled)
                return;
            if (null !== this._app.getManager("content").context[this._target] && (this._entityDesc = s.AppUtils.deepCopy(this._app.getManager("content").context[this._target])),
            void 0 !== t.child) {
                if (void 0 === this._scEvents[t.child])
                    return this._eventName = null,
                    void this._handleError(`EventView._updateResources: Cannot find event named ${t.child}.`);
                this._eventName = t.child,
                this._eventInfo = this._scEvents[this._eventName]
            } else
                this._eventName = null,
                this._eventInfo = null;
            if (null !== this._eventName) {
                if (await this._app.getManager("content").loadEvents(this._target, {
                    event: this._eventName
                }),
                t.cancelToken.isCanceled)
                    return;
                null !== this._app.getManager("content").context.eventDesc && (this._eventDesc = s.AppUtils.deepCopy(this._app.getManager("content").context.eventDesc))
            } else
                this._eventDesc = null;
            const e = this._eventDesc?.target || this._eventInfo?.target
              , i = this.app.getManager("scene")
              , {followId: n} = t
              , o = [];
            this._eventDesc?.related && o.push(...this._eventDesc.related),
            e && o.push(e),
            null !== this._target && o.push(this._target),
            n && o.push(n);
            const a = [...new Set(o)];
            i.setEntitiesForceVisible(a, !1)
        }
        async _updateComponents(t) {
            await super._updateComponents(t);
            const e = this._app.getManager("router")
              , i = e.currentRoute.url.match(/[^/]+/g);
            this._app.getComponent("breadcrumb").onRouteChange({
                ...t,
                routeParts: i.filter((t => "events" !== t))
            }),
            this._app.getManager("layer").toggleLayer("heliosphere", {
                parentId: "sun"
            }, !1);
            const s = this._app.getComponent("contentPanel");
            if (s) {
                const e = !0 === t.embed || !1 === t.detailPanel;
                this._eventName && await s.onRouteChangeEvent(this._target, this._eventName, this._eventInfo, this._eventDesc, this._scOrderedEvents, t.cancelToken, i),
                s.show(),
                e && s.collapse()
            }
            if (this._app.getComponent("timeControls")._cMenuParent.setExpanded(!1),
            t.cancelToken.isCanceled)
                return;
            this._collapsibleItems = await Promise.all(this._collapsibleItems).then((t => t.filter((t => t))));
            const n = this._collapsibleItems.find((t => "Events Timeline" === t.getState("itemTitle")));
            e.previousRoute.params?.spaceObject !== this._target && n?.hide();
            const {id: o, iauName: a, displayName: r} = this._entityInfo
              , {dates: l} = this._entityDesc
              , c = {
                id: o,
                title: a || r,
                dates: l,
                orderedEvents: this._scOrderedEvents
            };
            this._onLoaded = () => {
                const t = this._app.getComponent("eventsTimeline");
                t.setTarget(c),
                t.resize(),
                n?.show()
            }
            ,
            this._hasLoaded && (this._onLoaded(),
            this._onLoaded = null)
        }
        async _updateTimeForTarget(t, e=!0) {
            const {start: i, end: s} = this._eventInfo || {}
              , n = !i || !s;
            await super._updateTimeForTarget(t, n);
            const o = this._app.getManager("time")
              , r = this._app.getManager("router")
              , {setTimeLimits: l} = t
              , c = this._eventInfo?.rate || this._eventDesc?.rate
              , h = (r.previousRoute.query?.includes("followId"),
            o.getTime())
              , {min: d, max: u} = this._app.getManager("scene").getCoverage(this._target);
            this._eventInfo && (i || (this._eventInfo.start = d),
            s || (this._eventInfo.end = u));
            const p = i || d.toISOString()
              , m = s || u.toISOString()
              , [_,g] = [p && a()(p), m && a()(m)];
            _ && g && this._setMinEventEnd(_, g);
            const y = void 0 === t.rate
              , f = void 0 === t.time
              , b = y && f
              , T = h.valueOf() === g?.valueOf()
              , v = !b && 0 === t.rate && a()(t.time).valueOf() === h.valueOf()
              , S = _ && (b || g && h.isAfter(g) || _ && h.isBefore(_) || T && t.rate > 0)
              , E = void 0 !== c && (y || S);
            l && (_ && o.setMin(_),
            g && o.setMax(g));
            let C = o.parseTime(t.time);
            const x = o.isWithinLimits(C)
              , w = -1 === x || 1 === x;
            if (C?.isValid() || (C = o.parseTime(_),
            o.setTime(C)),
            w) {
                const t = `/${this._target}`;
                let e = o.getTimeUrl(C)
                  , i = 1
                  , s = "time outside event limits";
                const {min: n, max: a} = this._app.getManager("scene").getCoverage(this._target);
                C.isAfter(a) ? (e = o.getTimeUrl(a),
                i = 0,
                s = "time exceeds mission end") : C.isBefore(n) && (e = o.getTimeUrl(n),
                s = "time preceeds mission start");
                const l = {
                    rate: i,
                    time: e
                };
                return o.setMin(n ?? o.getDefaultLimits().min),
                o.setMax(a ?? o.getDefaultLimits().max),
                this._app.getComponent("clock")?.setLimitMessage(x, s),
                void await r.navigate(l, t)
            }
            v || !E && !S || (this._onAfter = () => {
                r.reroute(r.currentRoute.url, {
                    ...E && {
                        rate: c
                    },
                    ...S && {
                        time: o.getTimeUrl(_)
                    }
                })
            }
            )
        }
        _setMinEventEnd(t, e) {
            const i = Math.abs(e.valueOf() - t.valueOf());
            if (i < 6e4) {
                const t = 6e4 - i;
                e.add(t, "ms")
            }
        }
        _loaded(t) {
            super._loaded(t),
            "function" == typeof this._onLoaded && this._onLoaded(),
            this._onLoaded = null,
            this._hasLoaded = !0
        }
        _backToLive() {
            const t = this._app.getManager("time")
              , e = t.getTimeUrl(t.getNow());
            this._app.getManager("router").navigate({
                time: e,
                rate: 1
            })
        }
        replayEvent(t=!0) {
            const e = this._app.getManager("router")
              , i = this._app.getManager("time")
              , n = i.getTime()
              , o = "followId"in e.query;
            if (t && "event" === e.currentView && !o) {
                const {params: t} = e.lastRouteResolved();
                this._updateCamera({
                    ...t
                })
            }
            const {min: a} = i.timeLimits
              , r = n.valueOf() === a.valueOf()
              , l = {
                rate: "event" === e.currentView ? this._eventInfo?.rate ?? this._eventDesc?.rate ?? 1 : 1,
                ...a && !r && {
                    time: i.getTimeUrl(a)
                }
            };
            s.AppUtils.deepEqual(e.query, l) ? e.reload() : e.navigate(l)
        }
        async _updateCamera(t) {
            const e = {
                ...this._eventDesc,
                ...this._eventInfo
            }
              , {target: i, related: s} = e
              , {followId: n} = this._app.getManager("router").query;
            if (n)
                return;
            if (this._app.getManager("content").hasLanded(this._entityInfo))
                await this._app.cameraScripts.alignSpacecraftPlanet(this._target);
            else if (i) {
                const {duration: t, distance: s, horizontalOffset: n, verticalOffset: o} = e;
                await this._app.cameraScripts.alignObjects(this._target, i, {
                    duration: t,
                    distance: s,
                    horizontalOffset: n,
                    verticalOffset: o
                })
            } else
                await this._app.cameraScripts.goToSpacecraft(this._target);
            this.app.getManager("scene").setEntitiesForceVisible([...s || [], ...n ? [n] : [], ...i ? [i] : [], ...null !== this._target ? [this._target] : []], !0)
        }
        _shouldHideControls() {
            const t = this._app.getComponent("contentPanel")?.getState("isVisible")
              , e = this._app.getComponent("contentPanel")?.getState("isExpanded");
            return s.AppUtils.isMobileMode() && t && e
        }
        after() {
            "function" == typeof this._onAfter && this._onAfter(),
            this._onAfter = null
        }
    }
}
, , , , function(t, e, i) {
    var s = {
        "./af": 751,
        "./af.js": 751,
        "./ar": 752,
        "./ar-dz": 753,
        "./ar-dz.js": 753,
        "./ar-kw": 754,
        "./ar-kw.js": 754,
        "./ar-ly": 755,
        "./ar-ly.js": 755,
        "./ar-ma": 756,
        "./ar-ma.js": 756,
        "./ar-sa": 757,
        "./ar-sa.js": 757,
        "./ar-tn": 758,
        "./ar-tn.js": 758,
        "./ar.js": 752,
        "./az": 759,
        "./az.js": 759,
        "./be": 760,
        "./be.js": 760,
        "./bg": 761,
        "./bg.js": 761,
        "./bm": 762,
        "./bm.js": 762,
        "./bn": 763,
        "./bn-bd": 764,
        "./bn-bd.js": 764,
        "./bn.js": 763,
        "./bo": 765,
        "./bo.js": 765,
        "./br": 766,
        "./br.js": 766,
        "./bs": 767,
        "./bs.js": 767,
        "./ca": 768,
        "./ca.js": 768,
        "./cs": 769,
        "./cs.js": 769,
        "./cv": 770,
        "./cv.js": 770,
        "./cy": 771,
        "./cy.js": 771,
        "./da": 772,
        "./da.js": 772,
        "./de": 773,
        "./de-at": 774,
        "./de-at.js": 774,
        "./de-ch": 775,
        "./de-ch.js": 775,
        "./de.js": 773,
        "./dv": 776,
        "./dv.js": 776,
        "./el": 777,
        "./el.js": 777,
        "./en-au": 778,
        "./en-au.js": 778,
        "./en-ca": 779,
        "./en-ca.js": 779,
        "./en-gb": 780,
        "./en-gb.js": 780,
        "./en-ie": 781,
        "./en-ie.js": 781,
        "./en-il": 782,
        "./en-il.js": 782,
        "./en-in": 783,
        "./en-in.js": 783,
        "./en-nz": 784,
        "./en-nz.js": 784,
        "./en-sg": 785,
        "./en-sg.js": 785,
        "./eo": 786,
        "./eo.js": 786,
        "./es": 787,
        "./es-do": 788,
        "./es-do.js": 788,
        "./es-mx": 789,
        "./es-mx.js": 789,
        "./es-us": 790,
        "./es-us.js": 790,
        "./es.js": 787,
        "./et": 791,
        "./et.js": 791,
        "./eu": 792,
        "./eu.js": 792,
        "./fa": 793,
        "./fa.js": 793,
        "./fi": 794,
        "./fi.js": 794,
        "./fil": 795,
        "./fil.js": 795,
        "./fo": 796,
        "./fo.js": 796,
        "./fr": 797,
        "./fr-ca": 798,
        "./fr-ca.js": 798,
        "./fr-ch": 799,
        "./fr-ch.js": 799,
        "./fr.js": 797,
        "./fy": 800,
        "./fy.js": 800,
        "./ga": 801,
        "./ga.js": 801,
        "./gd": 802,
        "./gd.js": 802,
        "./gl": 803,
        "./gl.js": 803,
        "./gom-deva": 804,
        "./gom-deva.js": 804,
        "./gom-latn": 805,
        "./gom-latn.js": 805,
        "./gu": 806,
        "./gu.js": 806,
        "./he": 807,
        "./he.js": 807,
        "./hi": 808,
        "./hi.js": 808,
        "./hr": 809,
        "./hr.js": 809,
        "./hu": 810,
        "./hu.js": 810,
        "./hy-am": 811,
        "./hy-am.js": 811,
        "./id": 812,
        "./id.js": 812,
        "./is": 813,
        "./is.js": 813,
        "./it": 814,
        "./it-ch": 815,
        "./it-ch.js": 815,
        "./it.js": 814,
        "./ja": 816,
        "./ja.js": 816,
        "./jv": 817,
        "./jv.js": 817,
        "./ka": 818,
        "./ka.js": 818,
        "./kk": 819,
        "./kk.js": 819,
        "./km": 820,
        "./km.js": 820,
        "./kn": 821,
        "./kn.js": 821,
        "./ko": 822,
        "./ko.js": 822,
        "./ku": 823,
        "./ku.js": 823,
        "./ky": 824,
        "./ky.js": 824,
        "./lb": 825,
        "./lb.js": 825,
        "./lo": 826,
        "./lo.js": 826,
        "./lt": 827,
        "./lt.js": 827,
        "./lv": 828,
        "./lv.js": 828,
        "./me": 829,
        "./me.js": 829,
        "./mi": 830,
        "./mi.js": 830,
        "./mk": 831,
        "./mk.js": 831,
        "./ml": 832,
        "./ml.js": 832,
        "./mn": 833,
        "./mn.js": 833,
        "./mr": 834,
        "./mr.js": 834,
        "./ms": 835,
        "./ms-my": 836,
        "./ms-my.js": 836,
        "./ms.js": 835,
        "./mt": 837,
        "./mt.js": 837,
        "./my": 838,
        "./my.js": 838,
        "./nb": 839,
        "./nb.js": 839,
        "./ne": 840,
        "./ne.js": 840,
        "./nl": 841,
        "./nl-be": 842,
        "./nl-be.js": 842,
        "./nl.js": 841,
        "./nn": 843,
        "./nn.js": 843,
        "./oc-lnc": 844,
        "./oc-lnc.js": 844,
        "./pa-in": 845,
        "./pa-in.js": 845,
        "./pl": 846,
        "./pl.js": 846,
        "./pt": 847,
        "./pt-br": 848,
        "./pt-br.js": 848,
        "./pt.js": 847,
        "./ro": 849,
        "./ro.js": 849,
        "./ru": 850,
        "./ru.js": 850,
        "./sd": 851,
        "./sd.js": 851,
        "./se": 852,
        "./se.js": 852,
        "./si": 853,
        "./si.js": 853,
        "./sk": 854,
        "./sk.js": 854,
        "./sl": 855,
        "./sl.js": 855,
        "./sq": 856,
        "./sq.js": 856,
        "./sr": 857,
        "./sr-cyrl": 858,
        "./sr-cyrl.js": 858,
        "./sr.js": 857,
        "./ss": 859,
        "./ss.js": 859,
        "./sv": 860,
        "./sv.js": 860,
        "./sw": 861,
        "./sw.js": 861,
        "./ta": 862,
        "./ta.js": 862,
        "./te": 863,
        "./te.js": 863,
        "./tet": 864,
        "./tet.js": 864,
        "./tg": 865,
        "./tg.js": 865,
        "./th": 866,
        "./th.js": 866,
        "./tk": 867,
        "./tk.js": 867,
        "./tl-ph": 868,
        "./tl-ph.js": 868,
        "./tlh": 869,
        "./tlh.js": 869,
        "./tr": 870,
        "./tr.js": 870,
        "./tzl": 871,
        "./tzl.js": 871,
        "./tzm": 872,
        "./tzm-latn": 873,
        "./tzm-latn.js": 873,
        "./tzm.js": 872,
        "./ug-cn": 874,
        "./ug-cn.js": 874,
        "./uk": 875,
        "./uk.js": 875,
        "./ur": 876,
        "./ur.js": 876,
        "./uz": 877,
        "./uz-latn": 878,
        "./uz-latn.js": 878,
        "./uz.js": 877,
        "./vi": 879,
        "./vi.js": 879,
        "./x-pseudo": 880,
        "./x-pseudo.js": 880,
        "./yo": 881,
        "./yo.js": 881,
        "./zh-cn": 882,
        "./zh-cn.js": 882,
        "./zh-hk": 883,
        "./zh-hk.js": 883,
        "./zh-mo": 884,
        "./zh-mo.js": 884,
        "./zh-tw": 885,
        "./zh-tw.js": 885
    };
    function n(t) {
        var e = o(t);
        return i(e)
    }
    function o(t) {
        if (!i.o(s, t)) {
            var e = new Error("Cannot find module '" + t + "'");
            throw e.code = "MODULE_NOT_FOUND",
            e
        }
        return s[t]
    }
    n.keys = function() {
        return Object.keys(s)
    }
    ,
    n.resolve = o,
    t.exports = n,
    n.id = 750
}
, , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        FeatureView: function() {
            return FeatureView
        }
    });
    var s = i(1)
      , n = i(742);
    class FeatureView extends n.default {
        constructor(...t) {
            super(...t),
            this._rules.spaceObject = {
                value: t => null !== this._app.getManager("content").getEntityInfo(t)
            },
            this._rules.feature = {
                value: t => {
                    const e = this._app.getManager("router").currentRoute.params.spaceObject
                      , i = this._app.getManager("content").getEntityInfo(e);
                    return !("moons" === t && !i.hasMoons)
                }
            },
            this._entityInfo = null,
            this._entityDesc = null,
            this._featureDesc = null,
            this._featureInfo = {},
            this._forceLoadEntities = []
        }
        async onEnter(t) {
            const e = this._app.getComponent("contentPanel");
            this._offsetPanel = e,
            await super.onEnter(t, e?.components)
        }
        registerCallbacks() {
            super.registerCallbacks();
            const t = this._app.getComponent("contentPanel");
            t && (t.registerCallback("visiblechange", this.updateVisibility),
            t.registerCallback("expandtoggle", this.updateVisibility),
            t.registerCallback("overlay", this.updateVisibility))
        }
        removeCallbacks() {
            super.removeCallbacks();
            const t = this._app.getComponent("contentPanel");
            t && (t.removeCallback("visiblechange", this.updateVisibility),
            t.removeCallback("expandtoggle", this.updateVisibility),
            t.removeCallback("overlay", this.updateVisibility))
        }
        _reset(t) {
            super._reset(t),
            this._entityInfo = null,
            this._entityDesc = null,
            this._featureDesc = null,
            this._featureInfo = {},
            this._forceLoadEntities = [],
            this._target = t.spaceObject
        }
        async _updateResources(t) {
            const e = this._app.getManager("content").getEntityList();
            if (this._entityInfo = this._app.getManager("content").getEntityInfo(this._target),
            null === this._entityInfo)
                return void this._handleError(`FeatureView._updateResources: Cannot find entity named ${this._target}.`);
            this._app.getManager("content").resetContext();
            const i = this.app.getManager("scene");
            switch (null !== this._target && this._forceLoadEntities.push(this._target),
            this._app.cameraScripts.isBarycenter(this._target) && this._forceLoadEntities.push(this._app.cameraScripts.removeBarycenter(this._target)),
            i.setEntitiesForceVisible(this._forceLoadEntities, !1),
            await this._app.scene.waitTillEntitiesInPlace(this._forceLoadEntities),
            this._app.getManager("layer").setTarget(this._target),
            this._app.getManager("selection").selectEntity(this._target),
            t.feature) {
            case "moons":
                {
                    const t = await this._app.getManager("content").getEntityDesc(this._target);
                    let i = [];
                    if (null !== t && (i = t.featuredMoons,
                    i && i.length > 0)) {
                        i = i.filter((t => t in e));
                        const t = i.map((t => {
                            const e = this._app.getManager("content").getEntityInfo(t);
                            return {
                                title: e.displayName || e.iauName,
                                url: `${this._app.getManager("router").currentRoute.url}/${t}`
                            }
                        }
                        ))
                          , s = 5
                          , n = t.length > s ? s : t.length;
                        this._featureInfo = {
                            initial: t.slice(0, n),
                            more: n === s ? t.slice(n) : []
                        }
                    }
                    break
                }
            default:
                return void this._handleError(`FeatureView._updateResources: Unrecognized feature - ${t.feature}.`)
            }
            if (this._featureInfo.initial && 0 === this._featureInfo.initial.length)
                return void this._handleError(`FeatureView._updateResources: No data to display for ${this._target}'s ${t.feature}.`);
            const n = `${this._target}_${t.feature}`;
            await this._app.getManager("content").loadDescriptions([this._target, n]),
            t.cancelToken.isCanceled || (null !== this._app.getManager("content").context[this._target] && (this._entityDesc = s.AppUtils.deepCopy(this._app.getManager("content").context[this._target])),
            this._featureDesc = this._app.getManager("content").context[n] ? s.AppUtils.deepCopy(this._app.getManager("content").context[n]) : {
                title: `${this._entityInfo.displayName || this._entityInfo.iauName}'s ${t.feature}`
            })
        }
        async _updateComponents(t) {
            super._updateComponents(t);
            const e = this._app.getManager("router").currentRoute.url.match(/[^/]+/g);
            this._app.getComponent("breadcrumb").onRouteChange({
                ...t,
                routeParts: e
            });
            const i = this._app.getComponent("contentPanel");
            if (i) {
                const s = !0 === t.embed || !1 === t.detailPanel;
                await i.onRouteChangeFeature(this._target, this._entityInfo, this._featureInfo, this._featureDesc, t.cancelToken, e),
                i.show(),
                s && i.collapse()
            }
        }
        async _updateCamera(t) {
            this._app.getComponent("contentPanel")?.isEnabled() || await this._app.cameraScripts.goToSystem(this._target);
            this.app.getManager("scene").setEntitiesForceVisible(this._forceLoadEntities, !0)
        }
        _shouldHideControls() {
            const t = this._app.getComponent("contentPanel")?.getState("isVisible")
              , e = this._app.getComponent("contentPanel")?.getState("isExpanded");
            return s.AppUtils.isMobileMode() && t && e
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        HomeView: function() {
            return HomeView
        }
    });
    var s = i(1)
      , n = i(742);
    class HomeView extends n.default {
        async onEnter(t) {
            const e = this._app.getComponent("featuredStoriesPanel");
            this._offsetPanel = e;
            const i = e?.components ?? [];
            await super.onEnter(t, i)
        }
        registerCallbacks() {
            super.registerCallbacks(),
            this._app.getComponent("featuredStoriesPanel")?.registerCallback("visiblechange", this.updateVisibility)
        }
        removeCallbacks() {
            super.removeCallbacks(),
            this._app.getComponent("featuredStoriesPanel")?.removeCallback("visiblechange", this.updateVisibility)
        }
        async _updateResources(t) {
            this.app.getManager("scene").setEntitiesForceVisible(null !== this._target ? [this._target] : [], !1),
            this._app.getManager("time").resetLimits(),
            this._app.getManager("layer").setTarget("");
            const e = s.AppUtils.deepCopy(this._app.getManager("content").getStoryList());
            this._featuredCardsList = [],
            e.featured.forEach((t => {
                void 0 !== e.stories[t] ? this._featuredCardsList.push(e.stories[t]) : e.external && void 0 !== e.external[t] ? (e.external[t].isExternal = !0,
                this._featuredCardsList.push(e.external[t])) : void 0 !== e.internal[t] && (e.internal[t].isInternal = !0,
                this._featuredCardsList.push(e.internal[t]))
            }
            ))
        }
        async _updateComponents(t) {
            super._updateComponents(t);
            const {embed: e, locked: i} = this._app.getManager("router").configs
              , s = this._app.getComponent("featuredStoriesPanel");
            s && (!i && null !== this._featuredCardsList && this._featuredCardsList.length > 0 ? (await s.onRouteChange(t, this._featuredCardsList),
            e ? s.hide() : s.show()) : (s.hide(),
            s.setEnabled(!1)),
            await (this._app.getComponent("mobileExpandButton")?.showCPButton(!0, "featuredStoriesPanel"))),
            await (this._app.getComponent("breadcrumb")?.onRouteChange(t))
        }
        async _updateCamera(t) {
            await this._app.cameraScripts.goToSystem("inner_solar_system");
            this.app.getManager("scene").setEntitiesForceVisible(null !== this._target ? [this._target] : ["c_2025_n1"], !0)
        }
        _shouldHideControls() {
            return s.AppUtils.isMobileMode() && this._app.getComponent("featuredStoriesPanel")?.getState("isVisible")
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        ObjectView: function() {
            return ObjectView
        }
    });
    var s = i(5)
      , n = i(1)
      , o = (i(890),
    i(742));
    class ObjectView extends o.default {
        constructor(...t) {
            super(...t),
            this._rules.spaceObject = {
                value: t => null !== this._app.getManager("content").getEntityInfo(t)
            },
            this._entityInfo = null,
            this._entityDesc = null,
            this._scEvents = null,
            this._featuredCardsList = null,
            this._isSpacecraft = !1,
            this._forceLoadEntities = [],
            this._hasLoaded = null,
            this._onLoaded = [],
            this._onAfter = null,
            this.bindFunctions(["onParentChanged", "onChildChanged", "getCurrentTarget"])
        }
        async onEnter(t) {
            const e = this._app.getComponent("contentPanel");
            this._offsetPanel = e,
            await super.onEnter(t, e?.components)
        }
        async onLeave(t) {
            this._app.getManager("layer").toggleLayer("heliosphere", {
                parentId: "sun"
            }, !1);
            const e = this._app.getManager("scene").get("main").getEntity(this._target);
            null !== e && (e.removeParentChangedCallback(this.onParentChanged),
            e.removeChildChangedCallback(this.onChildChanged)),
            this.app.getManager("cameraFollow").setEnabled(!1, {
                resetCam: !1,
                resetLimits: !1,
                removeQueries: !1
            }),
            await super.onLeave(t)
        }
        async onRouteChange(t) {
            const e = this._app.getManager("scene");
            if (null !== this._target) {
                const t = e.get("main").getEntity(this._target);
                null !== t && (t.removeParentChangedCallback(this.onParentChanged),
                t.removeChildChangedCallback(this.onChildChanged))
            }
            this._app.getManager("layer").toggleLayer("heliosphere", {
                parentId: "sun"
            }, !1);
            if ("Moon" === this._app.getManager("content").getEntityInfo(t.spaceObject).category) {
                const e = this._app.getManager("scene").getParent(t.spaceObject);
                if (null !== e) {
                    const i = "/" + e + "/moons/" + t.spaceObject;
                    if (void 0 !== this._app.getManager("router").query.time) {
                        const t = {
                            time: this._app.getManager("time").getTimeUrl(),
                            rate: this._app.getManager("time").getTimeRate()
                        };
                        this._app.getManager("router").reroute(i, t)
                    } else
                        this._app.getManager("router").reroute(i)
                }
            }
            super.onRouteChange(t)
        }
        async onQueryChange(t) {
            await super.onQueryChange(t);
            this._app.getComponent("contentPanel").onQueryChange(t)
        }
        registerCallbacks() {
            super.registerCallbacks();
            const t = this._app.getComponent("contentPanel");
            t && (t.registerCallback("visiblechange", this.updateVisibility),
            t.registerCallback("expandtoggle", this.updateVisibility),
            t.registerCallback("overlay", this.updateVisibility))
        }
        removeCallbacks() {
            super.removeCallbacks();
            const t = this._app.getComponent("contentPanel");
            t && (t.removeCallback("visiblechange", this.updateVisibility),
            t.removeCallback("expandtoggle", this.updateVisibility),
            t.removeCallback("overlay", this.updateVisibility))
        }
        _reset(t) {
            super._reset(t),
            this._entityDesc = null,
            this._scEvents = null,
            this._featuredCardsList = null,
            this._scOrderedEvents = null,
            this._isSpacecraft = !1,
            this._forceLoadEntities = [],
            this._hasLoaded = null,
            this._onLoaded = [],
            this._target = "moons" === t.feature && t.child ? t.child : t.spaceObject
        }
        async _updateResources(t) {
            const e = this._app.getManager("content")
              , i = this.app.getManager("scene")
              , s = this._app.getManager("layer");
            if (this._entityInfo = e.getEntityInfo(this._target),
            null === this._entityInfo)
                return void this._handleError(`ObjectView._updateResources: Cannot find entity named ${this._target}.`);
            e.resetContext(),
            null !== this._target && this._forceLoadEntities.push(this._target),
            this._app.cameraScripts.isBarycenter(this._target) && this._forceLoadEntities.push(this._app.cameraScripts.removeBarycenter(this._target));
            const {followId: o} = t;
            o && this._forceLoadEntities.push(o);
            const a = [...new Set(this._forceLoadEntities)];
            i.setEntitiesForceVisible(a, !1),
            await this._app.scene.waitTillEntitiesInPlace(this._forceLoadEntities),
            s.setTarget(this._target),
            this._app.getManager("selection").selectEntity(this._target);
            if ("spacecraft" === this._entityInfo.category.toLowerCase() && (this._isSpacecraft = !0,
            this._hasLoaded = !1),
            this._entityInfo.hasEvents) {
                try {
                    await e.loadEvents(this._target, {
                        all: "all_events"
                    })
                } catch (t) {
                    console.error("ObjectView._updateResources:", t)
                }
                if (t.cancelToken.isCanceled)
                    return;
                null !== e.context.events && (this._scEvents = n.AppUtils.deepCopy(e.context.events)),
                null !== e.context.orderedEvents && (this._scOrderedEvents = n.AppUtils.deepCopy(e.context.orderedEvents))
            }
            if (await e.loadDescriptions([this._target]),
            t.cancelToken.isCanceled)
                return;
            null !== e.context[this._target] && (this._entityDesc = n.AppUtils.deepCopy(e.context[this._target]));
            let r = null;
            if (null !== this._entityDesc && (r = this._entityDesc.cards),
            null != r) {
                const t = n.AppUtils.deepCopy(e.getStoryList());
                this._featuredCardsList = [];
                for (let e = 0; e < r.length; e++) {
                    const i = r[e].storyId;
                    void 0 !== t.stories[i] ? this._featuredCardsList.push(t.stories[i]) : t.external && void 0 !== t.external[i] && (t.external[i].isExternal = !0,
                    this._featuredCardsList.push(t.external[i]))
                }
            }
        }
        getCurrentTarget() {
            return this._target
        }
        async onChildChanged(t, e) {
            if (null === e.getComponent(s.CameraComponent) && null !== this._target) {
                const t = this._app.getComponent("contentPanel")
                  , i = "Instrument" === (this._app.getManager("content").getEntityInfo(e)?.category || "")
                  , {followId: s} = this._app.getManager("router").query;
                !t || i || s || await t.onChildParentChange(this._target, this._entityInfo, !0)
            }
        }
        async onParentChanged(t, e, i) {
            if (null !== this._target) {
                const t = this._app.getManager("layer")
                  , s = null !== e ? e.getName() : ""
                  , n = null !== i ? i.getName() : "";
                t.resetContextualLayers(n, s);
                const o = this._app.getComponent("contentPanel");
                o && await o.onChildParentChange(this._target, this._entityInfo, !0),
                this._updateCamera({
                    oldParent: s,
                    newParent: n
                })
            }
        }
        async _updateComponents(t) {
            super._updateComponents(t);
            const e = this._app.getManager("router")
              , i = e.currentRoute.url.match(/[^/]+/g);
            this._app.getComponent("breadcrumb").onRouteChange({
                ...t,
                routeParts: i
            });
            if (this._components.includes("eventsTimeline")) {
                this._collapsibleItems = await Promise.all(this._collapsibleItems).then((t => t.filter((t => t))));
                const t = this._collapsibleItems.find((t => "Events Timeline" === t.getState("itemTitle")));
                e.previousRoute.params?.spaceObject !== this._target && t?.hide();
                const {id: i, iauName: s, displayName: n} = this._entityInfo
                  , {dates: o} = this._entityDesc
                  , a = {
                    id: i,
                    title: s || n,
                    dates: o,
                    orderedEvents: this._scOrderedEvents
                };
                if (this._onLoaded.push(( () => {
                    const e = this._app.getComponent("eventsTimeline");
                    e.setTarget(a),
                    e.resize(),
                    t?.show()
                }
                )),
                this._hasLoaded) {
                    for (let t = 0; t < this._onLoaded.length; t++)
                        this._onLoaded[t]();
                    this._onLoaded = []
                }
            }
            if (null !== this._target) {
                const e = this._app.getComponent("contentPanel");
                if (e) {
                    const s = !0 === t.embed || !1 === t.detailPanel
                      , n = this._entityDesc?.title || this._entityInfo.displayName || this._entityInfo.iauName;
                    e.clearPanel(n),
                    await e.onRouteChangeObject(this._target, this._entityInfo, this._entityDesc, this._scEvents, this._featuredCardsList, t.cancelToken, i),
                    this._onLoaded.push((async n => {
                        t.cancelToken && t.cancelToken.isCanceled && n !== this.getCurrentTarget() || (await e.onRouteChangeObjectLoaded(this._target, this._entityInfo, this._entityDesc, this._scEvents, this._featuredCardsList, t, i),
                        e.show(),
                        s && !e.getState("isCollapsed") && e.collapse())
                    }
                    ))
                }
                const s = this._app.getManager("scene").get("main").getEntity(this._target);
                s.addParentChangedCallback(this.onParentChanged),
                s.addChildChangedCallback(this.onChildChanged)
            }
        }
        async _updateTimeForTarget(t) {
            t.setTimeLimits = !0;
            let e = !1;
            t.rate && Math.abs(t.rate) < 60 && (e = !0),
            await super._updateTimeForTarget(t, e);
            const i = this._app.getManager("time")
              , s = this._app.getManager("router")
              , n = i.parseTime(t.time)
              , o = i.isWithinLimits(n);
            if (0 !== o) {
                const {min: t, max: e} = i.timeLimits;
                let n;
                1 === o && e ? n = i.getTimeUrl(e) : -1 === o && t && (n = i.getTimeUrl(t)),
                n && (this._app.getComponent("clock")?.setLimitMessage(o),
                this._onAfter = () => {
                    s.reroute(s.currentRoute.url, {
                        time: n
                    })
                }
                )
            }
        }
        async _updateCamera(t) {
            const e = this._entityInfo.category.toLowerCase()
              , {cameraScripts: i} = this._app
              , s = this._app.getManager("content").hasLanded(this._entityInfo)
              , n = this._app.getComponent("contentPanel");
            void 0 !== t?.oldParent ? await this._updateCameraOnParentChange(t) : n?.isEnabled() || ("spacecraft" === e ? s ? await i.alignSpacecraftPlanet(this._target) : await i.goToSpacecraft(this._target) : "landing site" === e ? await i.alignSpacecraftPlanet(this._target) : "goToInstrument" === e ? await i.goToInstrument(this._target) : await i.goToCelestialObject(this._target));
            this.app.getManager("scene").setEntitiesForceVisible(this._forceLoadEntities, !0)
        }
        async _updateCameraOnParentChange(t) {}
        _loaded(t) {
            super._loaded(t);
            for (let e = 0; e < this._onLoaded.length; e++)
                this._onLoaded[e](t);
            this._onLoaded = [],
            this._hasLoaded = !0
        }
        _shouldHideControls() {
            const t = this._app.getComponent("contentPanel")?.getState("isVisible")
              , e = this._app.getComponent("contentPanel")?.getState("isExpanded");
            return n.AppUtils.isMobileMode() && t && e
        }
        after() {
            "function" == typeof this._onAfter && this._onAfter(),
            this._onAfter = null
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        AppVersion: function() {
            return s.version
        },
        SolarSystemApp: function() {
            return n.SolarSystemApp
        },
        TimeManager: function() {
            return o.TimeManager
        },
        LinkManager: function() {
            return a.LinkManager
        },
        LabelManager: function() {
            return r.LabelManager
        },
        SelectionManager: function() {
            return l.SelectionManager
        },
        MobileExpandButton: function() {
            return c.MobileExpandButton
        },
        Menu: function() {
            return h.Menu
        },
        BaseContentBlock: function() {
            return d.BaseContentBlock
        },
        OptionsBlock: function() {
            return u.OptionsBlock
        },
        FeaturedStoryBlock: function() {
            return p.FeaturedStoryBlock
        },
        EventsBlock: function() {
            return m.EventsBlock
        },
        OverviewBlock: function() {
            return _.OverviewBlock
        },
        DescriptionBlock: function() {
            return g.DescriptionBlock
        },
        FeaturedMoonsBlock: function() {
            return y.FeaturedMoonsBlock
        },
        FeaturedEventsBlock: function() {
            return f.FeaturedEventsBlock
        },
        ExplorationBlock: function() {
            return b.ExplorationBlock
        },
        ToolboxBlock: function() {
            return T.ToolboxBlock
        },
        CameraViewBlock: function() {
            return v.CameraViewBlock
        },
        SpecialFeaturesBlock: function() {
            return S.SpecialFeaturesBlock
        },
        ReplayBlock: function() {
            return E.ReplayBlock
        },
        LayersBlock: function() {
            return C.LayersBlock
        },
        InstrumentFOVBlock: function() {
            return x.InstrumentFOVBlock
        },
        SurfaceMapBlock: function() {
            return w.SurfaceMapBlock
        },
        TextureQualityBlock: function() {
            return I.TextureQualityBlock
        },
        FeaturesBlock: function() {
            return M.FeaturesBlock
        },
        RelatedBlock: function() {
            return A.RelatedBlock
        },
        ContentPanel: function() {
            return N.ContentPanel
        },
        FeaturedStoriesPanel: function() {
            return L.FeaturedStoriesPanel
        },
        Comparison: function() {
            return k.Comparison
        },
        InfoPanel: function() {
            return V.InfoPanel
        },
        DistancePanel: function() {
            return R.DistancePanel
        },
        EventsTimeline: function() {
            return P.EventsTimeline
        },
        CollapsibleMenu: function() {
            return O.CollapsibleMenu
        },
        CollapsibleMenuItem: function() {
            return F.CollapsibleMenuItem
        },
        TimeControls: function() {
            return U.TimeControls
        },
        Telescope: function() {
            return D.Telescope
        },
        Search: function() {
            return z.Search
        },
        KioskMode: function() {
            return j.KioskMode
        },
        Settings: function() {
            return B.Settings
        },
        Types: function() {
            return H.Types
        }
    });
    var s = i(891)
      , n = i(0)
      , o = i(892)
      , a = i(893)
      , r = i(894)
      , l = i(895)
      , c = i(896)
      , h = i(955)
      , d = i(959)
      , u = i(961)
      , p = i(963)
      , m = i(966)
      , _ = i(969)
      , g = i(972)
      , y = i(975)
      , f = i(977)
      , b = i(979)
      , T = i(981)
      , v = i(984)
      , S = i(987)
      , E = i(990)
      , C = i(993)
      , x = i(995)
      , w = i(998)
      , I = i(1e3)
      , M = i(1003)
      , A = i(1005)
      , N = i(1008)
      , L = i(1011)
      , k = i(1014)
      , V = i(1017)
      , R = i(1020)
      , P = i(1023)
      , O = i(1026)
      , F = i(1029)
      , U = i(1032)
      , D = i(1035)
      , z = i(1039)
      , j = i(1040)
      , B = i(1041)
      , H = i(1042)
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        version: function() {
            return s
        }
    });
    const s = "1.7.2"
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        TimeManager: function() {
            return TimeManager
        }
    });
    var s = i(1);
    class TimeManager extends s.TimeManager {
        _onLimitReach(t) {
            const e = this._app.getManager("time")
              , i = this._timeLimits[t];
            this.app.getComponent("timecontrolsCollapsible")?.setExpanded(!0);
            const s = "min" === t ? i.add(1, "ms") : i.subtract(1, "ms")
              , n = "max" === t ? 1 : -1;
            this._app.getComponent("clock")?.setLimitMessage(n),
            this.app.getView("distance")._redirect = !0,
            this._app.getManager("router")?.navigate({
                rate: 0,
                time: e.getTimeUrl(s)
            })
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        LinkManager: function() {
            return LinkManager
        }
    });
    var s = i(1);
    class LinkManager extends s.BaseManager {
        getParsedLink(t, e) {
            const i = this._app.getManager("router")
              , s = t.startsWith("/") ? t.slice(1) : t
              , {currentView: n} = i
              , {params: o} = i.currentRoute || {}
              , a = {
                path: `/${s}`
            };
            if ("event" === n) {
                const t = o?.spaceObject !== s;
                a.options = t ? {
                    __remove: "all"
                } : {
                    keepTime: !0
                }
            }
            const {isEnabled: r} = this.app.getManager("cameraFollow") || {}
              , l = "desktop" !== e && r;
            return r && (a.options = {
                __remove: "all"
            }),
            "distanceSource" === e ? a.path = `${a.path}/distance` : "distanceTarget" === e || "distance" === n ? (delete a.path,
            a.query = {
                to: s
            }) : l && (delete a.path,
            delete a.options,
            a.query = {
                followId: s
            }),
            a
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        LabelManager: function() {
            return LabelManager
        }
    });
    var s = i(1);
    class LabelManager extends s.LabelManager {
        _getLink(t) {
            const e = super._getLink(t);
            return this._app.getManager("link")?.getParsedLink?.(e) || e
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        SelectionManager: function() {
            return SelectionManager
        }
    });
    var s = i(1);
    class SelectionManager extends s.SelectionManager {
        _getLink(t) {
            const e = super._getLink(t);
            return this._app.getManager("link")?.getParsedLink?.(e) || e
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        MobileExpandButton: function() {
            return MobileExpandButton
        }
    });
    var s = i(1)
      , n = (i(897),
    i(900))
      , o = i(898)
      , a = i.n(o);
    i(899);
    class MobileExpandButton extends s.BaseComponent {
        constructor(t) {
            super(t),
            this._component = "",
            this._expandButtonClicked = this._expandButtonClicked.bind(this),
            this.showCPButton = this.showCPButton.bind(this),
            n.default.setDefaultProps({
                theme: "default",
                touch: ["hold", 2e3],
                delay: [600, null],
                plugins: [n.followCursor]
            })
        }
        init() {
            super.init(),
            (0,
            n.default)(this._children.mobileExpandButton, {
                content: "Expand content panel.",
                placement: "top"
            })
        }
        _expandButtonClicked() {
            this._app.getComponent(this._component).onClickShowCollapse(),
            this.hide()
        }
        showCPButton(t, e) {
            s.AppUtils.isMobileMode() || (t = !1),
            this._component = e;
            const i = t ? "" : "hidden";
            this.setState({
                isVisibleClass: i
            })
        }
    }
    MobileExpandButton.html = a()
}
, , function(t) {
    t.exports = '<button key="mobileExpandButton" class="mobile-expand-button button clickable icon icon-expand {{isVisibleClass}}" onclick="_expandButtonClicked" data-tippy-content="Expand content panel." aria-label="Expand content panel"></button>\n'
}
, function(t, e, i) {
    "use strict";
    i.r(e)
}
, , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        Menu: function() {
            return Menu
        }
    });
    i(956);
    var s = i(1)
      , n = i(957)
      , o = i.n(n);
    i(958);
    class Menu extends s.BaseComponent {
        constructor(t, e={}) {
            super(t, null, {
                isVisible: !1,
                menuClass: "",
                menuText: "",
                titleText: "",
                brandingText: "EYES ON THE SOLAR SYSTEM",
                currentInfo: null,
                ...e
            }),
            this._backFunction = null,
            this._categories = ["stories", "planets", "asteroids", "comets", "spacecraft"],
            this._listMenuContainer = {},
            this._listMenu = {},
            this._aToZMenu = {};
            for (let t = 0; t < this._categories.length; t++) {
                const e = this._categories[t];
                this._listMenuContainer[e] = null,
                this._listMenu[e] = null,
                this._aToZMenu[e] = null
            }
            this.bindFunctions(["clickOnEntry", "handleBackButton", "_goToMain", "_goToList", "_goToAtoZ"]),
            this._scrollbar = null
        }
        handleBackButton() {
            this._backFunction()
        }
        init() {
            super.init(),
            this._children.backButton = s.AppUtils.htmlToElement('\n\t\t\t<div class="branding clickable" onclick="handleBackButton">\n\t\t\t\t<span class="icon icon-lesser clickable"></span>\n\t\t\t\t<label class="text clickable">Back</label>\n\t\t\t</div>\n\t\t'),
            this._setEventHandlersFromAttributes(this._children.backButton),
            this.resize()
        }
        resize() {
            if (super.resize(),
            s.AppUtils.isMobileMode()) {
                this.setState({
                    menuText: ""
                });
                for (const t in this._listMenuContainer) {
                    const e = this._listMenuContainer[t]
                      , i = this._listMenu[t];
                    null !== e && e.contains(i) && e.removeChild(i)
                }
                "a-to-z" === this._state.menuClass && (this._backFunction = this._goToList)
            } else {
                this.setState({
                    menuText: "Menu"
                });
                for (const t in this._listMenuContainer) {
                    const e = this._listMenuContainer[t]
                      , i = this._listMenu[t];
                    null === e || e.contains(i) || e.appendChild(i)
                }
                "a-to-z" === this._state.menuClass && (this._backFunction = this._goToMain),
                "list" === this._state.menuClass && this.getState("isVisible") && this._goToMain()
            }
        }
        setupAtoZ(t) {
            const e = ["0-9", "a-f", "g-k", "l-p", "q-u", "v-z"].map((e => {
                const i = t.entries.filter((t => ( (t, e) => {
                    const i = t.subtitle ? t.subtitle + ": " + t.title : t.title
                      , s = t.displayName || t.iauName || i;
                    return e.test(s)
                }
                )(t, new RegExp(`^[${e}]`,"i"))));
                return {
                    entries: i.sort(( (t, e) => {
                        const i = t.subtitle ? t.subtitle + ": " + t.title : t.title
                          , s = e.subtitle ? e.subtitle + ": " + e.title : e.title;
                        let n = t.displayName || t.iauName || i
                          , o = e.displayName || e.iauName || s;
                        return n = String(n).toLowerCase(),
                        o = String(o).toLowerCase(),
                        n < o ? -1 : n > o ? 1 : 0
                    }
                    )),
                    title: e
                }
            }
            ))
              , i = document.createElement("h5");
            i.className = "semi",
            i.innerText = t.name;
            const s = document.createElement("span");
            s.className = "icon icon-close clickable close-button",
            s.addEventListener("click", this.hide, !1);
            const n = document.createElement("div");
            n.className = "menu-content";
            for (let t = 0; t < e.length; t++)
                if (e[t] && e[t].entries && e[t].entries.length > 0) {
                    const i = document.createElement("div");
                    i.className = "block";
                    const s = document.createElement("div");
                    s.className = "small semi title",
                    s.innerText = e[t].title,
                    i.appendChild(s);
                    const o = document.createElement("div");
                    o.className = "list-container",
                    i.appendChild(o);
                    for (let i = 0; i < e[t].entries.length; i++) {
                        const s = e[t].entries[i]
                          , n = document.createElement("button");
                        n.className = "small clickable entry-label";
                        const a = s.subtitle ? s.subtitle + ": " : ""
                          , r = s.displayName || s.iauName || a + s.title;
                        if (s.icon) {
                            n.classList.add("with-thumb");
                            const t = document.createElement("img");
                            t.src = s.icon,
                            t.classList.add("entry-image-all");
                            const e = document.createElement("span");
                            if (e.className = "entry-image-label",
                            e.innerText = r,
                            s.link) {
                                const t = document.createElement("span");
                                t.className = "icon icon-external",
                                e.appendChild(t)
                            }
                            n.appendChild(t),
                            n.appendChild(e)
                        } else
                            n.innerText = r;
                        n.addEventListener("click", ( () => {
                            this.clickOnEntry(s)
                        }
                        ), {
                            passive: !1
                        }),
                        o.appendChild(n)
                    }
                    n.appendChild(i)
                }
            const o = document.createElement("div");
            o.className = "container",
            o.appendChild(n),
            this._aToZMenu[t.id] = o
        }
        _goToMain() {
            this.setState({
                titleText: "",
                menuClass: "main"
            }),
            null !== this._scrollbar && (this._scrollbar.destroy(),
            this._scrollbar = null),
            this._children.header.replaceChild(this._children.branding, this._children.header.firstChild),
            this._children.contentWrapper.lastChild ? this._children.contentWrapper.replaceChild(this._children.mainMenu, this._children.contentWrapper.lastChild) : this._children.contentWrapper.appendChild(this._children.mainMenu),
            s.AppUtils.isMobileMode() && this._children.mainMenu?.firstChild !== this._app.getComponent("searchMobile")?.element && this._children.mainMenu.prepend(this._app.getComponent("searchMobile")?.element),
            this.getState("isVisible") && this._initScrollbar()
        }
        _goToList() {
            this._backFunction = this._goToMain;
            const {currentInfo: t} = this._state;
            this.setState({
                titleText: t.name,
                menuClass: "list"
            }),
            null !== this._scrollbar && (this._scrollbar.destroy(),
            this._scrollbar = null),
            this._children.header.replaceChild(this._children.backButton, this._children.header.firstChild),
            this._children.contentWrapper.replaceChild(this._listMenu[t.id], this._children.contentWrapper.lastChild),
            this.getState("isVisible") && this._initScrollbar()
        }
        _goToAtoZ() {
            this._backFunction = s.AppUtils.isMobileMode() ? this._goToList : this._goToMain;
            const {currentInfo: t} = this._state;
            this.setState({
                titleText: t.name,
                menuClass: "a-to-z"
            }),
            null !== this._scrollbar && (this._scrollbar.destroy(),
            this._scrollbar = null),
            this._children.header.replaceChild(this._children.backButton, this._children.header.firstChild),
            this._children.contentWrapper.replaceChild(this._aToZMenu[t.id], this._children.contentWrapper.lastChild),
            this.getState("isVisible") && this._initScrollbar()
        }
        clickOnEntry(t) {
            if (this.hide(),
            t && t.id)
                if (t.link)
                    t.internal ? this._app.getManager("router").navigate(t.link) : window.open(t.link);
                else if (t.title) {
                    const e = "story/" + t.id;
                    this._app.getManager("router").navigate(e)
                } else
                    this._app.getManager("router").navigate("/" + t.id)
        }
        _initScrollbar() {
            null === this._scrollbar ? this._scrollbar = s.AppUtils.addScrollbar(this._children.contentWrapper) : this._scrollbar.scroll(0)
        }
        show() {
            super.show(),
            this._goToMain()
        }
        hide() {
            null !== this._scrollbar && (this._scrollbar.destroy(),
            this._scrollbar = null),
            super.hide()
        }
        updateMenuContent() {
            const t = this._app.getManager("content")
              , e = ["134340_pluto", "101955_bennu", "dimorphos", "16_psyche", "4_vesta"]
              , i = [];
            for (let s = 0; s < e.length; s++)
                i.push(t.getEntityInfo(e[s]));
            const s = ["c_2025_n1", "1p_halley", "9p_tempel_1", "67p_churyumov_gerasimenko", "103p_hartley_2"]
              , n = [];
            for (let e = 0; e < s.length; e++)
                n.push(t.getEntityInfo(s[e]));
            const o = ["sc_europa_clipper", "sc_nisar", "sc_psyche", "sc_lucy", "sc_swot", "sc_voyager_1", "sc_artemis_1", "sc_iss", "sc_jwst"]
              , a = [];
            for (let e = 0; e < o.length; e++)
                a.push(t.getEntityInfo(o[e]));
            const {hideExternalLinks: r} = this._app.getManager("router").configs
              , l = []
              , c = t.getStoryList();
            for (let t = 0; t < c.featured.length; t++)
                c.stories[c.featured[t]] ? l.push(c.stories[c.featured[t]]) : !r && c.external[c.featured[t]] ? l.push(c.external[c.featured[t]]) : c.internal[c.featured[t]] ? l.push(c.internal[c.featured[t]]) : console.error(`Story not found id:${c.featured[t]}`);
            const h = [];
            Object.keys(c.stories).forEach((t => {
                h.push(c.stories[t])
            }
            )),
            !r && Object.keys(c.external).forEach((t => {
                h.push(c.external[t])
            }
            ));
            const d = {
                stories: h,
                ...t.entitiesByCategory
            }
              , u = ["mercury", "venus", "earth", "mars", "jupiter", "saturn", "uranus", "neptune"]
              , p = [];
            for (let e = 0; e < u.length; e++)
                p.push(t.getEntityInfo(u[e]));
            this.setupContent(d, l, p, i, n, a),
            this._app.getComponent("searchMobile")?.registerCallback("resultselected", this.hide)
        }
        async setupContent(t, e, i, n, o, a) {
            this._contentInfo = t,
            this._children.mainMenu.innerHTML = "";
            const r = [{
                id: "stories",
                name: "Stories",
                max: 5,
                featuredEntries: [...e],
                entries: [...this._contentInfo.stories || []]
            }, {
                id: "planets",
                name: "Planets & Moons",
                max: 5,
                featuredEntries: [...i],
                entries: [...this._contentInfo.Moon || [], ...this._contentInfo.Planet || []]
            }, {
                id: "asteroids",
                name: "Dwarf Planets & Asteroids",
                max: 5,
                featuredEntries: [...n || []],
                entries: [...this._contentInfo.Asteroid || [], ...this._contentInfo["Dwarf Planet"] || []]
            }, {
                id: "comets",
                name: "Comets",
                max: 5,
                featuredEntries: [...o || []],
                entries: [...this._contentInfo.Comet || []]
            }, {
                id: "spacecraft",
                name: "Spacecraft",
                max: 5,
                featuredEntries: [...a || []],
                entries: [...this._contentInfo.Spacecraft || [], ...this._contentInfo.Instrument || []]
            }]
              , l = document.createElement("div");
            l.className = "menu-content";
            for (let t = 0; t < r.length; t++)
                if (r[t] && r[t].entries && r[t].entries.length > 0) {
                    const e = document.createElement("div");
                    e.className = "block",
                    e.addEventListener("click", ( () => {
                        s.AppUtils.isMobileMode() && (this.setState({
                            currentInfo: r[t]
                        }),
                        this._goToList())
                    }
                    ), !1);
                    const i = document.createElement("div");
                    i.className = "list-container",
                    this._listMenu[r[t].id] = i,
                    this._listMenuContainer[r[t].id] = e;
                    const n = document.createElement("button");
                    n.className = "small semi title",
                    n.innerText = r[t].name,
                    e.appendChild(n),
                    e.appendChild(i);
                    const o = document.createElement("span");
                    if (o.className = "icon icon-greater clickable expand",
                    e.appendChild(o),
                    void 0 !== r[t].featuredEntries) {
                        const e = document.createElement("div");
                        e.className = "entry-container featured";
                        for (let i = 0; i < r[t].featuredEntries.length; i++) {
                            const s = r[t].featuredEntries[i]
                              , n = document.createElement("div");
                            if (n.classList.add("link-container"),
                            s.icon) {
                                const t = document.createElement("img");
                                t.src = s.icon,
                                t.classList.add("entry-image"),
                                n.appendChild(t)
                            }
                            const o = document.createElement("span")
                              , a = s.subtitle ? s.subtitle + ": " : "";
                            if (o.className = "small clickable entry-label",
                            o.innerText = s.displayName || s.iauName || a + s.title,
                            o.addEventListener("click", ( () => {
                                this.clickOnEntry(s)
                            }
                            ), !1),
                            s.link && !s.internal) {
                                const t = document.createElement("span");
                                t.className = "icon icon-external",
                                o.appendChild(t)
                            }
                            n.appendChild(o),
                            e.appendChild(n)
                        }
                        i.appendChild(e)
                    } else {
                        const e = r[t].max ? Math.min(r[t].entries.length, r[t].max) : r[t].entries.length
                          , s = document.createElement("div");
                        s.className = "entry-container";
                        for (let i = 0; i < e; i++) {
                            const e = r[t].entries[i]
                              , n = document.createElement("div");
                            n.className = "small clickable entry-label",
                            n.innerText = e.displayName || e.iauName,
                            n.addEventListener("click", ( () => {
                                this.clickOnEntry(e)
                            }
                            ), !1),
                            s.appendChild(n)
                        }
                        i.appendChild(s)
                    }
                    const a = document.createElement("div");
                    a.className = "az-link-container clickable",
                    a.addEventListener("click", ( () => {
                        this.setState({
                            currentInfo: r[t]
                        }),
                        this._goToAtoZ()
                    }
                    ), !1);
                    const c = document.createElement("button");
                    c.className = "small clickable az-link",
                    c.innerHTML = `View <strong>${r[t].entries.length}</strong> ${r[t].name}`,
                    a.appendChild(c);
                    const h = document.createElement("span");
                    o.className = "icon icon-greater clickable expand",
                    a.appendChild(h),
                    i.appendChild(a),
                    l.appendChild(e),
                    this.setupAtoZ(r[t])
                }
            const c = this._app.getComponent("searchMobile");
            c && this._children.mainMenu.appendChild(c?.element),
            c?.setParent(this._children.mainMenu),
            this._children.mainMenu.appendChild(l);
            const h = new CustomEvent("setupSearch");
            window.dispatchEvent(h),
            this.resize(),
            this._goToMain()
        }
    }
    Menu.html = o()
}
, , function(t) {
    t.exports = '<nav class="mega-menu">\n\t<button class="menu-btn clickable" onclick="toggle">\n\t\t<span class="icon icon-menu"></span>\n\t\t{{menuText}}\n\t</button>\n\t<div class="overlay-bg clickable {{isVisibleClass}}" onclick="hide"></div>\n\t<div key="container" class="menu-container {{menuClass}} {{isVisibleClass}} scrollable">\n\t\t<div key="header" class="menu-header">\n\t\t\t<div key="branding" class="branding">\n\t\t\t\t<span class="icon icon-nasa-logo clickable" onclick="hide"></span>\n\t\t\t\t<span class="semi clickable app-title" onclick="hide">{{brandingText}}</span>\n\t\t\t</div>\n\t\t\t<h5 class="semi">{{titleText}}</h5>\n\t\t\t<span class="icon icon-close clickable close-button" onclick="hide"></span>\n\t\t</div>\n\t\t<div key="contentWrapper" class="content-wrapper">\n\t\t\t<div key="mainMenu" class="main-menu"></div>\n\t\t</div>\n\t</div>\n</nav>\n'
}
, function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        BaseContentBlock: function() {
            return BaseContentBlock
        }
    });
    var s = i(1);
    i(960);
    class BaseContentBlock extends s.BaseComponent {
        constructor(t, e, i={}) {
            super(t, e, {
                isVisible: !0,
                isMoreVisible: !1,
                hideMoreMessage: "",
                ...i
            }),
            this._more = {
                isVisible: {
                    moreMessage: "Show Less",
                    moreIcon: "icon-minus",
                    moreClass: ""
                },
                isHidden: {
                    moreMessage: "Show More",
                    moreIcon: "icon-plus",
                    moreClass: "hidden"
                }
            },
            Object.assign(this._state, this._more.isHidden)
        }
        async init() {
            super.init(),
            this._element.classList.add("content-block", "{{isVisibleClass}}"),
            this._setVariables(this._element)
        }
        showMore() {
            this.setState({
                isMoreVisible: !0,
                ...this._more.isVisible
            })
        }
        hideMore() {
            this.setState({
                isMoreVisible: !1,
                ...this._more.isHidden
            })
        }
        toggleMore() {
            this._state.isMoreVisible ? this.hideMore() : this.showMore()
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        OptionsBlock: function() {
            return OptionsBlock
        }
    });
    var s = i(1)
      , n = i(890);
    i(962);
    class OptionsBlock extends n.BaseContentBlock {
        constructor(t, e={}) {
            super(t, null, {
                isVisible: !0,
                title: "",
                subtitle: "",
                ...e
            }),
            this._state = {
                ...this._state,
                isVisibleClass: this._class.isVisible[this._state.isVisible]
            },
            Object.assign(this._class, {
                isVisible: {
                    true: "",
                    false: "hidden"
                }
            }),
            this._previousEntity = null,
            this._previousChildEntity = void 0
        }
        onRouteChange(t, e={}) {}
        _createCheckbox(t, e) {
            const i = new s.Checkbox(this._app,{
                config: {
                    key: t.id,
                    function: t.function
                },
                isChecked: e,
                text: t.text()
            });
            return i.init(),
            i
        }
        _createMultistateCheckbox(t, e, i) {
            const n = new s.CheckboxMultistate(this._app,{
                config: {
                    key: t.id,
                    function: t.function
                },
                stateIndex: i,
                text: t.text()
            });
            return n.init(),
            n.setNumStates(e),
            n
        }
        _createRadioButton(t) {
            const {id: e, title: i} = t
              , s = document.createElement("li");
            s.className = "option radio-option clickable";
            const n = `${e}-radio-button`
              , o = document.createElement("label");
            o.innerText = i,
            o.className = "layer-name",
            o.setAttribute("for", n);
            const a = document.createElement("input");
            a.id = n,
            a.className = "radio-button clickable",
            a.type = "radio",
            a.name = "radio-layers",
            s.appendChild(a),
            s.appendChild(o);
            const r = document.createElement("span");
            return r.className = "radio-icon",
            s.appendChild(r),
            s
        }
        _createToggle(t, e) {
            const i = document.createElement("li");
            i.id = `${t}-container`;
            const s = document.createElement("label");
            s.classList.add("toggle"),
            s.id = `${t}-toggle-label-el`,
            i.appendChild(s);
            const n = document.createElement("span");
            n.classList.add("toggle-label"),
            n.innerHTML = e,
            i.appendChild(n);
            const o = document.createElement("input");
            o.id = t,
            o.type = "checkbox",
            o.classList.add("checkbox-input"),
            s.appendChild(o);
            const a = document.createElement("span");
            return a.classList.add("slider"),
            s.appendChild(a),
            {
                container: i,
                input: o
            }
        }
        _addDefaultOptions(t, e=null, i={}) {}
        reset() {}
        __disable() {
            this._previousEntity = null,
            this._previousChildEntity = null,
            this.setState({
                entityName: null,
                childEntityId: null
            }),
            super.__disable()
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        FeaturedStoryBlock: function() {
            return FeaturedStoryBlock
        }
    });
    i(1);
    var s = i(890)
      , n = i(964)
      , o = i.n(n);
    i(965);
    class FeaturedStoryBlock extends s.BaseContentBlock {
        constructor(t) {
            super(t, null, {
                colorClass: "spacecraft",
                blockTitle: "",
                hideTitle: ""
            }),
            this._more.isHidden.moreMessage = "Show More",
            this._storyList = null
        }
        onRouteChange(t, e, i, s) {
            if (this._storyList = this._children.storyList,
            null === this._storyList || void 0 === this._storyList)
                return void this.setEnabled(!1);
            if ("home" !== t && void 0 === this._app.getManager("content").context[t])
                return;
            this._storyList.innerHTML = "",
            i.forEach((t => {
                const e = document.createElement("li");
                let s = null;
                s = void 0 === t.storyId ? t : i[t.storyId];
                const {title: n, subtitle: o, icon: a, link: r, isExternal: l, isInternal: c} = s
                  , h = document.createElement("div");
                h.classList.add("story-container"),
                e.appendChild(h);
                const d = document.createElement("div");
                d.classList.add("story-title");
                const u = document.createElement("h2");
                if (u.appendChild(document.createTextNode(n)),
                d.appendChild(u),
                h.appendChild(d),
                o) {
                    const t = document.createElement("div");
                    t.classList.add("story-list", "story-subtitle", "wide-text", "color", "{{colorClass}}", "x-small"),
                    t.appendChild(document.createTextNode(o)),
                    h.appendChild(t)
                }
                const p = document.createElement("div");
                p.classList.add("story-icon");
                const m = document.createElement("img")
                  , _ = `${o}: ${n}`;
                if (m.setAttribute("alt", _),
                m.setAttribute("src", a),
                m.classList.add("story-icon-image"),
                p.appendChild(m),
                h.appendChild(p),
                l)
                    e.addEventListener("click", ( () => {
                        window.open(r)
                    }
                    ), !1);
                else if (c)
                    e.addEventListener("click", ( () => {
                        this._app.getManager("router").navigate(r)
                    }
                    ), !1);
                else {
                    const i = "story/" + t.id;
                    e.addEventListener("click", ( () => {
                        this._app.getManager("router").navigate(i)
                    }
                    ), !1)
                }
                if (l) {
                    const t = document.createElement("div");
                    t.classList.add("icon", "icon-external"),
                    h.appendChild(t)
                }
                e.classList.add("clickable"),
                this._storyList.appendChild(e)
            }
            ));
            const n = "" === e ? "hidden" : "";
            this._setVariables(this._element),
            this.setState({
                blockTitle: e,
                hideTitle: n
            })
        }
    }
    FeaturedStoryBlock.html = o()
}
, function(t) {
    t.exports = '<div key="storyBlock" class="story-block">\n        <span class="story-block-title color {{colorClass}} semi title-underline {{hideTitle}}">{{blockTitle}}</span>\n        <span class="story-related-list">\n                <ul key="storyList" id="story-list" class="story-list"> </ul>\n        </span>\n</div>'
}
, function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        EventsBlock: function() {
            return EventsBlock
        }
    });
    var s = i(1)
      , n = i(890)
      , o = i(967)
      , a = i.n(o);
    i(968);
    class EventsBlock extends n.BaseContentBlock {
        constructor(t) {
            super(t, null, {}),
            this._introMessages = {
                timeline: "Select an event below to learn more.",
                table: "Click or tap an event to start the animation"
            },
            this._currentTab = "timeline",
            this._defaultTab = "timeline",
            this._minEventsForTimeline = 4,
            this.setState({
                isLoadingClass: "hide",
                isViewToggleVisible: "hide",
                isNumEventsVisible: "hide",
                isEventsViewContainerVisible: "hide",
                isIntroLabelVisible: "",
                introLabelText: this._introMessages.timeline,
                sortAscending: !1
            }),
            this._app = t
        }
        onRouteChange(t, e, i) {
            this.startLoading(),
            i || (this._currentTab = this._defaultTab);
            const {timelineContainer: s} = this._children;
            this._timeline = this._app.getComponent("eventsTimeline"),
            this._timeline.setParent(s),
            this._app.pioneer.getScene("main").waitTillEntitiesInPlace([t], this._app.pioneer.getTime(), 10).then((async () => {
                this._events = e,
                this._currentEvent = null,
                this._events && i && (this._currentEvent = this._events.find((t => t.id === i.id)));
                const {currentView: s} = this._app.getManager("router")
                  , n = "event" === s;
                this._numEvents = Object.keys(this._events).length,
                this.setState({
                    numEvents: this._numEvents
                });
                const o = document.getElementsByClassName("sort-triangle")[0];
                if (o && o.classList.remove("rotated"),
                n && i && this._currentEvent) {
                    const s = {
                        id: t,
                        title: i.title,
                        dates: [this._currentEvent.start, this._currentEvent.end],
                        orderedEvents: e
                    };
                    this._timeline.setTarget(s)
                }
                return this.selectTab(this._numEvents > this._minEventsForTimeline ? this._currentTab : "table"),
                this.stopLoading(),
                !0
            }
            )).catch((t => {
                console.warn(t)
            }
            ))
        }
        startLoading() {
            const {tableContainer: t} = this._children;
            this.showContainer(t, !1),
            this._timeline?.hide(),
            this.setState({
                isLoadingClass: "loading",
                isViewToggleVisible: "hide",
                isEventsViewContainerVisible: "hide",
                isNumEventsVisible: "hidden",
                introLabelText: "Loading events..."
            })
        }
        stopLoading() {
            const t = s.AppUtils.isMobile() || s.AppUtils.isTablet()
              , e = this._numEvents > this._minEventsForTimeline;
            this.setState({
                isLoadingClass: "hide",
                isViewToggleVisible: e ? "" : "hide",
                isNumEventsVisible: t ? "hidden" : "",
                isEventsViewContainerVisible: "",
                introLabelText: this._introMessages[this._currentTab]
            }),
            e && this.selectTab(this._currentTab)
        }
        _onTabSelect(t) {
            let e = t.target;
            e.classList.contains("toggle-title") || (e = Array.from(t.target.children).find((t => t.classList.contains("toggle-title"))));
            const i = Array.from(t.target.parentElement.children).find((t => "" !== t.innerHTML))
              , s = e?.innerHTML ?? i.innerHTML;
            this.selectTab(s)
        }
        selectTab(t) {
            const e = t.toLowerCase();
            Array.from(this._children.toggleContainer?.children)?.forEach((t => {
                t.classList.contains("tab") && t.classList.toggle("selected", t.lastChild.innerText.toLowerCase() === e)
            }
            )),
            this._currentTab = e,
            this.setState({
                introLabelText: `${this._introMessages[e]}`
            }),
            "timeline" === e ? this.showTimeline() : this.showTable()
        }
        showTimeline() {
            const {timelineContainer: t, tableContainer: e} = this._children;
            this.showContainer(t),
            this.showContainer(e, !1),
            this.setState({
                isIntroLabelVisible: ""
            }),
            this._timeline.checkForZoom(this._currentEvent),
            this._timeline.show()
        }
        showTable() {
            const {timelineContainer: t, tableContainer: e} = this._children;
            this.showContainer(t, !1),
            this._timeline.hide(),
            this.populateTable(),
            this.showContainer(e),
            (s.AppUtils.isMobile() || s.AppUtils.isTablet()) && this.setState({
                isIntroLabelVisible: "hidden"
            })
        }
        resetScrollbar() {
            this._children.tableContainer.scrollTop = 0
        }
        populateTable() {
            const {eventsTable: t} = this._children;
            t.innerHTML = "",
            Object.values(this._events).forEach((e => {
                const i = document.createElement("tr");
                i.classList.add("clickable", "event-row");
                const s = document.createElement("td")
                  , n = e.title;
                s.appendChild(document.createTextNode(n)),
                s.classList.add("event-title"),
                i.appendChild(s);
                const o = document.createElement("td")
                  , a = this._app.getManager("time").parseTime(e.start);
                o.appendChild(document.createTextNode(a.year())),
                i.appendChild(o);
                const r = document.createElement("td")
                  , l = this._app.getManager("content").getEntityInfo(e.target)
                  , c = l?.displayName || l?.iauName;
                r.appendChild(document.createTextNode(c || "None")),
                i.appendChild(r),
                t.appendChild(i),
                i.onclick = this.rowClick;
                const {currentView: h, currentRoute: d} = this._app.getManager("router");
                if ("event" === h) {
                    const t = d.params.child;
                    i.classList.toggle("highlight", t === e.id)
                }
            }
            ))
        }
        sortEventsByTitle = () => {
            this.sortTable("title"),
            this.populateTable(),
            this.rotateSortTriangle("title"),
            this.resetScrollbar()
        }
        ;
        sortEventsByYear = () => {
            this.sortTable("start"),
            this.populateTable(),
            this.rotateSortTriangle("year"),
            this.resetScrollbar()
        }
        ;
        sortEventsByTarget = () => {
            this.sortTable("target"),
            this.populateTable(),
            this.rotateSortTriangle("target"),
            this.resetScrollbar()
        }
        ;
        rotateSortTriangle(t) {
            Array.from(document.getElementsByClassName("sort-triangle")).find((e => e.classList.contains(t))).classList.toggle("rotated")
        }
        sortTable(t) {
            const e = this._app.getManager("content");
            this.setState({
                sortAscending: !this.getState("sortAscending")
            }),
            this._events = Object.values(this._events).sort(( (i, s) => {
                let {[`${t}`]: n} = i
                  , {[`${t}`]: o} = s;
                return "start" === t && ("string" != typeof n && (n = n.format("MMM DD, YYYY")),
                "string" != typeof o && (o = o.format("MMM DD, YYYY"))),
                n && o ? ("target" === t && (n = e.getEntityInfo(n).displayName || e.getEntityInfo(n).iauName,
                o = e.getEntityInfo(o).displayName || e.getEntityInfo(o).iauName),
                "start" === t && (n = new Date(n).toISOString(),
                o = new Date(o).toISOString())) : (n = n || "None",
                o = o || "None"),
                this.getState("sortAscending") ? n.localeCompare(o) : o.localeCompare(n)
            }
            ))
        }
        showContainer(t, e=!0) {
            t.classList.toggle("hide", !e)
        }
        rowClick = async t => {
            const e = t.target.parentElement
              , i = Array.from(e.children).find((t => t.classList.contains("event-title"))).innerHTML
              , s = Object.values(this._events).find((t => t.title === i));
            this._timeline.goToEvent(s.id)
        }
        ;
        resize() {
            super.resize();
            const t = s.AppUtils.isMobile() || s.AppUtils.isTablet();
            this.setState({
                isNumEventsVisible: t ? "hidden" : ""
            }),
            "table" === this._currentTab && this.setState({
                isIntroLabelVisible: t || s.AppUtils.isLandscape() ? "hidden" : ""
            }),
            this._events && Object.keys(this._events).length > this._minEventsForTimeline && this._timeline.show()
        }
    }
    EventsBlock.html = a()
}
, function(t) {
    t.exports = '<div class="content-block events-block panel-block">\n\t<div class="title-toggle-block {{isViewToggleVisible}}">\n\t\t<h5 class="title {{isNumEventsVisible}}">Events</h5>\n\t\t<h5 class="num-events-label {{isNumEventsVisible}}">{{numEvents}}</h5>\n\t\t<div key="toggleContainer" id="toggle-container" class="{{isViewToggleVisible}}">\n\t\t\t<span class="tab selected clickable" onclick="_onTabSelect">\n\t\t\t\t<div class="toggle-icon icon-timeline"></div>\n\t\t\t\t<span class="toggle-title">Timeline</span>\n\t\t\t</span>\n\t\t\t<span class="tab clickable" onclick="_onTabSelect">\n\t\t\t\t<div class="toggle-icon icon-table"></div>\n\t\t\t\t<span class="toggle-title">Table</span>\n\t\t\t</span>\n\t\t\t<div class="toggle-slider"></div>\n\t\t</div>\n\t</div>\n\t<div class="intro-label {{isIntroLabelVisible}}">{{introLabelText}}</div>\n\n\t<div class="loading-bar {{isLoadingClass}}"></div>\n\n\t<div id="events-view-container" class="{{isEventsViewContainerVisible}}">\n\t\t<div key="timelineContainer" class="events-timeline"></div>\n\t\t<div key="tableContainer" class="table-container scrollable">\n\t\t\t<table key="table">\n\t\t\t\t<thead>\n\t\t\t\t\t<th scope="col" id=\'title-header\'class="clickable" onclick="sortEventsByTitle">\n\t\t\t\t\t\tEvent\n\t\t\t\t\t\t<span class="sort-triangle title"></span>\n\t\t\t\t\t</th>\n\t\t\t\t\t<th scope="col" id=\'year-header\' class="clickable" onclick="sortEventsByYear">\n\t\t\t\t\t\tYear\n\t\t\t\t\t\t<span class="sort-triangle year"></span>\n\t\t\t\t\t</th>\n\t\t\t\t\t<th scope="col" id=\'target-header\' class="clickable" onclick="sortEventsByTarget">\n\t\t\t\t\t\tTarget\n\t\t\t\t\t\t<span class="sort-triangle target"></span>\n\t\t\t\t\t</th>\n\t\t\t\t</thead>\n\t\t\t\t<tbody key="eventsTable"></tbody>\n\t\t\t</table>\n\t\t</div>\n\t</div>\n</div>'
}
, function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        OverviewBlock: function() {
            return OverviewBlock
        }
    });
    i(1);
    var s = i(890)
      , n = i(747)
      , o = i.n(n)
      , a = i(970)
      , r = i.n(a)
      , l = (i(971),
    i(5));
    class OverviewBlock extends s.BaseContentBlock {
        constructor(t) {
            super(t, null, {
                objectType: "",
                objectDescription: "",
                moreDescription: "",
                disclaimerClass: "hidden",
                disclaimerMessage: ""
            }),
            this.setState({
                category: "",
                shapeType: "circle",
                shapeColor: "blue",
                isShapeVisibleClass: "hidden",
                isCategoryVisibleClass: "hidden",
                isDateVisible: "hidden",
                isBackButtonVisible: "hidden",
                time: ""
            }),
            this._more.isHidden.moreMessage = "Read More",
            this.bindFunctions(["goBack"])
        }
        goBack() {
            const t = this._app.getManager("router");
            this._app.getComponent("contentPanel").selectTab("info"),
            t.navigate(this._targetId)
        }
        onRouteChange(t, e, i) {
            this._targetId = t;
            let s = "hidden";
            const n = e ?? this._app.getManager("content").getEntityInfo(t);
            let o = "";
            ["Asteroid", "Comet", "Moon", "Dwarf Planet"].indexOf(n.category) >= 0 && this._app.scene.getEntity(t).getComponent(l.ModelComponent)?._url.includes("generic") && (o = "This ",
            o += n.category.toLowerCase(),
            o += " is represented by a generic model."),
            "" !== o && (s = "active");
            const {title: a, subHeadingString: r, missionStartDate: c, missionEndDate: h} = this._determineOverviewContent(t, n, i)
              , d = this._app.getManager("time").parseTime(c)
              , u = this._app.getManager("time").parseTime(h)
              , p = this._app.getManager("content").getCategoryShapeMap()
              , m = p[n.category] ? p[n.category].shape : "circle"
              , _ = p[n.category] ? p[n.category].color : "brown"
              , g = "event" === this._app.getManager("router").currentView
              , y = `${d.year()} - ${"" !== h ? u.year() : "Present"}`;
            let f = n.category;
            g ? f = r : n.title?.toLowerCase().includes("moons") && (f = i),
            this.setState({
                title: a,
                category: f,
                shapeType: m,
                shapeColor: _,
                isShapeVisibleClass: n.category && !g ? "" : "hidden",
                isCategoryVisibleClass: n.category ? "" : "hidden",
                isDateVisible: c ? "" : "hidden",
                missionDates: y,
                disclaimerClass: s,
                disclaimerMessage: o,
                isBackButtonVisible: g ? "" : "hidden"
            }),
            this._setVariables(this._element);
            const b = this._app.getComponent("contentPanel").element.clientWidth - this._children.overviewTitle.clientWidth < 100;
            this._children.overviewTitle.classList.toggle("long-title", b),
            this._app.pioneer.getScene("main").waitTillEntitiesInPlace([t], this._app.pioneer.getTime(), 10).then(( () => {
                this._targetId = t;
                const e = document.getElementsByClassName("back-button");
                for (const t of e)
                    t.onclick = this.goBack;
                return !0
            }
            )).catch((t => {
                console.warn(t)
            }
            ))
        }
        _determineOverviewContent(t, e, i) {
            const s = e?.displayName || e?.iauName || e?.title
              , n = this._getSubheadingForObject(t, e, i)
              , o = i?.dates?.start
              , a = i?.dates?.end;
            return {
                title: s,
                subHeadingString: n,
                missionStartDate: o,
                missionEndDate: a
            }
        }
        _getSubheadingForObject(t, e, i) {
            const s = this._app.getManager("content").getEntityInfo(t);
            let n = "";
            const {currentView: a} = this._app.getManager("router");
            if ("event" === a)
                return o()(e.start).format("MMM DD, YYYY");
            if (s) {
                switch (s.category) {
                case "Spacecraft":
                    {
                        let t = "";
                        const s = o()(e.start)
                          , a = new (o());
                        if (void 0 === i.dates || !0 !== s.isValid())
                            return "";
                        t = s.year();
                        let r = "present";
                        !0 === o()(i.dates.end).isValid() && (r = o()(i.dates.end).year()),
                        s.isAfter(a) ? (s.month() > -1 && s.year() > -1 ? t = s.format("MMMM YYYY") : s.month() < 0 && s.year() > -1 && (t = s.year()),
                        n = t) : n = t + "-" + r;
                        break
                    }
                case "Moon":
                    {
                        const e = this._app.getManager("content").getEntityInfo(this._app.getManager("scene").get("main").getEntity(t).getParent().getName());
                        n = "Moon of " + (e.displayName || e.iauName);
                        break
                    }
                default:
                    n = void 0 !== s.subcategory ? s.subcategory : s.category
                }
                return n
            }
        }
    }
    OverviewBlock.html = r()
}
, function(t) {
    t.exports = '<div id="overview-block" class="content-block overview panel-block">\n\t<button class="back-button {{isBackButtonVisible}} clickable" onclick="goBack">\n\t\t<div class="icon caret-up"></div>\n\t</button>\n\t\n\t<div class="overview-content-container">\n\t\t<span key="overviewTitle" class="semi title" aria-labelledby="title">{{title}}</span>\n\t\t<div class="subtitle-container">\n\t\t\t<div class="event-title {{isBackButtonVisible}}">\n\t\t\t\t<div class="icon icon-calendar"></div>\n\t\t\t\tEvent\n\t\t\t</div>\n\t\t\t<span class="{{isBackButtonVisible}}">Â·</span>\n\t\t\t<div class="subtitle">\n\t\t\t\t<div class="shape {{shapeType}} {{shapeColor}} {{isShapeVisibleClass}}"></div>\n\t\t\t\t<span class="subtitle category {{isCategoryVisibleClass}}">{{category}}</span>\n\t\t\t\t<span class="{{isDateVisible}}">Â· <span>{{missionDates}}</span></span>\n\t\t\t</div>\n\t\t</div>\n\t\t\n\t\t<span class="{{disclaimerClass}} color gray x-small">{{disclaimerMessage}}</span>\n\t</div>\n</div>'
}
, function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        DescriptionBlock: function() {
            return DescriptionBlock
        }
    });
    var s = i(1)
      , n = i(890)
      , o = i(973)
      , a = i.n(o);
    i(974);
    class DescriptionBlock extends n.BaseContentBlock {
        constructor(t) {
            super(t, null, {});
            const e = s.AppUtils.isMobile() || s.AppUtils.isTabletPortrait();
            this.setState({
                showTitleLabel: e ? "hidden" : "",
                isButtonVisible: e ? "hidden" : "",
                isMoreVisible: e ? "expanded" : "hidden",
                moreDescription: "",
                isExpanded: "",
                readMsg: "More"
            }),
            this._app = t
        }
        onRouteChange(t) {
            const e = s.AppUtils.isMobile() || s.AppUtils.isTabletPortrait()
              , {hideExternalLinks: i, kiosk: n} = this._app.getManager("router").configs
              , o = !0 === i || !0 === n;
            if (!t.description)
                return;
            let a = t.description.blurb
              , r = t.description.more;
            o && (a = this._app.getManager("content").hideExternalLinksInText(t.description.blurb),
            r = this._app.getManager("content").hideExternalLinksInText(t.description.more)),
            this.setState({
                blurbDescription: a,
                moreDescription: r,
                showTitleLabel: e ? "hidden" : "",
                isButtonVisible: e || !r ? "hidden" : "",
                isMoreVisible: t.description.more && e ? "expanded" : "hidden",
                isExpanded: "",
                readMsg: "More"
            }),
            this.resetScrollbar()
        }
        resetScrollbar() {
            this._app.getComponent("contentPanel").getScrollbar()?.scroll(0)
        }
        resize() {
            const t = s.AppUtils.isMobile() || s.AppUtils.isTabletPortrait();
            this.setState({
                showTitleLabel: t ? "hidden" : "",
                isButtonVisible: t ? "hidden" : "",
                isMoreVisible: t ? "expanded" : "hidden",
                isExpanded: "",
                readMsg: t ? "Less" : "More"
            })
        }
        onClickReadMore() {
            const t = "hidden" === this.getState("isMoreVisible");
            document.documentElement.style.setProperty("--overviewBlockHeight", `${document.getElementById("overview-block").offsetHeight}px`),
            t || this.resetScrollbar(),
            this.setState({
                isExpanded: t ? "expanded" : "",
                isMoreVisible: t ? "expanded" : "hidden",
                readMsg: t ? "Less" : "More"
            })
        }
    }
    DescriptionBlock.html = a()
}
, function(t) {
    t.exports = '<div class="content-block description panel-block {{isExpanded}}">\n    <h5 class="title {{showTitleLabel}}">Description</h5>\n\t<div key="copyContainer" class="copy-container">\n\t\t<div class="copy">{{blurbDescription}}</div>\n\t\t<div key="moreContainer" class="more-container {{isMoreVisible}}">\n\t\t\t<div class="copy more line-break-text" key="moreCopy">{{moreDescription}}</div>\n\t\t</div>\n\t</div>\n\t\n\t<button class="more-button clickable {{isButtonVisible}} " onclick="onClickReadMore">Read <span>{{readMsg}}</span></button>\n</div> '
}
, function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        FeaturedMoonsBlock: function() {
            return FeaturedMoonsBlock
        }
    });
    var s = i(1)
      , n = i(890)
      , o = i(976)
      , a = i.n(o);
    class FeaturedMoonsBlock extends n.BaseContentBlock {
        constructor(...t) {
            super(...t),
            this.resize()
        }
        resize() {
            super.resize();
            const t = s.AppUtils.isMobile() || s.AppUtils.isTabletPortrait();
            this.setState({
                showTitleLabel: t ? "hidden" : ""
            })
        }
        async onRouteChange(t, e, i) {
            i && i.isCanceled || (this.hideMore(),
            this._children.featuredMoonsList.innerHTML = "",
            void 0 !== e.initial && 0 !== e.initial.length ? (this._element.classList.remove("hidden"),
            Array.isArray(e.more) && 0 !== e.more.length ? this.setState({
                hideMoreMessage: ""
            }) : this.setState({
                hideMoreMessage: "hidden"
            }),
            e.initial.forEach((t => {
                if (i && i.isCanceled)
                    return;
                const e = this._createListElement(t);
                this._children.featuredMoonsList.appendChild(e)
            }
            )),
            e.more.forEach((t => {
                if (i && i.isCanceled)
                    return;
                const e = this._createListElement(t);
                e.classList.add("hidden", "{{moreClass}}", "hover-background"),
                this._children.featuredMoonsList.appendChild(e)
            }
            ))) : this.setEnabled(!1),
            this._setVariables(this._element))
        }
        _createListElement(t) {
            const e = document.createElement("li")
              , i = t.info ? `${t.title} (${t.info})` : t.title;
            e.appendChild(document.createTextNode(i)),
            e.addEventListener("click", ( () => {
                this._app.getManager("router").navigate(t.url)
            }
            ), !1),
            e.classList.add("clickable", "hover-background");
            const s = document.createElement("span");
            return s.classList.add("icon", "icon-greater", "mobile-icon"),
            e.appendChild(s),
            e.style.paddingLeft = "1.25em",
            e.style.paddingRight = "1.25em",
            e.style.paddingTop = "0.5em",
            e.style.paddingBottom = "0.5em",
            e.style.justifyContent = "space-between",
            e
        }
    }
    FeaturedMoonsBlock.html = a()
}
, function(t) {
    t.exports = '<div class="content-block panel-block no-side-padding">\n\t<h5 class="title {{showTitleLabel}}" style="margin: 0em 1.25em">Featured Moons</h5>\n\t<span>\n\t\t<ul key="featuredMoonsList"></ul>\n\t</span>\n\t<span class="more-toggle {{hideMoreMessage}}" onclick="toggleMore">\n\t\t<span class="x-small more-message {{hideMoreMessage}}">\n\t\t\t{{moreMessage}}\n\t\t</span>\n\t\t<span class="button clickable icon more-icon {{moreIcon}} {{hideMoreMessage}}"></span>\n\t</span>\n</div>\n'
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        FeaturedEventsBlock: function() {
            return FeaturedEventsBlock
        }
    });
    var s = i(747)
      , n = i.n(s)
      , o = (i(1),
    i(890))
      , a = i(978)
      , r = i.n(a);
    class FeaturedEventsBlock extends o.BaseContentBlock {
        constructor(t) {
            super(t),
            this._more.isHidden.moreMessage = "Show More",
            this._featuredEventsList = null
        }
        async onRouteChange(t, e, i, s) {
            this._featuredEventsList = this._children.featuredEventsList;
            const o = e.featuredEvents;
            this._featuredEventsList.innerHTML = "",
            o.initial.forEach((e => {
                const s = document.createElement("li")
                  , o = i[e.eventId];
                let a = "";
                n()(o.start).isValid() && (a = " (" + n()(o.start).year() + ")");
                const r = document.createElement("span");
                r.innerHTML = `<span class="semi">${o.title}</span> ${a}`,
                s.appendChild(r);
                const l = document.createElement("span");
                l.classList.add("icon", "icon-greater", "mobile-icon"),
                s.appendChild(l);
                const c = t + "/events/" + e.eventId;
                s.addEventListener("click", ( () => {
                    this._app.getManager("router").navigate(c)
                }
                ), !1),
                s.classList.add("featured-events-list-item", "clickable", "underline"),
                this._featuredEventsList.appendChild(s)
            }
            ));
            let a = "hidden";
            void 0 !== o.more && o.more.length > 0 && (a = "",
            o.more.forEach((e => {
                const i = document.createElement("li")
                  , s = this._app.getManager("content").events[e.eventId];
                let o = "";
                n()(s.start).isValid() && (o = " (" + n()(s.start).year() + ")");
                const a = document.createElement("span");
                a.innerHTML = `<span class="semi">${s.title}</span> ${o}`,
                i.appendChild(a);
                const r = t + "/events/" + e.eventId;
                i.addEventListener("click", ( () => {
                    this._app.getManager("router").navigate(r)
                }
                ), !1),
                i.classList.add("featured-events-list-item", "clickable", "underline"),
                i.classList.add("{{moreClass}}");
                const l = document.createElement("span");
                l.classList.add("icon", "icon-greater", "mobile-icon"),
                i.appendChild(l),
                this._featuredEventsList.appendChild(i)
            }
            )));
            const r = this._app.getManager("content").getColorClass(t);
            this._setVariables(this._children.featuredEventsList),
            this.setState({
                colorClass: r,
                hideMoreMessage: a
            })
        }
    }
    FeaturedEventsBlock.html = r()
}
, function(t) {
    t.exports = '<div class="featured-events-block">\n\t<span class="color {{colorClass}} small semi title-underline">Featured Events</span>\n\t<span class="featured-events-underline color gray dark"></span>\n\t<span class="featured-events-related-list">\n\t\t<ul key="featuredEventsList" id="featured-events-list" class="featured-events-list"> </ul>\n\t</span>\n\t<span class="more-toggle {{hideMoreMessage}}" onclick="toggleMore">\n\t\t<span class="x-small more-message">\n\t\t\t{{moreMessage}}\n\t\t</span>\n\t\t<span class="button clickable icon more-icon {{moreIcon}}"></span>\n\t</span>\n</div>\n'
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        ExplorationBlock: function() {
            return ExplorationBlock
        }
    });
    i(1);
    var s = i(890)
      , n = i(980)
      , o = i.n(n);
    class ExplorationBlock extends s.BaseContentBlock {
        constructor(t) {
            super(t),
            this._explorationList = null
        }
        async onRouteChange(t, e, i) {
            if (null === this._children.explorationList || void 0 === this._children.explorationList)
                return console.log("explorationList is null or undefined!!!"),
                void this.setEnabled(!1);
            this._explorationList = this._children.explorationList,
            this.setState({
                colorClass: this._app.getManager("content").getColorClass(t)
            }),
            this._explorationList.innerHTML = "",
            void 0 !== e && 0 !== e.initial.length ? (this._element.classList.remove("hidden"),
            null === e.more || void 0 === e.more || e.more.length <= 0 ? this.setState({
                hideMoreMessage: "hidden"
            }) : this.setState({
                hideMoreMessage: ""
            }),
            e.initial.forEach((t => {
                const e = document.createElement("li")
                  , i = document.createElement("span");
                i.innerHTML = t.info ? `<span class="semi">${t.title}</span> (${t.info})` : `<span class="semi">${t.title}</span>`,
                e.appendChild(i),
                e.addEventListener("click", ( () => {
                    this._app.getManager("router").navigate(t.url)
                }
                ), !1),
                e.classList.add("exploration-list-item", "underline"),
                e.classList.add("clickable");
                const s = document.createElement("span");
                s.classList.add("icon", "icon-greater", "mobile-icon"),
                e.appendChild(s),
                this._explorationList.appendChild(e)
            }
            )),
            e.more.forEach((t => {
                const e = document.createElement("li")
                  , i = document.createElement("span");
                i.innerHTML = t.info ? `<span class="semi">${t.title}</span> (${t.info})` : `<span class="semi">${t.title}</span>`,
                e.appendChild(i),
                e.addEventListener("click", ( () => {
                    this._app.getManager("router").navigate(t.url)
                }
                ), !1),
                e.classList.add("exploration-list-item"),
                e.classList.add("clickable"),
                e.classList.add("hidden"),
                this._explorationList.appendChild(e),
                e.classList.add("clickable", "{{moreClass}}", "underline")
            }
            ))) : this.setEnabled(!1),
            this.setState({
                colorClass: this._app.getManager("content").getColorClass(t)
            }),
            this._setVariables(this._element)
        }
    }
    ExplorationBlock.html = o()
}
, function(t) {
    t.exports = '<div class="exploration-block">\n\t<span class="exploration-title color {{colorClass}} small semi title-underline">Exploration</span>\n\t<span class="exploration-related-list">\n\t\t<ul key="explorationList" id="exploration-list" class="exploration-list"> </ul>\n\t</span>\n\t<span class="more-toggle {{hideMoreMessage}}" onclick="toggleMore">\n\t\t<span class="x-small more-message {{hideMoreMessage}}">\n\t\t\t{{moreMessage}}\n\t\t</span>\n\t\t<span class="button clickable icon more-icon {{moreIcon}} {{hideMoreMessage}}"></span>\n\t</span>\n</div>\n'
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        ToolboxBlock: function() {
            return ToolboxBlock
        }
    });
    var s = i(1)
      , n = i(890)
      , o = i(982)
      , a = i.n(o)
      , r = (i(983),
    i(897),
    i(900));
    class ToolboxBlock extends n.BaseContentBlock {
        constructor(t, e={}) {
            super(t, null, {
                isVisible: !0,
                iconClass: "",
                title: "",
                tooltipText: "",
                ...e
            }),
            this._state = {
                ...this._state,
                isVisibleClass: this._class.isVisible[this._state.isVisible],
                inputTipVisibleClass: "hidden",
                nav: []
            },
            this._isTouch = s.AppUtils.isMobile() || s.AppUtils.isTablet()
        }
        init() {
            super.init(),
            this._children.clickableDiv.addEventListener("click", ( () => {
                this._app.getManager("router").navigate(...this._state.nav)
            }
            )),
            window.addEventListener("contentPanelCollapse", (t => {
                t.detail && this._closeTooltip()
            }
            ))
        }
        onRouteChange({entityId: t, link: e, query: i={}, options: s={
            __remove: "all"
        }, updatedTitle: n="", tooltipText: o=this._state.tooltipText}) {
            const a = `/${t}${e}`;
            this.setState({
                nav: [i, a, s],
                title: n || this._state.title,
                tooltipText: o
            }),
            this._tippy || (this._tippy = (0,
            r.default)(this._children.tooltipIcon, {
                content: this._state.tooltipText,
                delay: 50
            })),
            this._tippy.setContent(this._state.tooltipText),
            window.removeEventListener("click", this._closeTooltip)
        }
        _showTooltip(t) {
            if (!this._isTouch)
                return;
            const e = document.getElementById("overview-block")?.getBoundingClientRect()?.height;
            this.element.style.setProperty("--tooltip-top-margin", `${e}px`);
            const i = this._children.tooltipPopup.classList.value.includes("hidden");
            Array.from(document.getElementsByClassName("tooltip-popup")).forEach((e => {
                e.classList.toggle("hidden", e.nextElementSibling !== t.target)
            }
            )),
            this.setState({
                inputTipVisibleClass: i ? "" : "hidden"
            }),
            window.addEventListener("click", (t => {
                t.target.classList.contains("tooltip") || this._closeTooltip()
            }
            ))
        }
        _closeTooltip(t) {
            t?.preventDefault(),
            Array.from(document.getElementsByClassName("tooltip-popup")).forEach((t => {
                t.classList.add("hidden")
            }
            )),
            this.setState({
                inputTipVisibleClass: "hidden"
            })
        }
        resize() {
            this._isTouch = s.AppUtils.isMobile() || s.AppUtils.isTablet()
        }
    }
    ToolboxBlock.html = a()
}
, function(t) {
    t.exports = '<li key="toolboxBlock" class="toolbox-block content-block clickable hover-background {{isVisibleClass}}">\n\t<div key="clickableDiv" class="clickable-div"></div>\n\t<span class="icon circle mobile-icon">\n\t\t<span class="icon {{iconClass}} mobile-icon"></span>\n\t</span>\n\t<div class="toolbox-description">\n\t\t<div class="title capitalize">{{title}}</div>\n\t\t<div class="tooltop-icon-container">\n\t\t\t<div key="tooltipIcon" class="tooltip tooltip-info-icon clickable icon icon-info" \n\t\t\t\tonclick="_showTooltip" \n\t\t\t\tontouch="_showTooltip">\n\t\t\t</div>\n\t\t</div>\n\t</div>\n\t<span key="goButton" class="icon caret-right mobile-icon hover-background clickable"></span>\n\t<div key="tooltipPopup" class="tooltip-popup {{inputTipVisibleClass}}">\n\t\t<div class="semi tooltip-text">\n\t\t\t<div alt="Close tooltip" class="tooltip-close-btn semi" onclick="_closeTooltip" ontouchstart="_closeTooltip">\n\t\t\t\t<div class="icon icon-close"></div>\n\t\t\t</div>{{tooltipText}}\n\t\t</div>\n\t</div>\n</li>'
}
, function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        CameraViewBlock: function() {
            return CameraViewBlock
        }
    });
    i(1);
    var s = i(890)
      , n = i(985)
      , o = i.n(n);
    i(986);
    class CameraViewBlock extends s.BaseContentBlock {
        constructor(t, e={}) {
            e.config = {
                defaultSelectionIndex: 0,
                ...e.config
            },
            super(t, null, {
                category: "",
                ...e
            }),
            this.onLoaded = [],
            this._cameraOptions = {
                nearObject: (t, e) => ({
                    type: "nearby",
                    text: "Nearby",
                    id: "nearObject-" + e,
                    onSelect: async () => {
                        await this._app.cameraScripts.goToCelestialObject(e)
                    }
                }),
                nearSpacecraft: (t, e) => ({
                    type: "nearby",
                    text: "Nearby",
                    id: "nearSpacecraft-" + e,
                    onSelect: async () => {
                        await this._app.cameraScripts.goToSpacecraft(e)
                    }
                }),
                nearEvent: (t, e) => ({
                    type: "nearby",
                    text: "Nearby",
                    id: "nearEvent-" + e,
                    onSelect: async () => {
                        const {_eventDesc: t, _eventInfo: i} = this.app.getView("event")
                          , s = {
                            ...t,
                            ...i
                        }
                          , {target: n, duration: o, distance: a, horizontalOffset: r, verticalOffset: l} = s;
                        n && await this._app.cameraScripts.alignObjects(e, n, {
                            duration: o,
                            distance: a,
                            horizontalOffset: r,
                            verticalOffset: l
                        })
                    }
                }),
                alignSpacecraftPlanet: (t, e) => ({
                    type: "nearby",
                    text: "Nearby ",
                    id: "alignSpacecraftPlanet-" + e,
                    onSelect: async () => {
                        await this._app.cameraScripts.alignSpacecraftPlanet(e)
                    }
                }),
                nearInstrument: (t, e, i) => ({
                    type: "nearby",
                    text: "Nearby",
                    id: "nearInstrument-" + e,
                    onSelect: async () => {
                        await this._app.cameraScripts.goToInstrument(e, i)
                    }
                }),
                system: (t, e) => ({
                    type: "system",
                    text: e || "System",
                    id: "system-" + t,
                    onSelect: async () => {
                        await this._app.cameraScripts.goToSystem(t)
                    }
                }),
                aboveParent: (t, e) => ({
                    type: "system",
                    text: e || "System",
                    id: "aboveParent-" + t,
                    onSelect: async () => {
                        await this._app.cameraScripts.showLocationInParentSystem(t)
                    }
                }),
                aboveSun: (t, e) => ({
                    type: "system",
                    text: "Outer",
                    id: "aboveSun-" + t,
                    onSelect: async () => {
                        await this._app.cameraScripts.showLocationInSolarSystem(t, e)
                    }
                }),
                cameraFollow: () => ({
                    type: "follow",
                    text: "Follow",
                    id: "cameraFollow",
                    onCreate: t => {
                        const e = this.app.getManager("cameraFollow");
                        e.initSearch(this._element),
                        e.registerCallback("cameraFollowUndo", this.goBackToPreviousView),
                        e.registerCallback("cameraFollowSelect", this.goToFollowCameraView)
                    }
                    ,
                    onSelect: () => {
                        this.app.getManager("cameraFollow").isEnabled || this.app.getManager("cameraFollow").setEnabled(!0)
                    }
                    ,
                    onDeselect: () => {
                        this._followId = "";
                        this.app.getManager("cameraFollow").setEnabled(!1, {
                            resetLimits: !1,
                            removeQueries: ["followId"]
                        })
                    }
                })
            },
            this._activeCameraOptions = [],
            this._currentCameraView = null,
            this._prevCameraView = null,
            this._activeCamOptIndex = -1,
            this._prevCamOptIndex = -1,
            this._optionIndexMap = {},
            this._followId = "",
            this._defaultViewIndexOverride = void 0,
            this._entityId = "",
            this.bindFunctions(["goBackToPreviousView", "goToFollowCameraView"])
        }
        _renderOptions(t, e=!1) {
            this._children.cameraOptions.innerHTML = "",
            this._activeCameraOptions = [],
            this._currentCameraView = null,
            this._prevCameraView = null,
            this._activeCamOptIndex = -1,
            this._prevCamOptIndex = -1,
            this._optionIndexMap = {};
            for (let e = 0; e < t.length; e++) {
                let {text: i, id: s, onCreate: n, onSelect: o, onDeselect: a, type: r} = t[e];
                const l = e;
                void 0 !== this._optionIndexMap[s] && (s = s + "-" + e),
                this._optionIndexMap[s] = l;
                const c = "function" == typeof i ? i() : i
                  , h = document.createElement("li");
                h.className = "option clickable";
                const d = document.createElement("label");
                d.innerHTML = c;
                const u = `${d.innerText.toLowerCase().split(" ").join("-")}-radio-button`;
                d.setAttribute("for", u);
                const p = document.createElement("input");
                p.id = u,
                p.type = "radio",
                p.name = "camera-view";
                const m = document.createElement("div");
                m.className = "icon " + r,
                m.ariaHidden = "true",
                h.appendChild(p),
                h.appendChild(m),
                h.appendChild(d),
                h.addEventListener("click", (t => {
                    this._activeCamOptIndex !== l ? this._goToView(s) : o(),
                    p.blur()
                }
                ));
                const _ = c;
                this._activeCameraOptions.push({
                    id: s,
                    optionTitle: _,
                    option: h,
                    radioButtonLabel: d,
                    radioButton: p,
                    onSelect: o,
                    onDeselect: a
                }),
                this._children.cameraOptions.appendChild(h),
                "function" == typeof n && n(h)
            }
            this._setVariables(this._children.cameraOptions)
        }
        _addPlanetOptions(t, e=!1) {
            const i = t.displayName || t.iauName
              , s = t.id
              , n = [this._cameraOptions.nearObject(i, s), this._cameraOptions.system(s), this._cameraOptions.cameraFollow()];
            this._renderOptions(n, e)
        }
        _addMoonOptions(t, e=!1) {
            const i = t.displayName || t.iauName
              , s = t.id
              , n = this._app.getManager("scene").getParent(s)
              , o = [this._cameraOptions.nearObject(i, s), this._cameraOptions.system(n), this._cameraOptions.cameraFollow()];
            this._renderOptions(o, e)
        }
        _addStarOptions(t, e=!1) {
            const i = t.displayName || t.iauName
              , s = t.id
              , n = [this._cameraOptions.nearObject(i, s), this._cameraOptions.system("inner_solar_system", "Inner"), this._cameraOptions.system("outer_solar_system", "Outer"), this._cameraOptions.cameraFollow()];
            this._renderOptions(n, e)
        }
        async _addSpacecraftOptions(t, e=!1) {
            const i = this._app.getManager("content")
              , {currentView: s} = this._app.getManager("router")
              , n = t.displayName || t.iauName
              , o = t.id;
            if (await this._app.getManager("scene").isReady(o),
            o !== this._app.getView(s)?._target)
                return;
            const a = this._app.getManager("scene").getParent(o)
              , r = i.getEntityInfo(a)
              , l = r?.displayName || r?.iauName
              , c = i.hasLanded(t)
              , h = [];
            if ("event" === s)
                h.push(this._cameraOptions.nearEvent(n, o), this._cameraOptions.cameraFollow());
            else if (c || "Landing site" === t.category) {
                "Landing site" === r.category && this._app.getManager("scene").getParent(a);
                h.push(this._cameraOptions.alignSpacecraftPlanet(n, o), this._cameraOptions.aboveParent(o))
            } else
                "Instrument" === t.category ? h.push(this._cameraOptions.nearInstrument(n, o, t.cameraOptions), this._cameraOptions.nearSpacecraft(l, a)) : (h.push(this._cameraOptions.nearSpacecraft(n, o), this._cameraOptions.aboveParent(o)),
                h.push(this._cameraOptions.cameraFollow()));
            this._renderOptions(h, e)
        }
        _addFeatureOptions(t, e=!1) {
            const i = t.displayName || t.iauName
              , s = t.id
              , n = [this._cameraOptions.nearObject(i, s), this._cameraOptions.system(s)];
            this._renderOptions(n, e)
        }
        async _addDefaultOptions(t, e) {
            const i = this._app.getManager("content")
              , s = t.displayName || t.iauName
              , n = t.id;
            await this._app.getManager("scene").isReady(n);
            const o = this._app.getManager("scene").getParent(n)
              , a = i.getEntityInfo(o)
              , r = (a.displayName || a.iauName,
            [this._cameraOptions.nearObject(s, n), this._cameraOptions.aboveParent(n), this._cameraOptions.cameraFollow()]);
            "sun" !== o && r.push(this._cameraOptions.aboveSun(n)),
            this._renderOptions(r, e)
        }
        _goToView(t) {
            const e = this._optionIndexMap[t];
            if (e !== this._activeCamOptIndex) {
                this._prevCameraView = this._currentCameraView,
                this._currentCameraView = t,
                this._prevCamOptIndex = this._activeCamOptIndex,
                this._activeCamOptIndex = e;
                const i = this._activeCameraOptions[this._prevCamOptIndex];
                "function" == typeof i?.onDeselect && i.onDeselect(),
                i?.option.classList.remove("selected");
                const s = this._activeCameraOptions[this._activeCamOptIndex];
                "function" == typeof s?.onSelect && s.onSelect(),
                s?.option.classList.add("selected")
            }
        }
        goBackToPreviousView() {
            null == this._prevCameraView ? this._selectDefaultView() : this._goToView(this._prevCameraView)
        }
        goToFollowCameraView(t) {
            this._goToView("cameraFollow"),
            this._followId = t
        }
        _selectDefaultView() {
            const {defaultSelectionIndex: t} = this._config
              , e = this._activeCameraOptions[this._defaultViewIndexOverride || t];
            this._goToView(e.id)
        }
        async onRouteChange(t) {
            const e = t.entityInfo
              , {currentView: i} = this.app.getManager("router")
              , {followId: s} = this.app.getManager("router")?.query || {};
            if (!s) {
                const t = this.app.getManager("cameraFollow");
                t.isEnabled && t.setEnabled(!1, {
                    resetLimits: !1,
                    removeQueries: []
                })
            }
            this._entityId = e.id,
            this._defaultViewIndexOverride = t.defaultView || void 0;
            const n = e.category.toLowerCase()
              , o = this._app.getManager("content").getColorClass(e.id);
            this.setState({
                category: "landing site" === n ? "spacecraft" : o
            });
            let a = n;
            switch ("feature" === i && (a = "feature"),
            a) {
            case "planet":
                this._addPlanetOptions(e);
                break;
            case "moon":
                this._addMoonOptions(e);
                break;
            case "star":
                this._addStarOptions(e);
                break;
            case "spacecraft":
            case "landing site":
            case "instrument":
                await this._addSpacecraftOptions(e);
                break;
            case "feature":
                await this._addFeatureOptions(e);
                break;
            default:
                await this._addDefaultOptions(e)
            }
            void 0 !== (s && this._activeCameraOptions.find(( ({id: t}) => "cameraFollow" === t))) ? this._processQuery(t) : this._selectDefaultView(),
            this.onLoaded.forEach((t => t())),
            this.onLoaded = []
        }
        async onQueryChange(t) {
            this._processQuery(t)
        }
        _processQuery(t) {
            const e = this.app.getManager("router")
              , i = this.app.getManager("scene")
              , s = this.app.getManager("cameraFollow")
              , {query: n, params: o} = e.previousRoute
              , {query: a, params: r} = e.currentRoute
              , {followId: l} = e.parseQuery(n)
              , {followId: c} = e.parseQuery(a)
              , {spaceObject: h} = o || {};
            let {followId: d, spaceObject: u} = t;
            d = d || c;
            (d !== l || u !== h) && (void 0 !== l && i.setEntitiesForceVisible([l], !1, !1),
            d ? (i.setEntitiesForceVisible([d], !1, !0),
            s.follow(d)) : (s.setEnabled(!1, {
                resetLimits: !1,
                removeQueries: !1
            }),
            "cameraFollow" === this._currentCameraView && this._selectDefaultView()))
        }
        get isLoaded() {
            return this._activeCameraOptions.length > 0
        }
    }
    CameraViewBlock.html = o()
}
, function(t) {
    t.exports = '<div class="content-block camera-views panel-block">\n\t<h5 class="title">Camera View</h5>\n\t<ul key="cameraOptions" role="radiogroup"></ul>\n</div>'
}
, function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        SpecialFeaturesBlock: function() {
            return SpecialFeaturesBlock
        }
    });
    i(1);
    var s = i(542)
      , n = i(890)
      , o = i(988)
      , a = i.n(o);
    i(989);
    class SpecialFeaturesBlock extends n.BaseContentBlock {
        constructor(t, e) {
            super(t, e),
            this._state = {
                ...this._state,
                category: ""
            }
        }
        init() {
            super.init(),
            this._element.classList.add("special-features")
        }
        onRouteChange(t) {
            if (this._app.getManager("content").hasLanded(t))
                return void this.hide();
            if (!this._children.specialFeatures)
                return;
            this._children.specialFeatures.innerHTML = "",
            this.show();
            const e = this._app.getManager("content").getColorClass(t.id);
            this.setState({
                category: e
            });
            const i = [];
            if (!1 !== t.comparisonFeature && i.push({
                title: "Compare size",
                link: "/compare"
            }),
            !1 !== t.distanceTool && i.push({
                title: "Distance Tool",
                link: "/distance",
                options: {
                    keepTime: !0
                }
            }),
            t.hasMoons) {
                if (s.Entity.getEntityNamesInGroup(t.id + ", moons").size > 1) {
                    const e = t.displayName || t.iauName
                      , s = e + ("s" === e.slice(-1) ? "'" : "'s") + " Moons";
                    i.push({
                        title: s,
                        link: "/moons"
                    })
                }
            }
            0 !== i.length ? ("Planet" !== t.category && "moon" !== t.id || i.push({
                title: "Telescope Mode",
                link: "/telescope"
            }),
            i.forEach((e => {
                const {link: i, query: s={}, options: n={
                    __remove: "all"
                }} = e
                  , o = `/${t.id}${i}`
                  , a = document.createElement("li");
                a.classList.add("item"),
                a.classList.add("clickable"),
                a.addEventListener("click", ( () => {
                    this._app.getManager("router").navigate(s, o, n)
                }
                ), !1);
                const r = document.createElement("button");
                r.classList.add("clickable", "underline", "capitalize"),
                r.innerHTML = e.title,
                a.appendChild(r);
                const l = document.createElement("span");
                l.classList.add("icon", "icon-greater", "mobile-icon"),
                a.appendChild(l),
                this._children.specialFeatures.appendChild(a)
            }
            ))) : this.hide()
        }
    }
    SpecialFeaturesBlock.html = a()
}
, function(t) {
    t.exports = '<div>\n\t<span class="small semi color {{category}} title-underline" >\n\t\tSpecial Features\n\t</span>\n\t<ul key="specialFeatures"></ul>\n</div>\n'
}
, function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        ReplayBlock: function() {
            return ReplayBlock
        }
    });
    i(1);
    var s = i(890)
      , n = i(991)
      , o = i.n(n);
    i(992);
    class ReplayBlock extends s.BaseContentBlock {
        constructor(t) {
            super(t, null, {
                hideNextEventButton: "",
                dateText: "",
                timeText: "",
                playIconClass: "pause-icon-solid",
                isPrevBtnActive: "",
                isNextBtnActive: "",
                timeLimit: null
            }),
            this._app = t,
            this._isPlaying = {
                true: "pause-icon-solid",
                false: "play-icon-solid",
                replay: "replay-icon-solid"
            },
            this.bindFunctions(["_onSliderMove", "update", "_playEvent"])
        }
        init() {
            super.init(),
            this._callbackRegistry.push({
                emitter: this._app.getManager("time"),
                event: "update",
                callback: this.update
            })
        }
        onRouteChange(t, e, i, s, n) {
            if (n && n.isCanceled)
                return;
            const o = this._app.getManager("time");
            this._objectId = t,
            this._eventStartTime = new Date(i.start),
            this._eventEndTime = new Date(i.end);
            const a = this._app.getManager("content").orderedEvents.findIndex((t => t.id === e));
            this._currentEvent = s[a];
            const r = a < 0 || a === s.length - 1;
            this._prevEventId = 0 === a ? null : s[a - 1].id,
            this._nextEventId = r ? null : s[a + 1].id;
            const l = o.getTime().format("ll")
              , c = o.getTime().format(o.getDateFormat("time"));
            this.setState({
                dateText: l,
                timeText: c,
                isPrevBtnActive: null === this._prevEventId ? "disable" : "",
                isNextBtnActive: null === this._nextEventId ? "disable" : ""
            });
            const h = this.app.getComponent("eventsReplayClock");
            h.show(),
            h.setEnabled(!0),
            h.setParent(this._children.clockContainer),
            this._app.getComponent("clockShortcut").hide();
            const {eventInputRange: d} = this._children;
            d.value = 0,
            d.addEventListener("input", this._onSliderMove),
            d.addEventListener("mouseup", this._playEvent),
            d.addEventListener("touchend", this._playEvent),
            this.setState({
                playIconClass: this._isPlaying[this._app.pioneer.getTimeRate() > 0]
            })
        }
        _addTimeToDate(t) {
            const e = new Date(this._eventStartTime);
            let i = e.getMilliseconds();
            return i += t,
            e.setMilliseconds(i),
            e
        }
        _onSliderMove(t) {
            const e = this._eventEndTime - this._eventStartTime
              , i = this._addTimeToDate(e * (t.target.value / 100))
              , s = this._app.getManager("time").parseTime(i).format("ll");
            this.setState({
                dateText: s
            }),
            Number(t.target.value) >= 0 && this._app.getManager("time").setTime(i)
        }
        update(t) {
            this.setState({
                dateText: t.format(this._app.getManager("time").getDateFormat("date"))
            });
            const {eventInputRange: e} = this._children
              , i = this._app.getManager("time").parseTime(this._eventStartTime)
              , s = (t - i) / (this._app.getManager("time").parseTime(this._eventEndTime) - i) * 100;
            isNaN(s) || (e.value = s);
            const n = new Date(t);
            this._eventEndTime - n < 100 ? (this._app.getManager("time").pause(),
            this._isAtEnd = !0,
            this.setState({
                playIconClass: this._isPlaying.replay
            })) : (this._isAtEnd = !1,
            this.setState({
                playIconClass: this._isPlaying[0 !== this._app.pioneer.getTimeRate()]
            }))
        }
        setUpEventTimeControls() {
            const t = this._app.getComponent("eventReplayTimeControls");
            t.setState({
                isRateControlsVisible: "hidden",
                currentEvent: this._currentEvent
            }),
            t.show(),
            t.element.classList.add("event-time-controls"),
            t.setCanUpdate(!0),
            t.setEnabled(!0),
            t.setParent(this._children.eventsSliderContainer)
        }
        prevButtonClicked() {
            this._app.getComponent("eventsTimeline").goToEvent(this._prevEventId)
        }
        nextButtonClicked() {
            this._app.getComponent("eventsTimeline").goToEvent(this._nextEventId)
        }
        _pauseEvent() {
            this.setState({
                playIconClass: this._isPlaying[!1]
            }),
            this._app.getManager("time").pause()
        }
        _playEvent() {
            this.setState({
                playIconClass: this._isPlaying[!0]
            }),
            this._app.getManager("time").play()
        }
        playPauseEvent() {
            this._isAtEnd ? this._app.getView("event")?.replayEvent() : 0 === this._app.pioneer.getTimeRate() ? this._playEvent() : this._pauseEvent()
        }
    }
    ReplayBlock.html = o()
}
, function(t) {
    t.exports = '<div id="replay-block" class="content-block panel-block">\n\t<div class="date-container">\n\t\t<div class="date">{{dateText}}</div>\n\t\t<span>Â·</span>\n\t\t<time key="clockContainer" class="clock"></time>\n\t</div>\n\n\t<div key=\'eventsSliderContainer\' class="slider-container">\n\t\t<input id="event-slider-range" class=\'slider-input clickable scrollable\' key=\'eventInputRange\' type="range">\n\t</div>\n\n\t<div class="button-container">\n\t\t<button class="event-button clickable color gray med small {{isPrevBtnActive}}" onclick="prevButtonClicked">\n\t\t\t<span class="prev-icon icon next-arrow-solid"></span>\n\t\t\tPrev Event\n\t\t</button>\n\t\t<button class="clickable play-pause-button event-button" data-tippy-content="Pause / play" aria-label="Pause or play" onclick="playPauseEvent">\n\t\t\t<span class="icon {{playIconClass}}"></span>\n\t\t</button>\n\t\t<button class="event-button clickable color gray med small {{hideNextEventButton}} {{isNextBtnActive}}" onclick="nextButtonClicked">\n\t\t\tNext Event\n\t\t\t<span class="icon icon next-arrow-solid"></span>\n\t\t</button>\n\t</div>\n</div>\n'
}
, function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        LayersBlock: function() {
            return LayersBlock
        }
    });
    i(5);
    var s = i(542)
      , n = (i(1),
    i(890))
      , o = i(994)
      , a = i.n(o);
    class LayersBlock extends n.OptionsBlock {
        constructor(t) {
            super(t, null, {
                entityName: "",
                numMinorMoons: 0,
                childEntityId: null
            }),
            Object.assign(this._class, {
                isVisible: {
                    true: "",
                    false: "hidden"
                },
                showContextualLayers: {
                    true: "",
                    false: "hidden"
                }
            }),
            Object.assign(this._state, {
                showContextualLayers: this._class.showContextualLayers.false
            }),
            this._layers = {
                majorMoons: t => ({
                    id: "majorMoons",
                    text: () => {
                        let e = "Major Moon"
                          , i = 0;
                        const n = this._app.getManager("content")
                          , o = s.Entity.getEntityNamesInGroup(t + ", moons");
                        return o.forEach((t => {
                            const e = n.getEntityInfo(t);
                            e && "Major Moon" === (e.subcategory || e.category) && i++
                        }
                        )),
                        this._state.numMinorMoons = o.size - i,
                        i > 1 && (e = `Major Moons (${i})`),
                        e
                    }
                    ,
                    function: () => {
                        this._app.getManager("layer").toggleLayer("majorMoons", {
                            parentId: t
                        })
                    }
                }),
                minorMoons: t => ({
                    id: "minorMoons",
                    text: () => `Minor Moons (${this._state.numMinorMoons})`,
                    function: () => {
                        this._app.getManager("layer").toggleLayer("minorMoons", {
                            parentId: t
                        })
                    }
                }),
                orbiters: (t, e) => ({
                    id: "orbiters",
                    text: () => {
                        const {iauName: e, displayName: i} = this._app.getManager("content").getEntityInfo(t)
                          , s = i ?? e;
                        return s ? `${s} Orbiters` : "Orbiters"
                    }
                    ,
                    function: () => {
                        this._app.getManager("layer").toggleLayer("orbiters", {
                            parentId: t,
                            satelliteGroup: e
                        })
                    }
                }),
                landers: t => ({
                    id: "landers",
                    text: () => "Landers",
                    function: () => {
                        this._app.getManager("layer").toggleLayer("landers", {
                            parentId: t
                        })
                    }
                }),
                satelliteGroup: (t, e) => ({
                    id: "satelliteGroup",
                    text: () => "Satellite Group",
                    function: () => {
                        this._app.getManager("layer").toggleLayer("satelliteGroup", {
                            satelliteGroup: e
                        })
                    }
                }),
                heliosphere: t => ({
                    id: "heliosphere",
                    text: () => "Heliosphere",
                    function: () => {
                        this._app.getManager("layer").toggleLayer("heliosphere", {
                            parentId: t
                        })
                    }
                })
            },
            this._previousEntity = null,
            this._previousChildEntity = void 0,
            this._defaultLayers = [],
            this.bindFunctions(["syncSpacecraftLayer"])
        }
        init() {
            super.init(),
            this._callbackRegistry.push({
                emitter: this._app.getManager("layer"),
                event: "toggleLayer",
                callback: this.syncSpacecraftLayer
            })
        }
        _addLayerOptions(t) {
            this._children.layersList.innerHTML = "";
            for (let e = 0; e < t.length; e++) {
                const i = t[e]
                  , s = this._app.getManager("layer").getLayer(i.id).visible
                  , n = this._createCheckbox(i, s);
                n.setEnabled(!0),
                this._components.push(n),
                this._children.layersList.appendChild(n.element)
            }
        }
        _addDefaultOptions(t, e=null, i={}) {
            const s = t.id
              , n = this._app.getManager("layer").getContextualLayers(s)
              , o = i?.id ? this._app.getManager("layer").getContextualLayers(i?.id) : [];
            if (0 === n.length)
                this._children.layersList.innerHTML = "",
                this.setState({
                    showContextualLayers: this._class.showContextualLayers.false
                });
            else {
                const t = [];
                o.forEach((n => {
                    if (null === e || e.includes(n)) {
                        const e = this._layers[n](s, i?.constellation);
                        t.push(e),
                        this._defaultLayers.push(e.id)
                    }
                }
                )),
                n.forEach((n => {
                    if (null === e || e.includes(n)) {
                        const e = this._layers[n](s, i?.constellation);
                        t.push(e),
                        this._defaultLayers.push(e.id)
                    }
                }
                )),
                this._addLayerOptions(t),
                this.setState({
                    showContextualLayers: this._class.showContextualLayers.true
                })
            }
            this._setVariables(this._children.layersBlock)
        }
        onRouteChange(t, e, i=null, s={}) {
            const {id: n} = t
              , o = this._previousEntity && this._app.scene.getEntity(this._previousEntity) && this._previousEntity !== n;
            (this._previousChildEntity !== s?.id || o) && this.reset(),
            this.setState({
                entityName: e,
                childEntityId: s?.id
            }),
            this._addDefaultOptions(t, i, s);
            const a = this._app.getManager("layer");
            for (let t = 0; t < this._defaultLayers.length; t++) {
                const e = this._defaultLayers[t];
                let i = a.getLayer(e).defaultVisibility;
                ["orbiters", "landers", "satelliteGroup"].includes(e) && (i = a.getLayer("spacecraft").visible,
                "orbiters" === e && this._defaultLayers.includes("satelliteGroup") && (i = !1));
                const s = this._components.find((t => t.getConfig().key === e));
                s && s.getState("isChecked") !== i && s?.toggle()
            }
            this._previousEntity = t.id,
            this._previousChildEntity = s?.id
        }
        syncSpacecraftLayer(t, e, i) {
            if ("spacecraft" === t) {
                const t = this._components.find((t => "landers" === t.getConfig().key))
                  , i = this._components.find((t => "orbiters" === t.getConfig().key))
                  , s = this._components.find((t => "satelliteGroup" === t.getConfig().key));
                i?.isEnabled() && this.syncCheckbox(i, "orbiters", e),
                t?.isEnabled() && this.syncCheckbox(t, "landers", e),
                s?.isEnabled() && (this.syncCheckbox(s, "satelliteGroup", e),
                this.syncCheckbox(i, "orbiters", e))
            }
        }
        syncCheckbox(t, e, i) {
            t.getState("isChecked") !== i && (t.toggle(null, !0),
            this._app.getManager("layer").getLayer(e).visible = i)
        }
        reset() {
            for (let t = 0; t < this._defaultLayers.length; t++) {
                const e = this._defaultLayers[t];
                let i = this._app.getManager("layer").getLayer(e).defaultVisibility;
                ["orbiters", "landers", "satelliteGroup"].includes(e) && (i = this._app.getManager("layer").getLayer("spacecraft").visible);
                const s = this._components.find((t => t.getConfig().key === e));
                s && s.getState("isChecked") !== i && (this._app.getManager("layer").getLayer(e).visible !== i ? s?.toggle() : this.syncCheckbox(s, "heliosphere", i))
            }
            this._defaultLayers = [],
            this._components = []
        }
        __disable() {
            this._previousEntity = null,
            this._previousChildEntity = null,
            this.setState({
                entityName: null,
                childEntityId: null
            }),
            super.__disable()
        }
    }
    LayersBlock.html = a()
}
, function(t) {
    t.exports = '<div key="layersBlock" class="layers-block options-block {{showContextualLayers}}">\n\t<h5 class="title">Layer Visibility</h5>\n\t<p class="subtitle x-small">Select the related content you would like to be visible in the 3D view.</p>\n\t<ul key="layersList"></ul>\n</div>\n'
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        InstrumentFOVBlock: function() {
            return InstrumentFOVBlock
        }
    });
    var s = i(542)
      , n = i(5)
      , o = i(890)
      , a = (i(996),
    i(997))
      , r = i.n(a);
    class InstrumentFOVBlock extends o.OptionsBlock {
        constructor(t) {
            super(t, null, {
                entityName: ""
            }),
            Object.assign(this._class, {
                isVisible: {
                    true: "",
                    false: "hidden"
                }
            }),
            this._previousEntity = null,
            this._spacecraft = {
                sc_cassini: {
                    enabled: !1,
                    instruments: [{
                        id: "radar",
                        name: "Radar",
                        enabled: 1,
                        frustumType: "cone",
                        frustumLength: 4e3,
                        numConeLines: 2,
                        intersectionEntities: ["titan"],
                        spinAngle: Math.PI / 2,
                        keyframes: l,
                        instances: [{
                            fov: {
                                x: 1.3,
                                y: 1.3
                            },
                            position: new n.Vector3(0,0,-.002),
                            direction: new n.Vector3(0,-.03838,-.99926),
                            color: new n.Color(.4,.4,.15)
                        }, {
                            fov: {
                                x: 1.35,
                                y: 1.35
                            },
                            position: new n.Vector3(0,0,-.002),
                            direction: new n.Vector3(.02094,-.01484,-.99977),
                            color: new n.Color(.4,.4,.15)
                        }, {
                            fov: {
                                x: .35,
                                y: .35
                            },
                            position: new n.Vector3(0,0,-.002),
                            direction: n.Vector3.ZAxisNeg,
                            color: new n.Color(.9,.5,.3)
                        }, {
                            fov: {
                                x: 1.35,
                                y: 1.35
                            },
                            position: new n.Vector3(0,0,-.002),
                            direction: new n.Vector3(.02093,.01484,-.99976),
                            color: new n.Color(.4,.4,.15)
                        }, {
                            fov: {
                                x: 1.3,
                                y: 1.3
                            },
                            position: new n.Vector3(0,0,-.002),
                            direction: new n.Vector3(0,.03838,-.99926),
                            color: new n.Color(.4,.4,.15)
                        }]
                    }, {
                        id: "wac",
                        name: "ISS Wide-Angle Camera",
                        enabled: !1,
                        instances: [{
                            frustumType: "pyramid",
                            frustumLength: 4e3,
                            fov: {
                                x: 3.5,
                                y: 3.5
                            },
                            position: new n.Vector3(.001565,-43e-5,29e-5),
                            direction: n.Vector3.YAxisNeg,
                            color: new n.Color(0,.8,1),
                            nearBase: {
                                x: 12288e-9,
                                y: 12288e-9
                            }
                        }]
                    }, {
                        id: "nac",
                        name: "ISS Narrow-Angle Camera",
                        enabled: !1,
                        instances: [{
                            frustumType: "pyramid",
                            frustumLength: 4e3,
                            fov: {
                                x: .35,
                                y: .35
                            },
                            position: new n.Vector3(.00156,-43e-5,-1e-4),
                            direction: new n.Vector3(-426e-6,-.9999996,-822e-6),
                            color: new n.Color(0,1,.4),
                            nearBase: {
                                x: 12288e-9,
                                y: 12288e-9
                            },
                            spinAngle: .46199892
                        }]
                    }, {
                        id: "vims",
                        name: "VIMS (Visible and Infrared Mapping Spectrometer)",
                        enabled: !1,
                        instances: [{
                            frustumType: "pyramid",
                            frustumLength: 4e3,
                            fov: {
                                x: 1.83,
                                y: 1.83
                            },
                            position: new n.Vector3(.001382,-44e-5,-705e-6),
                            direction: n.Vector3.YAxisNeg,
                            color: new n.Color(.8,.2,.32),
                            nearBase: {
                                x: 25e-7,
                                y: 25e-7
                            },
                            spinAngle: Math.PI / 2
                        }]
                    }, {
                        id: "uvis",
                        name: "UVIS (Ultraviolet Imaging Spectrograph)",
                        enabled: !1,
                        frustumType: "pyramid",
                        frustumLength: 4e3,
                        direction: n.Vector3.YAxisNeg,
                        color: new n.Color(.4,.3,.7),
                        nearBase: {
                            x: 256e-7,
                            y: 64e-7
                        },
                        spinAngle: Math.PI / 2,
                        instances: [{
                            fov: {
                                x: .04297183,
                                y: 3.49504
                            },
                            position: new n.Vector3(.00105,-44e-5,15e-5),
                            hiddenPyramidEdges: [0, 1, 2, 3]
                        }, {
                            fov: {
                                x: .0859437,
                                y: 3.49504
                            },
                            position: new n.Vector3(.00105,-44e-5,1e-4),
                            hiddenPyramidEdges: [0, 1, 2, 3]
                        }, {
                            fov: {
                                x: .343775,
                                y: 3.49504
                            },
                            position: new n.Vector3(.00105,-44e-5,1e-4)
                        }, {
                            fov: {
                                x: .34377468,
                                y: .366693
                            },
                            position: new n.Vector3(.00105,-44e-5,5e-5),
                            nearBase: {
                                x: 8e-6,
                                y: 8e-6
                            }
                        }, {
                            frustumType: "cone",
                            fov: {
                                x: 3.32,
                                y: 3.32
                            },
                            position: new n.Vector3(.00105,-44e-5,0),
                            nearBase: {
                                x: 13e-6,
                                y: 13e-6
                            },
                            numConeLines: 0
                        }]
                    }]
                },
                sc_new_horizons: {
                    enabled: !1,
                    instruments: [{
                        id: "mvic",
                        name: "MVIC (Multispectral Visible Imaging Camera)",
                        enabled: !1,
                        frustumType: "pyramid",
                        frustumLength: 4e3,
                        fov: {
                            x: 5.7,
                            y: .037
                        },
                        position: new n.Vector3(-9e-4,-63e-6,.001038),
                        nearBase: {
                            x: 65312e-9,
                            y: 416e-9
                        },
                        instances: [{
                            fov: {
                                x: 5.7,
                                y: .15
                            },
                            direction: new n.Vector3(-.9999685,.0078494,-.0012505),
                            color: new n.Color(1,.84,0),
                            nearBase: {
                                x: 65312e-9,
                                y: 1664e-9
                            }
                        }, {
                            direction: new n.Vector3(-.999777,.0210862,-.0012505),
                            color: new n.Color(.87,.41,.41)
                        }, {
                            direction: new n.Vector3(-.9998146,.0192191,-.0012505),
                            color: new n.Color(.35,.46,.34)
                        }, {
                            direction: new n.Vector3(-.9998487,.0173519,-.0012505),
                            color: new n.Color(.8,.16,.16)
                        }, {
                            direction: new n.Vector3(-.9998794,.0154847,-.0012505),
                            color: new n.Color(.3,.4,.6)
                        }, {
                            direction: new n.Vector3(-.9999066,.0136174,-.0012505),
                            color: new n.Color(.71,.71,.73)
                        }, {
                            direction: new n.Vector3(-.9999303,.01175,-.0012505),
                            color: new n.Color(.71,.71,.73)
                        }]
                    }, {
                        id: "leisa",
                        name: "LEISA (Linear Etalon Imaging Spectral Array)",
                        enabled: !1,
                        instances: [{
                            frustumType: "pyramid",
                            frustumLength: 4e3,
                            fov: {
                                x: .911,
                                y: .911
                            },
                            position: new n.Vector3(-9e-4,-63e-6,.001038),
                            direction: new n.Vector3(-.9999136,.013085,-.0012696),
                            color: new n.Color(.25,.8,1),
                            nearBase: {
                                x: 1024e-8,
                                y: 1024e-8
                            }
                        }]
                    }, {
                        id: "lorri",
                        name: "LORRI (Long Range Reconnaissance Imager)",
                        enabled: !1,
                        instances: [{
                            frustumType: "pyramid",
                            frustumLength: 4e3,
                            fov: {
                                x: .29,
                                y: .29
                            },
                            position: new n.Vector3(-7e-4,-2e-5,-323e-6),
                            direction: new n.Vector3(-.9999955,3382e-7,-.0029684),
                            color: new n.Color(.51,.75,.59),
                            nearBase: {
                                x: 133e-7,
                                y: 133e-7
                            }
                        }]
                    }, {
                        id: "alice",
                        name: "Alice (UV Spectrometer)",
                        enabled: !1,
                        frustumType: "pyramid",
                        frustumLength: 4e3,
                        position: new n.Vector3(-85e-5,3e-4,995e-6),
                        color: new n.Color(.65,.45,1),
                        spinAngle: -.0349066,
                        instances: [{
                            fov: {
                                x: 4,
                                y: .1
                            },
                            direction: new n.Vector3(-.9997723,8516e-7,.0213245),
                            hiddenPyramidEdges: [1, 2]
                        }, {
                            fov: {
                                x: 2,
                                y: 2
                            },
                            direction: new n.Vector3(-.9995182,.0025548,-.0310288)
                        }]
                    }]
                },
                sc_europa_clipper: {
                    enabled: !1,
                    instruments: [{
                        id: "wac",
                        name: "EIS WAC (Europa Imaging System)",
                        enabled: !1,
                        instances: [{
                            frustumType: "pyramid",
                            frustumLength: 4e3,
                            fov: {
                                x: 48,
                                y: 28
                            },
                            position: new n.Vector3(-43e-5,.0013,.00212),
                            direction: n.Vector3.YAxis,
                            color: new n.Color(.678,.435,.231),
                            nearBase: {
                                x: 4096e-8,
                                y: 2048e-8
                            },
                            spinAngle: Math.PI / 2
                        }]
                    }, {
                        id: "nac",
                        name: "EIS NAC (Europa Imaging System)",
                        enabled: !1,
                        instances: [{
                            frustumType: "pyramid",
                            frustumLength: 4e3,
                            fov: {
                                x: 2.3,
                                y: 1.2
                            },
                            position: new n.Vector3(-393e-6,.0016,.001407),
                            direction: n.Vector3.YAxis,
                            color: new n.Color(.204,.455,.831),
                            nearBase: {
                                x: 4e-5,
                                y: 2e-5
                            },
                            spinAngle: Math.PI / 2
                        }]
                    }, {
                        id: "e-themis",
                        name: "E-THEMIS (Thermal Emission Imaging System)",
                        enabled: !1,
                        frustumType: "pyramid",
                        frustumLength: 4e3,
                        fov: {
                            x: 5.7,
                            y: 1
                        },
                        position: new n.Vector3(-18e-5,.00125,.002069),
                        color: new n.Color(.45,.65,.45),
                        nearBase: {
                            x: 168e-8,
                            y: 1104e-8
                        },
                        instances: [{
                            direction: new n.Vector3(0,.9995854,-.028794)
                        }, {
                            direction: n.Vector3.YAxis,
                            spinAngle: Math.PI / 2
                        }, {
                            direction: new n.Vector3(0,.9995854,.028794)
                        }]
                    }, {
                        id: "uvs",
                        name: "Europa Ultraviolet Spectrograph (Europa-UVS)",
                        enabled: !1,
                        frustumType: "pyramid",
                        frustumLength: 4e3,
                        position: new n.Vector3(-67e-5,.00135,.002),
                        color: new n.Color(.486,.306,.639),
                        instances: [{
                            fov: {
                                x: 7.3,
                                y: .1
                            },
                            direction: new n.Vector3(0,.9999452,.0104718),
                            hiddenPyramidEdges: [3, 4]
                        }, {
                            fov: {
                                x: .2,
                                y: .2
                            },
                            direction: new n.Vector3(.0645288,.9978609,.0104718),
                            spinAngle: .13
                        }]
                    }, {
                        id: "mise",
                        name: "MISE (Mapping Imaging Spectrometer)",
                        enabled: !1,
                        instances: [{
                            frustumType: "pyramid",
                            frustumLength: 4e3,
                            position: new n.Vector3(39e-5,.0011,.00194),
                            color: new n.Color(.395,.13,.195),
                            fov: {
                                x: 4.3,
                                y: .007
                            },
                            direction: n.Vector3.YAxis,
                            nearBase: {
                                x: 96e-7,
                                y: 144e-7
                            },
                            spinAngle: Math.PI / 2
                        }]
                    }]
                }
            },
            this._instrumentCheckboxes = []
        }
        hasInstrumentsWithFOV(t) {
            return void 0 !== this._spacecraft[t]
        }
        init() {
            super.init()
        }
        onRouteChange(t, e) {
            const i = t.id;
            this._previousEntity && this._previousEntity !== i && this.reset(),
            this.setState({
                entityName: e
            });
            const s = this._spacecraft[i];
            s ? (this._addInstrumentOptions(i, s),
            this._previousEntity = i,
            this._setVariables(this._children.instrumentFOVBlock)) : this._children.instrumentsList.innerHTML = ""
        }
        _addInstrumentOptions(t, e) {
            this._children.instrumentsList.innerHTML = "",
            this.reset();
            const i = e.instruments;
            if (void 0 === i)
                return void console.warn(`Spacecraft ${t} is missing instruments`);
            const s = t => t.keyframes || t.instances.some((t => t.keyframes))
              , n = t => "number" == typeof t ? t : t ? 2 : 0;
            i.forEach((t => {
                void 0 === t.enabled && (t.enabled = !1),
                s(t) && (t.enabled = n(t.enabled))
            }
            ));
            const o = i.every(s);
            let a;
            const r = i => {
                e.enabled = i,
                this._instrumentCheckboxes.forEach(( ({instrument: s, checkbox: o}) => {
                    (a.cycle ? i !== s.enabled : n(i) !== n(s.enabled)) && (o.cycle ? (s.enabled = n(i),
                    o.cycle(null, !0, s.enabled)) : (s.enabled = i,
                    o.toggle(null, !0)),
                    this._toggleFrustums(t, s, e.enabled))
                }
                ))
            }
              , l = t => ({
                key: "allInstruments",
                text: () => "All Instruments",
                function: () => r(t())
            });
            o ? (e.enabled = n(e.enabled),
            a = this._createMultistateCheckbox(l(( () => a.getCurrentStateIndex())), 3, e.enabled),
            a.setClassesForIndex({
                checkbox: "checked",
                icon: "fov-coverage"
            }, 1)) : a = this._createCheckbox(l(( () => !e.enabled)), e.enabled),
            a.setEnabled(!0),
            this._children.instrumentsList.appendChild(a.element),
            i.forEach((i => {
                let o;
                const r = s => {
                    i.enabled = s;
                    const o = !this._instrumentCheckboxes.some(( ({instrument: t}) => 2 !== n(t.enabled)))
                      , r = !this._instrumentCheckboxes.some(( ({instrument: t}) => 1 !== n(t.enabled)));
                    if (a.cycle) {
                        const t = o ? 2 : r ? 1 : 0;
                        e.enabled !== t && (e.enabled = t,
                        a.cycle(null, !0, e.enabled))
                    } else
                        e.enabled !== o && (e.enabled = o,
                        a.toggle(null, !0, e.enabled));
                    this._toggleFrustums(t, i, e.enabled)
                }
                  , l = t => ({
                    key: i.id,
                    text: () => i.name,
                    function: () => r(t())
                });
                s(i) ? (o = this._createMultistateCheckbox(l(( () => o.getCurrentStateIndex())), 3, n(e.enabled || i.enabled)),
                o.setClassesForIndex({
                    checkbox: "checked",
                    icon: "fov-coverage"
                }, 1)) : o = this._createCheckbox(l(( () => !i.enabled)), e.enabled || i.enabled),
                this._toggleFrustums(t, i, e.enabled),
                o.setEnabled(!0),
                this._children.instrumentsList.appendChild(o.element),
                this._instrumentCheckboxes.push({
                    instrument: i,
                    checkbox: o
                })
            }
            ))
        }
        _toggleFrustums(t, e, i=!1) {
            const n = this._app.scene.getEntity(t);
            i || e.enabled ? e.instances.forEach(( (t, i) => {
                const o = `${e.id}_${i}`;
                let a = n.getComponent(s.FrustumComponent, o);
                if (!a) {
                    a = n.addComponent(s.FrustumComponent, o);
                    const i = {
                        frustumType: t => a.setFrustumType(t),
                        color: t => a.setColor(t),
                        position: t => a.setOriginOffset(t),
                        direction: t => a.setDirection(t),
                        fov: t => a.setFOVDegrees(t.x, t.y),
                        nearBase: t => a.setNearBase(t.x, t.y),
                        farBase: t => a.setFarBase(t.x, t.y),
                        frustumLength: t => a.setLength(t),
                        spinAngle: t => a.setSpinAngle(t),
                        numConeLines: t => a.setNumConeLines(t),
                        numCirlePoints: t => a.setNumberOfCirclePoints(t),
                        intersectionEntities: t => a.setIntersectionEntities(t),
                        hiddenPyramidEdges: t => a.setHiddenPyramidEdges(t),
                        keyframes: t => a.setKeyframes(t)
                    };
                    Object.entries(i).forEach(( ([i,s]) => {
                        const n = t[i] ?? e[i];
                        void 0 !== n && s(n)
                    }
                    ))
                }
                "number" == typeof e.enabled && (t.keyframes || e.keyframes) && a.setUseKeyframes(1 === e.enabled),
                a.setEnabled(!0)
            }
            )) : e.instances.forEach(( (t, i) => {
                const o = n.getComponent(s.FrustumComponent, `${e.id}_${i}`);
                o && o.setEnabled(!1)
            }
            ))
        }
        reset() {
            this._instrumentCheckboxes = [],
            this._triggeredByInstrumentCheckbox = !1,
            this._triggeredByAllCheckbox = !1
        }
        __disable() {
            this._previousEntity = null,
            this.setState({
                entityName: null
            }),
            super.__disable()
        }
    }
    const l = [[152076418.941, 152077844.412], [161721448.394, 161724013.234], [179351880.56, 179352668.353], [183743728.557, 183746127.345], [199702044.251, 199703987.076], [206798889.687, 206801144.93200004], [210932215.601, 210932517.45200002], [212309741.233, 212310243.7950001], [213685760.527, 213688255.84599993], [219195475.712, 219197059.475], [221948389.032, 221950786.682], [225384888.335, 225387096.692], [229516775.022, 229519123.281], [230894296.139, 230896399.898], [232272791.587, 232273835.696], [244571878.159, 244572546.418], [251462344.531, 251463838.295], [256972389.815, 256974676.527], [263857450.298, 263859678.339], [265234202.56, 265236244.55], [281758018.902, 281759595.803], [283135322.768, 283137674.735], [287268409.109, 287269025.629], [296212054.577, 296214379.301], [297589376.218, 297591620.304], [298967209.919, 298970186.382], [300343766.246, 300345887.534], [301721355.559, 301722016.9010002], [304475666.639, 304477841.213], [315231186.563, 315232652.162], [316609663.387, 316610787.603], [331733884.384, 331734589.517], [361865506.41000015, 361866749.799], [390920724.199, 390922243.28], [392298523.298, 392300869.696], [422601256.394, 422602979.474], [426733393.407, 426735687.991], [434998223.861, 434999085.116], [444640446.583, 444641556.386], [461880883.82, 461881966.261], [546113407.629, 546114474.108]];
    InstrumentFOVBlock.html = r()
}
, function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t) {
    t.exports = '<div key="instrumentFOVBlock" class="instrument-fov-block options-block">\n\t<h5 class="title">Instrument Field of View</h5>\n\t<p class="subtitle x-small">Select instruments to see their coverage. Instruments labeled "AUTO" will be enabled by default by the spacecraft when they are being used.</p>\n\t<ul key="instrumentsList"></ul>\n</div>\n'
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        SurfaceMapBlock: function() {
            return SurfaceMapBlock
        }
    });
    var s = i(5)
      , n = i(1)
      , o = i(890)
      , a = i(999)
      , r = i.n(a);
    class SurfaceMapBlock extends o.OptionsBlock {
        constructor(t) {
            super(t, null, {
                entityName: "",
                childEntityId: null,
                featureRoute: null
            }),
            Object.assign(this._class, {
                isVisible: {
                    true: "",
                    false: "hidden"
                },
                showSurfaceMaps: {
                    true: "",
                    false: "hidden"
                },
                showSubtitle: {
                    true: "",
                    false: "hidden"
                }
            }),
            Object.assign(this._state, {
                showSurfaceMaps: this._class.showSurfaceMaps.false,
                showSubtitle: this._class.showSubtitle[!(n.AppUtils.isMobile() || n.AppUtils.isTablet())]
            }),
            this._defaultTextureDescription = null,
            this._currentlyCheckedOption = "default",
            this._previousEntity = null,
            this._previousChildEntity = void 0
        }
        async onRouteChange(t, e, i=null, s={}, o=null) {
            const {id: a} = t;
            this._currentLayer = this._app.getManager("layer").getCurrentSurfaceLayer(),
            this.setState({
                entityName: e,
                childEntityId: s?.id,
                featureRoute: o,
                showSubtitle: this._class.showSubtitle[!(n.AppUtils.isMobile() || n.AppUtils.isTablet())]
            }, ( () => {
                this._currentlyCheckedOption = "default",
                this.addSurfaceMaps(a)
            }
            )),
            await this._app.getManager("scene").updateHDTarget(t, t.id),
            this._previousEntity = a,
            this._previousChildEntity = s?.id,
            this._setVariables(this._children.surfaceMapBlock)
        }
        addSurfaceMaps(t) {
            this._children.surfaceMapList.innerHTML = "";
            const e = this._app.getManager("content").getSpheroidLayers(t);
            void 0 === e ? this.setState({
                showSurfaceMaps: this._class.showSurfaceMaps.false
            }) : (this.addDefaultTexture(t),
            this._createDefaultRadioButton(t),
            e.forEach((e => {
                const i = this._createRadioButton(e);
                i.addEventListener("click", ( () => {
                    this._app.getManager("layer").changeSpheroidMap(t, e),
                    document.getElementById("default-map-radio-button")?.blur(),
                    this._currentlyCheckedOption = e.id;
                    const i = new CustomEvent("surfaceMapEnabled",{
                        detail: e
                    });
                    window.dispatchEvent(i)
                }
                )),
                this._children.surfaceMapList.appendChild(i);
                const s = Array.from(i.children).find((t => t.id === `${this._currentLayer}-radio-button`));
                s && s.click();
                const {configs: n} = this._app.getManager("router");
                if (!0 === n.surfaceMapTiling && "wmts" === e.type) {
                    Array.from(i.children).find((t => t.id === `${e.id}-radio-button`))?.click()
                }
            }
            )),
            this.setState({
                showSurfaceMaps: this._class.showSurfaceMaps.true
            }))
        }
        _createDefaultRadioButton(t) {
            const e = document.createElement("li");
            e.className = "option radio-option clickable";
            const i = "default-map-radio-button"
              , s = document.createElement("label");
            s.innerText = "Default Map",
            s.setAttribute("for", i);
            const n = document.createElement("input");
            n.id = i,
            n.className = "radio-button clickable",
            n.type = "radio",
            n.name = "radio-layers",
            n.checked = "default" === this._currentlyCheckedOption,
            e.appendChild(n),
            e.appendChild(s),
            e.addEventListener("click", ( () => {
                !this._defaultTextureDescription && this.addDefaultTexture(t),
                this._defaultTextureDescription && this._app.getManager("layer").changeSpheroidMap(t, this._defaultTextureDescription);
                const e = new CustomEvent("surfaceMapEnabled",{
                    detail: this._defaultTextureDescription
                });
                window.dispatchEvent(e),
                n.blur(),
                this._currentlyCheckedOption = "default"
            }
            ));
            const o = document.createElement("span");
            o.className = "radio-icon bg-color",
            e.appendChild(o),
            this._children.surfaceMapList.appendChild(e)
        }
        addDefaultTexture(t) {
            const e = this._app.pioneer.getScene("main").getEntity(t)?.getComponent(s.AtmosphereComponent);
            let i = ["shadowEntities"];
            e?.isEnabled() && (i = ["shadowEntities", "atmosphere"]),
            this._defaultTextureDescription = this._app.getManager("content").getSpheroidDefaultTextureInformation(t, i),
            this._defaultTextureType = "texture"
        }
        resize() {
            super.resize(),
            this.setState({
                showSubtitle: this._class.showSubtitle[!(n.AppUtils.isMobile() || n.AppUtils.isTablet())]
            })
        }
        reset() {
            const {surfaceMapTiling: t} = this.app.getManager("router").configs;
            !this._defaultTextureDescription && this.addDefaultTexture(this._previousEntity),
            null !== this._defaultTextureDescription && !0 !== t && (this.addSurfaceMaps(this._previousEntity),
            this._app.getManager("layer").changeSpheroidMap(this._previousEntity, this._defaultTextureDescription)),
            this._defaultTextureDescription = null
        }
        __disable() {
            this._previousEntity = null,
            this._previousChildEntity = null,
            this.setState({
                entityName: null,
                childEntityId: null
            }),
            super.__disable()
        }
    }
    SurfaceMapBlock.html = r()
}
, function(t) {
    t.exports = '<div key="surfaceMapBlock" class="surface-map-block options-block {{showSurfaceMaps}}">\n\t<h5 class="title">Surface Map</h5>\n\t<p class="subtitle x-small grayMed {{showSubtitle}}">Select the map you would like to be projected onto the surface of the globe.</p>\n\t<ul key="surfaceMapList" class="radio-button-list"></ul>\n</div>\n'
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        TextureQualityBlock: function() {
            return TextureQualityBlock
        }
    });
    i(1);
    var s = i(890)
      , n = i(1001)
      , o = i.n(n)
      , a = (i(1002),
    i(542));
    class TextureQualityBlock extends s.OptionsBlock {
        constructor(t) {
            super(t, null, {}),
            Object.assign(this._class, {
                isVisible: {
                    true: "",
                    false: "hidden"
                },
                showContextualLayers: {
                    true: "",
                    false: "hidden"
                }
            }),
            Object.assign(this._state, {
                showContextualLayers: this._class.showContextualLayers.false
            }),
            this._previousEntity = null,
            this._previousChildEntity = void 0,
            this._defaultOptions = {
                hdToggle: {
                    text: "High Definition",
                    function: () => {
                        this._toggleHD()
                    }
                    ,
                    customURLBehavior: {
                        hd: async (t, e) => {
                            const i = this._app.pioneer.getScene("main").getEntity(this._hdToggleEntity).getComponent(a.WMTSComponent);
                            if (!i || !i.isEnabled()) {
                                const i = await this._app.getManager("scene").isEntityHD(this._hdToggleEntity);
                                e && !0 === t && (e.checked = t,
                                i || this._toggleHD())
                            }
                        }
                    },
                    customEventListeners: {
                        surfaceMapEnabled: async t => {
                            const e = t.detail;
                            if (e) {
                                const {configs: t} = this._app.getManager("router")
                                  , i = document.getElementById("hdToggle")
                                  , s = await this._app.getManager("scene").isEntityHD(this._hdToggleEntity);
                                document.getElementById("hdToggle-container")?.classList.toggle("disabled", "wmts" === e.type),
                                i && (i.checked = !1,
                                !0 !== t.hd || s || (this._toggleHD(),
                                i.checked = !0))
                            }
                        }
                    }
                }
            }
        }
        _addDefaultOptions() {
            this._children.optionsList.innerHTML = "";
            for (const [t,e] of Object.entries(this._defaultOptions)) {
                const {container: i, input: s} = this._createToggle(t, e.text);
                if (i?.addEventListener("click", (i => {
                    const s = document.getElementById(t);
                    e.function(),
                    s && (s.checked = !s.checked)
                }
                )),
                e.customURLBehavior) {
                    const {configs: t} = this._app.getManager("router");
                    for (const [i,n] of Object.entries(e.customURLBehavior))
                        Object.keys(t).includes(i) && i && n(t[i], s)
                }
                if (e.customEventListeners)
                    for (const [t,i] of Object.entries(e.customEventListeners))
                        window.addEventListener(t, (t => {
                            i(t)
                        }
                        ));
                this._children.optionsList.appendChild(i)
            }
        }
        async _toggleHD() {
            null !== this._hdToggleEntity && void 0 !== this._hdToggleEntity && await this.app.getManager("scene").toggleHDTextureForEntity(this._hdToggleEntity)
        }
        onRouteChange(t, e, i=null, s={}) {
            const n = this._previousEntity && this._app.scene.getEntity(this._previousEntity) && this._previousEntity !== t.id;
            (this._previousChildEntity !== s?.id || n) && this.reset(),
            this._hdToggleEntity = t.id,
            this._addDefaultOptions(),
            this._previousEntity = t.id,
            this._previousChildEntity = s?.id
        }
        __disable() {
            this._previousEntity = null,
            this._previousChildEntity = null,
            super.__disable()
        }
    }
    TextureQualityBlock.html = o()
}
, function(t) {
    t.exports = '<div key="textureQualityBlock" class="texture-block options-block">\n\t<h5 class="title">Texture Quality</h5>\n\t<p class="subtitle x-small"></p>\n\t<ul key="optionsList"></ul>\n</div>\n'
}
, function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        FeaturesBlock: function() {
            return FeaturesBlock
        }
    });
    i(1);
    var s = i(542)
      , n = i(890)
      , o = i(1004)
      , a = i.n(o);
    class FeaturesBlock extends n.OptionsBlock {
        constructor(t) {
            super(t, null, {}),
            Object.assign(this._class, {
                checkbox: {
                    true: "icon-checkmark",
                    false: "checkbox-hover"
                },
                isVisible: {
                    true: "active",
                    false: "hidden"
                },
                showFeatures: {
                    true: "active",
                    false: "hidden"
                }
            })
        }
        addFeatures(t) {
            this._children.featuresList.innerHTML = "";
            const e = this._app.getManager("content")
              , i = this._app.getManager("scene")
              , n = e.getSpheroidFeatures(t);
            if (void 0 === n)
                this.setState({
                    showFeatures: this._class.showFeatures.false
                });
            else {
                document.createElement("li").className = "coption checkbox-list clickable",
                n.forEach((e => {
                    e.function = () => {
                        const n = s.Features.isEnabled(i.main, t, e.id);
                        s.Features.setEnabled(i.main, t, e.id, !n)
                    }
                    ,
                    e.text = () => e.title;
                    const n = s.Features.isEnabled(i.main, t, e.id)
                      , o = this._createCheckbox(e, n);
                    this._children.featuresList.appendChild(o.element)
                }
                )),
                this._setVariables(this._children.featuresBlock)
            }
        }
        async onRouteChange(t) {
            const e = this._app.getManager("content")
              , i = this._app.getManager("scene").get("main").getEntity(t.id)?.getParent()?.getName()
              , s = this._previousEntity && this._app.scene.getEntity(this._previousEntity);
            null !== this._defaultTextureDescription && s && this._app.getManager("layer").changeSpheroidMap(this._previousEntity, this._defaultTextureDescription),
            this._defaultTextureDescription = null,
            this._previousEntity = t.id;
            let n = "";
            if (0 !== e.getSpheroidFeatures(t.id)?.length)
                n = t.id;
            else if (0 !== e.getSpheroidFeatures(i)?.length) {
                n = e.getEntityInfo(i).id
            }
            this.addFeatures(n)
        }
    }
    FeaturesBlock.html = a()
}
, function(t) {
    t.exports = '<div key="featuresBlock" class="content-block options-block">\n\t<h5 class="title {{showFeatures}}" >Features</h5>\n\t<ul key="featuresList" class="checkbox-list"></ul>\n</div>\n'
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        RelatedBlock: function() {
            return RelatedBlock
        }
    });
    var s = i(1)
      , n = i(890)
      , o = i(1006)
      , a = i.n(o);
    i(1007);
    class RelatedBlock extends n.BaseContentBlock {
        constructor(t) {
            super(t, null, {
                relatedMessage: "Related"
            });
            const e = s.AppUtils.isMobile() || s.AppUtils.isTabletPortrait();
            this.setState({
                showTitleLabel: e ? "hidden" : ""
            })
        }
        onRouteChange(t, e, i, n) {
            const o = s.AppUtils.isMobile() || s.AppUtils.isTabletPortrait();
            null !== this._children.relatedList && (this._children.relatedList.innerHTML = "",
            this.populateStoryCard(i),
            void 0 !== e && 0 !== e.length ? (this.setState({
                moreShowing: !1,
                moreMessage: "Show More",
                moreIcon: "icon-plus",
                relatedMessage: t,
                showTitleLabel: o ? "hidden" : ""
            }),
            e.forEach((t => {
                const e = this._app.getManager("content").getEntityInfo(t);
                if (null !== e) {
                    const i = this._app.getManager("content").getCategoryShapeMap()
                      , s = i[e.category] ? i[e.category].shape : "circle"
                      , n = i[e.category] ? i[e.category].color : "brown"
                      , o = document.createElement("li")
                      , a = document.createElement("span");
                    a.classList.add("shape"),
                    a.classList.add(s),
                    n && a.classList.add(n),
                    o.appendChild(a),
                    o.appendChild(document.createTextNode(e.displayName ?? e.iauName)),
                    o.addEventListener("click", ( () => {
                        this._app.getManager("router").navigate(t)
                    }
                    ), !1),
                    o.setAttribute("data-value", t),
                    o.classList.add("item"),
                    o.classList.add("clickable"),
                    this._children.relatedList.appendChild(o)
                }
            }
            ))) : this.hide())
        }
        populateStoryCard(t) {
            if (this._storyList && (this._storyList.innerHTML = ""),
            null !== t && t?.length > 0) {
                if (this._storyList = this._children.storyList,
                null === this._storyList || void 0 === this._storyList)
                    return void this.setEnabled(!1);
                t.forEach((e => {
                    const i = document.createElement("li")
                      , s = e.storyId && t.hasOwn(e.storyId) ? t[e.storyId] : e
                      , {title: n, subtitle: o, icon: a, link: r, isExternal: l, isInternal: c} = s
                      , h = document.createElement("div");
                    h.classList.add("story-container");
                    const d = document.createElement("div");
                    d.appendChild(document.createTextNode((e.isExternal ? "External" : "") + " Story")),
                    d.classList.add("story-tag"),
                    h.appendChild(d),
                    i.appendChild(h);
                    const u = document.createElement("div");
                    u.classList.add("story-title");
                    const p = document.createElement("h2");
                    if (p.appendChild(document.createTextNode(n)),
                    u.appendChild(p),
                    h.appendChild(u),
                    o) {
                        const t = document.createElement("div");
                        t.classList.add("story-list", "story-subtitle", "wide-text", "color", "x-small"),
                        t.appendChild(document.createTextNode(o)),
                        h.appendChild(t)
                    }
                    const m = document.createElement("div");
                    m.classList.add("story-icon");
                    const _ = document.createElement("img")
                      , g = `${o}: ${n}`;
                    if (_.setAttribute("alt", g),
                    _.setAttribute("src", a),
                    _.classList.add("story-icon-image"),
                    m.appendChild(_),
                    h.appendChild(m),
                    l)
                        i.addEventListener("click", ( () => {
                            window.open(r)
                        }
                        ), !1);
                    else if (c)
                        i.addEventListener("click", ( () => {
                            this._app.getManager("router").navigate(r)
                        }
                        ), !1);
                    else {
                        const t = "story/" + e.id;
                        i.addEventListener("click", ( () => {
                            this._app.getManager("router").navigate(t)
                        }
                        ), !1)
                    }
                    if (l) {
                        const t = document.createElement("div");
                        t.classList.add("icon", "icon-external"),
                        h.appendChild(t)
                    }
                    i.classList.add("clickable"),
                    this._storyList.appendChild(i)
                }
                ))
            }
        }
        resize() {
            const t = s.AppUtils.isMobile() || s.AppUtils.isTabletPortrait();
            this.setState({
                showTitleLabel: t ? "hidden" : ""
            })
        }
    }
    RelatedBlock.html = a()
}
, function(t) {
    t.exports = '<div key="relatedBlock" class="related-block">\n\t<h5 class="title {{showTitleLabel}}">Related</h5>\n\t<div key="storyBlock" class="related-story-block">\n\t\t<ul key="storyList" id="story-list" class="story-list"> </ul>\n\t</div>\n\t<ul id="content-related-list" key="relatedList" class="list color gray med"></ul>\n</div>'
}
, function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        ContentPanel: function() {
            return ContentPanel
        }
    });
    i(897);
    var s = i(900)
      , n = i(542)
      , o = i(1)
      , a = i(890)
      , r = i(1009)
      , l = i.n(r);
    i(1010);
    const c = {
        info: {
            subtabs: {
                about: []
            },
            contentBlocks: ["overview", "description"]
        },
        toolbox: {
            subtabs: {},
            contentBlocks: []
        },
        viewOptions: {
            subtabs: {
                camera: ["cameraView"]
            },
            contentBlocks: ["cameraView"]
        }
    }
      , h = ["toolbox"]
      , d = "info";
    class ContentPanel extends o.BaseComponent {
        constructor(t, e) {
            super(t, null, {
                title: "",
                isOverlay: !1,
                isOverlayClass: "",
                backButtonVisibleClass: "",
                backButtonText: "Back",
                scrollToTopVisible: "hidden",
                subtabsVisible: "hidden",
                ...e
            }),
            this._class.isOverlay = {
                true: "overlay",
                false: ""
            },
            this._class.isExpanded = {
                true: "expanded",
                false: ""
            },
            this._class.iconExpand = {
                mid: "arrow-line-up",
                bottom: "caret-up",
                left: "icon-expand-side"
            },
            this._class.isCollapsed = {
                true: "collapsed",
                false: ""
            },
            this._class.iconCollapse = {
                top: "caret-down",
                mid: "arrow-line-down",
                left: "caret-double-left"
            },
            this._backRoute = this._state.backButtonRoute || "#",
            this._backButtonVisibleClass = "",
            this._class.isScrollToTopVisible = {
                true: "active",
                false: "hidden"
            },
            this._defaultState = {
                backButtonVisibleClass: this._backButtonVisibleClass,
                scrollToTopVisible: this._class.isScrollToTopVisible.false,
                title: ""
            },
            this._blockState = {
                overviewBlock: !1,
                descriptionBlock: !1,
                relatedBlock: !1,
                eventsBlock: !1,
                cameraViewBlock: !1,
                featuredMoonsBlock: !1,
                surfaceMapBlock: !1,
                instrumentFOVBlock: !1,
                layersBlock: !1,
                textureQualityBlock: !1,
                compareSizeBlock: !1,
                distanceToolBlock: !1,
                moonsBlock: !1,
                telescopeModeBlock: !1,
                replayBlock: !1,
                featuresBlock: !1
            },
            this._components = Object.keys(this._blockState),
            this._eventNames.push("overlay", "expandtoggle"),
            this._initCallbacks(),
            this._currentId = "",
            this._overviewBlock = null,
            this._cameraViewBlock = null,
            this._descriptionBlock = null,
            this._relatedBlock = null,
            this._eventsBlock = null,
            this._featuredMoonsBlock = null,
            this._instrumentFOVBlock = null,
            this._layersBlock = null,
            this._surfaceMapBlock = null,
            this._textureQualityBlock = null,
            this._compareSizeBlock = null,
            this._distanceToolBlock = null,
            this._moonsBlock = null,
            this._telescopeModeBlock = null,
            this._replayBlock = null,
            this._featuresBlock = null,
            this._mainViewportEl = null,
            this._pioneerParentEl = null;
            const i = Object.keys(c).reduce(( (t, e) => ({
                ...t,
                [e + "TabVisibleClass"]: this._class.isVisible[!0]
            })), {})
              , n = o.AppUtils.isMobile() || o.AppUtils.isTablet();
            this.setState({
                ...i,
                selectedTab: null,
                selectedSubtab: null,
                currentMainTab: d,
                infoSelectedClass: "",
                toolboxSelectedClass: "",
                viewOptionsSelectedClass: "",
                isExpanded: !n,
                isExpandedClass: this._class.isExpanded[!n],
                iconExpandClass: this._class.iconExpand[n ? "mid" : "left"],
                isCollapsed: n,
                isCollapsedClass: this._class.isCollapsed[n],
                iconCollapseClass: this._class.iconCollapse.left,
                tabsVisible: ""
            }),
            s.default.setDefaultProps({
                theme: "default",
                touch: ["hold", 2e3],
                delay: [600, null],
                plugins: [s.followCursor]
            }),
            this._scrollbar = null,
            this._isDragging = !1,
            this._snapHeights = {
                index: -1,
                value: []
            },
            this._adjustedMobileHeight = 0,
            this._resizeTimeoutAmount = 300,
            this.bindFunctions(["backRoute", "selectTab", "_onTabSelect", "onClickShowCollapse", "onDragStart", "onDrag", "onDragEnd", "collapse", "expand", "onChildParentChange", "clearPanel", "_setUpMobileCollapse"])
        }
        getScrollbar() {
            return this._scrollbar
        }
        _showTab(t) {
            this.setState({
                [t + "TabVisibleClass"]: this._class.isVisible[!0]
            })
        }
        _hideTab(t) {
            this.setState({
                [t + "TabVisibleClass"]: this._class.isVisible[!1]
            })
        }
        async init() {
            super.init(),
            this._overviewBlock = await this._app.addComponent("overviewBlock", a.OverviewBlock),
            this._descriptionBlock = await this._app.addComponent("descriptionBlock", a.DescriptionBlock),
            this._relatedBlock = await this._app.addComponent("relatedBlock", a.RelatedBlock),
            this._eventsBlock = await this._app.addComponent("eventsBlock", a.EventsBlock),
            this._replayBlock = await this._app.addComponent("replayBlock", a.ReplayBlock),
            this._featuredMoonsBlock = await this._app.addComponent("featuredMoonsBlock", a.FeaturedMoonsBlock),
            this._compareSizeBlock = await this._app.addComponent("compareSizeBlock", a.ToolboxBlock, {
                iconClass: "compare-size",
                title: "Compare Size"
            }),
            this._distanceToolBlock = await this._app.addComponent("distanceToolBlock", a.ToolboxBlock, {
                iconClass: "distance-tool",
                title: "Distance Tool"
            }),
            this._moonsBlock = await this._app.addComponent("moonsBlock", a.ToolboxBlock, {
                iconClass: "shape crescent",
                title: "Moons"
            }),
            this._telescopeModeBlock = await this._app.addComponent("telescopeModeBlock", a.ToolboxBlock, {
                iconClass: "telescope-mode",
                title: "Telescope Mode"
            }),
            this._cameraViewBlock = await this._app.addComponent("cameraViewBlock", a.CameraViewBlock),
            this._surfaceMapBlock = await this._app.addComponent("surfaceMapBlock", a.SurfaceMapBlock),
            this._instrumentFOVBlock = await this._app.addComponent("instrumentFOVBlock", a.InstrumentFOVBlock),
            this._layersBlock = await this._app.addComponent("layersBlock", a.LayersBlock),
            this._textureQualityBlock = await this._app.addComponent("textureQualityBlock", a.TextureQualityBlock),
            this._featuresBlock = await this._app.addComponent("featuresBlock", a.FeaturesBlock),
            (0,
            s.default)(this._children.expandButton, {
                content: "Expand content panel.",
                placement: "top"
            }),
            (0,
            s.default)(this._children.collapseButton, {
                content: "Collapse content panel.",
                placement: "top"
            }),
            this._isMobile = o.AppUtils.isMobile() || o.AppUtils.isTablet(),
            this._isLandscape = o.AppUtils.isLandscape(),
            this._tabContent = o.AppUtils.deepClone(c),
            this.setState({
                isCollapsed: this._isMobile
            }),
            this._isMobile && this._app.getComponent("collapsibleMenu").collapse(),
            this.resize()
        }
        _onRouteChange(t, e) {
            this.isEnabled() && (this._disableAllComponents(),
            this._defaultState.title = "",
            this._currentId = t,
            this.setupBackButton(e),
            this._tabContent = o.AppUtils.deepClone(c),
            this.selectTab(d),
            this._persistingBlocks = [])
        }
        getParentTabOfSubtab(t) {
            for (const [e,i] of Object.entries(this._tabContent))
                if (Object.keys(i.subtabs).includes(t))
                    return e;
            return ""
        }
        selectTab(t, e=!0) {
            const i = t === this._state.currentMainTab
              , s = this.getParentTabOfSubtab(t)
              , n = e ? t : s;
            let o = this._tabContent;
            e && !this._isMobile || (o = this._tabContent[n].subtabs);
            const a = !h.includes(n) ? Object.keys(o)[0] : null
              , r = e ? a : t;
            this.setState({
                selectedTab: t,
                selectedSubtab: r,
                currentMainTab: n
            });
            const l = !h.includes(this._state.currentMainTab);
            this.setState({
                subtabsVisible: l ? "" : "hidden"
            }),
            i || (this._isMobile && this._calcTabPanelBottomMargin(),
            this.populateTabs(this._tabContent, this._persistingBlocks));
            const c = e ? Object.keys(this._tabContent) : Object.keys(o);
            for (const i of c) {
                const s = i === t;
                (this._children[`${i}Tab`] ?? document.getElementById(`${i}Tab`))?.classList.toggle("selected", s);
                const o = this._children[`${e ? i : n}Panel`] ?? document.getElementById(`${e ? i : n}Panel`);
                e && o?.classList.toggle("selected", s)
            }
        }
        _onTabSelect(t) {
            const {tab: e} = t.target.dataset
              , i = !t.target.parentElement.classList.contains("sub-tab-nav");
            this.selectTab(e, i)
        }
        addBlockToTab(t, e="info", i=null) {
            const s = this._tabContent[e].subtabs || {};
            i && (s[i] && !s[i].includes(t) ? s[i].push(t) : s[i] = [t]),
            this._tabContent[e].contentBlocks.includes(t) || (this._tabContent[e].contentBlocks.push(t),
            this._blockState[`${t}Block`] = !0)
        }
        removeBlockFromTab(t, e="info", i=null) {
            if (i && delete this._tabContent[e].subtabs[t],
            this._tabContent[e].contentBlocks.includes(t)) {
                const i = this._tabContent[e].contentBlocks.indexOf(t);
                this._tabContent[e].contentBlocks.splice(i, 1)
            }
            this._blockState[`${t}Block`] = !1
        }
        populateTabs(t, e=[]) {
            const {selectedSubtab: i, currentMainTab: s} = this._state
              , n = this._children[`${s}Panel`];
            if (n && n.firstChild)
                for (; n.firstChild; )
                    n.removeChild(n.firstChild);
            if (this._isMobile) {
                if (this.createSubtabHTML(),
                this._state.isCollapsed)
                    return
            } else if (this._children.tabGroup.contains(this._overviewBlock.element)) {
                this._overviewBlock.element.parentElement.removeChild(this._overviewBlock.element)
            }
            (this._isMobile && i ? t[s].subtabs[i] : t[s].contentBlocks).forEach((t => {
                const e = this._app.getComponent(`${t}Block`);
                n.appendChild(e.element)
            }
            )),
            e.length && !this._isMobile && e.forEach((t => {
                const e = t.block
                  , i = "end" === t.index ? n.children.length : t.index;
                n.insertBefore(e.element, n.children[i])
            }
            ))
        }
        createSubtabHTML() {
            if (this._overviewBlock?.element) {
                if ("content-main" !== this._overviewBlock.element.nextElementSibling?.id) {
                    const t = Array.from(this._children.tabGroup.children).find((t => "content-main" === t?.id));
                    this._children.tabGroup.insertBefore(this._overviewBlock.element, t)
                }
            }
            const {subTabNav: t} = this._children
              , {currentMainTab: e} = this._state
              , i = this._app.getManager("content").context.orderedEvents
              , s = Object.keys(i).length > 0
              , n = Object.keys(this._tabContent[e].subtabs);
            if (n) {
                const o = n[0]
                  , a = null !== this._state.selectedSubtab && n.includes(this._state.selectedSubtab) ? this._state.selectedSubtab : o;
                t.innerHTML = "",
                n.forEach((n => {
                    const r = document.getElementById(`${n}Tab`) || document.createElement("li");
                    r.setAttribute("id", `${n}Tab`),
                    r.setAttribute("data-tab", n);
                    let l = n.split(/(?=[A-Z])/).join(" ");
                    l = l.charAt(0).toUpperCase() + l.slice(1),
                    s && "events" === n && (l += ` (${i.length})`),
                    r.appendChild(document.createTextNode(l)),
                    r.onclick = this._onTabSelect,
                    t.appendChild(r),
                    this._children[`${e}Tab`].classList.toggle("selected", Object.keys(this._tabContent[e].subtabs).includes(o)),
                    r.classList.toggle("selected", n === a)
                }
                )),
                this.setState({
                    selectedSubtab: a
                })
            }
        }
        async onQueryChange(t) {
            await this._cameraViewBlock.onQueryChange(t)
        }
        setupBackButton(t) {
            if (this._app.getManager("router").configs.locked || t?.length <= 1)
                this._backButtonVisibleClass = "hidden";
            else {
                if (t && t.length > 1) {
                    this._backRoute = "";
                    for (let e = 0; e < t.length - 1; e++)
                        this._backRoute += "/" + t[e]
                }
                this._backButtonVisibleClass = "visible"
            }
        }
        async onRouteChangeEvent(t, e, i, s, n, o, a) {
            this._onRouteChange(t, a);
            const r = this._app.getManager("content").getEntityInfo(t);
            if (null !== s) {
                if (await this._overviewBlock.onRouteChange(t, i, s),
                n && (this._replayBlock.onRouteChange(t, e, i, n, o),
                this.addBlockToTab("replay", "info", "about"),
                this._delayedResize()),
                s && (await this._descriptionBlock.onRouteChange(s),
                this.addBlockToTab("description", "info", "about")),
                o && o.isCanceled && t !== this._app.getView("object")?.getCurrentTarget())
                    return
            } else
                this.removeBlockFromTab("description", "info", "about");
            if (n) {
                if (this._eventsBlock.onRouteChange(t, n, i),
                this.addBlockToTab("events", "info", "events"),
                o && o.isCanceled && t !== this._app.getView("event")?._target)
                    return
            } else
                this.removeBlockFromTab("events", "info", "events");
            s.related.length ? (await this._relatedBlock.onRouteChange("Related", s.related, [], o),
            this.addBlockToTab("related", "info", "related")) : this.removeBlockFromTab("related", "info", "related");
            const l = "toolbox";
            if (this._hideTab(l),
            this._state.selectedTab === l) {
                const t = d;
                this.selectTab(t)
            }
            this.addBlockToTab("cameraView", "viewOptions", "camera"),
            await this._cameraViewBlock.onRouteChange({
                entityInfo: r
            }),
            await this.determineViewOptionBlocksState(i.target, o),
            this._persistingBlocks = [{
                block: this._overviewBlock,
                index: 0
            }, {
                block: this._replayBlock,
                index: "end"
            }],
            this.populateTabs(this._tabContent, this._persistingBlocks),
            this._isMobile && this._setUpMobileCollapse()
        }
        async onRouteChangeObject(t, e, i, s, n, o, a, r=!1) {
            let l = i;
            this._onRouteChange(t, a);
            const {locked: c} = this._app.getManager("router").configs;
            if (await this._overviewBlock.onRouteChange(t, e, i),
            this._delayedResize(),
            "Landing site" === e.category) {
                const t = e.id.split("_landing_site")[0];
                l = await this._app.getManager("content").getEntityDesc(t)
            }
            if (null !== l && (this.setState({
                title: l.title
            }),
            this._defaultState.title = l.title,
            await this._descriptionBlock.onRouteChange(l),
            this.addBlockToTab("description", "info", "about"),
            o && o.isCanceled && t !== this._app.getView("object")?.getCurrentTarget()))
                return;
            if (s ? (this._eventsBlock.onRouteChange(t, s),
            this.addBlockToTab("events", "info", "events")) : this.removeBlockFromTab("events", "info", "events"),
            !c && l?.related?.length > 0) {
                if (await this._relatedBlock.onRouteChange("Related", l.related, n, o),
                this.addBlockToTab("related", "info", "related"),
                o && o.isCanceled && t !== this._app.getView("object")?.getCurrentTarget())
                    return
            } else
                this.removeBlockFromTab("related", "info", "related");
            const h = "toolbox";
            this._app.getManager("content").hasLanded(e) ? this._hideTab(h) : (await this.determineToolboxBlocksState(e),
            this._showTab(h)),
            this._isMobile && this._setUpMobileCollapse()
        }
        async onRouteChangeObjectLoaded(t, e, i, s, n, o, a) {
            const {cancelToken: r} = o;
            r && r.isCanceled && t !== this._app.getView("object")?.getCurrentTarget() || !this._app.getManager("router").configs.locked && null !== i && void 0 !== i.related && i.related.length > 0 && (await this._relatedBlock.onRouteChange("Related", i.related, n, r),
            r && r.isCanceled && t !== this._app.getView("object")?.getCurrentTarget()) || r && r.isCanceled && t !== this._app.getView("object")?.getCurrentTarget() || (this.addBlockToTab("cameraView", "viewOptions", "camera"),
            await this._cameraViewBlock.onRouteChange({
                entityInfo: e
            }),
            r && r.isCanceled && t !== this._app.getView("object")?.getCurrentTarget() || (this.determineViewOptionBlocksState(e.id, r),
            this.populateTabs(this._tabContent)))
        }
        async onRouteChangeFeature(t, e, i, s, o, a) {
            this._onRouteChange(t, a);
            const r = "moons" === a[a.length - 1]
              , l = n.Entity.getEntityNamesInGroup(t + ", moons")?.size;
            if (await this._overviewBlock.onRouteChange(t, s, r ? `${l} Moons` : `Feature of ${e?.displayName || e?.iauName}`),
            this._delayedResize(),
            s && (await this._descriptionBlock.onRouteChange(s),
            this.addBlockToTab("description", "info", "about")),
            r && i.initial && i.initial.length > 0 && (await this._featuredMoonsBlock.onRouteChange(t, i, o),
            this.addBlockToTab("featuredMoons", "info", "featuredMoons"),
            o && o.isCanceled))
                return;
            if (o && o.isCanceled)
                return;
            this._hideTab("toolbox"),
            this.addBlockToTab("cameraView", "viewOptions", "camera"),
            await this._cameraViewBlock.onRouteChange({
                entityInfo: e,
                defaultView: 1
            }),
            o && o.isCanceled && t !== this._app.getView("feature")?.getCurrentTarget() || (this.determineViewOptionBlocksState(e.id, o),
            this.populateTabs(this._tabContent),
            this._isMobile && this._setUpMobileCollapse())
        }
        async onChildParentChange(t, e, i) {
            await this._app.getManager("scene").updateHDTarget(e, t);
            let s = this._app.getManager("scene").getHDToggleEntity();
            s || "Spacecraft" === e.category || (s = this._currentId);
            const n = this._app.pioneer.getScene("main").getEntity(t)?.getParent()?.getName();
            let o = s;
            s !== t && s !== n && (o = n),
            o !== t && await this.determineViewOptionBlocksState(o),
            t === this._app.getView("object")?.getCurrentTarget() && this.populateTabs(this._tabContent)
        }
        async determineToolboxBlocksState(t) {
            const e = []
              , i = t?.displayName || t?.iauName
              , s = "Spacecraft" === t?.category;
            !1 !== t.comparisonFeature && !("Landing site" === t.category) && (await this._compareSizeBlock.onRouteChange({
                entityId: t.id,
                link: "/compare",
                tooltipText: `See the relative size of ${i} compared to other ${s ? "spacecraft." : "celestial bodies."}`
            }),
            e.push("compareSize"));
            !1 !== t.distanceTool && (await this._distanceToolBlock.onRouteChange({
                entityId: t.id,
                link: "/distance",
                options: {
                    keepTime: !0
                },
                tooltipText: `Calculate the distance between ${i} and any other celestial body.`
            }),
            e.push("distanceTool"));
            if (Boolean(t.hasMoons) && n.Entity.getEntityNamesInGroup(t.id + ", moons")?.size > 1) {
                const i = t.displayName || t.iauName;
                await this._moonsBlock.onRouteChange({
                    entityId: t.id,
                    link: "/moons",
                    updatedTitle: `Moons of ${i}`,
                    tooltipText: `See ${i}'s featured moons.`
                }),
                e.push("moons")
            }
            ("Planet" === t.category || "moon" === t.id) && (await this._telescopeModeBlock.onRouteChange({
                entityId: t.id,
                link: "/telescope",
                tooltipText: "Pick any location on the surface of the planet or moon to land there and see the sky from that spot."
            }),
            e.push("telescopeMode"));
            for (const t of e)
                this.addBlockToTab(t, "toolbox")
        }
        async determineViewOptionBlocksState(t, e=null) {
            const i = this._app.getManager("content").getEntityInfo(t);
            await this.determineSurfaceMapBlockState(t),
            await this.determineInstrumentFOVBlockState(t),
            await this.determineLayersBlockState(t, e),
            await this.determineTextureQualityBlockState(t),
            await this.determineFeaturesBlockState(t, i)
        }
        async determineSurfaceMapBlockState(t) {
            const e = this._app.getManager("content")
              , i = this._app.pioneer.getScene("main").getEntity(t)?.getParent()?.getName()
              , s = e.getEntityInfo(t)
              , n = s?.displayName || s?.iauName || ""
              , o = e.getEntityInfo(i);
            let a = "";
            o && (a = o.displayName || o.iauName || ""),
            void 0 !== e.getSpheroidLayers(s?.id) ? (this.addBlockToTab("surfaceMap", "viewOptions", "textures"),
            await this._surfaceMapBlock.onRouteChange(s, n)) : void 0 !== e.getSpheroidLayers(i) ? (this.addBlockToTab("surfaceMap", "viewOptions", "textures"),
            await this._surfaceMapBlock.onRouteChange(o, a, null, s)) : this.removeBlockFromTab("surfaceMap", "viewOptions", "textures")
        }
        async determineLayersBlockState(t, e=null) {
            const i = this._app.getManager("content")
              , s = this._app.getManager("layer")
              , {currentView: n} = this._app.getManager("router")
              , o = s.getContextualLayers(t)
              , a = i.getEntityInfo(t)
              , r = this._app.pioneer.getScene("main").getEntity(t)?.getParent()?.getName()
              , l = i.getEntityInfo(r);
            let c = "";
            if (l && (c = l.displayName || l.iauName || ""),
            0 === o.length || o.includes("satelliteGroup")) {
                if ("event" !== n)
                    if (0 !== s.getContextualLayers(r).length) {
                        if (this.addBlockToTab("layers", "viewOptions", "layers"),
                        await this._layersBlock.onRouteChange(l, c, null, a),
                        e && e.isCanceled && t !== this._app.getView("object")?.getCurrentTarget())
                            return
                    } else if (l && "Landing site" === l.category) {
                        const n = this._app.getManager("scene").getParent(r)
                          , o = i.getEntityInfo(n);
                        if (0 !== s.getContextualLayers(n).length || void 0 !== i.getSpheroidLayers(n)) {
                            const i = n.displayName || n.iauName || "";
                            if (this.addBlockToTab("layers", "viewOptions", "layers"),
                            await this._layersBlock.onRouteChange(o, i),
                            e && e.isCanceled && t !== this._app.getView("object")?.getCurrentTarget())
                                return
                        }
                    } else
                        this.removeBlockFromTab("layers", "viewOptions", "layers")
            } else if (this.addBlockToTab("layers", "viewOptions", "layers"),
            await this._layersBlock.onRouteChange(a),
            e && e.isCanceled && t !== this._app.getView("object")?.getCurrentTarget())
                return
        }
        async determineInstrumentFOVBlockState(t) {
            const e = this._app.getManager("content");
            let i = t
              , s = e.getEntityInfo(t);
            const {currentView: n, currentRoute: o} = this._app.getManager("router");
            "event" === n && (i = o.params.spaceObject,
            s = e.getEntityInfo(i)),
            this._instrumentFOVBlock.hasInstrumentsWithFOV(i) ? (this.addBlockToTab("instrumentFOV", "viewOptions", "instruments"),
            await this._instrumentFOVBlock.onRouteChange(s)) : this.removeBlockFromTab("instrumentFOV", "viewOptions", "instruments")
        }
        async determineTextureQualityBlockState(t) {
            const e = this._app.getManager("scene")
              , i = this._app.getManager("content")
              , s = this._app.pioneer.getScene("main").getEntity(t)?.getParent()?.getName()
              , n = i.getEntityInfo(t);
            e.hasHD(t) && !o.AppUtils.isiPhone() ? (this.addBlockToTab("textureQuality", "viewOptions", "textures"),
            await this._textureQualityBlock.onRouteChange(n)) : s && e.hasHD(s) && !o.AppUtils.isiPhone() ? (this.addBlockToTab("textureQuality", "viewOptions", "textures"),
            await this._textureQualityBlock.onRouteChange(i.getEntityInfo(s))) : this.removeBlockFromTab("textureQuality", "viewOptions", "textures"),
            o.AppUtils.isAppleDevice() && this.removeBlockFromTab("textureQuality", "viewOptions", "textures")
        }
        async determineFeaturesBlockState(t, e) {
            const i = this._app.getManager("content")
              , {currentView: s} = this._app.getManager("router")
              , n = "event" === s
              , o = this._app.getManager("scene").get("main").getEntity(e?.id)?.getParent()?.getName()
              , a = t => 0 !== i.getSpheroidFeatures(t)?.length;
            a(t) || a(o) && !n ? (this.addBlockToTab("features", "viewOptions", "layers"),
            await this._featuresBlock.onRouteChange(e)) : this.removeBlockFromTab("features", "viewOptions", "layers")
        }
        backRoute() {
            const t = this._app.getManager("router");
            let e = {};
            const i = this._app.getManager("time");
            t.query.time && i && (e = {
                time: i.getTimeUrl(),
                rate: i.getTimeRate(),
                __remove: ["followId"]
            }),
            this._app.getManager("router").navigate(e, this._backRoute)
        }
        onClickShowCollapse() {
            this._state.isVisible ? this._state.isOverlay && o.AppUtils.isMobileMode() ? this.hideOverlay() : this.hide() : this.show()
        }
        resize() {
            super.resize();
            const {currentMainTab: t, isExpanded: e} = this._state
              , i = this._isMobile;
            this._isMobile = o.AppUtils.isMobile() || o.AppUtils.isTablet();
            const s = this._isLandscape;
            this._isLandscape = o.AppUtils.isLandscape(),
            this.selectTab(t),
            this._isMobile === i && this._isLandscape === s || (this.populateTabs(this._tabContent, this._persistingBlocks),
            this._setUpMobileCollapse(e))
        }
        onDragStart(t) {
            this._isDragging = !0,
            t.preventDefault()
        }
        onDrag(t) {
            if (!this._isDragging)
                return;
            t.preventDefault();
            const e = t.changedTouches[0]
              , i = window.innerHeight - e.pageY;
            this.element.style.height = `${i}px`
        }
        onDragEnd(t) {
            this._isDragging = !1,
            t.preventDefault();
            const e = !h.includes(this._state.currentMainTab)
              , i = parseInt(this.element.style.height)
              , s = this._snapHeights.value.reduce(( (t, e, s) => Math.abs(e - i) < Math.abs(t - i) ? e : t));
            this._snapHeights.index = this._snapHeights.value.indexOf(s),
            this.element.style.height = `${s}px`;
            const n = 0 === this._snapHeights.index
              , o = this._snapHeights.index === this._snapHeights.value.length - 1;
            this.setState({
                isExpanded: n,
                isExpandedClass: this._class.isExpanded[n],
                iconExpandClass: this._class.iconExpand[o ? "bottom" : "mid"],
                isCollapsed: o,
                isCollapsedClass: this._class.isCollapsed[o],
                iconCollapseClass: this._class.iconCollapse[n ? "top" : "mid"],
                subtabsVisible: o || !e ? "hidden" : "",
                tabsVisible: o ? "hidden" : ""
            });
            const a = new CustomEvent("contentPanelCollapse",{
                detail: o
            });
            window.dispatchEvent(a),
            this._setUpMobileCollapse()
        }
        expand() {
            const t = !h.includes(this._state.currentMainTab);
            if (o.AppUtils.isMobile() || o.AppUtils.isTablet()) {
                if (0 === this._snapHeights.index)
                    return;
                this._snapHeights.index--,
                this.element.style.height = this._snapHeights.value[this._snapHeights.index] - this._adjustedMobileHeight + "px";
                const e = 0 === this._snapHeights.index
                  , i = this._snapHeights.index === this._snapHeights.value.length - 1;
                this.setState({
                    isExpanded: e,
                    isExpandedClass: this._class.isExpanded[e],
                    iconExpandClass: this._class.iconExpand.mid,
                    isCollapsed: !1,
                    isCollapsedClass: this._class.isCollapsed[!1],
                    iconCollapseClass: this._class.iconCollapse[e ? "top" : "mid"],
                    subtabsVisible: i || !t ? "hidden" : "",
                    tabsVisible: i ? "hidden" : ""
                }),
                this._setUpMobileCollapse()
            } else
                this.toggleExpandCollapse()
        }
        collapse() {
            const t = !h.includes(this._state.currentMainTab);
            if (o.AppUtils.isMobile() || o.AppUtils.isTablet()) {
                if (this._snapHeights.index === this._snapHeights.value.length - 1)
                    return;
                this._snapHeights.index++,
                this.element.style.height = `${this._snapHeights.value[this._snapHeights.index]}px`;
                const e = this._snapHeights.index === this._snapHeights.value.length - 1;
                this.setState({
                    isExpanded: !1,
                    isExpandedClass: this._class.isExpanded[!1],
                    iconExpandClass: this._class.iconExpand[e ? "bottom" : "mid"],
                    isCollapsed: e,
                    isCollapsedClass: this._class.isCollapsed[e],
                    iconCollapseClass: this._class.iconCollapse.mid,
                    subtabsVisible: e || !t ? "hidden" : "",
                    tabsVisible: e ? "hidden" : ""
                }),
                this._setUpMobileCollapse()
            } else
                this.toggleExpandCollapse()
        }
        toggleExpandCollapse() {
            const t = !this._state.isExpanded
              , e = !this._state.isCollapsed;
            this.setState({
                isExpanded: t,
                isExpandedClass: this._class.isExpanded[t],
                isCollapsed: e,
                isCollapsedClass: this._class.isCollapsed[e]
            }, ( () => {
                this.triggerCallbacks("expandtoggle", [t])
            }
            ))
        }
        show() {
            !1 !== this._app.getManager("layer").getLayer("ui").visible && (super.show(),
            this.setEnabled(!0),
            this._components.forEach((t => {
                void 0 !== this._blockState[t] && null !== this._blockState[t] && this._app.getComponent(t).setEnabled(this._blockState[t])
            }
            )),
            this.triggerCallbacks("expandtoggle", [!0]),
            this._state.isCollapsed && this._state.isVisible && this._app.getComponent("collapsibleMenu").collapse(),
            null === this._scrollbar && (this._scrollbar = o.AppUtils.addScrollbar(this._element.querySelector("#content-main"))))
        }
        hide() {
            super.hide(),
            this.triggerCallbacks("expandtoggle", [!1])
        }
        _delayedResize() {
            let t = 1;
            const e = setInterval(( () => {
                const i = document.getElementById("overview-block")
                  , s = i?.getElementsByClassName("title")[0];
                if (s && 10 === t) {
                    const t = parseFloat(window.getComputedStyle(s).height);
                    isNaN(t) || (this._adjustedMobileHeight = parseFloat(window.getComputedStyle(i).height),
                    clearInterval(e),
                    this.resize())
                }
                t++
            }
            ), 100)
        }
        _getParentTabOfSubtab(t) {
            for (const [e,i] of Object.entries(this._tabContent))
                if (Object.keys(i.subtabs).includes(t))
                    return e;
            return ""
        }
        _calcTabPanelBottomMargin() {
            const {currentMainTab: t} = this._state
              , e = document.querySelectorAll("ul")
              , i = Array.from(e).find((t => "sub-tab-container" === t.id))
              , s = Array.from(e).find((t => "tab-container" === t.id))
              , n = h.includes(t) ? s?.offsetHeight : s?.offsetHeight + i?.offsetHeight;
            this._element.style.setProperty("--content-bottom-margin", "" + (s ? `${n > 0 ? n : 112}px` : "10em")),
            this._state.isCollapsed && this._element.style.setProperty("--content-bottom-margin", "0")
        }
        async _getBlockHeight(t) {
            return new Promise((e => {
                const i = setInterval(( () => {
                    const s = parseFloat(window.getComputedStyle(t).height);
                    isNaN(s) || (clearInterval(i),
                    e(parseFloat(window.getComputedStyle(t).height)))
                }
                ), 25)
            }
            )).then((t => t)).catch((t => {
                console.warn("Could not calculate block height: ", t)
            }
            ))
        }
        async _calculateAdjustedMobileHeight() {
            if (!this._isMobile)
                return;
            const {currentMainTab: t} = this._state
              , e = this._children[`${t}Panel`];
            let i = 0;
            const s = await this._getBlockHeight(this._overviewBlock.element) ?? 95;
            s > 0 && s !== this._adjustedMobileHeight && (this._adjustedMobileHeight = s),
            await this._determineCollapsedBlockVisiblity();
            const n = Array.from(e.children);
            if ("toolbox" !== t)
                for (let t = 0; t < n.length; t++)
                    this._isLandscape || (i += await this._getBlockHeight(n[t]));
            const o = this._snapHeights.index === this._snapHeights.value.length - 1;
            this._adjustedMobileHeight !== i && !isNaN(i) && o && (this._adjustedMobileHeight += i);
            const a = s / 3
              , r = o ? this._adjustedMobileHeight - s + a : 0
              , l = this._adjustedMobileHeight > s;
            document.documentElement.style.setProperty("--collapsible-bottom-margin", `${l ? r : a}px`),
            this._app.getComponent("collapsibleMenu")._element.style.setProperty("--collapsible-bottom-margin", `${this._adjustedMobileHeight}px`)
        }
        async _setUpMobileCollapse(t=!1) {
            await this._calculateAdjustedMobileHeight();
            const e = document.getElementById("dynamic-ui")
              , i = window.getComputedStyle(e).getPropertyValue("grid-template-rows").split(" ")
              , s = this._isLandscape ? window.innerHeight : window.innerHeight - parseInt(i[0])
              , n = this._adjustedMobileHeight || parseInt(i.at(-1))
              , a = parseInt(i.at(-3))
              , r = o.AppUtils.isLandscape() ? this._adjustedMobileHeight / 4 : this._adjustedMobileHeight / 8;
            if (this._snapHeights.value = [],
            this._snapHeights.value.push(s),
            !o.AppUtils.isLandscape() && this._snapHeights.value.push(a + n + r + this._adjustedMobileHeight),
            this._snapHeights.value.push(n + r),
            this._calcTabPanelBottomMargin(),
            this._isMobile) {
                let {isCollapsed: e, isExpanded: i, currentMainTab: s} = this._state;
                const n = !h.includes(s);
                (e || t) && (this._snapHeights.index = this._snapHeights.value.length - 1),
                e = this._snapHeights.index === this._snapHeights.value.length - 1,
                i = !e && !t;
                const o = 0 === this._snapHeights.index;
                this.element.style.height = `${this._snapHeights.value[this._snapHeights.index]}px`,
                this._isLandscape && o ? this.element.classList.add("overlay") : this.element.classList.remove("overlay"),
                this.setState({
                    isExpanded: i,
                    isExpandedClass: this._class.isExpanded[o],
                    iconExpandClass: this._class.iconExpand[e ? "bottom" : "mid"],
                    isCollapsed: e,
                    isCollapsedClass: this._class.isCollapsed[e],
                    iconCollapseClass: this._class.iconCollapse[o ? "top" : "mid"],
                    subtabsVisible: e || !n ? "hidden" : "",
                    tabsVisible: e ? "hidden" : ""
                }),
                i && this.populateTabs(this._tabContent)
            } else {
                this.element.style.height = "auto",
                this._snapHeights.index = -1;
                const t = !this._state.isCollapsed;
                this.setState({
                    isExpanded: t,
                    isExpandedClass: this._class.isExpanded[t],
                    iconExpandClass: this._class.iconExpand.left,
                    iconCollapseClass: this._class.iconCollapse.left,
                    subtabsVisible: "hidden",
                    tabsVisible: ""
                })
            }
            this.triggerCallbacks("expandtoggle", [this._state.isExpanded])
        }
        _determineCollapsedBlockVisiblity() {
            const {selectedSubtab: t, currentMainTab: e} = this._state
              , i = this._children[`${e}Panel`]
              , s = this._tabContent[`${e}`].subtabs[`${t}`]
              , n = this._snapHeights.index === this._snapHeights.value.length - 1
              , o = ["replay"]
              , a = s?.filter((t => !o.includes(t)));
            return new Promise((t => {
                a && a.forEach((t => {
                    const e = this._app.getComponent(`${t}Block`).element;
                    n ? i.contains(e) && i.removeChild(e) : i.appendChild(e)
                }
                )),
                o && o.forEach((async t => {
                    const e = this._app.getComponent(`${t}Block`).element;
                    let o = !1;
                    for (const e in this._tabContent)
                        if (this._tabContent[e].contentBlocks.includes(t)) {
                            o = !0;
                            break
                        }
                    !s?.includes(t) && i.contains(e) && i.removeChild(e),
                    n ? (o && i.appendChild(e),
                    this._element.style.setProperty("--custom-overview-border", o ? "1px solid #ffffff30" : "none")) : (!s?.includes(t) && i.contains(e) && i.removeChild(e),
                    this._element.style.setProperty("--custom-overview-border", "none"))
                }
                )),
                t(!0)
            }
            ))
        }
        _disableAllComponents() {
            this._components.forEach((t => {
                null !== this._blockState[t] && void 0 !== this._blockState[t] && (this._blockState[t] = !1),
                this._app.getComponent(t).setEnabled(!1)
            }
            ))
        }
        clearPanel(t=null) {
            if (this._disableAllComponents(),
            t) {
                const e = `Loading ${t}...`;
                this.setState({
                    title: e
                }),
                this._defaultState.title = e
            }
        }
        reset() {
            this.setState(this._defaultState),
            this._currentId = "",
            this._app.getComponent("collapsibleMenu")._element.style.setProperty("--collapsible-bottom-margin", "1em"),
            document.documentElement.style.setProperty("--collapsible-bottom-margin", "1em")
        }
        __disable() {
            this.reset(),
            super.__disable()
        }
    }
    ContentPanel.html = l()
}
, function(t) {
    t.exports = '<article class="content-panel-container scrollable {{isVisibleClass}} {{isOverlayClass}} {{isExpandedClass}} {{isCollapsedClass}}">\n\t<button key="desktopCollapseExpandButton" class="button clickable icon {{desktopIconName}} desktop-collapse-button" data-tippy-content="Toggle content panel." onclick="onClickShowCollapse"></button>\n\n\t<div key="tabGroup" class="tab-group">\n\t\t\x3c!-- Drag bar --\x3e\n\t\t<span key="dragHandle" ontouchstart="onDragStart" ontouchmove="onDrag" ontouchend="onDragEnd">\n\t\t\t<span class="drag-handle clickable"></span>\n\t\t</span>\n\n\t\t<span class="expand-btn-group">\n\t\t\t<button key="expandButton" class="button clickable expand-button icon-bg" data-tippy-content="Expand content panel." aria-label="Expand content panel" onclick="expand">\n\t\t\t\t<icon class="icon {{iconExpandClass}}"></icon>\n\t\t\t</button>\n\t\t\t<button key="collapseButton" class="button clickable collapse-button icon-bg" data-tippy-content="Collapse content panel" aria-label="Collapse content panel" onclick="collapse">\n\t\t\t\t<icon class="icon {{iconCollapseClass}}"></icon>\n\t\t\t</button>\n\t\t</span>\n\n\t\t\x3c!-- Tab nav --\x3e\n\t   <nav class="{{tabsVisible}}">\n\t\t\t<ul id="sub-tab-container" class="sub-tab-container {{subtabsVisible}}">\n\t\t\t\t<div key="subTabNav" class="sub-tab-nav"></div>\n\t\t\t</ul>\n\t\t\t<ul id="tab-container" class="tab-nav" role="tablist">\n\t\t\t\t<li key="infoTab" class="{{infoTabVisibleClass}}" role="presentation">\n\t\t\t\t\t<div class="icon info-sel" aria-hidden="true"></div>\n\t\t\t\t\t<div class="icon info" aria-hidden="true"></div>\n\t\t\t\t\t<button class="clickable" role="tab" aria-selected="false"\n\t\t\t\t\t\taria-controls="info-tab-panel" id="info-tab" data-tab="info"\n\t\t\t\t\t\tonclick="_onTabSelect">Info</button>\n\t\t\t\t\t<div class="bg" aria-hidden="true"></div>\n\t\t\t\t</li>\n\t\t\t\t<li key="toolboxTab" class="{{toolboxTabVisibleClass}}" role="presentation">\n\n\t\t\t\t\t<div class="icon toolbox-sel" aria-hidden="true"></div>\n\t\t\t\t\t<div class="icon toolbox" aria-hidden="true"></div>\n\t\t\t\t\t<button class="clickable" role="tab" aria-selected="false"\n\t\t\t\t\t\taria-controls="toolbox-tab-panel" id="toolbox-tab" data-tab="toolbox"\n\t\t\t\t\t\tonclick="_onTabSelect">Toolbox</button>\n\t\t\t\t\t<div class="bg" aria-hidden="true"></div>\n\t\t\t\t</li>\n\t\t\t\t<li key="viewOptionsTab" class="{{viewOptionsTabVisibleClass}}" role="presentation">\n\n\t\t\t\t\t<div class="icon view-options-sel" aria-hidden="true"></div>\n\t\t\t\t\t<div class="icon view-options" aria-hidden="true"></div>\n\t\t\t\t\t<button class="clickable" role="tab" aria-selected="false"\n\t\t\t\t\t\taria-controls="viewOptions-tab-panel" id="viewOptions-tab" data-tab="viewOptions"\n\t\t\t\t\t\tonclick="_onTabSelect">View Options</button>\n\t\t\t\t\t<div class="bg" aria-hidden="true"></div>\n\t\t\t\t</li>\n\t\t\t</ul>\n\t   </nav>\n\t   \x3c!-- Main content --\x3e\n\t   <main id="content-main">\n\t\t\x3c!-- Info tab --\x3e\n\t\t<div key="infoPanel" class="tab-content" id="info-tab-panel" role="tabpanel" aria-labelledby="info-tab"></div>\n\t\t\x3c!-- Toolbox tab --\x3e\n\t\t<div key="toolboxPanel" class="tab-content" id="toolbox-tab-panel" role="tabpanel" aria-labelledby="toolbox-tab">\n\t\t\t<div class="content-block toolbox-content">\n\t\t\t\t<ul></ul>\n\t\t\t</div>\n\t\t</div>\n\t\t\x3c!-- View Options tab --\x3e\n\t\t<div key="viewOptionsPanel" class="tab-content {{viewOptionsSelectedClass}}" id="viewOptions-tab-panel" role="tabpanel" aria-labelledby="viewOptions-tab"></div>\n\t</main>\n   </div>\n</article>'
}
, function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        FeaturedStoriesPanel: function() {
            return FeaturedStoriesPanel
        }
    });
    i(956);
    var s = i(1)
      , n = i(890)
      , o = i(1012)
      , a = i.n(o);
    i(1013);
    class FeaturedStoriesPanel extends s.BaseComponent {
        constructor(t, e) {
            super(t, null, {
                title: "Featured Stories",
                isOverlay: !1,
                isOverlayClass: "",
                isOpenTitleClass: "open",
                isOpenButtonClass: "open",
                ...e
            }),
            this._class.isOverlay = {
                true: "overlay",
                false: ""
            },
            this._class.isOpen = {
                true: "open",
                false: "closed"
            },
            this._collapseMobile = "icon-collapse",
            this._expandMobile = "icon-expand",
            this._collapseDesktop = "icon-collapse-side",
            this._expandDesktop = "icon-expand-side",
            this._defaultState = {
                desktopIconName: this._collapseDesktop,
                mobileIconName: this._collapseMobile
            },
            this._state.desktopIconName = this._collapseDesktop,
            this._state.mobileIconName = this._collapseMobile,
            this._components = ["featuredStoryBlock"],
            this._eventNames.push("overlay", "expandtoggle"),
            this._initCallbacks(),
            this._scrollbar = null,
            this._currentId = "",
            this._storyBlock = null,
            this.bindFunctions(["onClickShowCollapse", "showOverlay", "hideOverlay", "handleLayerToggle"])
        }
        async init() {
            super.init(),
            this._storyBlock = await this._app.addComponentWithPlaceholder({
                type: n.FeaturedStoryBlock,
                name: "featuredStoryBlock"
            }, this._element),
            this._isLandscape = s.AppUtils.isLandscape(),
            this._callbackRegistry.push({
                emitter: this._app.getManager("layer"),
                event: "toggleLayer",
                callback: this.handleLayerToggle
            })
        }
        _onRouteChange() {
            this.isEnabled() && this._disableAllComponents()
        }
        async onRouteChange(t, e) {
            if (!t || !t.isCanceled) {
                if (this._onRouteChange(),
                e && e.length > 0) {
                    if (await this._storyBlock.onRouteChange("home", "", e, t),
                    t && t.isCanceled)
                        return;
                    this._storyBlock.setEnabled(!0)
                }
                null === this._scrollbar ? this._scrollbar = s.AppUtils.addScrollbar(document.getElementById("content-body")) : this._scrollbar.scroll(0)
            }
        }
        showOverlay() {
            this.setState({
                isOverlay: !0,
                isOverlayClass: this._class.isOverlay.true,
                desktopIconName: this._collapseDesktop,
                mobileIconName: this._collapseMobile
            }, ( () => this.triggerCallbacks("overlay", [this._state.isOverlay])))
        }
        hideOverlay() {
            this.setState({
                isOverlay: !1,
                isOverlayClass: this._class.isOverlay.false,
                desktopIconName: this._collapseDesktop,
                mobileIconName: this._collapseMobile
            }, ( () => this.triggerCallbacks("overlay", [this._state.isOverlay])))
        }
        onClickShowCollapse() {
            this._state.isVisible ? this._state.isOverlay && s.AppUtils.isMobileMode() ? this.hideOverlay() : this.hide() : this.show()
        }
        get shouldOffsetRight() {
            return s.AppUtils.isDesktop()
        }
        show() {
            super.show();
            const {currentView: t} = this._app.getManager("router");
            this._app.getView(t)?.setViewportOffset(!0);
            const {expandToggleBtn: e} = this._children;
            e.setAttribute("aria-label", "Collapse featured stories panel"),
            this._app.getComponent("mobileExpandButton").showCPButton(!1, "featuredStoriesPanel"),
            this.setState({
                desktopIconName: this._collapseDesktop,
                mobileIconName: this._collapseMobile,
                isOpenTitleClass: this._class.isOpen.true,
                isOpenButtonClass: this._class.isOpen.true
            })
        }
        hide() {
            super.hide();
            const {currentView: t} = this._app.getManager("router");
            this._app.getView(t)?.setViewportOffset(!1);
            const {expandToggleBtn: e} = this._children;
            e.setAttribute("aria-label", "Expand featured stories panel"),
            this._app.getComponent("mobileExpandButton").showCPButton(!0, "featuredStoriesPanel"),
            this.setState({
                desktopIconName: this._expandDesktop,
                mobileIconName: this._expandMobile,
                isOpenTitleClass: this._class.isOpen.false,
                isOpenButtonClass: this._class.isOpen.false
            })
        }
        handleLayerToggle(t, e) {
            "ui" === t && (e ? this.show() : this.hide())
        }
        _disableAllComponents() {
            this._components.forEach((t => {
                this._app.getComponent(t).setEnabled(!1)
            }
            ))
        }
        reset() {
            this.setState(this._defaultState),
            this._currentId = ""
        }
        __disable() {
            this.reset(),
            super.__disable()
        }
    }
    FeaturedStoriesPanel.html = a()
}
, function(t) {
    t.exports = '<article class="featured-stories-panel {{isVisibleClass}} {{isOverlayClass}}">\n\t<div class="featured-stories-header">\n\t\t<span class="featured-stories-title color gray {{isOpenTitleClass}}" >\n\t\t\tFeatured Stories and Events\n\t\t</span>\n\t\t<span class="button clickable icon desktop-collapse-button {{desktopIconName}} {{isOpenButtonClass}}" onclick="onClickShowCollapse"></span>\n\t</div>\n\n\t<div id="content-body" class="content-body panel scrollable">\n\t\t<div class="content-header">\n\t\t\t<span class="mobile-button-pair">\n\t\t\t\t<button key="expandToggleBtn" class="button clickable icon {{mobileIconName}} mobile-collapse-button" onclick="onClickShowCollapse"></button>\n\t\t\t</span>\n\t\t</div>\n\t\t<div id="content" class="content">\n\t\t\t<FeaturedStoryBlock></FeaturedStoryBlock>\n\t\t</div>\n\t</div>\n</article>\n'
}
, function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        Comparison: function() {
            return Comparison
        }
    });
    var s = i(1)
      , n = (i(1015),
    i(1016))
      , o = i.n(n);
    class Comparison extends s.BaseComponent {
        constructor(t, e) {
            super(t, e),
            this.list = [],
            this.name = null,
            this.compare = null,
            this.unitConverter = null,
            this._class.fontSize.xSmall = "x-small",
            this._class.fontSize.small = "small",
            this._class.fontSize.default = "",
            Object.assign(this._state, {
                unitSystem: "imperial",
                leftValueClass: "",
                rightValueClass: "",
                leftTitle: "",
                leftType: "",
                leftRadius: "",
                leftIdentifier: "",
                rightTitle: "",
                rightType: "",
                rightRadius: "",
                rightUnit: "",
                rightIdentifier: "",
                photoMode: "",
                unit: "",
                fontSizeClass: this._class.fontSize.default,
                altFontSizeClass: this._class.fontSize.small
            }),
            this.bindFunctions(["closeView", "nextCompare", "previousCompare", "unitchange", "clearLeftPanelText", "clearRightPanelText"])
        }
        init() {
            super.init();
            const t = this._children.exit;
            t && (t.addEventListener("click", this.closeView, {
                passive: !1
            }),
            t.addEventListener("mouseenter", ( () => {
                this._children.exitIcon.classList.add("hover")
            }
            ), {
                passive: !1
            }),
            t.addEventListener("mouseleave", ( () => {
                this._children.exitIcon.classList.remove("hover")
            }
            ), {
                passive: !1
            })),
            this._children.next && this._children.next.addEventListener("click", this.nextCompare, {
                passive: !1
            }),
            this._children.previous && this._children.previous.addEventListener("click", this.previousCompare, {
                passive: !1
            })
        }
        _updateFontSize() {
            let t = this._class.fontSize.default
              , e = this._class.fontSize.small;
            s.AppUtils.isMobileMode() ? (t = this._class.fontSize.xSmall,
            e = this._class.fontSize.xSmall) : (s.AppUtils.is2K() || s.AppUtils.is4K()) && (t = this._class.fontSize.default,
            e = this._class.fontSize.small),
            this.setState({
                fontSizeClass: t,
                altFontSizeClass: e
            })
        }
        unitchange(t) {
            this.setState({
                unitSystem: t ? "metric" : "imperial"
            }),
            this.generateValues()
        }
        nextCompare() {
            const t = this.list.indexOf(this.compare) || 0;
            this.compare = this.list[(t + 1) % this.list.length],
            this.clearRightPanelText(this.compare),
            this._app.getManager("router").navigate(`${this.name}/compare?id=${this.compare}`)
        }
        previousCompare() {
            const t = this.list.indexOf(this.compare) || 0;
            this.compare = this.list[t - 1 < 0 ? this.list.length - 1 : t - 1],
            this.clearRightPanelText(this.compare),
            this._app.getManager("router").navigate(`${this.name}/compare?id=${this.compare}`)
        }
        clearRightPanelText(t) {
            const e = this._app.getManager("content").getEntityInfo(t)
              , i = e?.displayName || e?.iauName
              , s = e?.subcategory || e?.category;
            this.setState({
                rightTitle: i ?? "",
                rightType: s ?? "",
                rightRadius: "",
                rightUnit: "",
                rightIdentifier: "loading..."
            })
        }
        clearLeftPanelText(t) {
            const e = this._app.getManager("content").getEntityInfo(t)
              , i = e?.displayName || e?.iauName
              , s = e?.subcategory || e?.category;
            this.setState({
                leftTitle: i ?? "",
                leftType: s ?? "",
                leftRadius: "",
                leftUnit: "",
                leftIdentifier: "loading..."
            })
        }
        async setup(t={}) {
            if (t.cancelToken.isCanceled)
                return;
            this.list = t.list || this.list,
            this.name = t.name || this.name,
            this.compare = t.compare || this.compare,
            this.unitConverter = t.unitConverter || this.unitConverter;
            const e = Object.keys(this.list);
            for (let t = 0; t < e.length; t++)
                this.list[e[t]] === this.name && (this.list = this.list.slice(0, t).concat(this.list.slice(t + 1)));
            this.generateValues()
        }
        formatValue(t, e=1) {
            if (t < 1) {
                let i = t.toFixed(2 * e);
                if (0 === Number.parseFloat(i))
                    for (let s = e; s < e + 5 && (i = t.toFixed(s),
                    0 === Number.parseFloat(i)); s += 1)
                        ;
                return i
            }
            if (t < 1e3)
                return t.toFixed(e);
            let i = Math.round(t);
            const s = Math.pow(10, i.toString().length - 5);
            return i = Math.round(i / s) * s,
            i.toFixed(e)
        }
        async generateValues() {
            this.leftDescription = await this._app.getManager("content").getEntityDesc(this.name) || {};
            const t = this._app.getManager("content").getEntityInfo(this.name)
              , e = this.leftDescription.data || this.leftDescription || {};
            e.type = t ? t.subcategory || t.category : "",
            this.rightDescription = await this._app.getManager("content").getEntityDesc(this.compare) || {};
            const i = this._app.getManager("content").getEntityInfo(this.compare)
              , s = this.rightDescription.data || this.rightDescription || {};
            s.type = i ? i.subcategory || i.category : "";
            const {unitSystem: n} = this._state
              , o = this.leftDescription.title || t.displayName || t.iauName || this.name
              , a = this.rightDescription.title || i.displayName || i.iauName || this.compare
              , r = {
                leftValueClass: "color " + this._app.getManager("content").getColorClass(this.name),
                rightValueClass: "color " + this._app.getManager("content").getColorClass(this.compare),
                leftTitle: o,
                rightTitle: a,
                leftType: e.type,
                leftRadius: "",
                leftIdentifier: "Radius",
                rightType: s.type,
                rightRadius: "",
                rightUnit: o,
                rightIdentifier: "Radius",
                unit: this.unitConverter[n].radius.unit
            };
            if (this.unitConverter[n].radius) {
                let o = e.radius;
                if (!o) {
                    const t = this.entityCompareLookup(this.name, "left");
                    o = t ? t.radius : null
                }
                let a = s.radius;
                if (!a) {
                    const t = this.entityCompareLookup(this.compare, "right");
                    a = t ? t.radius : null
                }
                if (!o || !a)
                    return;
                const l = a / o
                  , c = ["Spacecraft", "Human", "Building", "Vehicle"];
                t && c.indexOf(t.category) >= 0 && (o *= 2,
                r.leftIdentifier = "Length");
                let h = this.unitConverter[n].radius.multiplier || 1
                  , d = o * h;
                if (d < 1 && (h = this.unitConverter[n].radius.small.multiplier,
                d = o * h,
                r.unit = this.unitConverter[n].radius.small.unit),
                o = d,
                r.leftRadius = this.formatValue(o),
                i && c.indexOf(i.category) >= 0) {
                    a *= 2,
                    r.rightIdentifier = "Length";
                    let t = this.unitConverter[n].radius.multiplier || 1
                      , e = a * t;
                    r.rightUnit = this.unitConverter[n].radius.unit,
                    e < 1 && (t = this.unitConverter[n].radius.small.multiplier,
                    e = a * t,
                    r.rightUnit = this.unitConverter[n].radius.small.unit),
                    a = e,
                    r.rightRadius = this.formatValue(a)
                } else
                    r.rightRadius = this.formatValue(l),
                    r.leftTitle && (r.rightUnit = "Ã— " + r.leftTitle.toUpperCase())
            }
            this.setState(r)
        }
        entityCompareLookup(t, e) {
            const i = this._app.getManager("content").getEntityInfo(t) || {}
              , s = "left" === e ? this._app.getManager("comparison").entityLeft : this._app.getManager("comparison").entityRight;
            if (!s)
                return null;
            let n = i.category || "NA"
              , o = (i.subcategory || i.category || "").toLowerCase().replace(/ /g, "-");
            void 0 !== i.subcategory && (n = i.subcategory,
            "Spacecraft" === i.category && (n += " " + i.category,
            o += " " + i.subcategory.toLowerCase().replace(/ /g, "-")));
            return {
                icon: o,
                category: n,
                type: i.category || "NA",
                className: this._app.getManager("content").getClassName(t),
                name: i.displayName || i.iauName || i.name || s.getName(),
                radius: "Spacecraft" === i.category ? s.getExtentsRadius() : s.getOcclusionRadius()
            }
        }
        closeView() {
            this._app.getManager("comparison").exit(),
            this._app.getManager("router").navigate(`/${this.name}`)
        }
    }
    Comparison.html = o()
}
, function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t) {
    t.exports = '<div class="compare">\n\t<section key="left" class="left section">\n\t\t<div class="block {{isVisibleClass}}">\n\t\t\t<h5 class="semi title">{{leftTitle}}</h5>\n\t\t\t<div class="data-area">\n\t\t\t\t<div class="data left">\n\t\t\t\t\t<span class="{{fontSizeClass}} color gray med">Type</span>\n\t\t\t\t\t<span class="{{fontSizeClass}} color gray semi upper">{{leftType}}</span>\n\t\t\t\t</div>\n\t\t\t\t<div class="data right">\n\t\t\t\t\t<span class="{{fontSizeClass}} color gray med">{{leftIdentifier}}</span>\n\t\t\t\t\t<span class="{{fontSizeClass}} {{leftValueClass}} radius semi">{{leftRadius}}</span>\n\t\t\t\t\t<span class="{{altFontSizeClass}} color gray semi upper">{{unit}}</span>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n\t</section>\n\t<div class="divider"></div>\n\t<section key="right" class="right section">\n\t\t<div class="block {{isVisibleClass}}">\n\t\t\t<h5 class="semi title">{{rightTitle}}</h5>\n\t\t\t<div class="data-area">\n\t\t\t\t<div class="data left">\n\t\t\t\t\t<span class="{{fontSizeClass}} color gray med">Type</span>\n\t\t\t\t\t<span class="{{fontSizeClass}} color gray semi upper">{{rightType}}</span>\n\t\t\t\t</div>\n\t\t\t\t<div class="data right">\n\t\t\t\t\t<span class="{{fontSizeClass}} color gray med">{{rightIdentifier}}</span>\n\t\t\t\t\t<span class="{{fontSizeClass}} {{rightValueClass}} radius semi">{{rightRadius}}</span>\n\t\t\t\t\t<span class="{{altFontSizeClass}} color gray semi upper">{{rightUnit}}</span>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n\t\t<span key="previous" alt="Previous compare object" class="previous icon clickable icon-arrow-left-large"></span>\n\t\t<span key="next" alt="Next compare object" class="next icon clickable icon-arrow-right-large"></span>\n\t</section>\n\t<footer class="footer {{isVisibleClass}}">\n\t\t<span class="menu {{altFontSizeClass}} semi upper color gray">Comparison Overview</span>\n\t\t<span key="exit" class="exit clickable {{isVisibleClass}}">\n\t\t\t<span class="text upper semi">Exit</span>\n\t\t\t<span key="exitIcon" alt="Close comparison" class="icon icon-box {{isVisibleClass}}">\n\t\t\t\t<span class="icon icon-close"></span>\n\t\t\t</span>\n\t\t</span>\n\t</footer>\n</div>\n'
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        InfoPanel: function() {
            return InfoPanel
        }
    });
    var s = i(1)
      , n = (i(1018),
    i(1019))
      , o = i.n(n);
    class InfoPanel extends s.BaseComponent {
        constructor(t, e={}) {
            e.config = {
                ...e.config
            },
            super(t, null, {
                isVisible: !1,
                ...e
            }),
            Object.assign(this._class, {
                isVisible: {
                    true: "",
                    false: "hidden"
                }
            }),
            this.bindFunctions(["openPanel", "closePanel"])
        }
        openPanel() {
            this.show()
        }
        closePanel() {
            this.hide()
        }
        hide() {
            this.getState("isVisible") && (super.hide(),
            this._app.getComponent("overlay").hide())
        }
        show() {
            super.show(),
            this._app.getComponent("overlay").setContent(this._element),
            this._app.getComponent("overlay").show()
        }
    }
    InfoPanel.html = o()
}
, function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t) {
    t.exports = '<div key="infoPanel" class="info-panel {{isVisibleClass}}">\n\t<div id="info-panel" class="container scrollable">\n\t\t<h2 class="title">Your Solar System</h2>\n\t\t<h3 class="subtitle">Real-time, Real data</h3>\n\t\t<div class="content">\n\t\t\t<p>Welcome to <strong>Eyes on the Solar System!</strong> This simulated view of the solar system allows you to explore the planets, their moons, asteroids, comets and the spacecraft exploring them. You can also fast-forward or rewind time, and explore the solar system as it looked from 1950 to 2050. Rewind back to Earth in 1958 to see Explorer 1, skip forward to see the incredible journey of missions like Cassini and Voyager in their entirety, or watch OSIRIS-REx sample the surface of the asteroid Bennu. See the International Space Station\'s current position over Earth, land on Mars with the Perseverance rover, or watch the Juno spacecraft orbit Jupiter\'s north pole. </p>There are hundreds of places to visit and it is all using real data, images, engineering models, and events, just as they happened in space and time.</p>\n\t\t\t<p>This app runs in a web browser, and is mobile and tablet-friendly. Most devices with a web browser and an internet connection can enjoy the app, with no download necessary.</p><p>Here are some tips to get you navigating around the solar system quickly.</p>\n\t\t\t<p style="text-align:center;">\n\t\t\t\t<div class = "videoWrapper" style="display: none; position: relative; padding-bottom: 56.25%; height: 0;">\n\t\t\t\t\t<iframe width="560" height="315" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: 0;"\n\t\t\t\t\tsrc="https://www.youtube.com/embed/QRTfKYOfPLg" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowFullScreen>\n\t\t\t\t\t</iframe>\n\t\t\t\t</div>\n\t\t\t</p>\n\t\t\t<ul>\n\n\t\t\t\t<li><strong>Time controls. </strong>Use the time controls to move forwards and backwards through space and time. You can simply click or touch the date and time directly and change it to any time you want, or use the rewind, fast-forward and play/pause buttons. For finer control, try the time slider to zip back and forth. If you get lost in time, just click on the "LIVE" buttton to go to the current time.</li>\n\n\t\t\t\t<li><strong>Moving around objects. </strong>Desktop - click/drag, Mobile/Touch - tap/drag. Keyboard: Rotate heading - <strong>A/D</strong>, rotate pitch - <strong>Q/E</strong>, rotate bank - <strong>Z/C</strong>. Add <strong>SHIFT</strong> for faster speed.</li>\n\n\t\t\t\t<li><strong>Zoom in and out.</strong> Desktop - mouse wheel, Mobile/Touch - pinch in/out. Keyboard: Zoom in/out - <strong>W/S</strong>, Add <strong>SHIFT</strong> for faster speed.</li>\n\n\t\t\t\t<li><strong>Click on any label</strong>. If you see a label, just click or touch it to instantly travel to the object. Once there, you can see featured events, compare the size to other celestial bodies or spacecraft, change the view, or jump over to other related objects.</li>\n\n\t\t\t\t<li><strong>Menu and search. </strong>Just select the magnifying glass and type in what you seek. Alternatively, use the Menu to select any object by name, including planets, moons, spacecraft, asteroids, and comets. On mobile, search and menu are accessed through the "hamburger" menu at the top right.</li>\n\n\t\t\t\t<li><strong>Stories. </strong>On the left side of the screen (bottom of the screen on mobile), you will see several stories. Click on one to experience "scrolly-telling". Learn about the Cassini spacecraft discovering geysers on Saturn\'s moon Enceladus, watch the Perseverance rover land on Mars, or follow the grand tour of the famous Voyager spacecraft.</li>\n\n\t\t\t\t<li> <strong>Surface layers. </strong>For several planets and moons, you can turn on high quality textures. Just go to the object, then on the panel (left side of the screen for laptops, bottom of the screen for mobile phones) go to the "View Options" tab. On laptops, you will see the "Texture Quality" option, where you select "High Definition." On mobile, you select "View Options" and then "Textures" and you will see the same option. For Earth, Mars, and the Moon, you can also select an even higher-quality texture under the "Surface Map" section, with a description of the source. In the case of Earth, this is a very high-resolution global image mosaic of Earth from the day before! </li>\n\n\t\t\t\t<li><strong>Settings. </strong>On desktop and mobile, the show/hide settings button is in the bottom right of the screen. Once opened, you can change the lighting (flood, shadow, and natural lighting), expand to full screen, and turn off and on different layers of visibility (constellations, spacecraft, labels, trails, asteroids, comets, and even the user interface).</li>\n\n\t\t\t\t<li><strong>Telescope mode. </strong>When you are at a planet, try telescope mode! Click anywhere on the planet, and you will land at that location. Then turn on constellations and see what\'s in the sky right now.</li>\n\t\t\t</ul>\n\n\t\t</div>\n\t</div>\n</div>\n'
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        DistancePanel: function() {
            return DistancePanel
        }
    });
    var s = i(1)
      , n = (i(1021),
    i(1022))
      , o = i.n(n);
    const a = "Â« Select or search for a target Â»";
    class DistancePanel extends s.BaseComponent {
        constructor(t, e={}) {
            super(t, null, {
                isVisible: !0,
                isSearchingClass: "",
                isMinimized: null,
                isMinimizedClass: "",
                canMinimizeClass: "",
                maxMinIconClass: "",
                maxMinBtnPosition: "right",
                isDraggable: null,
                isDraggableClass: "",
                currDraggingClass: "",
                isLoadingClass: "hidden",
                fromText: "<span>from</span>",
                showSourceMPToggleClass: "hidden",
                sourceMpClass: "",
                toText: "<span>to</span>",
                showTargetMPToggleClass: "hidden",
                touchActiveClass: "",
                swapIsVisibleClass: "hidden",
                swapOffsetClass: "",
                dotPosClass: "source-dot",
                targetMpClass: "",
                resultText: "",
                resultUnit: "",
                resultTextClass: "",
                relVelocityText: "",
                relVelocityUnit: "",
                relVelocityClass: "hidden",
                isExpandedClass: ""
            }),
            this._isTouch = null,
            this._touchOptions = {
                activeDelay: 3e3,
                activeTimeout: null
            },
            this._canHover = null,
            this._isMobile = s.AppUtils.isMobile(),
            this.isMobileChangedCallback = null,
            this._dragState = {
                currentlyDragging: null,
                downX: null,
                downY: null,
                dragX: null,
                dragY: null,
                limitX: null,
                limitY: null,
                screenCenterX: null,
                screenCenterY: null
            },
            this._size = {
                width: 320,
                height: 320,
                expandedHeight: 360,
                padding: {
                    top: 70,
                    bottom: 150
                }
            },
            this._lineGraphic = {
                top: null,
                height: null,
                dotPos: null
            },
            this.bindFunctions(["onMouseDown", "onMouseMove", "onMouseUp", "onTouchStart", "onTouchMove", "onTouchEnd", "onLineMouseEnter", "onLineMouseLeave", "onLineMouseMove", "_onLineTouchStart", "_onLineTouchEnd", "_calcNewXandY", "setPanelProps"])
        }
        initSearchUI() {
            const {sourceSearchContainer: t, targetSearchContainer: e} = this._children;
            this.sourceSearch = this.app.getComponent("distanceSourceSearch"),
            this.targetSearch = this.app.getComponent("distanceTargetSearch"),
            t.appendChild(this.sourceSearch?.element),
            this.sourceSearch?.setParent(t),
            e.appendChild(this.targetSearch?.element),
            this.targetSearch?.setParent(e);
            const {input: i} = this.sourceSearch?._children || {}
              , {input: s} = this.targetSearch?._children || {};
            i && i.setAttribute("placeholder", "Name of source"),
            s && s.setAttribute("placeholder", "Name of target"),
            this.sourceSearch.show(),
            this.targetSearch.show()
        }
        onMouseDown(t) {
            this.setCurrentlyDragging(!0),
            this.setDownXY(t.clientX, t.clientY),
            window.addEventListener("mousemove", this.onMouseMove),
            window.addEventListener("mouseup", this.onMouseUp)
        }
        onMouseMove(t) {
            if (1 === t.buttons && this.currentlyDragging) {
                const {newX: e, newY: i} = this._calcNewXandY(t.clientX, t.clientY)
                  , {limitX: s, limitY: n} = this.getLimitedXandY(e, i);
                this.setLimitXY(s, n),
                this.setTransformCSSVars(s, n),
                this.calcMaxMinBtnPos(s)
            }
        }
        onMouseUp() {
            const {limitX: t, limitY: e} = this._dragState;
            this.setDragXY(t, e),
            this.setCurrentlyDragging(!1),
            window.removeEventListener("mousemove", this.onMouseMove),
            window.removeEventListener("mouseup", this.onMouseUp)
        }
        onTouchStart(t) {
            this.setCurrentlyDragging(!0);
            const {clientX: e, clientY: i} = t.touches[0];
            this.setDownXY(e, i),
            window.addEventListener("touchmove", this.onTouchMove),
            window.addEventListener("touchend", this.onTouchEnd)
        }
        onTouchMove(t) {
            if (this.currentlyDragging) {
                const {clientX: e, clientY: i} = t.touches[0]
                  , {newX: s, newY: n} = this._calcNewXandY(e, i)
                  , {limitX: o, limitY: a} = this.getLimitedXandY(s, n);
                this.setLimitXY(o, a),
                this.setTransformCSSVars(o, a),
                this.calcMaxMinBtnPos(o)
            }
        }
        onTouchEnd() {
            const {limitX: t, limitY: e} = this._dragState;
            this.setDragXY(t, e),
            this.setCurrentlyDragging(!1),
            window.removeEventListener("touchmove", this.onTouchMove),
            window.removeEventListener("touchend", this.onTouchEnd)
        }
        _calcNewXandY(t, e) {
            const {downX: i, downY: s, dragX: n, dragY: o} = this._dragState;
            return {
                newX: n + (t - i),
                newY: o + (e - s)
            }
        }
        exit() {
            const t = this.app.getManager("router")
              , {spaceObject: e} = t.currentRoute?.params || {};
            e && t.navigate({}, `/${e}`, {
                __remove: ["to"],
                keepTime: !0
            })
        }
        toggleSourceMP() {
            const {dotPos: t} = this._lineGraphic;
            this.distanceManager.toggleSourceMeasurePoint(),
            0 === t && this.onLineClick(null, 0)
        }
        toggleTargetMP() {
            const {dotPos: t} = this._lineGraphic;
            this.distanceManager.toggleTargetMeasurePoint(),
            1 === t && this.onLineClick(null, 1)
        }
        onSwapClick() {
            this.distanceManager?.swapSourceAndTarget()
        }
        toggleUnitSystem(t) {
            t.stopPropagation(),
            this.distanceManager?.toggleCurrentUnitSystem(),
            this.distanceManager?.updateMeasurement(!1)
        }
        onResultClick(t) {
            const {resultText: e} = this._state
              , i = Boolean(this._isMobile && this._cMenuParent) && !this._cMenuParent._state.isExpanded
              , s = e === a;
            i && this._cMenuParent.setExpanded(!0),
            s ? this.targetSearch?.onInputFocus() : i || this._cMenuParent?.setExpanded(!0)
        }
        onContainerClick(t) {
            t.target === this.element && (this.sourceSearch?.reset(),
            this.targetSearch?.reset())
        }
        addEvents() {
            const {isDraggable: t} = this._state
              , {isTouch: e, canHover: i} = this.app
              , {dragArea: s, lineGraphic: n} = this._children;
            t && (i && s.addEventListener("mousedown", this.onMouseDown),
            e && s.addEventListener("touchstart", this.onTouchStart)),
            i && (n.addEventListener("mouseenter", this.onLineMouseEnter),
            n.addEventListener("mouseleave", this.onLineMouseLeave),
            n.addEventListener("mousemove", this.onLineMouseMove)),
            e && (n.addEventListener("touchstart", this._onLineTouchStart),
            n.addEventListener("touchend", this._onLineTouchEnd)),
            this._isTouch = e,
            this._canHover = i
        }
        removeAllEvents() {
            const {dragArea: t, lineGraphic: e} = this._children;
            t.removeEventListener("mousedown", this.onMouseDown),
            t.removeEventListener("touchstart", this.onTouchStart),
            e.addEventListener("mouseenter", this.onLineMouseEnter),
            e.addEventListener("mouseenter", this.onLineMouseLeave),
            e.addEventListener("mousemove", this.onLineMouseMove),
            e.removeEventListener("touchstart", this._onLineTouchStart),
            e.removeEventListener("touchend", this._onLineTouchEnd)
        }
        setIsSearching(t) {
            this.setState({
                isSearchingClass: t ? "searching" : ""
            })
        }
        setScreenCenter(t, e) {
            this._dragState.screenCenterX = t,
            this._dragState.screenCenterY = e
        }
        setPanelProps() {
            const {width: t, height: e, expandedHeight: i} = this._size
              , {isDraggable: n, isExpandedClass: o} = this._state;
            this._element.style.setProperty("--d-panel-width", n ? `${t}px` : ""),
            this._element.style.setProperty("--d-panel-height", n ? `${o ? i : e}px` : "");
            const {dragX: a, dragY: r, screenCenterX: l, screenCenterY: c} = this._dragState
              , h = .5 * window.innerWidth
              , d = .5 * window.innerHeight
              , u = h - l
              , p = d - c
              , m = s.AppUtils.isLandscape()
              , _ = null !== a ? a + u : h - t * (m ? 1.5 : .5)
              , g = null !== r ? r + p : d - e * (m ? .5 : -1)
              , {limitX: y, limitY: f} = this.getLimitedXandY(_, g);
            this.setDragXY(y, f),
            n ? (this.setTransformCSSVars(y, f),
            this.calcMaxMinBtnPos(y)) : (this.setTransformCSSVars(),
            this.calcMaxMinBtnPos()),
            this.setScreenCenter(h, d)
        }
        get currentlyDragging() {
            return this._dragState.currentlyDragging
        }
        setCurrentlyDragging(t) {
            this._dragState.currentlyDragging = t,
            this.setState({
                currDraggingClass: t ? "dragging" : ""
            })
        }
        setDownXY(t, e) {
            this._dragState.downX = t,
            this._dragState.downY = e
        }
        setLimitXY(t, e) {
            this._dragState.limitX = t,
            this._dragState.limitY = e
        }
        setDragXY(t=this._dragState.x, e=this._dragState.y) {
            this._dragState.dragX = t,
            this._dragState.dragY = e
        }
        setTransformCSSVars(t, e) {
            const i = void 0 === t && void 0 === e;
            this._element.style.setProperty("--d-panel-x", i ? "" : `${t}px`),
            this._element.style.setProperty("--d-panel-y", i ? "" : `${e}px`)
        }
        setCanMinimize(t) {
            this.setState({
                canMinimizeClass: t ? "minimizable" : ""
            })
        }
        setSwapButtonVisible(t) {
            this.setState({
                swapIsVisibleClass: t ? "" : "hidden"
            })
        }
        calcMaxMinBtnPos(t) {
            const {width: e} = this._size
              , {maxMinBtnPosition: i} = this._state
              , s = void 0 === t
              , n = .5 * (window.innerWidth - e)
              , o = !s && t > n ? "left" : "right"
              , a = "left" === o ? "offset" : "";
            o !== i && this.setState({
                maxMinBtnPosition: o,
                swapOffsetClass: a
            })
        }
        getLimitedXandY(t, e) {
            const {isExpandedClass: i} = this._state
              , {width: s, height: n, padding: o, expandedHeight: a} = this._size
              , r = o.top
              , l = window.innerWidth - s
              , c = window.innerHeight - (i ? a : n) - o.bottom;
            return {
                limitX: Math.min(Math.max(0, t), l),
                limitY: Math.min(Math.max(r, e), c)
            }
        }
        toggleIsMinimized(t, e) {
            const {isMinimized: i} = this._state
              , {maxMinButton: s} = this._children
              , n = e ?? !i
              , o = n ? "minimized" : "maximized"
              , a = n ? "icon-plus" : "icon-minus";
            this.setState({
                isMinimized: n,
                isMinimizedClass: o,
                maxMinIconClass: a
            });
            const r = (n ? "Maximize" : "Minimize") + " distance tool panel";
            s.setAttribute("alt", r)
        }
        setIsDraggable(t) {
            this.setState({
                isDraggable: t,
                isDraggableClass: t ? "draggable" : "fixed"
            })
        }
        setIsLoading(t) {
            this.setState({
                isLoadingClass: t ? "" : "hidden"
            })
        }
        setResult({text: t, unit: e, relText: i, relUnit: s, isRelVelocity: n=!1, isDistance: o=!1}={}) {
            clearTimeout(this.app.getManager("distance")?.errorResultTimeout),
            this.setState({
                resultText: t ?? a,
                resultUnit: e ?? "",
                resultTextClass: o ? "distance monospace" : "info semi small color gray med",
                relVelocityText: i ?? "",
                relVelocityUnit: s ?? "",
                relVelocityClass: n ? "rel-velocity monospace" : "hidden",
                isExpandedClass: n ? "expanded" : ""
            });
            const {height: r, expandedHeight: l} = this._size
              , {isDraggable: c} = this._state;
            this._element.style.setProperty("--d-panel-height", c ? `${n ? l : r}px` : "")
        }
        setSourceText(t) {
            const {input: e} = this.sourceSearch?._children || {};
            e && (e.value = t),
            t && this.sourceSearch?.setConfig({
                defaultText: t
            })
        }
        setSourceMpState(t) {
            const e = "Moon" === this.distanceManager?.sourceDisplayName ? " the" : ""
              , i = t ? `<span>from the <span class="mp-highlight">${t}</span> of${e}</span>` : `<span>from${e}</span>`
              , s = t ? "" : "hidden"
              , n = t || "no-toggle";
            this.setState({
                fromText: i,
                showSourceMPToggleClass: s,
                sourceMpClass: n
            })
        }
        setTargetText(t) {
            const {input: e} = this.targetSearch?._children || {};
            e && (e.value = t ?? ""),
            "string" == typeof t && this.targetSearch?.setConfig({
                defaultText: t
            })
        }
        setTargetMpState(t) {
            const e = "Moon" === this.distanceManager?.targetDisplayNames[0] ? " the" : ""
              , i = t ? `<span>to the <span class="mp-highlight">${t}</span> of${e}</span>` : `<span>to${e}</span>`
              , s = t ? "" : "hidden"
              , n = t || "no-toggle";
            this.setState({
                toText: i,
                showTargetMPToggleClass: s,
                targetMpClass: n
            })
        }
        onIsMobileChanged(t) {
            this._isMobile = t,
            this._updateTitleAndCloseBtnParent(this._isMobile),
            this.setIsDraggable(!this._isMobile),
            "function" == typeof this.isMobileChangedCallback && this.isMobileChangedCallback(this._isMobile)
        }
        _updateTitleAndCloseBtnParent(t=this._isMobile) {
            const {dpTitle: e, dpCloseButton: i, dragArea: s} = this._children;
            t ? this.app._dynamicElement.prepend(e, i) : s.append(e, i)
        }
        get allowBpOffset() {
            return this._state.isDraggable && this._state.isMinimized
        }
        setBpCSSOffsets() {
            const t = this.app.pioneer.getInput().getActiveViewport().getCamera()
              , {x: e=0, y: i=0} = this.distanceManager._betweenPosEntity?.getPixelSpacePosition(t) || {};
            this._element.style.setProperty("--d-panel-bpX", `${e}px`),
            this._element.style.setProperty("--d-panel-bpY", `${i}px`)
        }
        onLineClick(t, e) {
            const {lineGraphic: i} = this._children
              , {top: s, height: n} = this._lineGraphic
              , {hasTarget: o} = this.distanceManager;
            if (!o && void 0 === e && (null === t || t.target !== i))
                return;
            clearTimeout(this._touchOptions.activeTimeout),
            this.distanceManager.hideTooltip();
            const a = e ?? (t.clientY - s) / n
              , r = a < .4 ? 0 : a > .6 ? 1 : .5
              , l = 1 === r ? "target-dot" : .5 === r ? "centered-dot" : "source-dot";
            this.setState({
                dotPosClass: l,
                touchActiveClass: ""
            });
            const c = this.distanceManager.getOffsetU(r);
            this.distanceManager.on3dLineClick(null, c),
            this.distanceManager.setHoldU(r)
        }
        onLineMouseMove(t) {
            const {lineGraphic: e} = this._children
              , {top: i, height: s} = this._lineGraphic;
            if (t.target !== e)
                return;
            const {clientY: n} = t
              , o = (n - i) / s
              , a = o < .4 ? 0 : o > .6 ? 1 : .5;
            this.setLineGraphicDotOffset(a)
        }
        onLineMouseEnter() {
            this.setLineGraphicDimensions()
        }
        onLineMouseLeave() {
            this.setLineGraphicDotOffset(null)
        }
        setLineGraphicDimensions() {
            const {lineGraphic: t} = this._children
              , {top: e, height: i} = t.getBoundingClientRect();
            this._lineGraphic.top = e,
            this._lineGraphic.height = i
        }
        _onLineTouchStart(t) {
            clearTimeout(this._touchOptions.activeTimeout);
            const {touchActiveClass: e} = this._state
              , {hasTarget: i} = this.distanceManager;
            i && !e && (t.preventDefault(),
            this.setState({
                touchActiveClass: "touchactive"
            }),
            this.setLineGraphicDimensions(),
            this.distanceManager.showTooltip())
        }
        _onLineTouchEnd() {
            this._touchOptions.activeTimeout = setTimeout(( () => {
                this.setState({
                    touchActiveClass: ""
                }),
                this.distanceManager.hideTooltip()
            }
            ), this._touchOptions.activeDelay)
        }
        setLineGraphicDotPos(t) {
            const {lineGraphic: e} = this._children
              , i = parseFloat(t.toFixed(5))
              , s = 0 === i || 1 === i ? i : t;
            this._lineGraphic.dotPos = s,
            e?.style.setProperty("--focus-dot-pos", 100 * t + "%")
        }
        setLineGraphicDotOffset(t) {
            const {lineGraphic: e} = this._children
              , i = null !== t ? 100 * t + "%" : "unset";
            e?.style.setProperty("--focus-dot-offset", i)
        }
        resize(t, e=!1) {
            const {isTouch: i, canHover: n} = this.app
              , o = s.AppUtils.isMobile()
              , a = this._isMobile !== o
              , r = this._isTouch !== i
              , l = this._canHover !== n;
            (e || a) && this.onIsMobileChanged(o),
            (e || r || l || a) && (this.removeAllEvents(),
            this.addEvents()),
            this.setPanelProps()
        }
        show() {
            this.distanceManager ??= this.app.getManager("distance"),
            this.toggleIsMinimized(null, !1)
        }
        hide() {
            this.toggleIsMinimized(null, !0);
            const {parentElement: t} = this.element;
            "componentContainer" === t.getAttribute("key") && (t.style.opacity = 1,
            t.style.visibility = "visible")
        }
        __enable() {
            super.__enable(),
            this.resize(null, !0)
        }
        __disable() {
            this.removeAllEvents(),
            this._updateTitleAndCloseBtnParent(!1),
            super.__disable()
        }
    }
    DistancePanel.html = o()
}
, function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t) {
    t.exports = '<div class="distance-panel-container {{isVisibleClass}} {{canMinimizeClass}} {{isMinimizedClass}} {{isSearchingClass}}"\n\tonclick="onContainerClick">\n\t<div class="distance-panel {{isDraggableClass}} {{currDraggingClass}}">\n\t\t<div key="dragArea" class="distance-panel-header drag-container">\n\t\t\t<button class="icon icon-drag"></button>\n\t\t\t<h1 key="dpTitle" class="dp-title small semi color gray light">Distance Tool</h1>\n\t\t\t<button key="dpCloseButton" class="dp-close-button icon icon-close clickable" onclick="exit"></button>\n\t\t</div>\n\t\t<div class="distance-panel-content">\n\t\t\t<div key="sourceSearchContainer" class="search-container source">\n\t\t\t\t<span class="from-to color gray x-small">{{fromText}}</span>\n\t\t\t\t<button class="{{showSourceMPToggleClass}} clickable" onClick="toggleSourceMP"\n\t\t\t\t\taria-label="toggle between the center or the surface of the source"></button>\n\t\t\t</div>\n\t\t\t<button class="swap-btn icon distance-swap clickable {{swapIsVisibleClass}} {{swapOffsetClass}}" onClick="onSwapClick"></button>\n\t\t\t<div key="targetSearchContainer" class="search-container target">\n\t\t\t\t<span class="from-to color gray x-small">{{toText}}</span>\n\t\t\t\t<button class="{{showTargetMPToggleClass}} clickable" onClick="toggleTargetMP"\n\t\t\t\t\taria-label="toggle between the center or the surface of the target"></button>\n\t\t\t</div>\n\t\t\t<div class="line-graphic-container {{touchActiveClass}} {{dotPosClass}}">\n\t\t\t\t<button class="source-mp-toggle clickable {{sourceMpClass}}" onClick="toggleSourceMP">\n\t\t\t\t\t<span class="icon distance-source source-icon"></span>\n\t\t\t\t</button>\n\t\t\t\t<button class="target-mp-toggle clickable {{targetMpClass}}" onClick="toggleTargetMP">\n\t\t\t\t\t<span class="icon distance-target target-icon"></span>\n\t\t\t\t</button>\n\t\t\t\t<div class="line-graphic" key="lineGraphic" onClick="onLineClick"></div>\n\t\t\t</div>\n\t\t</div>\n\t</div>\n\t<div class="result-container {{isExpandedClass}}" onClick="onResultClick">\n\t\t<div class="distance-subcontainer">\n\t\t\t<h3 class="result-text {{resultTextClass}}">{{resultText}}</h3>\n\t\t\t<h3 class="result-unit clickable monospace" onclick="toggleUnitSystem">{{resultUnit}}</h3>\n\t\t\t<div class="loading-bar {{isLoadingClass}}"></div>\n\t\t</div>\n\t\t<div class="rel-velocity-subcontainer">\n\t\t\t<span class="tooltip {{relVelocityClass}}"></span>\n\t\t\t<h3 class="result-text distance {{relVelocityClass}}">{{relVelocityText}}</h3>\n\t\t\t<h3 class="result-unit clickable {{relVelocityClass}}" onclick="toggleUnitSystem">{{relVelocityUnit}}</h3>\n\t\t</div>\n\t</div>\n\t<button key="maxMinButton" class="max-min-btn icon {{maxMinIconClass}} {{maxMinBtnPosition}} clickable"\n\t\tonClick="toggleIsMinimized"></button>\n</div>'
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        EventsTimeline: function() {
            return EventsTimeline
        }
    });
    var s = i(749)
      , n = i.n(s)
      , o = i(1)
      , a = (i(1024),
    i(1025))
      , r = i.n(a);
    const {deepMerge: l, debounce: c, throttle: h, formatNumber: d} = o.AppUtils
      , u = "1px";
    class EventsTimeline extends o.BaseComponent {
        constructor(t, e, i={}) {
            super(t, e),
            this._settings = this._app.getComponent("settings"),
            this.defaultOptions = {
                marginPercent: 2,
                events: {
                    clusterCoeff: 8e3,
                    clusterMin: 3,
                    clusterMax: 25,
                    clusterThresh: 1.5
                },
                focusPanel: {
                    padding: 5,
                    tickChar: "|",
                    tickMult: .8,
                    events: {
                        width: 2,
                        threshold: 1
                    },
                    touch: {
                        leftOffset: 70
                    }
                },
                doubleThreshold: 5,
                doubleTimeout: 400,
                tapFadeDelay: 2e3,
                classNames: {
                    clusterMarker: "cluster-marker",
                    eventMarker: "event-marker",
                    eventStatic: "event-static",
                    clusterEventLine: "cluster-line {{clusterLineVisibleClass}} {{clusterLineColorClass}}",
                    focusPanel: {
                        eventLine: "event-line {{fpEventTextSideClass}}"
                    }
                },
                tooltips: {},
                animation: {
                    keyframes: {
                        fpTicks: {
                            zoom: [{
                                transform: "scale(0,0)"
                            }, {
                                transform: "scale(0.1,0.1)"
                            }, {
                                transform: "scale(1,1)"
                            }],
                            left: [{
                                transform: "translateX(0%)"
                            }, {
                                transform: "translateX(-50%)",
                                offset: .49
                            }, {
                                transform: "translateX(50%)",
                                offset: .5
                            }, {
                                transform: "translateX(0%)"
                            }],
                            right: [{
                                transform: "translateX(0%)"
                            }, {
                                transform: "translateX(50%)",
                                offset: .49
                            }, {
                                transform: "translateX(-50%)",
                                offset: .5
                            }, {
                                transform: "translateX(0%)"
                            }]
                        },
                        fpLine: [{
                            opacity: .6
                        }, {
                            opacity: 0
                        }],
                        fpEvents: {
                            zoom: [{
                                transform: "translateY(50%) scale(var(--fpMarker-scaleX), 0)"
                            }, {
                                transform: "translateY(0) scale(var(--fpMarker-scaleX), 1)",
                                offset: .3
                            }, {
                                transform: "scale(1,1) rotate(0.01deg)"
                            }]
                        }
                    },
                    timings: {
                        zoom: {
                            duration: 1200,
                            delay: 200,
                            fill: "forwards",
                            easing: "cubic-bezier(0.3, 0, 0, 1)"
                        }
                    }
                }
            },
            this.setState({
                isVisible: !1,
                isVisibleClass: "hidden",
                targetLineVisibleClass: "hidden",
                targetDateVisibleClass: "hidden",
                viewingLineVisibleClass: "",
                targetDateColorClass: "yellow",
                clusterLineVisibleClass: "hidden",
                clusterLineColorClass: "white",
                rangeDatesVisibleClass: "",
                resetZoomVisibleClass: "hidden",
                fpVisibleClass: "hidden",
                focusContentVisibleClass: "hidden",
                fpTicksVisibleClass: "hidden",
                fpTargetLineVisibleClass: "hidden",
                fpViewingLineVisibleClass: "hidden",
                fpEventName: "",
                fpEventTime: "",
                fpArrowVisible: "hidden"
            }),
            this._localState = {
                target: null,
                title: null,
                time: null,
                dates: {},
                isTouch: this._app.isTouch,
                activeMarkerIndex: -1,
                animMarkerIndex: -1,
                currentHoverMarkerIndex: -1,
                activeEventId: null,
                viewingLineX: 0,
                updateViewingLine: !1,
                toolTipTimeout: null,
                timelinebar: {
                    active: !1,
                    width: null,
                    height: null,
                    left: null,
                    viewingLineX: 0,
                    touchLineX: 0,
                    displayedTip: !1,
                    clickedOnce: !1,
                    doubleClick: !1,
                    fadeTimeout: null
                },
                focusPanel: {
                    enabled: !1,
                    calcWidths: !1,
                    totalWidth: null,
                    contentWidth: null,
                    arrowWidth: null,
                    left: null,
                    viewingLineX: 0,
                    active: !1,
                    animating: !1,
                    wheelX: 0,
                    touchX: 0,
                    touchDeltaX: 0,
                    touchLineX: 0,
                    clickEnabled: !0,
                    displayedTip: !1,
                    clickedOnce: !1,
                    doubleClick: !1
                }
            },
            this._events = [],
            this._markers = [],
            this._tooltips = {},
            this._animations = {},
            this.bindFunctions(["_onTimelineMouseLeave", "_onTimelineMouseMove", "_onTimelineClick", "_onMarkerMouseEnter", "_onMarkerMouseLeave", "_onMarkerMouseMove", "_onViewClick", "_onFpMouseEnter", "_onFpMouseLeave", "_onFpEventMouseOver", "_onFpTicksMouseEnter", "_onFpTicksMouseMove", "_onFpTicksMouseLeave", "_onFpTicksClick", "_onFpWheel", "_onFpTouchStart", "_onFpTouchMove", "_onFpTouchEnd", "_onFpTicksTouchStart", "_onFpTicksTouchMove", "_onFpTicksTouchEnd", "_onMarkerTouch", "_onDateTouchStart", "_onDateTouchEnd", "_onFpEventTouch", "_onFpArrowClick", "_onTimelineTouchStart", "_onTimelineTouchMove", "_onTimelineTouchEnd", "_onOutsideTouch", "_onResize", "_setResizeTimeout", "update"]),
            this._setViewingLineXThrottled = h(this._setViewingLineX, 500),
            this._onFpTouchMoveThrottled = h(this._onFpTouchMove, 100),
            this._showToolTipDebounced = c(this._showToolTip, 2e3),
            this._resizeDebounced = c(this._onResize, 200),
            this._onMarkerMouseEnterDebounced = c(this._onMarkerMouseEnter, 200),
            this._onMarkerMouseLeaveDebounced = c(this._onMarkerMouseLeave, 200),
            this._onTimelineMouseLeaveDebounced = c(this._onTimelineMouseLeave, 200),
            this._onFpMouseLeaveDebounced = c(this._onFpMouseLeave, 200),
            this._setEventNameDebounced = c(this._setEventName, 200),
            window.timeline = this,
            this._resizeTimeout = null,
            this.setOptions({
                ...i
            }, !0),
            this.routeManager = this._app.getManager("router")
        }
        init() {
            super.init();
            const {tooltips: t} = this._options
              , {isTouch: e} = this._localState
              , {timelinebar: i} = this._children
              , s = e ? {
                props: {
                    content: t.tap,
                    interactive: !0,
                    appendTo: this._element,
                    trigger: "manual",
                    touch: !0
                },
                onclick: this._onViewClick
            } : {
                props: {
                    content: t.click,
                    followCursor: "initial",
                    appendTo: this._element,
                    trigger: "manual",
                    touch: !0
                }
            };
            this._tooltips.timelinebar = this._settings.addTooltips([i], s),
            window.ontouchend = this._onOutsideTouch,
            this._callbackRegistry.push({
                emitter: this._app.getManager("time"),
                event: "update",
                callback: this.update
            }, {
                emitter: this._app.getComponent("contentPanel"),
                event: "expandtoggle",
                callback: () => this._setResizeTimeout()
            })
        }
        _addFpTooltips() {
            if (this._tooltips.focusPanel)
                return;
            const {isTouch: t} = this._localState
              , {focusPanel: e, fpTicksContainer: i} = this._children
              , {tooltips: s} = this._options
              , n = t ? e : i
              , o = t ? {
                props: {
                    content: s.tap,
                    interactive: !0,
                    appendTo: n,
                    offset: [10, 0],
                    trigger: "manual",
                    touch: !0
                },
                onclick: this._onViewClick
            } : {
                props: {
                    content: s.click,
                    followCursor: "initial",
                    appendTo: this._element,
                    trigger: "manual",
                    touch: !0
                }
            };
            this._tooltips.focusPanel = this._settings.addTooltips([n], o)
        }
        _createAnimation(t, e, i) {
            const s = new KeyframeEffect(t,e,i);
            return new Animation(s,t.ownerDocument.timeline)
        }
        _depopulateFocusPanel() {
            const {fpContent: t} = this._children;
            for (; t.firstChild; )
                t.removeChild(t.firstChild)
        }
        _populateFocusPanel(t) {
            const {focusPanel: e, activeEventId: i, isTouch: s} = this._localState
              , {timelinebar: n} = this._localState
              , {focusPanel: o, classNames: a} = this._options
              , {fpContent: r, fpMask: l} = this._children;
            e.contentWidth || (e.contentWidth = n.width);
            const c = .01 * o.padding * e.contentWidth
              , h = .01 * o.events.threshold * e.contentWidth
              , d = .5 * o.events.width
              , u = e.contentWidth - 2 * c;
            t.fpEventXs = [];
            const p = t.events.map(( (e, s) => [this._calcXfromTime(e.start, t.min, t.timeRange, u) + c, 0 !== s, e.id === i]));
            for (let t = 0; t < p.length - 1; t++) {
                const e = p[t]
                  , i = p[t + 1]
                  , [s,n] = e
                  , [o] = i
                  , a = o - d - (s + d);
                if (a < h) {
                    const t = h - a;
                    if (n) {
                        const s = .5 * t;
                        e[0] -= s,
                        i[0] += s
                    } else
                        i[0] += t;
                    i[1] = !1
                }
            }
            t.fpEventElements = p.map((e => {
                const [i,,n] = e;
                t.fpEventXs.push(i);
                const l = document.createElement("div");
                return l.className = `${a.focusPanel.eventLine} ${n ? "active" : ""}`,
                s && (l.ontouchstart = t => t.preventDefault(),
                l.ontouchend = this._onFpEventTouch),
                this._app.canHover && (l.onmouseenter = this._onFpEventMouseOver,
                l.onclick = t => {
                    t.preventDefault(),
                    t.stopPropagation(),
                    this._onViewClick(t)
                }
                ),
                l.style.setProperty("width", `${o.events.width}px`),
                l.style.setProperty("left", `${i}px`),
                Array.from(r.children).includes(l) || r.appendChild(l),
                l
            }
            )),
            l.onclick = t => {
                t.preventDefault(),
                t.stopPropagation(),
                this._onViewClick(t)
            }
            ,
            this._setVariables(r)
        }
        _createEventsAndMarkers() {
            const {timelinebar: t} = this._localState
              , {events: e} = this._options
              , i = .01 * e.clusterThresh * t.width;
            this._events.forEach(( (t, e) => {
                const s = this._events[e - 1];
                let n = !0;
                if (s) {
                    this._calcWidthBtwnTimes(s.end, t.start) < i && (n = !1)
                }
                this._addToCluster(t, n)
            }
            )),
            this._markers.forEach((t => {
                const e = Array.from(t.element.children).find((t => t.classList.contains("cluster-num-events")));
                e && t.events.length > 1 && e.appendChild(document.createTextNode(t.events.length)),
                t.element.classList.toggle("single-event", t.events.length < 2)
            }
            ))
        }
        _createEventElement(t) {
            const {classNames: e} = this._options
              , {eventContainer: i} = this._children
              , s = document.createElement("div");
            s.className = e.eventStatic;
            const n = this._calcMidpointX(t.start, t.end);
            s.style.setProperty("left", `${t.cluster ? t.leftX : n}px`),
            i.appendChild(s)
        }
        _addToCluster(t, e=!0) {
            const {classNames: i} = this._options
              , {markerContainer: s} = this._children
              , n = this._getLastCluster()
              , o = this._calcEventClusterMax()
              , a = n && n.events.length === o;
            if (e || !n || a) {
                const e = document.createElement("div");
                e.className = i.clusterMarker,
                e.ontouchstart = this._onMarkerTouch,
                e.onmouseenter = this._onMarkerMouseEnterDebounced,
                e.onmouseleave = this._onMarkerMouseLeaveDebounced,
                e.onmousemove = this._onMarkerMouseMove,
                e.onclick = t => {
                    t.preventDefault(),
                    t.stopPropagation(),
                    this._onViewClick(t)
                }
                ,
                s.appendChild(e),
                this._markers.push({
                    cluster: !0,
                    element: e,
                    events: [t],
                    fpEventElements: [],
                    fpEventXs: []
                })
            } else
                n.events.push(t);
            const r = this._markers.find((e => e.events.includes(t)));
            if (r && r.events.length > 1) {
                const t = document.createElement("div");
                t.classList.add("cluster-num-events");
                Array.from(r.element.children).some((t => t.classList.contains("cluster-num-events"))) || r.element.appendChild(t),
                r.element.classList.add("cluster-dashed-line")
            }
        }
        _createClusterEventLine() {
            if (this._clusterEventLine)
                return;
            const {classNames: t} = this._options;
            this._clusterEventLine = document.createElement("div"),
            this._clusterEventLine.className = t.clusterEventLine,
            this._children.markerContainer.appendChild(this._clusterEventLine)
        }
        _populate() {
            if (!this._events.length || "hidden" !== this._state.focusContentVisibleClass)
                return;
            this._destroy(),
            this._createEventsAndMarkers(),
            this._setMarkerPositions();
            const t = this._markers.some((t => t.cluster));
            this.setLocalState({
                focusPanel: {
                    enabled: t
                }
            }),
            t && this._createClusterEventLine(),
            this._setVariables(this._children.markerContainer)
        }
        _destroy() {
            this._depopulateFocusPanel();
            const {markerContainer: t, eventContainer: e} = this._children;
            for (; t.firstChild; )
                t.removeChild(t.firstChild);
            for (; e.firstChild; )
                e.removeChild(e.firstChild);
            if (this._markers.length)
                for (const t of this._markers)
                    t.element.remove(),
                    t.fpEventElements && t.fpEventElements.filter((t => (t.remove(),
                    !1)));
            this._markers = []
        }
        _setClickedOnce(t, e=!0) {
            const {doubleTimeout: i} = this._options;
            this.setLocalState({
                [t]: {
                    clickedOnce: e
                }
            }),
            e && setTimeout(( () => {
                this.setLocalState({
                    [t]: {
                        clickedOnce: !1
                    }
                })
            }
            ), i)
        }
        _onTimelineMouseLeave(t) {
            this._hideTooltip(!1);
            const {focusPanel: e} = this._localState;
            this.setState({
                targetLineVisibleClass: "hidden",
                targetDateVisibleClass: e.active ? "" : "hidden",
                rangeDatesVisibleClass: e.active ? "hidden" : ""
            }),
            this.setLocalState({
                timelinebar: {
                    active: !1
                }
            })
        }
        _onTimelineMouseMove(t) {
            if (this._hideTooltip(),
            this._onMarkerMouseEnterDebounced.cancel(),
            this._resizeTimeout)
                return;
            const {timelinebar: e} = this._localState
              , {start: i, end: s} = this._options
              , n = t.clientX - e.left
              , o = this._calcTimefromTimelineX(n)
              , a = o.isBefore(i) || o.isAfter(s);
            this.setState({
                targetLineVisibleClass: a ? "hidden" : "",
                targetDateVisibleClass: a ? "hidden" : "",
                targetDateColorClass: "yellow",
                rangeDatesVisibleClass: "hidden"
            }),
            this.setLocalState({
                timelinebar: {
                    active: !0
                },
                focusPanel: {
                    active: !1
                }
            }),
            a || (this._setDateAndPosition(o, n),
            t.target === this._children.timelinebar && this._showToolTipDebounced())
        }
        _onTimelineClick(t) {
            if (t.target !== this._children.timelinebar)
                return;
            const {timelinebar: e} = this._localState
              , i = t.clientX - e.left
              , s = this._calcTimefromTimelineX(i);
            this.goToTime(s),
            this.setLocalState({
                time: s.valueOf()
            })
        }
        _onMarkerMouseEnter(t) {
            const {focusPanel: e, animMarkerIndex: i, activeMarkerIndex: s} = this._localState
              , {currentHoverMarkerIndex: n} = this._localState
              , a = this._markers[n]
              , r = this._markers.find((e => e.element === t.target)) || this._markers[s]
              , l = this._markers.indexOf(r)
              , c = this._markers[i];
            if (this.setLocalState({
                currentHoverMarkerIndex: l
            }),
            a?.element.style.setProperty("width", u),
            e.active && !t.force)
                return;
            this._hideTooltip(),
            this.setState({
                targetLineVisibleClass: "hidden",
                targetDateVisibleClass: "hidden",
                targetDateColorClass: "white",
                fpVisibleClass: "",
                rangeDatesVisibleClass: "hidden",
                fpTargetLineVisibleClass: "hidden",
                fpViewingLineVisibleClass: "hidden"
            });
            if (this._app.getComponent("eventsBlock").setState({
                isIntroLabelVisible: "invisible"
            }),
            o.AppUtils.isMobilePortrait() && this._settings?.hide(),
            this.setLocalState({
                activeMarkerIndex: l,
                animMarkerIndex: r?.cluster ? l : this._localState.animMarkerIndex,
                ...!r?.cluster && {
                    activeEventId: r ? r.events[0].id : this._localState.activeEventId
                }
            }),
            this._markers.forEach((t => this._setActive(t.element, t === r))),
            r)
                if (r.cluster) {
                    if (c === r)
                        return;
                    this._setFocusPanelPos(r)
                } else {
                    const t = r.events[0];
                    this._setEventName(t.title, t.start),
                    this._setDateAndPosition(t.start, r.leftX)
                }
            a && a.events?.length > 1 && (a.element.children[0].innerHTML = a.events.length),
            r && (r.element.style.setProperty("width", "3px"),
            r.events?.length > 1 && (r.element.children[0].innerHTML = "+"))
        }
        _onMarkerMouseLeave() {
            this._resetStates();
            const {currentHoverMarkerIndex: t} = this._localState
              , e = this._markers[t];
            e && (e.element.style.setProperty("width", u),
            e.events?.length > 1 && (e.element.children[0].innerHTML = e.events.length))
        }
        _onMarkerMouseMove(t) {
            t.stopPropagation(),
            this._onFpMouseLeaveDebounced.cancel(),
            this._onMarkerMouseLeaveDebounced.cancel();
            const {timelinebar: e, activeEventId: i, activeMarkerIndex: s, animMarkerIndex: n} = this._localState
              , o = this._markers.find((e => {
                let i;
                return t.target.classList.contains("single-event") && (i = t.target.parentElement),
                (e.element ?? i) === t.target
            }
            ))
              , a = t.clientX - e.left;
            if (o) {
                const t = o.cluster ? this._getNearestIndex(a, o.eventXs) : 0
                  , e = o.events[t]
                  , r = i === e.id
                  , l = s !== n;
                if (l && this._setDateAndPosition(e.start, o.leftX),
                r || l)
                    return;
                o.cluster ? this._setClusterEvent(o, t) : (this._setEventName(e.title, e.start),
                this._setDateAndPosition(e.start, o.leftX))
            }
            this.setLocalState({
                focusPanel: {
                    active: !1
                }
            })
        }
        _onFpMouseEnter() {
            this._onMarkerMouseLeaveDebounced.cancel(),
            this._onFpMouseLeaveDebounced.cancel(),
            this.setLocalState({
                focusPanel: {
                    active: !0
                }
            })
        }
        _onFpMouseLeave(t) {
            "hidden" !== this._state.fpVisibleClass && this._resetStates()
        }
        _onFpEventMouseOver(t) {
            this._hideTooltip();
            const [e,i] = this._getMarkerAndIndexFromFocusEl(t.target);
            this._setClusterEvent(e, i);
            const s = e.fpEventElements.find((t => t.classList.contains("active")))
              , n = {
                element: s,
                leftX: Number(s.style.left.split("px")[0])
            };
            this._setFocusPanelPos(n),
            this.setState({
                targetLineVisibleClass: "hidden",
                targetDateVisibleClass: "hidden",
                targetDateColorClass: "white",
                fpVisibleClass: "",
                rangeDatesVisibleClass: "hidden",
                fpTargetLineVisibleClass: "hidden",
                fpViewingLineVisibleClass: "hidden"
            });
            this._app.getComponent("eventsBlock").setState({
                isIntroLabelVisible: "invisible"
            })
        }
        _onFpTicksMouseEnter() {
            const {activeMarkerIndex: t, title: e} = this._localState
              , i = this._markers[t];
            i && this._setFpElementActive(i),
            this._setEventName(`Between ${e} events`)
        }
        _onFpTicksMouseMove(t) {
            this._hideTooltip();
            const {focusPanel: e, activeMarkerIndex: i} = this._localState;
            if (e.animating || -1 === i)
                return;
            this.setState({
                fpTargetLineVisibleClass: "",
                targetDateVisibleClass: "hidden",
                targetDateColorClass: "yellow",
                clusterLineColorClass: "yellow"
            }),
            this.setLocalState({
                focusPanel: {
                    touchLineX: t.offsetX
                }
            });
            const s = this._calcTimeFromFpX(t.offsetX)
              , n = this._calcXfromTime(s);
            this._setDateAndPosition(s, n),
            this._setClusterLineTransform(n),
            this._children.focusPanel.style.setProperty("--fp-dateline-X", `${t.offsetX}px`),
            this._localState.activeEventId || this._showToolTipDebounced("focusPanel")
        }
        _onFpTicksMouseLeave() {
            this._hideTooltip()
        }
        _onFpTicksClick() {
            this._hideTooltip();
            const {focusPanel: t, activeMarkerIndex: e} = this._localState;
            if (t.animating || -1 === e)
                return;
            const i = this._calcTimeFromFpX(t.touchLineX);
            this.goToTime(i),
            this.setLocalState({
                time: i.valueOf()
            })
        }
        _onViewClick(t) {
            this._hideTooltip();
            const {activeEventId: e, activeMarkerIndex: i, currentHoverMarkerIndex: s} = this._localState
              , {fpTargetLineVisibleClass: n} = this._state;
            let o = "string" == typeof t ? t : e;
            const a = t?.target?.parentElement?.classList?.contains("fp-details")
              , r = t?.target?.firstChild && !t.target.firstChild?.classList?.contains("single-event") && !a
              , l = this._markers[s >= 0 ? s : i];
            o || r || (o = l.events.find((t => t.title === this._state.fpEventName))?.id),
            r ? this._zoomIntoCluster(l) : null !== o ? this.goToEvent(o) : "" === n && this._onDateTouchEnd(),
            this.setLocalState({
                time: null
            })
        }
        _zoomIntoCluster(t=null) {
            const e = this._markers[this._localState.animMarkerIndex] || t
              , {markerContainer: i, eventContainer: s} = this._children;
            for (; i.firstChild; )
                i.removeChild(i.firstChild);
            for (; s.firstChild; )
                s.removeChild(s.firstChild);
            if (e?.events) {
                const t = e.events[0]
                  , i = e.events[e.events.length - 1];
                this._buildRangeOptions({
                    start: t.start,
                    end: i.end
                }),
                this._setStartEndDates(),
                this._populateFocusPanel(e)
            }
            this.setState({
                resetZoomVisibleClass: "",
                focusContentVisibleClass: "",
                fpVisibleClass: ""
            })
        }
        _zoomOutOfCluster() {
            const {target: t, dates: e} = this._localState;
            let i = t;
            t || (i = this._app.getView("object")?.getCurrentTarget());
            const {start: s, end: n} = this._calcCoverage(i, e);
            this._buildRangeOptions({
                start: s,
                end: n
            }),
            this._setStartEndDates(),
            this.setState({
                fpVisibleClass: "hidden",
                resetZoomVisibleClass: "hidden",
                focusContentVisibleClass: "hidden"
            }),
            this._populate()
        }
        _onFpWheel(t) {
            t.preventDefault();
            const {focusPanel: e, animMarkerIndex: i} = this._localState
              , s = .5 * e.contentWidth
              , n = e.wheelX - t.deltaX;
            if (this._hideTooltip(),
            e.animating)
                return;
            if (Math.abs(n) > s) {
                const t = n > 0 ? this._markers[i - 1] : this._markers[i + 1];
                return void this._onMarkerMouseEnter({
                    target: t.element,
                    force: !0
                })
            }
            this.setLocalState({
                focusPanel: {
                    wheelX: n
                }
            });
            const o = {
                duration: 200,
                fill: "forwards",
                easing: "ease-out"
            }
              , a = this._createAnimation(this._children.fpContent, {
                transform: `translateX(${n}px) rotate(0.01deg)`
            }, o)
              , r = this._createAnimation(this._children.fpTicksContainer, {
                transform: `translateX(${n}px)`
            }, o);
            a.play(),
            r.play()
        }
        _onFpTouchStart(t) {
            this._hideTooltip();
            const e = t.touches[0].clientX;
            this.setLocalState({
                focusPanel: {
                    touchX: e
                }
            })
        }
        _onFpTouchEnd() {
            this.setLocalState({
                focusPanel: {
                    clickEnabled: !0
                }
            })
        }
        _onFpTouchMove(t) {
            const {timelinebar: e, focusPanel: i, animMarkerIndex: s} = this._localState;
            if (i.animating)
                return;
            const n = t.touches[0].clientX
              , o = n - i.touchX
              , a = i.touchDeltaX + o
              , r = {
                touchX: n,
                touchDeltaX: a
            };
            i.clickEnabled && Math.abs(o) > 2 && (r.clickEnabled = !1),
            this.setLocalState({
                focusPanel: r
            });
            const l = .7 * this._localState.focusPanel.contentWidth;
            if (Math.abs(a) > l) {
                const t = a > 0
                  , i = t ? this._markers[s - 1] : this._markers[s + 1];
                this._onMarkerTouch({
                    target: i.element,
                    touches: [{
                        clientX: t ? e.width : 0
                    }]
                })
            }
            const c = {
                duration: 100,
                fill: "forwards",
                easing: "ease-out"
            }
              , h = this._createAnimation(this._children.fpContent, {
                transform: `translateX(${a}px) rotate(0.01deg)`
            }, c)
              , d = this._createAnimation(this._children.fpTicksContainer, {
                transform: `translateX(${a}px)`
            }, c);
            h.play(),
            d.play()
        }
        _onFpTicksTouchStart(t) {
            const {timelinebar: e, focusPanel: i, activeMarkerIndex: s, title: n} = this._localState
              , {left: o, arrowWidth: a, touchDeltaX: r, totalWidth: l, clickedOnce: c, touchLineX: h} = i
              , {doubleThreshold: d} = this._options
              , u = t.touches[0].clientX - o - a - r - e.left;
            if (t.preventDefault(),
            t.stopPropagation(),
            i.animating || -1 === s)
                return;
            if (this._hideTooltip(),
            this.setLocalState({
                focusPanel: {
                    touchLineX: u
                }
            }),
            c) {
                if (Math.abs(h - u) < d)
                    return this._setClickedOnce("focusPanel", !1),
                    void this.setLocalState({
                        focusPanel: {
                            doubleClick: !0
                        }
                    })
            } else
                this._setClickedOnce("focusPanel");
            this.setState({
                fpTargetLineVisibleClass: "",
                targetDateVisibleClass: "fp",
                targetDateColorClass: "yellow",
                clusterLineColorClass: "yellow",
                clusterLineVisibleClass: ""
            }),
            this._setEventName(`Between ${n} events`);
            const p = this._markers[s];
            this._setFpElementActive(p);
            const m = this._calcTimeFromFpX(u)
              , _ = o + .5 * l
              , g = this._calcXfromTime(m);
            this._setDateAndPosition(m, _),
            this._setClusterLineTransform(g),
            this._children.focusPanel.style.setProperty("--fp-dateline-X", `${u}px`)
        }
        _onFpTicksTouchMove(t) {
            const {timelinebar: e, focusPanel: i, activeMarkerIndex: s} = this._localState
              , {left: n, arrowWidth: o, touchDeltaX: a, totalWidth: r} = i
              , l = t.touches[0].clientX - n - o - a - e.left;
            if (t.stopPropagation(),
            i.animating || -1 === s)
                return;
            this.setLocalState({
                focusPanel: {
                    touchLineX: l
                }
            }),
            this.setState({
                fpTargetLineVisibleClass: "",
                targetDateVisibleClass: "fp",
                targetDateColorClass: "yellow",
                clusterLineColorClass: "yellow",
                clusterLineVisibleClass: ""
            });
            const c = this._calcTimeFromFpX(l)
              , h = n + .5 * r
              , d = this._calcXfromTime(c);
            this._setDateAndPosition(c, h),
            this._setClusterLineTransform(d),
            this._children.focusPanel.style.setProperty("--fp-dateline-X", `${l}px`)
        }
        _onFpTicksTouchEnd(t) {
            t.stopPropagation(),
            this.setLocalState({
                focusPanel: {
                    animating: !1
                }
            });
            const {focusPanel: e} = this._localState;
            e.doubleClick && (this._onDateTouchEnd(),
            this.setLocalState({
                focusPanel: {
                    doubleClick: !1
                }
            }))
        }
        _onMarkerTouch(t) {
            t.preventDefault && t.preventDefault(),
            t.stopPropagation && t.stopPropagation();
            const {timelinebar: e, animMarkerIndex: i, activeMarkerIndex: s} = this._localState
              , n = this._markers.find((e => e.element === t.target))
              , a = this._markers.indexOf(n)
              , r = this._markers[i];
            if (this._hideTooltip(),
            s !== a)
                if (this._markers.forEach((t => this._setActive(t.element, t === n))),
                this.setState({
                    targetLineVisibleClass: "hidden",
                    targetDateVisibleClass: "hidden",
                    targetDateColorClass: "white",
                    fpTargetLineVisibleClass: "hidden",
                    fpVisibleClass: "",
                    rangeDatesVisibleClass: "hidden",
                    fpViewingLineVisibleClass: "hidden",
                    clusterLineVisibleClass: n?.cluster ? "" : "hidden"
                }),
                o.AppUtils.isMobilePortrait() && this._settings?.hide(),
                this.setLocalState({
                    focusPanel: {
                        active: Boolean(n.cluster)
                    },
                    activeMarkerIndex: a,
                    animMarkerIndex: n.cluster ? a : this._localState.animMarkerIndex
                }),
                n.cluster) {
                    const i = t.touches[0].clientX
                      , s = this._getNearestIndex(i, n.eventXs)
                      , o = e.viewingLineX < n.leftX;
                    this._setFpViewingLineStart(o),
                    n.events.length > 1 && this._zoomIntoCluster(),
                    this._setFocusPanelPos(n),
                    this._setFpAnimation(r, n, s)
                } else {
                    const t = n.events[0];
                    this._setEventNameDebounced.cancel(),
                    this._setEventNameDebounced(t.title),
                    this._setDateAndPosition(t.start, n.leftX),
                    this._showToolTipDebounced()
                }
            else
                n && !n.cluster && (this._onViewClick(n.events[0].id),
                this._resetStates())
        }
        _onDateTouchStart(t) {
            t.preventDefault()
        }
        _onDateTouchEnd() {
            const {timelinebar: t, focusPanel: e} = this._localState;
            if (e.animating)
                return;
            const i = e.active ? this._calcTimeFromFpX(e.touchLineX) : this._calcTimefromTimelineX(t.touchLineX);
            this.goToTime(i),
            this.setLocalState({
                time: i.valueOf()
            })
        }
        _onFpEventTouch(t) {
            t.preventDefault();
            const {focusPanel: e, activeEventId: i} = this._localState;
            if (!e.clickEnabled)
                return;
            const [s,n] = this._getMarkerAndIndexFromFocusEl(t.target)
              , o = s.events[n];
            this._hideTooltip(),
            i !== o.id ? this._setClusterEvent(s, n) : this._onViewClick()
        }
        _onFpArrowClick(t) {
            t.preventDefault();
            const e = "left" === t.target.getAttribute("direction")
              , {timelinebar: i, activeMarkerIndex: s, activeEventId: n, focusPanel: o} = this._localState
              , {fpTargetLineVisibleClass: a} = this._state
              , r = this._markers.find((t => t.events.find((t => t.id === n))))
              , l = this._markers.indexOf(r)
              , c = this._markers[s] || this._markers[l];
            if (void 0 === c)
                return;
            const h = c.events.findIndex((t => t.id === n))
              , d = "" === a ? this._calcTimeFromFpX(o.touchLineX) : this._localState.time;
            this._hideTooltip();
            const u = h > -1 ? e ? h - 1 : h + 1 : this._getNextEventIndexByTime(d, c, e);
            if (c.events[u])
                this._setClusterEvent(c, u);
            else {
                c.events.length > 1 && this._zoomOutOfCluster();
                const t = e ? this._markers[s - 1] : this._markers[s + 1];
                t ? this._onMarkerTouch({
                    target: t.element,
                    touches: [{
                        clientX: e ? i.width : 0
                    }]
                }) : this._resetStates()
            }
        }
        _onTimelineTouchStart(t) {
            if (t.target !== this._children.timelinebar)
                return;
            const {timelinebar: e} = this._localState
              , {clickedOnce: i, touchLineX: s} = e
              , {doubleThreshold: n} = this._options
              , o = t.touches[0].clientX - e.left;
            if (t.preventDefault(),
            this._hideTooltip(),
            this.setLocalState({
                timelinebar: {
                    touchLineX: o
                }
            }),
            i) {
                if (Math.abs(s - o) < n)
                    return this._setClickedOnce("timelinebar", !1),
                    void this.setLocalState({
                        timelinebar: {
                            doubleClick: !0
                        }
                    })
            } else
                this._setClickedOnce("timelinebar");
            this.setLocalState({
                timelinebar: {
                    active: !0
                },
                focusPanel: {
                    active: !1
                }
            }),
            this._resetStates({
                hideDate: !1
            }),
            this.setState({
                targetLineVisibleClass: "",
                targetDateColorClass: "yellow",
                rangeDatesVisibleClass: "hidden"
            });
            const a = o / e.width
              , r = this._options.min + this._options.range * a;
            this._setDateAndPosition(r, o)
        }
        _onTimelineTouchMove(t) {
            const {start: e, end: i} = this._options
              , {timelinebar: s, activeMarkerIndex: n} = this._localState
              , o = t.touches[0].clientX - s.left
              , a = o / s.width
              , r = this._options.min + this._options.range * a
              , l = o < 0 || o > s.width || r < e.valueOf() || r > i.valueOf();
            n > -1 || l || (this.setLocalState({
                timelinebar: {
                    touchLineX: o
                }
            }),
            this.setState({
                targetLineVisibleClass: "",
                targetDateVisibleClass: ""
            }),
            this._setDateAndPosition(r, o))
        }
        _onTimelineTouchEnd() {
            const {activeEventId: t, activeMarkerIndex: e} = this._localState;
            if (null !== t || e > -1)
                return;
            const {timelinebar: i} = this._localState;
            if (i.doubleClick)
                return this._onDateTouchEnd(),
                void this.setLocalState({
                    timelinebar: {
                        doubleClick: !1
                    }
                });
            this.setState({
                targetLineVisibleClass: "hidden-slow",
                targetDateVisibleClass: "hidden-slow",
                rangeDatesVisibleClass: "fadein-slow"
            }),
            clearTimeout(this._localState.timelinebar.fadeTimeout);
            const s = setTimeout(( () => {
                if (this.setState && this.setLocalState) {
                    const {targetLineVisibleClass: t, targetDateVisibleClass: e} = this._state;
                    this.setState({
                        targetLineVisibleClass: "hidden-slow" === t ? "hidden" : t,
                        targetDateVisibleClass: "hidden-slow" === e ? "hidden" : e
                    }),
                    this.setLocalState({
                        timelinebar: {
                            doubleClick: !1
                        },
                        focusPanel: {
                            doubleClick: !1
                        }
                    })
                }
            }
            ), this._options.tapFadeDelay);
            this.setLocalState({
                timelinebar: {
                    active: !1,
                    fadeTimeout: s
                }
            })
        }
        _onOutsideTouch(t) {
            this._element.contains(t.target) || this._resetStates()
        }
        _setResizeTimeout(t=1e3) {
            clearTimeout(this._resizeTimeout),
            this._resizeTimeout = setTimeout(this._resizeDebounced, t)
        }
        _onResize() {
            this._resizeTimeout = null,
            this._resetStates();
            const {width: t, height: e, left: i} = this._children.timelinebar.getBoundingClientRect()
              , s = window.navigator.maxTouchPoints > 0;
            let n = t;
            t || (o.AppUtils.isMobile() ? n = 348 : o.AppUtils.isTablet() && (n = 720));
            this.setLocalState({
                isTouch: s,
                focusPanel: {
                    calcWidths: !0
                },
                timelinebar: {
                    width: t || n,
                    height: e || 40,
                    left: i || 21
                }
            }),
            this._children.timelinebar.style.setProperty("--timeline-height", `${this._localState.timelinebar.height}px`),
            this._populate()
        }
        resize() {
            this._resizeDebounced()
        }
        _calcEventClusterMax() {
            const {events: t} = this._options
              , {timelinebar: e} = this._localState
              , i = Math.floor(t.clusterCoeff / e.width);
            return Math.max(Math.min(i, t.clusterMax), t.clusterMin)
        }
        _calcMidpointX(t, e, i=this._options.min, s=this._options.range, n=this._localState.timelinebar.width) {
            const o = .5 * (t + e);
            return this._calcXfromTime(o, i, s, n)
        }
        _calcWidthBtwnTimes(t, e, i=this._options.range, s=this._localState.timelinebar.width, n=1, o=this._options.range, a=!0) {
            let r = n;
            const l = (e - t) / i;
            return l && !isNaN(l) ? (r = Math.max(l * s, r),
            r = Math.min(r, o),
            a ? Math.round(r) : r) : null
        }
        _calcXfromTime(t, e=this._options.min, i=this._options.range, s=this._localState.timelinebar.width, n=2) {
            let o = s * ((t - e) / i);
            if (o > this._localState.timelinebar.width && (o = this._localState.timelinebar.width),
            !isNaN(o)) {
                const t = d(o, n);
                return "string" == typeof t ? parseFloat(t.replace(/,/g, "")) : null
            }
            return null
        }
        _calcTimefromTimelineX(t) {
            const {timelinebar: e} = this._localState
              , i = t / e.width
              , s = this._options.min + i * this._options.range;
            return n()(s)
        }
        _calcTimeFromFpX(t) {
            const {focusPanel: e, activeMarkerIndex: i} = this._localState
              , {focusPanel: s} = this._options
              , o = .01 * s.padding * e.contentWidth
              , a = (t - o) / (e.contentWidth - 2 * o)
              , r = this._markers[i]
              , l = r.min + a * r.timeRange;
            return n()(l)
        }
        _calcRelativeProgress(t, e, i) {
            return t + i * (e - t)
        }
        _calcFpEventOffset(t, e) {
            const {leftOffset: i} = this._options.focusPanel.touch;
            return i - t.fpEventXs[e]
        }
        _nestedPropsChanged(t, e) {
            for (const i in t) {
                if (null !== t[i] && null !== e[i] && typeof t[i] != typeof e[i])
                    return console.error("Mismatched state types in object", t),
                    !1;
                if (null !== t[i] && t[i].constructor === Object) {
                    if (this._nestedPropsChanged(t[i], e[i]))
                        return !0
                } else if (t[i] !== e[i])
                    return !0
            }
            return !1
        }
        _showToolTip(t="timelinebar") {
            const e = this._tooltips[t]
              , {isTouch: i, activeMarkerIndex: s, timelinebar: n} = this._localState;
            if (this._localState[t].displayedTip || !e)
                return;
            const o = this._markers[s];
            if (i && o && !o.cluster) {
                const t = .5 * n.width
                  , i = o.leftX < t ? "right" : "left"
                  , s = ({placement: e, _: i, popper: s}) => {
                    if ("top" === e) {
                        const e = .5 * s.width;
                        return [Math.min(Math.max(o.leftX, e), n.width - e) - t, 30]
                    }
                    return []
                }
                  , a = ({popper: e, _: s, placement: n}) => {
                    if ("top" === n) {
                        const s = .3 + .4 * Math.abs((o.leftX - t) / t);
                        return {
                            [i]: e.width * s
                        }
                    }
                    return 0
                }
                ;
                this._setTooltipModifiers(e, s, a)
            }
            e.show();
            const {minTime: a} = this._options.tooltips;
            this.setLocalState({
                toolTipTimeout: setTimeout(( () => {
                    this.setLocalState({
                        [t]: {
                            displayedTip: !0
                        }
                    })
                }
                ), a)
            })
        }
        _setTooltipModifiers(t, e, i) {
            const s = [];
            "function" == typeof e && s.push({
                name: "offset",
                options: {
                    offset: e
                }
            }),
            "function" == typeof i && s.push({
                name: "arrow",
                options: {
                    padding: i
                }
            }),
            t.setProps({
                popperOptions: {
                    modifiers: s
                }
            })
        }
        _resetTooltip() {
            this._showToolTipDebounced.cancel(),
            clearTimeout(this._localState.toolTipTimeout)
        }
        _hideTooltip(t=!0) {
            t && this._resetTooltip(),
            Object.values(this._tooltips).forEach((t => t.hide()))
        }
        _resetStates({hideFocusPanel: t=!0, hideClusterLine: e=!0, hideDate: i=!0}={}) {
            const {timelinebar: s} = this._localState;
            if (this._hideTooltip(!1),
            o.AppUtils.isMobilePortrait() && this._app.getComponent("collapsibleMenu")?.getState("isVisible") && (t ? this._settings?.show() : this._settings?.hide()),
            this.setState({
                fpVisibleClass: t ? "hidden" : "",
                rangeDatesVisibleClass: t ? "" : "hidden",
                clusterLineVisibleClass: e ? "hidden" : "",
                targetDateVisibleClass: i && !s.active ? "hidden" : "",
                fpArrowVisible: o.AppUtils.isMobile() || o.AppUtils.isTablet() ? "" : "hidden"
            }),
            this.setLocalState({
                activeMarkerIndex: -1,
                animMarkerIndex: -1,
                activeEventId: null,
                focusPanel: {
                    active: !1,
                    wheelX: 0
                }
            }),
            !o.AppUtils.isMobile() && !o.AppUtils.isTablet()) {
                this._app.getComponent("eventsBlock").setState({
                    isIntroLabelVisible: ""
                })
            }
            this._markers.forEach((t => this._setActive(t.element, !1)))
        }
        _setViewingLineX(t) {
            const {timelinebar: e, updateViewingLine: i, focusPanel: s} = this._localState
              , n = {
                viewingLineVisibleClass: "hidden",
                fpViewingLineVisibleClass: "hidden"
            }
              , o = {
                updateViewingLine: !1
            }
              , a = this._calcXfromTime(t)
              , r = this._getFpViewingLineX(t);
            if (a) {
                const t = e.width && a <= e.width;
                n.viewingLineVisibleClass = t ? "" : "hidden",
                (a !== e.viewingLineX || i) && (this._children.timelinebar.style.setProperty("--viewingline-X", `${a}px`),
                o.timelinebar = {
                    viewingLineX: a
                })
            }
            r && (n.fpViewingLineVisibleClass = "",
            (r !== s.viewingLineX || i) && (this._children.focusPanel.style.setProperty("--fp-viewingline-X", `${r}px`),
            o.focusPanel = {
                viewingLineX: r
            })),
            this.setState(n),
            this.setLocalState(o)
        }
        _setFpViewingLineStart(t) {
            const {focusPanel: e} = this._localState
              , i = e.width || 1e3
              , s = t ? -i : 2 * i;
            this._children.focusPanel.style.setProperty("--fp-viewingline-X", `${s}px`)
        }
        _setClusterEvent(t, e) {
            const i = t.events[e]
              , s = t.eventXs[e]
              , n = t.fpEventElements[e];
            this._setEventName(i.title, i.start),
            this._setDateAndPosition(i.start, s),
            this._setClusterLineTransform(s),
            this.setState({
                clusterLineVisibleClass: "",
                clusterLineColorClass: "white",
                targetDateColorClass: "white",
                targetDateVisibleClass: "hidden",
                fpTargetLineVisibleClass: "hidden",
                fpVisibleClass: ""
            }),
            this._setFpElementActive(t, n)
        }
        _setFpAnimation(t, e, i) {
            const s = t
              , n = this._markers.indexOf(e)
              , {isTouch: o} = this._localState;
            if (s) {
                const s = 700
                  , a = 2e3
                  , r = t.leftX < e.leftX
                  , l = this._getNormDistance(t, e)
                  , c = this._calcRelativeProgress(s, a, l)
                  , h = .39 * c
                  , d = {
                    focusPanel: {
                        animating: !0
                    }
                };
                o || (this.setState({
                    clusterLineVisibleClass: "hidden"
                }),
                d.activeMarkerIndex = -1),
                this.setLocalState(d);
                const u = () => {
                    t.fpEventElements = [],
                    this._depopulateFocusPanel(t),
                    this._populateFocusPanel(e);
                    const s = {
                        activeMarkerIndex: n,
                        animMarkerIndex: n,
                        updateViewingLine: !0,
                        [o ? "touchDeltaX" : "wheelX"]: 0,
                        focusPanel: {
                            active: !0
                        }
                    };
                    void 0 !== i && this._setClusterEvent(e, i),
                    this.setLocalState(s);
                    const a = this._getFpEventsEnterAnim(h, r, 0);
                    a.onfinish = () => {
                        this.setLocalState({
                            focusPanel: {
                                animating: !1
                            }
                        })
                    }
                    ,
                    a.play()
                }
                  , p = this._getFpEventsExitAnim(h, r);
                p.onfinish = u,
                p.play();
                const m = this._getFpTickAnim(l, c, r)
                  , _ = this._getFpLineAnim(c);
                m.play(),
                _.play()
            } else {
                const {animation: {keyframes: t, timings: s}} = this._options;
                this._depopulateFocusPanel(),
                this._populateFocusPanel(e);
                const a = {
                    activeMarkerIndex: n,
                    animMarkerIndex: n,
                    updateViewingLine: !0,
                    [o ? "touchDeltaX" : "wheelX"]: 0,
                    focusPanel: {
                        active: !0
                    }
                }
                  , r = [...t.fpEvents.zoom];
                void 0 !== i && this._setClusterEvent(e, i),
                this.setLocalState(a);
                this._createAnimation(this._children.fpContent, r, s.zoom).play();
                const l = this._createAnimation(this._children.fpTicks, t.fpTicks.zoom, s.zoom)
                  , c = this._createAnimation(this._children.fpLine, t.fpLine, s.zoom);
                l.play(),
                c.play()
            }
        }
        _getFpViewingLineX(t) {
            const {activeMarkerIndex: e, focusPanel: i} = this._localState;
            if (-1 !== e) {
                const {focusPanel: s} = this._options
                  , {min: n, timeRange: o} = this._markers[e]
                  , a = .01 * s.padding * i.contentWidth
                  , r = i.contentWidth - 2 * a
                  , l = this._calcXfromTime(t, n, o, r, 0);
                if (null !== l) {
                    const t = l + Math.round(a);
                    if (t > -r && t < 2 * r)
                        return t
                }
            }
            return null
        }
        _getNearestEvent(t, e) {
            if (t.cluster) {
                const i = this._getNearestIndex(e, t.eventXs);
                return t.events[i]
            }
            return t.events[0]
        }
        _getNextEventIndexByTime(t=this._localState.time, e, i) {
            let s = -1;
            return e.events.forEach(( (e, i) => {
                t > e.start.valueOf() && (s = i)
            }
            )),
            i ? s : s + 1
        }
        _setDateAndPosition(t, e) {
            const {timelinebar: i} = this._children
              , s = ("number" == typeof t ? n()(t) : t).format("MMM DD, YYYY");
            i.style.setProperty("--formatted-date", `'${s}'`),
            e && i.style.setProperty("--dateline-X", `${e}px`)
        }
        _setEventName(t, e=null) {
            const {activeMarkerIndex: i, timelinebar: s} = this._localState;
            let o = 50;
            const a = this._markers[i];
            if (a && !a.cluster && (o = a.leftX / s.width * 100),
            this._element.style.setProperty("--event-offset-x", `-${o}%`),
            this._element.style.setProperty("--event-name", `'${t}'`),
            e) {
                const t = e
                  , i = ("number" == typeof t ? n()(t) : t).format("MMM DD, YYYY");
                this.setState({
                    fpEventTime: i
                })
            }
            this.setState({
                fpEventName: t
            })
        }
        _setActive(t, e) {
            e ? t.classList.add("active") : t.classList.remove("active")
        }
        _getNormDistance(t, e) {
            const {timelinebar: i} = this._localState;
            return Math.abs(e.leftX - t.leftX) / i.width
        }
        _getFpEventsEnterAnim(t, e, i) {
            const s = {
                duration: t,
                fill: "forwards",
                easing: "cubic-bezier(0, 1, 0, 1)"
            }
              , n = e ? "" : "-"
              , o = [{
                transform: `translateX(${n}100%) scaleY(0)`
            }, {
                transform: `translateX(${n}50%) scaleY(0.1)`
            }, {
                transform: `translateX(${i}px) scaleY(1) rotate(0.01deg)`
            }];
            return this._createAnimation(this._children.fpContent, o, s)
        }
        _getFpEventsExitAnim(t, e) {
            const i = {
                duration: t,
                easing: "cubic-bezier(.2, 0, 0, 1)"
            }
              , s = e ? "-" : ""
              , n = [{
                transform: `translateX(${s}50%) scaleY(0.1)`,
                offset: .5
            }, {
                transform: `translateX(${s}100%) scaleY(0)`
            }];
            return this._createAnimation(this._children.fpContent, n, i)
        }
        _getFpTickAnim(t, e, i) {
            const s = {
                duration: e,
                fill: "forwards",
                easing: "cubic-bezier(0, 1, 0, 1)"
            }
              , n = this._calcRelativeProgress(50, 150, t)
              , o = [{
                transform: "translateX(0%)"
            }, {
                transform: `translateX(${i ? "-" : ""}${n}%)`,
                offset: .49
            }, {
                transform: `translateX(${i ? "" : "-"}${n}%)`,
                offset: .5
            }, {
                transform: "translateX(0%)"
            }];
            return this._createAnimation(this._children.fpTicksContainer, o, s)
        }
        _getFpLineAnim(t) {
            const e = {
                duration: t,
                fill: "forwards",
                easing: "cubic-bezier(0, 1, 0, 1)"
            };
            return this._createAnimation(this._children.fpLine, [{
                opacity: 0
            }, {
                opacity: .6
            }, {
                opacity: 0
            }], e)
        }
        _setFpEventScaledClass(t) {
            t.fpEventElements.forEach((t => t.classList.add("scaled"))),
            requestAnimationFrame(( () => t.fpEventElements.forEach((t => t.classList.remove("scaled")))))
        }
        _setClusterLineTransform(t) {
            this._clusterEventLine.style.setProperty("transform", `translateX(calc(${t}px - 50%))`)
        }
        _getMarkerAndIndexFromFocusEl(t) {
            for (const e of this._markers)
                if (e.fpEventElements) {
                    const i = e.fpEventElements.indexOf(t);
                    if (i > -1)
                        return [e, i]
                }
            return null
        }
        _setFpElementActive(t, e) {
            t.fpEventElements.forEach((t => t.classList.toggle("active", t === e)));
            const i = t.fpEventElements.indexOf(e)
              , s = i > -1 ? t.events[i].id : null;
            this.setLocalState({
                activeEventId: s
            })
        }
        _setFocusPanelPos({leftX: t, widthPx: e}) {
            const {focusPanel: i, fpMask: s, fpDetails: n} = this._children;
            if (this._localState.focusPanel.calcWidths) {
                const t = i.getBoundingClientRect().width
                  , e = s.getBoundingClientRect().width
                  , n = .5 * (t - e);
                this._setNumOfTicks(e),
                this.setLocalState({
                    focusPanel: {
                        calcWidths: !1,
                        totalWidth: t,
                        contentWidth: e,
                        arrowWidth: n
                    }
                }),
                i.style.setProperty("--fp-midpoint", .5 * t + "px")
            }
            const {timelinebar: o, focusPanel: a} = this._localState
              , r = n.getBoundingClientRect().width
              , l = r / 2
              , c = o.width - r > 0 ? o.width - r : 0
              , h = Math.min(Math.max(t - l, 0), c)
              , d = t - l
              , u = e / a.contentWidth;
            i.style.setProperty("--focus-X", `${h}px`),
            i.style.setProperty("--fpMarker-X", `${d}px`),
            i.style.setProperty("--fpMarker-scaleX", `${u}`)
        }
        _setNumOfTicks(t) {
            const {tickChar: e, tickMult: i} = this._options.focusPanel
              , s = Math.round(t * i);
            this._children.fpTicks.innerText = e.repeat(s)
        }
        _getLastCluster() {
            for (let t = this._markers.length - 1; t >= 0; t--) {
                const e = this._markers[t];
                if (e.cluster)
                    return e
            }
            return null
        }
        _setMarkerPositions() {
            const {events: t, range: e} = this._options
              , i = .01 * t.clusterThresh * 2 * e
              , s = .5 * i;
            this._markers.forEach(( (t, e) => {
                const n = t.cluster ? 3 : 2
                  , o = t.events[0]
                  , a = t.events[t.events.length - 1];
                t.widthPx = Math.max(this._calcWidthBtwnTimes(o.start, a.end), n),
                t.leftX = this._calcMidpointX(o.start, a.end),
                t.min = Math.min(...t.events.map((t => t.start))),
                t.max = Math.max(...t.events.map((t => t.end))),
                t.timeRange = t.max - t.min;
                const r = 1 === t.events.length;
                r && t.timeRange < i && (0 === e ? t.max = o.end.clone().add(i, "milliseconds") : e === this._markers.length - 1 ? t.min = o.start.clone().subtract(i, "milliseconds") : (t.min = o.start.clone().subtract(s, "milliseconds"),
                t.max = o.end.clone().add(s, "milliseconds")),
                t.timeRange = t.max - t.min),
                t.cluster && (t.eventXs = t.events.map((t => this._calcMidpointX(t.start, t.end))),
                r && this._createEventElement(t)),
                t.element.style.setProperty("width", u),
                t.element.style.setProperty("transform", `translateX(calc(${t.leftX}px - 50%))`)
            }
            ))
        }
        _getNearestIndex(t, e) {
            const i = e.reduce(( (e, i) => Math.abs(i - t) < Math.abs(e - t) ? i : e));
            return e.indexOf(i)
        }
        setOptions(t, e=!1) {
            const i = e ? this.defaultOptions : this._options;
            this._options = l(i, t)
        }
        setLocalState(t) {
            const e = this._localState;
            this._nestedPropsChanged(t, e) && (this._localState = l(this._localState, t))
        }
        _setEvents(t) {
            this._events = [...t],
            this._events.forEach((t => {
                t.start = n()(t.start),
                t.end = t.end ? n()(t.end) : t.start.clone().add(1, "hours")
            }
            )),
            this._events.sort(( (t, e) => t.start > e.start))
        }
        _buildRangeOptions(t) {
            const {start: e, end: i} = t
              , s = {
                start: e,
                end: i
            }
              , n = (s.end - s.start) * this._options.marginPercent * .01;
            s.min = s.start.clone().subtract(n, "milliseconds"),
            s.max = s.end.clone().add(n, "milliseconds"),
            s.range = s.max - s.min,
            this.setOptions(s)
        }
        _setStartEndDates() {
            const {start: t, end: e} = this._options
              , {rangeDateStart: i, rangeDateEnd: s} = this._children;
            i.setAttribute("datetime", t.toISOString()),
            i.innerText = t.format("MMM DD, YYYY"),
            s.setAttribute("datetime", e.toISOString()),
            s.innerText = e.format("MMM DD, YYYY")
        }
        _calcCoverage(t, {start: e, end: i}) {
            let {min: s, max: o} = this._app.getManager("time").getDefaultLimits();
            const a = this._app.getManager("scene").getCoverage(t);
            return null !== a.min && (s = n().max(s, a.min)),
            null !== a.max && (o = n().min(o, a.max)),
            e && (s = n()(e)),
            i && (o = n()(i)),
            {
                start: s,
                end: o
            }
        }
        setTarget({id: t, title: e, dates: i, orderedEvents: s}) {
            const n = t !== this._localState.target;
            if (t && s && (this.setTime(),
            n)) {
                this.setLocalState({
                    target: t,
                    title: e,
                    dates: i
                }),
                this._setEvents(s);
                const n = this._calcCoverage(t, i);
                this._buildRangeOptions(n),
                this._setStartEndDates()
            }
        }
        checkForZoom(t) {
            if (!this._markers)
                return;
            const e = this._markers.find((e => e.events.length > 1 ? e.events?.find((e => e?.id === t?.id)) : null));
            t && e ? this._zoomIntoCluster(e) : this._zoomOutOfCluster()
        }
        show() {
            super.show(),
            this._setResizeTimeout(200)
        }
        hide() {
            super.hide()
        }
        __disable() {
            clearTimeout(this._resizeTimeout),
            super.__disable()
        }
        goToTime(t) {
            const e = this.routeManager.currentRoute.url
              , i = e.indexOf("events")
              , s = i > -1 ? e.slice(0, i) : e
              , n = this._app.getManager("time").getTimeUrl(t);
            this.routeManager.navigate({
                time: n
            }, s)
        }
        goToEvent(t) {
            const e = this.routeManager.currentRoute.url
              , i = e.lastIndexOf("events");
            let s = `${e}${e.endsWith("/") ? "" : "/"}`;
            -1 === i ? s += `events/${t}` : (s.endsWith("events/") || (s = s.slice(0, i + 7)),
            s += t),
            this.routeManager.navigate(s)
        }
        setTime() {
            const t = this.routeManager.query.time;
            t && this.setLocalState({
                time: n()(t).valueOf()
            })
        }
        update(t) {
            this._state.isVisible && this.isEnabled() && this._setViewingLineXThrottled(t)
        }
    }
    EventsTimeline.html = r()
}
, function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t) {
    t.exports = '<timeline class="events-timeline small semi {{isVisibleClass}}">\n\t<div \n\t\tclass="focus-container {{fpVisibleClass}}" \n\t\tkey="focusPanel"\n\t\tonmouseenter="_onFpMouseEnter"\n\t\tonmouseleave="_onFpMouseLeaveDebounced"\n\t\tonwheel="_onFpWheel"\n\t>\n\t<button class="fp-arrow left clickable {{fpArrowVisible}}" direction="left" onclick="_onFpArrowClick"></button>\n\t\t<div \n\t\t\tclass="fp-mask"\n\t\t\tkey="fpMask"\n\t\t\tontouchstart="_onFpTouchStart"\n\t\t\tontouchmove="_onFpTouchMoveThrottled"\n\t\t\tontouchend="_onFpTouchEnd"\n\t\t>\n\t\t\t<div key="fpDetails" class="fp-details">\n\t\t\t\t<h2>{{fpEventName}}</h2>\n\t\t\t\t<time>{{fpEventTime}}</time>\n\t\t\t</div>\n\t\t\t<div class="focus-ticks-container hidden" key="fpTicksContainer">\n\t\t\t\t<div class="focus-line" key="fpLine"></div>\n\t\t\t\t<span \n\t\t\t\t\tclass="focus-ticks"\n\t\t\t\t\tkey="fpTicks"\n\t\t\t\t\tontouchstart="_onFpTicksTouchStart"\n\t\t\t\t\tontouchmove="_onFpTicksTouchMove"\n\t\t\t\t\tontouchend="_onFpTicksTouchEnd"\n\t\t\t\t\tonmouseenter="_onFpTicksMouseEnter"\n\t\t\t\t\tonmousemove="_onFpTicksMouseMove"\n\t\t\t\t\tonmouseleave="_onFpTicksMouseLeave"\n\t\t\t\t\tonclick="_onFpTicksClick"\n\t\t\t\t>\n\t\t\t\t</span>\n\t\t\t\t<div class="focus-target-line {{fpTargetLineVisibleClass}}"></div>\n\t\t\t\t<div class="focus-viewing-line {{fpViewingLineVisibleClass}}"></div>\n\t\t\t</div>\n\t\t</div>\n\t\t<button class="fp-arrow right clickable {{fpArrowVisible}}" direction="right" onclick="_onFpArrowClick"></button>\n\t</div>\n\t<div \n\t\tclass="bar" \n\t\tkey="timelinebar"\n\t\tontouchstart="_onTimelineTouchStart"\n\t\tontouchmove="_onTimelineTouchMove"\n\t\tontouchend="_onTimelineTouchEnd"\n\t\tonmousemove="_onTimelineMouseMove"\n\t\tonmouseleave="_onTimelineMouseLeaveDebounced"\n\t\tonclick="_onTimelineClick"\n\t>\n\t\t<div class="event-container" key="eventContainer"></div>\n\t\t<div class="focus-content {{focusContentVisibleClass}}"  key="fpContent"></div>\n\t\t<div class="marker-container" key="markerContainer"></div>\n\t\t<div class="viewing-line {{viewingLineVisibleClass}}"></div>\n\t\t<div class="target-date-line {{targetLineVisibleClass}}"></div>\n\t\t<span class="target-date-label {{targetDateVisibleClass}} {{targetDateColorClass}}" ontouchstart="_onDateTouchStart" ontouchend="_onDateTouchEnd"></span>\n\t</div>\n\t<div class="timeline-footer-container">\n\t\t<time class="range-date start-date" key="rangeDateStart"></time>\n\t\t<div class="reset-zoom-button clickable {{resetZoomVisibleClass}}" onclick="_zoomOutOfCluster">Reset Zoom</div>\n\t\t<time class="range-date end-date" key="rangeDateEnd"></time>\n\t</div>\n</timeline>'
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        CollapsibleMenu: function() {
            return CollapsibleMenu
        }
    });
    var s = i(1)
      , n = i(890)
      , o = (i(1027),
    i(1028))
      , a = i.n(o);
    i(1029);
    class CollapsibleMenu extends s.BaseComponent {
        constructor(t) {
            super(t, null, {
                numMenusClass: "",
                expandedMenusClass: ""
            }),
            this._menuItems = [],
            this._expandedItems = [],
            this._allowMultiple = !0,
            this._maxHeight = this._getMaxHeight(),
            this._availableHeight = this._calcAvailableHeight(),
            this._resizeObserver = new ResizeObserver((t => {
                t.forEach(( () => {
                    this._maxHeight = this._getMaxHeight(),
                    this._availableHeight = this._calcAvailableHeight();
                    this._availableHeight < 0 && this._expandedItems > 1 && this._collapseLastItem()
                }
                ))
            }
            )),
            this._eventNames.push("expandtoggle"),
            this._initCallbacks(),
            this.bindFunctions(["onItemToggle", "onItemVisibleChange"])
        }
        init() {
            super.init(),
            this._resizeObserver.observe(this._element)
        }
        _getMaxHeight() {
            const t = window.innerHeight;
            return t > 600 ? .4 * t : .5 * t
        }
        _calcUsedHeight() {
            let t = 0;
            return this._expandedItems.forEach(( ({_config: e}) => {
                const {height: i} = e;
                t += i.max
            }
            )),
            t
        }
        _calcAvailableHeight() {
            const t = this._calcUsedHeight();
            return this._maxHeight - t
        }
        _itemHasSpace({height: t}) {
            return this._availableHeight > t.max
        }
        _addExpandedItem(t) {
            this._expandedItems.push(t),
            this._availableHeight = this._calcAvailableHeight()
        }
        _removeExpandedItem(t) {
            this._expandedItems = this._expandedItems.filter((e => e !== t)),
            this._availableHeight = this._calcAvailableHeight()
        }
        _collapseLastItem() {
            this._expandedItems.length && this._expandedItems[0].setExpanded(!1)
        }
        collapse() {
            for (let t = 0; t < this._menuItems.length; t++)
                this._menuItems[t].setExpanded(!1);
            this.triggerCallbacks("expandtoggle", [!1])
        }
        _setBtmGradScale() {
            const t = (80 + this._calcUsedHeight()) / 80;
            document.body.style.setProperty("--btm-grad-height", "80px"),
            document.body.style.setProperty("--btm-grad-scale", t)
        }
        async addItem({itemTitle: t, componentNames: e, positionIndex: i, dimensions: s, expand: o=!0}) {
            const a = `${t.split(" ").join("").toLowerCase()}Collapsible`;
            let r = this._app.getComponent(a);
            const l = Boolean(r);
            if (!l) {
                const i = n.Types.get("CollapsibleMenuItem");
                r = await i.create(this._app, a, i, !1, [this], {
                    isVisible: !0,
                    parent: this._element,
                    itemTitle: t,
                    config: s
                }),
                this._callbackRegistry.push({
                    emitter: r,
                    event: "expandtoggle",
                    callback: this.onItemToggle
                }, {
                    emitter: r,
                    event: "visiblechange",
                    callback: this.onItemVisibleChange
                }),
                this.registerCallbacks(),
                e.forEach(( (t, e) => {
                    const i = this._app.getComponent(t);
                    r.addComponent(i, 0 === e)
                }
                ))
            }
            i >= this._element.children.length ? this._element.appendChild(r.element) : this._element.insertBefore(r.element, this._element.children[i]),
            this._menuItems.push(r);
            const {embed: c} = this._app.getManager("router").configs
              , h = (l && o ? r.getState("isExpanded") : o) && this._itemHasSpace(s) && !c;
            return r.setExpanded(h),
            this.onItemVisibleChange(),
            r
        }
        removeAllItems() {
            this._menuItems.forEach(( ({element: t}) => {
                t?.parentNode === this._element && this._element.removeChild(t)
            }
            )),
            this._menuItems = [],
            this._expandedItems = [],
            this.onItemVisibleChange(),
            this._availableHeight = this._calcAvailableHeight()
        }
        onItemToggle(t, e) {
            const {_config: i} = e;
            if (t) {
                this._itemHasSpace(i) && this._allowMultiple || this._collapseLastItem(),
                this._addExpandedItem(e)
            } else
                this._removeExpandedItem(e);
            this.setState({
                expandedMenusClass: `expanded-${this._expandedItems.length}`
            }),
            this._expandedItems.length > 0 ? this.triggerCallbacks("expandtoggle", [!0]) : this.triggerCallbacks("expandtoggle", [!1]),
            this._setBtmGradScale()
        }
        onItemVisibleChange() {
            this.setState({
                numMenusClass: `items-${this.visibleItems.length}`,
                expandedMenusClass: `expanded-${this._expandedItems.length}`
            })
        }
        setAllowMultiple(t) {
            this._allowMultiple = t
        }
        get visibleItems() {
            return this._menuItems.filter((t => t.getState("isVisible")))
        }
        get allItems() {
            return this._element?.childNodes
        }
    }
    CollapsibleMenu.html = a()
}
, function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t) {
    t.exports = '<nav class="c-menu-container {{isVisibleClass}} {{numMenusClass}} {{expandedMenusClass}}"></nav>'
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        CollapsibleMenuItem: function() {
            return CollapsibleMenuItem
        }
    });
    var s = i(1)
      , n = (i(1030),
    i(1031))
      , o = i.n(n);
    class CollapsibleMenuItem extends s.BaseComponent {
        constructor(t, e, i={}) {
            super(t, null, {
                isExpanded: !1,
                expandedClass: "collapsed",
                collapseBtnVisibleClass: "hidden",
                itemTitle: "",
                ...i
            }),
            this._parentComponent = e,
            this._components = [],
            this._eventNames.push("expandtoggle"),
            this._initCallbacks()
        }
        init() {
            super.init();
            const {collapseButton: t} = this._children
              , {itemTitle: e, isExpanded: i} = this._state;
            t.setAttribute("aria-label", `${i ? "Collapse" : "Expand"} ${e.toLowerCase()}`);
            const {width: s} = this._config;
            this._element.style.setProperty("--container-width", `clamp(${s.min}px, 100%, ${s.max}px)`),
            this._setContainerHeight(i),
            this._setToggleAriaLabel(i)
        }
        addComponent(t, e=!1) {
            this._components.push(t),
            e && t.registerCallback("statuschange", (t => {
                t ? this.show() : this.hide()
            }
            )),
            t._cMenuParent = this;
            const {componentContainer: i} = this._children;
            t.setParent(i),
            i.appendChild(t.element)
        }
        onToggleClick() {
            const {isExpanded: t} = this._state
              , e = !t;
            this.setExpanded(e)
        }
        onCollapseClick() {
            this.setExpanded(!1)
        }
        _setToggleAriaLabel(t) {
            const {toggleButton: e} = this._children
              , {itemTitle: i} = this._state
              , s = t ? "Collapse" : "Expand";
            e.setAttribute("aria-label", `${s} ${i.toLowerCase()}`)
        }
        setExpanded(t) {
            this.triggerCallbacks("expandtoggle", [t, this]),
            t !== this._state.isExpanded && (this.setState({
                isExpanded: t,
                expandedClass: t ? "expanded" : "collapsed",
                collapseBtnVisibleClass: t ? "" : "hidden"
            }),
            this._setToggleAriaLabel(t),
            t ? this._components.forEach((t => t.show())) : this._components.forEach((t => t.hide())),
            this._setContainerHeight(t))
        }
        _setContainerHeight(t) {
            const {height: e} = this._config
              , i = t ? e.max : e.min;
            this._element.style.setProperty("--container-height", `${i}px`),
            e.active && this._element.style.setProperty("--container-height-active", `${e.active}px`)
        }
        get parentComponent() {
            return this._parentComponent
        }
    }
    CollapsibleMenuItem.html = o()
}
, function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t) {
    t.exports = '<div class="c-menu-item {{expandedClass}} {{isVisibleClass}}">\n\t<div key="componentContainer" class="expanded-container">\n\t\t<button key="collapseButton" class="item-collapse-btn clickable {{collapseBtnVisibleClass}} icon collapse-arrow" onclick="onCollapseClick"></button>\n\t</div>\n\t<button key="toggleButton" class="item-toggle-btn clickable" onclick="onToggleClick">{{itemTitle}}</button>\n</div>\n'
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        TimeControls: function() {
            return TimeControls
        }
    });
    var s = i(1)
      , n = (i(1033),
    i(1034))
      , o = i.n(n);
    const {formatNumber: a, throttle: r} = s.AppUtils
      , l = {
        yr: 31536e3,
        mth: 2592e3,
        wk: 604800,
        day: 86400,
        hr: 3600,
        min: 60,
        sec: 1
    };
    class TimeControls extends s.BaseComponent {
        constructor(t, e={}) {
            super(t, null, {
                isVisible: !0,
                isPlaying: null,
                isPlayingClass: "",
                isLiveClass: "",
                touchActiveClass: "",
                realTimeBtnClass: "hidden",
                isRateControlsVisible: "",
                playIconClass: null,
                rateDisplay: null,
                timeLimit: null,
                ...e
            }),
            this._curve = {
                x: 0,
                y: 0,
                cp1x: 60,
                cp1y: 50,
                cp2x: 540,
                cp2y: 50,
                endx: 600,
                endy: 0
            },
            this._rates = [-94608e3, -31536e3, -6048e3, -604800, -86400, -36e3, -3600, -600, -60, -10, -1, 1, 10, 60, 600, 3600, 36e3, 86400, 604800, 6048e3, 31536e3, 94608e3],
            this._class.isPlaying = {
                true: "rate-pause",
                false: "rate-play"
            },
            this._resizeObserver = new ResizeObserver((t => {
                t.forEach((t => {
                    const {svgParent: e} = this._children
                      , {width: i} = t.contentRect;
                    e.setAttribute("width", i);
                    const s = .1 * i;
                    this._curve.cp1x = s,
                    this._curve.cp2x = i - s,
                    this._curve.endx = i,
                    this._drawCurve(),
                    this._drawKnob(this._normValue)
                }
                ))
            }
            )),
            this._normValue = .5,
            this._currentRate = null,
            this._currentIsLive = null,
            this._canUpdate = null,
            this._rateBeforePause = null,
            this._touchTimeout = null,
            this._activeDelay = 3e3,
            this._manager = this._app.getManager("time"),
            this._router = this._app.getManager("router");
            const i = 0 !== this._manager.getTimeRate();
            this.setState({
                isPlaying: i,
                playIconClass: this._class.isPlaying[i],
                rateDisplay: this.getRateDisplay()
            }),
            this.bindFunctions(["_onRateChange", "_onSliderMove", "_onTouchStart", "_onTouchEnd", "update"]),
            this._drawKnobThrottled = r(this._drawKnob, 50),
            this._setQueryDebounced = r(this._setQuery, 200)
        }
        async init() {
            super.init(),
            this._createRatesMap();
            const {inputRange: t} = this._children
              , e = this._app.getManager("time");
            this._callbackRegistry.push({
                emitter: e,
                event: "ratechange",
                callback: this._onRateChange
            }, {
                emitter: this._app.getManager("time"),
                event: "update",
                callback: this.update
            }),
            t.addEventListener("input", this._onSliderMove),
            t.addEventListener("click", ( () => t.blur())),
            this._element.addEventListener("touchstart", this._onTouchStart),
            this._element.addEventListener("touchend", this._onTouchEnd);
            const {sliderContainer: i} = this._children;
            this._resizeObserver.observe(i)
        }
        _onRateChange(t) {
            t >= this._rates[0] && t <= this._rates[this._rates.length - 1] ? this._setRate(t) : this._setQuery(1)
        }
        _onSliderMove(t) {
            const {timeLimit: e} = this._state
              , {value: i} = t.target;
            if ("max" === e && i > 45 || "min" === e && i < 55)
                return void (t.target.value = 50);
            const s = this._ratesMap[i];
            this._canUpdate && this._currentRate !== s ? (this._normValue = i / 100,
            this._currentRate = s,
            this._drawKnobThrottled(this._normValue),
            this._setQueryDebounced(s)) : t.target.value = 100 * this._normValue
        }
        _onTouchStart(t) {
            const {touchActiveClass: e} = this._state
              , i = t.target?.classList.contains("slider-input")
              , s = t.target?.classList.contains("realtime");
            e || i || s || t.preventDefault(),
            clearTimeout(this._touchTimeout),
            this.setState({
                touchActiveClass: "touchactive"
            })
        }
        _onTouchEnd() {
            this._touchTimeout = setTimeout(( () => {
                this.setState({
                    touchActiveClass: ""
                })
            }
            ), this._activeDelay)
        }
        _createRatesMap() {
            const t = this._rates.indexOf(1)
              , e = this._rates.length - t - 1
              , i = 50 / t
              , s = 50 / e
              , n = this._rates.slice(0, t)
              , o = this._rates.slice(t);
            this._ratesMap = [],
            n.forEach(( (t, e) => {
                const s = Math.round(e * i)
                  , o = Math.round((e + 1) * i) - s
                  , a = n[e + 1] ?? 0;
                for (let e = 0; e < o; e++) {
                    const i = t + e / o * (a - t)
                      , s = i > -1 ? -1 : this._roundRate(i);
                    this._ratesMap.push(Math.floor(s))
                }
            }
            )),
            o.forEach(( (t, e) => {
                const i = 50 + Math.round(e * s)
                  , n = (e < o.length - 1 ? 50 + Math.round((e + 1) * s) : 101) - i
                  , a = o[e + 1] || o[o.length - 1];
                for (let e = 0; e < n; e++) {
                    const i = t + e / n * (a - t)
                      , s = this._roundRate(i);
                    this._ratesMap.push(Math.floor(s))
                }
            }
            ))
        }
        _roundRate(t) {
            const {rate: e, unit: i} = this.getRateUnit(t);
            return e * l[i]
        }
        _drawCurve() {
            const {x: t, y: e, cp1x: i, cp1y: s, cp2x: n, cp2y: o, endx: a, endy: r} = this._curve
              , {sliderPath: l} = this._children;
            l.setAttribute("d", `M${t},${e} C${i},${s} ${n},${o} ${a},${r}`)
        }
        _drawKnob(t) {
            const {endx: e, cp1y: i} = this._curve
              , s = t * e
              , n = .75 * i * (1 - .95 * Math.pow(2 * Math.abs(t - .5), 3.2))
              , o = n - i;
            this._element.style.setProperty("--knobX", `${s}px`),
            this._element.style.setProperty("--knobY", `${n}px`),
            this._element.style.setProperty("--knobOffsetY", `${o}px`)
        }
        _setRate(t) {
            const {inputRange: e} = this._children
              , i = 0 !== t
              , s = 0 !== this._currentRate
              , n = i ? null : this._getTimeLimit()
              , o = "max" === n
              , a = o || "min" === n;
            this._rateBeforePause = i || a || !s ? null : this._currentRate;
            const r = o ? "rate-replay" : this._class.isPlaying[i];
            if (i && this._currentRate !== t || a) {
                const i = a ? 50 : this._getValueFromRate(t);
                i && (e.value = i),
                this._normValue = e.value / 100,
                this._drawKnob(this._normValue),
                this._currentRate = t
            }
            const l = this._normValue < .47 || this._normValue > .53;
            this.setState({
                isPlaying: i,
                isPlayingClass: i ? "" : "paused",
                realTimeBtnClass: l ? "" : "hidden",
                playIconClass: r,
                rateDisplay: this.getRateDisplay(t),
                timeLimit: n
            }),
            this._timeLimit = null
        }
        _getTimeLimit() {
            const {min: t, max: e} = this._manager.timeLimits
              , i = this._manager.getTime();
            return Math.abs(i.valueOf() - e.valueOf()) < 10 ? "max" : Math.abs(i.valueOf() - t.valueOf()) < 10 ? "min" : null
        }
        _getValueFromRate(t) {
            const e = this._ratesMap.indexOf(t);
            if (e > -1)
                return e;
            for (let e = 0; e < this._ratesMap.length - 1; e++) {
                const i = this._ratesMap[e]
                  , s = this._ratesMap[e + 1];
                if (t >= i && t <= s) {
                    return e + (t - i) / (s - i)
                }
            }
            return 50
        }
        _setQuery(t, e) {
            this._router.navigate({
                rate: t,
                time: this._manager.getTimeUrl(e)
            })
        }
        decreaseRate() {
            if (!this._canUpdate)
                return;
            const {timeLimit: t} = this._state
              , e = (0 === this._currentRate ? this._rateBeforePause : this._currentRate) || 1
              , i = this._getValueFromRate(e);
            let s = i % 1 > 0 ? Math.floor(i) : i - 1;
            for (; this._ratesMap[s] === e; )
                s--;
            if (s <= 0)
                return;
            const n = "max" === t ? -1 : this._ratesMap[s];
            this._setQuery(n)
        }
        increaseRate() {
            if (!this._canUpdate)
                return;
            const {timeLimit: t} = this._state
              , e = (0 === this._currentRate ? this._rateBeforePause : this._currentRate) || 1
              , i = this._getValueFromRate(e);
            let s = i % 1 > 0 ? Math.ceil(i) : i + 1;
            for (; this._ratesMap[s] === e; )
                s++;
            if (s >= this._ratesMap.length || "max" === t)
                return;
            const n = this._ratesMap[s];
            this._setQuery(n)
        }
        playPauseRate(t, e=this._state.isPlaying) {
            if (!this._canUpdate)
                return;
            const {timeLimit: i} = this._state;
            if ("max" === i)
                return void this._app.getView("event")?.replayEvent();
            const s = this._rateBeforePause ?? 1
              , n = e ? 0 : s;
            this._setQuery(n)
        }
        onRealtimeClick() {
            this._canUpdate && this._setQuery(1)
        }
        getRateUnit(t, e=0) {
            const i = t / l.yr
              , s = t / l.mth
              , n = t / l.wk
              , o = t / l.day
              , r = t / l.hr
              , c = t / l.min
              , h = Object.keys(l);
            let d = t % l.min
              , u = h.find((t => l[t] === l.sec));
            return i >= 1 || i <= -1 ? (d = i,
            u = h.find((t => l[t] === l.yr))) : s >= 1 || s <= -1 ? (d = s,
            u = h.find((t => l[t] === l.mth))) : n >= 1 || n <= -1 ? (d = n,
            u = h.find((t => l[t] === l.wk))) : o >= 1 || o <= -1 ? (d = o,
            u = h.find((t => l[t] === l.day))) : r >= 1 || r <= -1 ? (d = r,
            u = h.find((t => l[t] === l.hr))) : (c >= 1 || c <= -1) && (d = c,
            u = h.find((t => l[t] === l.min))),
            {
                rate: parseFloat(a(d, e)),
                unit: u
            }
        }
        getRateDisplay(t=this._manager.getTimeRate()) {
            if (0 === t)
                return "paused";
            if (1 === t)
                return "real rate";
            const {rate: e, unit: i} = this.getRateUnit(t);
            return `${e} ${i}${1 === e ? "" : "s"}/s`
        }
        setCanUpdate(t) {
            this._canUpdate = Boolean(t)
        }
        update() {
            const t = this._manager.isNow();
            this._currentIsLive !== t && (this.setState({
                isLiveClass: t ? "live" : ""
            }),
            this._currentIsLive = t)
        }
        __disable() {
            super.__disable(),
            clearTimeout(this._touchTimeout)
        }
    }
    TimeControls.html = o()
}
, function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t) {
    t.exports = '<nav class="time-controls {{isVisibleClass}} {{touchActiveClass}} {{isLiveClass}} {{isPlayingClass}}">\n\t<div class="datetime-container">\n\t\t<time class="date">{{dateValue}}</time>\n\t\t<time class="time">{{timeValue}}</time>\n\t</div>\n\t<h3 class="rate {{isRateControlsVisible}}">{{rateDisplay}}</h3>\n\t<div class="rate-controls {{isRateControlsVisible}}">\n\t\t<button class="clickable" data-tippy-content="Decrease time rate" aria-label="Decrease time rate"\n\t\t\tonclick="decreaseRate">\n\t\t\t<span class="icon rate-change decrease"></span>\n\t\t</button>\n\t\t<button class="clickable" data-tippy-content="Pause / play" aria-label="Pause or play" onclick="playPauseRate">\n\t\t\t<span class="icon {{playIconClass}}"></span>\n\t\t</button>\n\t\t<button class="clickable" data-tippy-content="Increase time rate" aria-label="Increase time rate"\n\t\t\tonclick="increaseRate">\n\t\t\t<span class="icon rate-change increase"></span>\n\t\t</button>\n\t</div>\n\t<div key=\'sliderContainer\' class="slider-container">\n\t\t<input id="time-slider-input" class=\'slider-input clickable scrollable\' key=\'inputRange\' type="range" min="0" max="100">\n\t\t<svg class=\'svg-parent\' key=\'svgParent\' height="50" width="600">\n\t\t\t<defs>\n\t\t\t\t<linearGradient id="path-stroke" x1="0%" y1="0%" x2="0%" y2="100%">\n\t\t\t\t\t<stop offset="0%" stop-color="rgba(255, 255, 255, 0)" />\n\t\t\t\t\t<stop offset="100%" stop-color="rgba(255, 255, 255, 1)" />\n\t\t\t\t</linearGradient>\n\t\t\t</defs>\n\n\t\t\t<path key=\'sliderPath\' stroke="url(#path-stroke)" stroke-width="2" stroke-opacity="0.5"\n\t\t\t\tstroke-linecap="round" fill="none" />\n\t\t</svg>\n\t\t<button class="realtime clickable {{realTimeBtnClass}}" data-tippy-content="Return to real time speed"\n\t\t\taria-label="Return to real time speed" onclick="onRealtimeClick"></button>\n\t\t<label class="knob" for="time-slider-input">Drag time slider thumb</label>\n\t</div>\n</nav>'
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        Telescope: function() {
            return Telescope
        }
    });
    var s = i(5)
      , n = i(1)
      , o = (i(897),
    i(900))
      , a = i(1036)
      , r = i(1037)
      , l = i.n(r);
    i(1038);
    class Telescope extends n.BaseComponent {
        constructor(t, e={}) {
            super(t, null, {
                latitudeTitle: n.AppUtils.isMobileMode() ? "Lat" : "Latitude",
                longitudeTitle: n.AppUtils.isMobileMode() ? "Lon" : "Longitude",
                airClass: "",
                surfaceClass: "hidden",
                azimuth: 0,
                elevation: 0,
                formattedLatitude: "",
                formattedLongitude: "",
                inputTipVisibleClass: "hidden",
                ...e
            }),
            this._target = null,
            this._targetEntity = null,
            this.longitude = 0,
            this.latitude = 0,
            this.helper = null,
            this._firstLoad = !0,
            o.default.setDefaultProps({
                theme: "default",
                touch: ["hold", 2e3],
                delay: [600, null],
                plugins: [o.followCursor]
            })
        }
        resize() {
            super.resize(),
            this.checkPlatform()
        }
        async onEnter(t) {
            this.app.getManager("label").setClickable(!1),
            this.app.getManager("selection").setClickable(!1),
            this.lightType = this.app.getComponent("settings").getState("lightType"),
            this.app.getComponent("settings").toggleLightOptions("flood"),
            (0,
            o.default)(this._children.constellationToggleButton, {
                content: "Toggle Constellations",
                placement: "top"
            }),
            (0,
            o.default)(this._children.coordinateInfo, {
                content: "Positive inputs are North and East. Negative inputs are South and West.",
                placement: "top"
            }),
            this._toggleSurfaceMaps(!0, t.spaceObject)
        }
        async onRouteChange(t) {
            const {spaceObject: e} = t;
            if (this._target = e,
            this._targetEntity = this.app?.scene.getEntity(this._target),
            this._children.tapHint.classList.remove("hidden"),
            this._firstLoad = !0,
            !this._targetEntity)
                return;
            this.helper = new a.default(this.app,this._targetEntity),
            this.lyrManager = this.app.getManager("layer");
            const i = this.lyrManager?.getLayer("orbiters");
            i && (this.orbiterVisibility = i.visible),
            this.setLatitudeLongitude(0, 0)
        }
        onLeave() {
            this.helper.reset(),
            this.helper = null,
            this.app.scene.getEntity("camera").getController(s.PickController) && this.app.scene.getEntity("camera").removeController(this._pickController),
            this.azimathelevationInterval && clearInterval(this.azimathelevationInterval),
            this.constellations = !1,
            this.app.getManager("layer").toggleLayer("constellations", {}, this.constellations),
            this.app.getManager("label").setClickable(!0),
            this.app.getManager("selection").setClickable(!0),
            void 0 !== this.lightType && this.app.getComponent("settings").toggleLightOptions(this.lightType),
            void 0 !== this.occlusionRadius && this._targetEntity.setOcclusionRadius(this.occlusionRadius),
            void 0 !== this.orbiterVisibility && this.lyrManager.toggleLayer("orbiters", {
                parentId: this._target
            }, this.orbiterVisibility),
            this._toggleSurfaceMaps(!1)
        }
        exitTelescope() {
            this._target ? this._app.getManager("router").navigate(`/${this._target}`) : console.warn("Space object could not be located in the url")
        }
        async processQuery(t) {
            const {globeLat: e, globeLon: i} = t;
            this._children.tapHint.classList.add("hidden"),
            this.latitude || this.longitude || (this.latitude = e || 0,
            this.longitude = i || 0,
            this.setLatitudeLongitude(this.latitude, this.longitude));
            const s = void 0 !== e && void 0 !== i;
            await this.setView(s),
            s ? (await this.helper.flyToSurface(e, i),
            this._placemarkEl && (this._placemarkEl.innerHTML = ""),
            this._firstLoad = !1) : this._children.tapHint.classList.remove("hidden")
        }
        checkPlatform() {
            this.setState({
                latitudeTitle: n.AppUtils.isMobileMode() ? "Lat" : "Latitude",
                longitudeTitle: n.AppUtils.isMobileMode() ? "Lon" : "Longitude"
            })
        }
        async setView(t) {
            if (this.setState({
                airClass: t ? "hidden" : "",
                surfaceClass: t ? "" : "hidden"
            }),
            this._target && this.app)
                if (t)
                    this._placemarkEl && (this._placemarkEl.innerHTML = ""),
                    this.azimathelevationInterval && clearInterval(this.azimathelevationInterval),
                    this.azimathelevationInterval = setInterval(( () => {
                        const {azimuth: t, elevation: e} = this.helper?.getAzimuthElevation();
                        this.setState({
                            azimuth: t,
                            elevation: e
                        })
                    }
                    ), 300);
                else {
                    this._firstLoad ? (await this.app.cameraScripts.goToCelestialObject(this._target),
                    this._firstLoad = !1) : await this.app.cameraScripts.lookAtSurfaceLatLon(this._target, this.latitude, this.longitude);
                    const t = this.app.scene.getEntity("camera");
                    t.getController(s.PickController) && t.removeController(this._pickController),
                    this._pickController = t.addController(s.PickController),
                    this._pickController.setPickedEntity(this._targetEntity),
                    this._pickController.setCallback((t => {
                        this.position = new s.Vector3,
                        this.position.rotateInverse(this._targetEntity.getOrientation(), t);
                        const e = this.helper.getLatitudeLongitude(this.position);
                        e && (this.latitude = e.latitude,
                        this.longitude = e.longitude,
                        this.addPickLocation(this.latitude, this.longitude),
                        this.setLatitudeLongitude(this.latitude, this.longitude),
                        this._children.tapHint.classList.add("hidden"))
                    }
                    ))
                }
        }
        exitSurfaceMode() {
            this.constellations = !1,
            this.app.getManager("layer").toggleLayer("constellations", {}, this.constellations),
            this.validateLatLong() && this.addPickLocation(this.latitude, this.longitude),
            this._target && this.app.getManager("router").navigate(`/${this._target}/telescope`)
        }
        toggleConstellation() {
            this.constellations = !this.constellations,
            this.app.getManager("layer").toggleLayer("constellations", {}, this.constellations)
        }
        latitudeInputChange(t) {
            let e = t?.target?.value;
            e && (e.includes("S") && (e = -1 * parseFloat(e)),
            this.latitude = parseFloat(e)),
            this.validateLatLong() && this.addPickLocation(parseFloat(e), this.longitude)
        }
        longitudeInputChange(t) {
            let e = t?.target?.value;
            e && (e.includes("W") && (e = -1 * parseFloat(e)),
            this.longitude = parseFloat(e)),
            this.validateLatLong() && this.addPickLocation(this.latitude, parseFloat(e))
        }
        validateLatLong() {
            return this._children.latitude.classList.remove("error"),
            this._children.longitude.classList.remove("error"),
            null === this.latitude || void 0 === this.latitude || isNaN(this.latitude) || Math.abs(this.latitude) > 90 ? (this._children.latitude.classList.add("error"),
            !1) : !(null === this.longitude || void 0 === this.longitude || isNaN(this.longitude) || Math.abs(this.longitude) > 180) || (this._children.longitude.classList.add("error"),
            !1)
        }
        goSurfaceViewClick(t) {
            if (t.preventDefault(),
            t.stopPropagation(),
            this.setLatitudeLongitude(this.latitude, this.longitude),
            this.validateLatLong()) {
                this.helper.removePlacemark();
                const t = `/${this._target}/telescope?globeLat=${this.latitude}&globeLon=${this.longitude}`;
                this._toggleSurfaceMaps(!0),
                this.app.getManager("router").navigate(t)
            }
        }
        _toggleSurfaceMaps(t, e=this._target) {
            if (t) {
                const t = this._app.getManager("content").getSpheroidLayers(e)?.find((t => "wmts" === t.type));
                if (!t)
                    return;
                if ("earth" === e) {
                    const t = this._app.pioneer.getScene("main").getEntity(e)?.getComponent(s.AtmosphereComponent);
                    t?.setVisible(!1)
                }
                this._app.getManager("layer").changeSpheroidMap(e, t, {
                    atmosphere: "earth" !== e
                })
            } else {
                const t = this._app.getManager("content").getSpheroidDefaultTextureInformation(e, ["shadowEntities", "atmosphere"])
                  , {surfaceMapTiling: i} = this.app.getManager("router").configs;
                if (t && !0 !== i) {
                    if ("earth" === e) {
                        const t = this._app.pioneer.getScene("main").getEntity(e)?.getComponent(s.AtmosphereComponent);
                        t?.setVisible(!0)
                    }
                    this._app.getManager("layer").changeSpheroidMap(e, t)
                }
            }
        }
        addPickLocation(t, e) {
            const i = "placemark"
              , n = this.helper.addPlacemark(t, e, i);
            n.getComponent(s.DivComponent).setAlignment(new s.Vector2(.5,.5)),
            this._placemarkEl = n.getComponent(s.DivComponent).getDiv(),
            this._placemarkEl.classList.remove("pioneer-label-div"),
            this._placemarkEl.id = i,
            this._placemarkEl.innerHTML = "";
            const o = this.helper.formatLatitudeLongitude(t, e)
              , a = document.createElement("div");
            a.className = "telescope pick",
            a.innerHTML = `\n\t\t\t<div>\n\t\t\t\t<span class="target icon latlong-target"></span>\n\t\t\t\t<span class="semi small">${o.latitude}</span>\n\t\t\t\t/\n\t\t\t\t<span class="semi small">${o.longitude}</span>\n\t\t\t</div>\n\t\t\t<button type="button" class="clickable active" ontouchstart="goSurfaceViewClick" onClick="goSurfaceViewClick">GO</button>\n\t\t`,
            this._placemarkEl.appendChild(a),
            a.addEventListener("mousedown", (t => {
                t.stopPropagation()
            }
            )),
            a.addEventListener("mouseup", (t => {
                t.stopPropagation()
            }
            )),
            this._setEventHandlersFromAttributes(this._placemarkEl)
        }
        async setLatitudeLongitude(t, e) {
            if (void 0 === t || void 0 === e)
                return;
            this.validateLatLong();
            const i = this.helper?.formatLatitudeLongitude(t, e);
            i && this.setState({
                formattedLatitude: i.latitude,
                formattedLongitude: i.longitude
            }),
            await (this._pioneer?.waitUntilNextFrame()),
            this._children.latitude && this._children.longitude && (this._children.latitude.value = i.latitude,
            this._children.longitude.value = i.longitude)
        }
        showCoordinateInputTip() {
            const t = this._children.coordinateTipPopup.classList.value.includes("hidden");
            this.setState({
                inputTipVisibleClass: t ? "" : "hidden"
            })
        }
    }
    Telescope.html = l()
}
, function(t, e, i) {
    "use strict";
    i.r(e);
    var s = i(5)
      , n = i(542);
    i(1);
    e.default = class TelescopeHelper {
        constructor(t, e) {
            this.pioneer = t.pioneer,
            this.scene = t.scene,
            this.camera = t.scene.getEntity("camera"),
            this.cameraTarget = t.scene.getEntity("cameraTarget") || t.scene.addEntity("cameraTarget"),
            this.fixedController = this.cameraTarget.getController(s.FixedController) || this.cameraTarget.addController(s.FixedController),
            this.cameraTarget.getController(s.RotateByEntityOrientationController) || this.cameraTarget.addController(s.RotateByEntityOrientationController),
            this.entity = e
        }
        reset() {
            this.entity = null;
            this.scene.getEntity("pickLocation") && this.scene.removeEntity("pickLocation"),
            this.removePlacemark()
        }
        setPickedLocation(t) {
            let e = this.scene.getEntity("pickLocation");
            if (!e) {
                e = this.scene.addEntity("pickLocation"),
                e.setCanOcclude(!1);
                const t = e.addController(s.FixedController);
                t.setPosition(s.Vector3.Zero),
                t.setOrientation(s.Quaternion.Identity),
                e.addController(s.RotateByEntityOrientationController)
            }
            return e.getParent()?.getName() !== t.getName() && (e.setParent(t),
            e.setOcclusionRadius(t.getOcclusionRadius())),
            e
        }
        addPlacemark(t, e, i) {
            const s = this.setPickedLocation(this.entity);
            this.removePlacemark();
            let o = this.scene.getEntity(i);
            return o && this.scene.removeEntity(i),
            o = n.Placemarks.addPlacemark(i, i, this.entity, t, e, 10),
            o.setParent(s),
            o
        }
        removePlacemark(t="placemark") {
            this.scene.getEntity(t) && this.scene.removeEntity(t)
        }
        async flyToSurface(t, e) {
            this.fixedController.getEntity().setParent(this.entity);
            const i = this.getPositionFromLatitudeLongitude(t, e)
              , o = new s.Quaternion
              , a = this.entity.getComponent(s.SpheroidComponent)
              , r = new s.LatLonAlt;
            a.llaFromXYZ(r, i),
            a.orientationFromLLA(o, r),
            this.fixedController.setOrientation(o);
            const l = new s.Vector3;
            a.upFromLLA(l, r),
            l.mult(l, 25),
            i.add(i, l),
            this.fixedController.setPosition(i),
            await this.pioneer.waitUntilNextFrame();
            const c = this.camera.getComponent(s.CameraComponent).getVerticalFieldOfView() / 5
              , h = new s.Vector3(0,-.001 * Math.cos(c),-.001 * Math.sin(c));
            h.rotate(this.cameraTarget.getOrientation(), h);
            const d = this.entity.getComponent(s.AtmosphereComponent);
            null !== d && d.setEnabled(!1),
            await n.Cameras.goToEntity(this.camera, this.cameraTarget, {
                destination: h,
                up: !0,
                zoom: !1
            }).catch();
            const u = this.camera.getController(s.OrbitController);
            u && u.setPitchAngleLimits(new s.Interval(-Math.PI / 2,Math.PI / 72))
        }
        readCameraAE() {
            const t = {
                azimuth: 0,
                elevation: 0
            };
            return this.getAEFromEntity(this.camera, t),
            t
        }
        getAEFromEntity(t, e) {
            const i = t.getParent();
            if (i) {
                const n = s.Vector3.pool.get()
                  , o = s.AER.pool.get()
                  , a = s.Quaternion.pool.get();
                a.inverse(i.getOrientation()),
                t.getOrientation().getAxis(n, 1),
                n.rotate(a, n),
                o.setFromVector(n),
                e.azimuth = (90 - s.MathUtils.radToDeg(o.azimuth)).toFixed(2),
                e.azimuth = s.MathUtils.wrap(e.azimuth, 0, 360).toFixed(2),
                e.elevation = s.MathUtils.radToDeg(o.elevation).toFixed(2),
                s.Quaternion.pool.release(a),
                s.AER.pool.release(o),
                s.Vector3.pool.release(n)
            }
        }
        getAzimuthElevation() {
            const t = this.readCameraAE();
            if (!t)
                return null;
            let {azimuth: e, elevation: i} = t;
            return i += "Â°",
            e >= 157.5 && e <= 202.5 && (e += "Â°S"),
            e >= 247.5 && e <= 292.5 && (e += "Â°W"),
            (e >= 337.5 || e <= 22.5) && (e += "Â°N"),
            e >= 67.5 && e <= 112.5 && (e += "Â°E"),
            e > 202.5 && e < 247.5 && (e += "Â°SW"),
            e > 292.5 && e < 337.5 && (e += "Â°NW"),
            e > 22.5 && e < 67.5 && (e += "Â°NE"),
            e > 112.5 && e < 157.5 && (e += "Â°SE"),
            {
                azimuth: e,
                elevation: i
            }
        }
        getLatitudeLongitude(t) {
            const e = this.entity.getComponent(s.SpheroidComponent);
            if (null == e || null === parent || t.isNaN())
                return null;
            const i = s.LatLonAlt.pool.get();
            e.llaFromXYZ(i, t);
            const n = {
                latitude: s.MathUtils.radToDeg(i.lat),
                longitude: s.MathUtils.radToDeg(i.lon)
            };
            return s.LatLonAlt.pool.release(i),
            null == n.latitude || null == n.longitude ? null : n
        }
        getPositionFromLatitudeLongitude(t, e) {
            const i = this.entity.getComponent(s.SpheroidComponent);
            if (null == i || null === parent)
                return null;
            const n = new s.LatLonAlt;
            n.lat = s.MathUtils.degToRad(t),
            n.lon = s.MathUtils.degToRad(e);
            const o = new s.Vector3;
            return i.xyzFromLLA(o, n),
            o
        }
        formatLatitudeLongitude(t, e) {
            return {
                latitude: t < 0 ? Math.abs(t).toFixed(2) + "Â°S" : t.toFixed(2) + "Â°N",
                longitude: e < 0 ? Math.abs(e).toFixed(2) + "Â°W" : e.toFixed(2) + "Â°E"
            }
        }
        getUnformattedLatOrLon(t, e) {
            const i = t.replace(/\s/g, "");
            let s = parseFloat(i.split("Â°")[0]);
            return "lat" === e && t.includes("Â°S") && (s *= -1),
            "lon" === e && t.includes("Â°W") && (s *= -1),
            s
        }
    }
}
, function(t) {
    t.exports = '<div class="telescope">\n\t<span class="air {{airClass}}">\n\t\t<div class="description above">\n\t\t\t<span class="semi small">Pick a location</span>\n\t\t</div>\n\n\t\t<div class="container">\n\t\t\t<div class="title">\n\t\t\t\t<div class="vertical">\n\t\t\t\t\t<snap class="menu semi upper color gray small">Telescope Mode</snap>\n\t\t\t\t</div>\n\t\t\t</div>\n\n\t\t\t<span>\n\t\t\t\t<div class="latlong semi small color gray">\n\t\t\t\t\t<div key="coordinateTipPopup" class="coordinate-info-tip-popup {{inputTipVisibleClass}}" >\n\t\t\t\t\t\t<span class="semi small">Positive inputs are North and East. Negative inputs are South and West.</span>\n\t\t\t\t\t</div>\n\t\t\t\t\t<span key="coordinateInfo" class="coordinate-info-icon clickable icon icon-info" onclick="showCoordinateInputTip" ontouch="showCoordinateInputTip"></span>\n\t\t\t\t\t<snap class="latitude">\n\t\t\t\t\t\t<label>{{latitudeTitle}}</label>\n\t\t\t\t\t\t<input class=\'clickable\' key="latitude" type="text" oninput="latitudeInputChange"/>\n\t\t\t\t\t</snap>\n\n\t\t\t\t\t<snap class="longitude">\n\t\t\t\t\t\t<label>{{longitudeTitle}}</label>\n\t\t\t\t\t\t<input class=\'clickable\' key="longitude" type="text" oninput="longitudeInputChange"/>\n\t\t\t\t\t</snap>\n\t\t\t\t\t<button class=\'go-btn-footer clickable\' onclick="goSurfaceViewClick"> \n\t\t\t\t\t\tGO\n\t\t\t\t\t</button>\n\t\t\t\t</div>\n\t\t\t</span>\n\n\t\t\t<div class="exit">\n\t\t\t\t<span class="exit clickable active" onclick="exitTelescope">\n\t\t\t\t\t<span class="text semi menu upper small">Exit</span>\n\t\t\t\t\t<span alt="Close telescope mode" class="icon icon-box active">\n\t\t\t\t\t\t<span class="icon icon-close"></span>\n\t\t\t\t\t</span>\n\t\t\t\t</span>\n\t\t\t</div>\n\t\t</div>\n\t</span>\n\n\t<span class="surface {{surfaceClass}}">\n\t\t<div class="description surface top">\n\t\t\t<span class="semi small">{{azimuth}}</span>\n\t\t\t<span class="semi small">{{elevation}}</span>\n\t\t\t<span class="text semi small color gray">Azimuth</span>\n\t\t\t<span class="text semi small color gray">Elevation</span>\n\t\t</div>\n\n\t\t<div class="container">\n\t\t\t<div class="title">\n\t\t\t\t<div class="vertical">\n\t\t\t\t\t<snap class="menu semi upper color gray small">Telescope Mode</snap>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t<span class="readout">\n\t\t\t\t<div class="semi small color gray middle" onclick="exitSurfaceMode">\n\t\t\t\t\t<snap class="menu semi upper color gray small changeLocation clickable">CHANGE LOCATION</snap>\n\n\t\t\t\t\t<div class="location clickable">\n\t\t\t\t\t\t<span class="icon latlong-target"></span>\n\t\t\t\t\t\t<snap>{{formattedLatitude}}</snap>\n\t\t\t\t\t\t<snap> / </snap>\n\t\t\t\t\t\t<snap>{{formattedLongitude}}</snap>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\n\t\t\t\t<span key="constellationToggleButton" class="icon icon-constellation clickable" onclick="toggleConstellation"></span>\n\t\t\t\t<span class="target icon telescope-target">\n\t\t\t\t\t<div class="description surface center">\n\t\t\t\t\t\t<span class="semi small">{{azimuth}}</span>\n\t\t\t\t\t\t<span class="semi small">{{elevation}}</span>\n\t\t\t\t\t\t<span class="text semi small color gray">Azimuth</span>\n\t\t\t\t\t\t<span class="text semi small color gray">Elevation</span>\n\t\t\t\t\t</div>\n\t\t\t\t</span>\n\t\t\t</span>\n\n\t\t\t<div class="exit">\n\t\t\t\t<span class="exit clickable active" onclick="exitSurfaceMode">\n\t\t\t\t\t<span class="text semi menu upper small">Exit</span>\n\t\t\t\t\t<span alt="Close telescope mode" class="icon icon-box active">\n\t\t\t\t\t\t<span class="icon icon-close"></span>\n\t\t\t\t\t</span>\n\t\t\t\t</span>\n\t\t\t</div>\n\t\t</div>\n\t</span>\n\t<div class="tap-hint" key="tapHint">\n\t\t<div class="circle"></div>\n\t\t<div class="icon icon-finger"></div>\n\t</div>\n</div>'
}
, function(t, e, i) {
    "use strict";
    i.r(e)
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        Search: function() {
            return Search
        }
    });
    var s = i(1);
    class Search extends s.Search {
        _getLink(t) {
            const {searchType: e} = this._config;
            return this._app.getManager("link")?.getParsedLink?.(t, e) || t
        }
        reset(t) {
            const {onReset: e} = this._config;
            this.eraseInput(),
            "function" == typeof e && e(this, t),
            this._config.initialOpen || this.close(),
            "function" == typeof t?.stopPropagation && t.stopPropagation()
        }
        onInputFocus() {
            const {onSearchFocus: t} = this._config;
            "function" == typeof t && t(this),
            super.onInputFocus()
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        KioskMode: function() {
            return KioskMode
        }
    });
    var s = i(1)
      , n = i(5);
    class KioskMode extends s.KioskBase {
        async init() {
            super.init(),
            this._router = this.app.getManager("router"),
            this.camera = this.app.getManager("camera").cameraEntity,
            document.addEventListener("keydown", (async () => await this.onWindowInteract())),
            document.addEventListener("click", (async () => await this.onWindowInteract())),
            document.addEventListener("scroll", (async () => await this.onWindowInteract())),
            document.addEventListener("touchstart", (async () => await this.onWindowInteract())),
            document.addEventListener("touchend", (async () => await this.onWindowInteract()))
        }
        async handleMaxInactivityTime() {
            await super.handleMaxInactivityTime();
            Math.ceil(n.TimeUtils.now()) - s.KioskBase.screenLastClicked >= this.maxInactivityTime && await this.startAutoplay()
        }
        async onWindowInteract() {
            await this._app.getManager("autoplay").stopAutoplay(),
            await super.onWindowInteract()
        }
        async startAutoplay() {
            await super.startAutoplay();
            const t = this._app.getManager("layer");
            t.getLayer("ui").visible && t.toggleLayer("ui");
            const {kioskAutoplay: e} = this._children;
            this.app.getManager("camera").waitForTransitionComplete().then((async t => (!this.isHidden(e) && await this._app.getManager("autoplay").startAutoplay(),
            t))).catch((t => {
                console.warn("error: ", t)
            }
            ))
        }
        setupSpinController() {
            this.camera.clearControllers();
            const t = this.app.pioneer.getScene("main").getEntity("earth")
              , e = new n.Vector3;
            e.cross(t.getPosition(), t.getVelocity()),
            e.normalize(e);
            const i = this.camera.addController(n.SpinController, "autoplaySpin");
            i.setAxis(e, !0),
            i.setRate(.03),
            i.setUsingRealTime(!0),
            i.setRotatingPosition(!0)
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        Settings: function() {
            return Settings
        }
    });
    var s = i(1);
    class Settings extends s.Settings {
        constructor(t, e={}) {
            super(t, e),
            Object.assign(this._state, {
                paddingBottom: "0px"
            })
        }
        init() {
            super.init(),
            this._callbackRegistry.push({
                emitter: this._app.getComponent("collapsibleMenu"),
                event: "expandtoggle",
                callback: t => {
                    s.AppUtils.isMobile() && (t && this.collapse(),
                    this.setState({
                        paddingBottom: t && this._state.isCollapsed ? "30px" : "0px"
                    }, ( () => {
                        this._element.style.paddingBottom = this._state.paddingBottom
                    }
                    )))
                }
            })
        }
        collapse() {
            super.collapse(),
            this._element.style.paddingBottom = this._state.paddingBottom
        }
        expand() {
            super.expand(),
            this._element.style.paddingBottom = "0px"
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        Types: function() {
            return s.Types
        }
    });
    var s = i(1)
      , n = i(890);
    s.Types.set("TimeManager", n.TimeManager),
    s.Types.set("LinkManager", n.LinkManager),
    s.Types.set("LabelManager", n.LabelManager),
    s.Types.set("SelectionManager", n.SelectionManager),
    s.Types.set("Comparison", n.Comparison),
    s.Types.set("ContentPanel", n.ContentPanel),
    s.Types.set("FeaturedStoriesPanel", n.FeaturedStoriesPanel),
    s.Types.set("Menu", n.Menu),
    s.Types.set("MobileExpandButton", n.MobileExpandButton),
    s.Types.set("InfoPanel", n.InfoPanel),
    s.Types.set("DistancePanel", n.DistancePanel),
    s.Types.set("EventsTimeline", n.EventsTimeline),
    s.Types.set("CollapsibleMenu", n.CollapsibleMenu),
    s.Types.set("CollapsibleMenuItem", n.CollapsibleMenuItem),
    s.Types.set("TimeControls", n.TimeControls),
    s.Types.set("Telescope", n.Telescope),
    s.Types.set("Search", n.Search),
    s.Types.set("KioskMode", n.KioskMode),
    s.Types.set("Settings", n.Settings)
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        StoryView: function() {
            return StoryView
        }
    });
    var s = i(1)
      , n = i(742);
    class StoryView extends n.default {
        constructor(...t) {
            super(...t),
            this._story = null,
            this._storyId = null,
            this._slideId = null,
            this._isStoryEntry = !0,
            this._isStoryExit = !1,
            this._validQueries.push("slide"),
            this._rules.id = {
                value: t => t in this._app.getManager("content").getStoryList().stories
            },
            this.bindFunctions(["isStoryExit"])
        }
        before(t) {
            super.before(t),
            this._isStoryEntry = !0,
            this._isStoryExit = !1
        }
        after(t) {
            super.after(t),
            this._isStoryEntry = !1
        }
        async onRouteChange(t) {
            t.cancelToken.isCanceled || (await super.onRouteChange(t),
            await this._verifySlideInfo(t))
        }
        async onQueryChange(t) {
            t.cancelToken.isCanceled || (await this._verifySlideInfo(t),
            this._isStoryExit = !1,
            await super.onQueryChange(t),
            await this._app.getComponent("story").onQueryChange(t),
            this._slideId = t.slide,
            await this._updateCamera(t),
            this._isStoryEntry = !1)
        }
        async onEnter(t, e=[]) {
            this._isStoryExit = !1,
            this._offsetPanel = this._app.getComponent("story"),
            await super.onEnter(t, e);
            this._app.getComponent("clock").setState({
                allowEdit: !1
            }),
            this._app.getManager("label").setClickable(!1),
            this._app.getManager("selection").setClickable(!1),
            this._app.getComponent("menu")?.setEnabled(s.AppUtils.isMobileMode())
        }
        async onLeave(t) {
            await super.onLeave(t);
            const e = this._app.getComponent("story");
            await e.onLeave(),
            e.hide(),
            this.setViewportOffset(!1),
            await (this._story?.onLeave?.(this._app));
            this._app.getComponent("clock").setState({
                allowEdit: !0
            }),
            this._app.getManager("label").setClickable(!0),
            this._app.getManager("selection").setClickable(!0),
            this._app.getManager("time").resetMin(),
            this._app.getManager("time").resetMax(),
            this._story = null,
            this._isStoryEntry = !0,
            this._isStoryExit = !0
        }
        async _verifySlideInfo(t) {
            if (!(t.slide ? this._story.slides.find((e => e.id === t.slide)) : this._story.slides[0])) {
                const t = this._app.getManager("router");
                await t.reroute(t.currentRoute.url, {
                    slide: this._story.slides[0].id
                })
            }
        }
        async _updateResources(t) {
            if (!t.cancelToken.isCanceled) {
                await super._updateResources(t),
                this._app.getManager("layer").setTarget(""),
                this._story && (this._story.onLeave?.(this._app),
                this._app.getComponent("story")?.onLeave(),
                this._isStoryExit = !1);
                try {
                    const e = await this._app.getManager("content").getStory(t.id);
                    this._story = s.AppUtils.deepClone(e),
                    this._storyId = t.id,
                    this._slideId = t.slide;
                    const i = [...(t.slide ? this._story.slides.find((e => e.id === t.slide)) : this._story.slides[0])?.entities || [], ...this._story.entities || []];
                    this.app.getManager("scene").setEntitiesForceVisible(i, !1),
                    await this._app.scene.waitTillEntitiesInPlace(i),
                    await (this._story?.onEnter?.(this._app))
                } catch (e) {
                    this._handleError(`StoryView._updateResources: Cannot find story ${t.id}: ${e}`)
                }
            }
        }
        async _updateTime(t) {
            if (t.cancelToken.isCanceled)
                return;
            await super._updateTime(t);
            const e = this._app.getManager("time")
              , i = t.slide ? this._story.slides.find((e => e.id === t.slide)) : this._story.slides[0];
            !t.time && i?.time && (e.setTime(i.time),
            await this._app.pioneer.waitUntilNextFrame()),
            i?.timeLimits && (i.timeLimits.min && e.setMin(i.timeLimits.min),
            i.timeLimits.max && e.setMax(i.timeLimits.max))
        }
        _shouldHideControls() {
            return s.AppUtils.isMobileMode() && !this._app.getComponent("story").getState("isCollapsed")
        }
        async _updateComponents(t) {
            if (t.cancelToken.isCanceled)
                return;
            await super._updateComponents(t);
            const e = this._app.getManager("router").currentRoute.url.match(/[^/]+/g);
            e.splice(e.indexOf("story"), 1),
            this._app.getComponent("breadcrumb").onRouteChange({
                ...t,
                routeParts: e
            }),
            this._app.getComponent("storyClock").show();
            const i = this._app.getManager("content").getStory(t.id)?.slides.length
              , s = i < 2;
            this._app.getComponent("timeControls").setEnabled(s),
            this._app.getComponent("clockShortcut").setEnabled(s),
            this._app.getComponent("storyClock").setEnabled(!s);
            const n = this._app.getComponent("story");
            await n.onRouteChange(this._story.slides, t),
            n.show(),
            this.setViewportOffset(!0),
            await this._app.getComponent("settings").setConfig({
                orientation: {
                    tabletPortrait: {
                        ori: "horizontal"
                    },
                    smallLandscape: {
                        ori: "horizontal"
                    },
                    tabletLandscape: {
                        ori: "horizontal"
                    }
                }
            })
        }
        async _updateCamera(t) {
            if (t.cancelToken.isCanceled)
                return;
            await super._updateCamera(t);
            const e = t.slide ? this._story.slides.find((e => e.id === t.slide)) : this._story.slides[0]
              , i = [...e?.entities || [], ...this._story.entities || []];
            if (e?.camera) {
                const t = this._app.getComponent("story");
                if (this._isStoryEntry || t.getState("previousIndex") !== t.getState("currentIndex")) {
                    const t = e.camera[0];
                    await t(this._app, this.isStoryExit)
                }
            } else
                await this._app.cameraScripts.goToSystem("outer_solar_system");
            this.app.getManager("scene").setEntitiesForceVisible(i, !0),
            await this._app.scene.waitTillEntitiesInPlace(i)
        }
        resize() {
            super.resize(),
            this._app.getComponent("menu")?.setEnabled(s.AppUtils.isMobileMode())
        }
        registerCallbacks() {
            super.registerCallbacks();
            const t = this._app.getComponent("story");
            t && (t.registerCallback("expandtoggle", this.updateVisibility),
            t.registerCallback("overlay", this.updateVisibility))
        }
        removeCallbacks() {
            super.removeCallbacks();
            const t = this._app.getComponent("story");
            t && (t.removeCallback("expandtoggle", this.updateVisibility),
            t.removeCallback("overlay", this.updateVisibility))
        }
        setStorySlides(t) {
            this._story.slides = t
        }
        isStoryExit() {
            return this._isStoryExit
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        TelescopeView: function() {
            return TelescopeView
        }
    });
    var s = i(742);
    class TelescopeView extends s.default {
        async onEnter(t, e=[]) {
            await super.onEnter(t, e),
            await this._app.getComponent("telescope").onEnter(t)
        }
        async onRouteChange(t) {
            await this._app.getComponent("telescope").onRouteChange(t),
            await super.onRouteChange(t)
        }
        async _updateResources(t) {
            this._target = t.spaceObject,
            this.app.getManager("scene").setEntitiesForceVisible(null !== this._target ? [this._target] : [], !1)
        }
        async processQuery(t) {
            await super.processQuery(t),
            this._app.getComponent("telescope").processQuery(t)
        }
        async _updateComponents(t) {
            super._updateComponents(t),
            this._entityInfo = this._app.getManager("content").getEntityInfo(t.spaceObject);
            const e = this._app.getManager("router").currentRoute.url.match(/[^/]+/g);
            this._app.getComponent("breadcrumb").onRouteChange({
                ...t,
                routeParts: e
            })
        }
        async _updateCamera(t) {
            const e = null !== this._target ? [this._target] : [];
            this.app.getManager("scene").setEntitiesForceVisible(e, !0)
        }
        async onLeave(t) {
            await super.onLeave(t),
            this._app.getComponent("telescope").onLeave(t)
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        DistanceView: function() {
            return DistanceView
        }
    });
    var s = i(1)
      , n = i(1046)
      , o = i(742);
    class DistanceView extends o.default {
        constructor(...t) {
            super(...t),
            this._rules = {
                ...this._rules,
                spaceObject: {
                    value: t => null !== this._app.getManager("content").getEntityInfo(t)
                },
                to: {
                    value: t => {
                        const {spaceObject: e} = this._app.getManager("router").currentRoute.params
                          , i = this._app.getManager("content")
                          , s = this._app.getManager("scene")
                          , n = "string" == typeof t ? t?.split(",") : []
                          , o = n.every((t => null !== i.getEntityInfo(t)))
                          , a = n.some((t => t === e))
                          , r = n.every((t => Boolean(s._entityStatuses.get(t))));
                        return o && r && !a
                    }
                }
            },
            this._forceLoadEntities = [],
            this._spaceObjectChanged = null,
            this._targetChanged = null,
            this._timeChanged = null,
            this._rateChanged = null,
            this._redirect = null,
            this.bindFunctions(["onIsMobileChange"])
        }
        async onEnter(t) {
            this.distanceManager ??= this.app.addManager("distance", n.DistanceManager),
            this.distancePanel ??= this.app.getComponent("distancePanel"),
            this.distancePanel.show(),
            this.distanceManager.init(),
            this.app.getComponent("collapsibleMenu")?.setAllowMultiple(!1),
            this.distancePanel.initSearchUI(),
            this.distancePanel.isMobileChangedCallback = this.onIsMobileChange,
            this.setBreadcrumbStaticTextVisible(),
            this.updateVisibility(),
            await super.onEnter(t)
        }
        async onLeave(t) {
            this.app.getComponent("collapsibleMenu")?.setAllowMultiple(!0),
            this.distancePanel.isMobileChangedCallback = null,
            this.distanceManager.deinit(),
            this.setBreadcrumbStaticTextVisible(!0),
            await super.onLeave(t)
        }
        registerCallbacks() {
            super.registerCallbacks(),
            this._app.getManager("time").registerCallback("update", this.distanceManager.update)
        }
        removeCallbacks() {
            super.removeCallbacks(),
            this._app.getManager("time").removeCallback("update", this.distanceManager.update)
        }
        async processQuery(t) {
            await super.processQuery(t);
            const {spaceObject: e, to: i, time: s, rate: n} = t
              , o = this.app.getManager("router")
              , a = this.app.getManager("scene")
              , {query: r, params: l} = o.previousRoute
              , {to: c, time: h, rate: d} = o.parseQuery(r);
            if (this._spaceObjectChanged = l?.spaceObject !== e,
            this._targetChanged = c !== i,
            this._timeChanged = h !== s,
            this._rateChanged = d !== n,
            r && !this._spaceObjectChanged && !this._targetChanged && !this._redirect)
                return void t.cancelToken.cancel();
            this.distanceManager.setIsWaitingForEntities(!0),
            this.distanceManager.setBetweenPosHidden(!0),
            this._forceLoadEntities = [e];
            const u = "string" == typeof i ? i.split(",") : [];
            u && this._forceLoadEntities.push(...u),
            this._forceLoadEntities = this._forceLoadEntities.map((t => [t, ...a.getDependencies(t)])),
            this._forceLoadEntities = [...new Set(this._forceLoadEntities.flat())],
            a.setEntitiesForceVisible(this._forceLoadEntities, !0),
            this.distanceManager.setTargetDistanceEntities(u)
        }
        async onQueryChange(t) {
            if (this.distanceManager.setIsWaitingForEntities(!0),
            await super.onQueryChange(t),
            t.cancelToken.isCanceled)
                return this.distanceManager.setIsWaitingForEntities(!1),
                void this.distanceManager.updateMeasurement(!1);
            this._updateComponents(t),
            await this._checkReady(t),
            await this._updateCamera(t)
        }
        async _updateTime(t) {
            const e = this.app.getManager("time");
            if (t.time) {
                e.parseTime(t.time).isValid() ? e.setTime(t.time) : this._app.getManager("router").navigate({
                    __remove: ["time"]
                })
            }
        }
        _reset(t) {
            super._reset(t),
            this._forceLoadEntities = [],
            this.distanceManager.resetAllDistanceEntities()
        }
        async _updateResources({spaceObject: t}) {
            this.app.getManager("scene").setEntitiesForceVisible([t], !1),
            this.distanceManager.setSourceDistanceEntity(t),
            this._app.getManager("layer").setTarget(t),
            this._app.getManager("selection").selectEntity(t)
        }
        async _updateComponents(t) {
            super._updateComponents(t);
            const e = this._app.getManager("router")
              , i = this._app.getComponent("breadcrumb")
              , {targetDisplayNames: s} = this.distanceManager
              , n = "Distance to" + (s.length ? ` ${s.join(" & ")}` : "");
            i._crumbTexts.distance = n;
            const o = e.currentRoute.url.match(/[^/]+/g);
            i.onRouteChange({
                routeParts: o
            })
        }
        async _checkReady(t) {
            const e = this.app.getManager("time")
              , i = t.time ? e.parseTime(t.time) : e.getTime()
              , s = e.momentToET(i)
              , n = this.distanceManager.measureDistance(!1, s);
            if (this.distanceManager.hasTarget && this.distancePanel.setIsLoading(!0),
            await this._app.scene.waitTillEntitiesInPlace(this._forceLoadEntities, s),
            this.distancePanel.setIsLoading(!1),
            !t.cancelToken.isCanceled) {
                if (this.distanceManager.hasTarget && !this._checkCoverageOverlap(t))
                    return await this.distanceManager.setTempErrorResult("Â« Source and target do not co-exist Â»"),
                    this._redirect = !0,
                    void this._app.getManager("router").navigate({
                        __remove: ["to"]
                    });
                this.distanceManager.setIsWaitingForEntities(!1),
                this._redirect = !1,
                !n && this.distanceManager.updateMeasurement(null, !0)
            }
        }
        _checkCoverageOverlap(t) {
            const e = this.app.getManager("time")
              , i = this.app.getManager("scene")
              , s = this.app.getManager("router")
              , {id: n} = this.distanceManager.sourceDistanceEntity || {}
              , {id: o} = this.distanceManager.targetDistanceEntities[0] || {}
              , {min: a, max: r} = e.getDefaultLimits()
              , {min: l, max: c} = n ? i.getCoverage(n) : {}
              , {min: h, max: d} = o ? i.getCoverage(o) : {}
              , u = l?.isValid() ? l.valueOf() : a.valueOf()
              , p = c?.isValid() ? c.valueOf() : r.valueOf()
              , m = h?.isValid() ? h?.valueOf() : a.valueOf()
              , _ = d?.isValid() ? d?.valueOf() : r.valueOf()
              , g = m && m >= u ? m : u
              , y = _ && _ <= p ? _ : p;
            if (!(g < y))
                return !1;
            e.setMin(g),
            e.setMax(y);
            const f = e.getTime()
              , b = e.isWithinLimits(f);
            if (-1 === b || 1 === b) {
                const {min: t} = e.getLimits();
                if (t.isValid())
                    return s._previousRoute = {
                        ...s._currentRoute
                    },
                    this.app.getComponent("timecontrolsCollapsible")?.setExpanded(!0),
                    this._redirect = !0,
                    s.navigate({
                        time: e.getTimeUrl(t)
                    }),
                    !1
            }
            return !0
        }
        async _updateCamera() {
            const {id: t} = this.distanceManager.sourceDistanceEntity || {}
              , {hasTarget: e, measuredDistance: i} = this.distanceManager;
            e ? await this.distanceManager.camToBetweenPos({
                force: !0
            }) : await this.app.cameraScripts.goToCelestialObject(t, {
                distance: 3
            });
            e && i >= 0 && this.distanceManager.setBetweenPosHidden(!1)
        }
        _updateCollapsibleMenu(t=s.AppUtils.isMobile()) {
            this._collapsibleItemOptions = this._collapsibleItemOptions.filter((t => "Time Controls" === t.itemTitle && (t.expand = !1,
            !0))),
            t && this._collapsibleItemOptions.push({
                itemTitle: "Distance",
                componentNames: ["distancePanel"],
                positionIndex: 0,
                dimensions: {
                    width: {
                        min: 320,
                        max: 400
                    },
                    height: {
                        min: 30,
                        max: 175
                    }
                }
            }),
            super._updateCollapsibleMenu()
        }
        async onIsMobileChange(t) {
            this._updateCollapsibleMenu(t),
            this._collapsibleItems = await Promise.all(this._collapsibleItems).then((t => t.filter((t => t))));
            const e = this._collapsibleItems.find((t => "Distance" === t.getState("itemTitle")))
              , i = t && e?._children.componentContainer || this.app._dynamicElement;
            this.distancePanel.setParent(i)
        }
        setBreadcrumbStaticTextVisible(t=!s.AppUtils.isMobile()) {
            const e = this._app.getComponent("breadcrumb")?._element.querySelector("h1");
            e && (e.style.display = t ? "" : "none")
        }
        resize() {
            super.resize(),
            this.setBreadcrumbStaticTextVisible()
        }
        get shouldOffsetRight() {
            return !1
        }
        get shouldOffsetUp() {
            return !1
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        DistanceManager: function() {
            return DistanceManager
        }
    });
    var s = i(1)
      , n = i(5)
      , o = i(542)
      , a = i(900);
    const {formatNumber: r, conversionTable: l, throttle: c} = s.AppUtils
      , h = "center"
      , d = "surface"
      , u = h
      , p = "metric"
      , m = "imperial"
      , _ = p;
    class DistanceManager extends s.BaseManager {
        constructor(t) {
            super(t),
            this._sourceDistanceEntity = null,
            this._targetDistanceEntities = [],
            this.hasTarget = null,
            this._areRelated = null,
            this._areClose = null,
            this._currentSecond = null,
            this.distanceInfo = {
                centerValue: null,
                measuredValue: null,
                sourceTargetDiff: null
            },
            this._allowRaycasting = null,
            this._allowPlay = null,
            this._prevValues = {
                weights: {},
                occRadii: {}
            },
            this._currentUnitSystem = _,
            this.errorResultTimeout = null,
            this._vectors = {},
            this._uValueCurrent = null,
            this._uValueHold = null,
            this.intersect = null,
            this._bpAnimation = null,
            this._bpParentIsSource = null,
            this._currBetweenOffset = {},
            this._isTransitioning = null,
            this._isBelowZero = null,
            this._tooltipOpts = {
                contentSuffix: "the line to adjust the camera's orbit center",
                height: null,
                isTouch: null,
                instance: null
            },
            this._isWaitingForEntities = null,
            this.distancePanel = null,
            this.pionerEl = null,
            this.bindFunctions(["update", "on3dLineMouseMove", "on3dLineClick", "showTooltip", "hideTooltip"]),
            this._on3dLineMouseMoveThrottled = c(this.on3dLineMouseMove, 200, {
                leading: !0,
                trailing: !0
            })
        }
        init() {
            this._betweenPosEntity ??= this._createBetweenEntity(),
            this._bpController ??= this._betweenPosEntity.addController(o.PositionSumController, "bp_position_sum"),
            this.distancePanel ??= this.app.getComponent("distancePanel"),
            this.pionerEl ??= document.getElementById("pioneer"),
            this._grabVectors(),
            this.addEvents()
        }
        deinit() {
            this.resetAllDistanceEntities(),
            this.resetUValue(),
            this._releaseVectors(),
            this.removeEvents(),
            this.setBetweenPosHidden(!0)
        }
        hideSpacecraftLayer() {
            const t = this.app.getManager("layer")
              , {visible: e} = t.getLayer("spacecraft");
            e && t.toggleLayer("spacecraft")
        }
        showSpacecraftLayer() {
            const t = this.app.getManager("layer")
              , {visible: e} = t.getLayer("spacecraft");
            !e && t.toggleLayer("spacecraft")
        }
        addEvents() {
            const {canHover: t} = this.app;
            this.pionerEl?.addEventListener("click", this.on3dLineClick),
            t && this.pionerEl?.addEventListener("mousemove", this._on3dLineMouseMoveThrottled)
        }
        removeEvents() {
            this.pionerEl?.removeEventListener("click", this.on3dLineClick),
            this.pionerEl?.removeEventListener("mousemove", this._on3dLineMouseMoveThrottled)
        }
        resetEvents() {
            this.removeEvents(),
            this.addEvents()
        }
        _updateTooltip() {
            const {contentSuffix: t, height: e, isTouch: i, instance: s} = this._tooltipOpts
              , o = window.innerHeight
              , {isTouch: r} = this.app;
            if (o === e && r === i)
                return;
            const l = {
                content: `${r ? "Tap" : "Click"} ${t}`,
                placement: o > 640 ? "top" : "right",
                arrow: !r,
                hideOnClick: !r || "toggle",
                delay: [1e3, null]
            };
            if (s)
                s.setProps(l);
            else {
                const t = this._betweenPosEntity.getComponent(n.DivComponent).getDiv()?.firstChild;
                this._tooltipOpts.instance = (0,
                a.default)(t, l)
            }
            this._tooltipOpts.height = o,
            this._tooltipOpts.isTouch = r
        }
        showTooltip() {
            const {instance: t} = this._tooltipOpts;
            t?.show()
        }
        hideTooltip() {
            const {instance: t} = this._tooltipOpts;
            t?.hide()
        }
        on3dLineMouseMove(t) {
            if (this._isTransitioning)
                return;
            const {buttons: e=0} = t || {};
            if (0 !== e)
                return void (this.intersect = null);
            const i = this.app.pioneer.getInput().getActiveViewport().getCamera()
              , s = this.calcIntersect()
              , n = null === this.intersect && s || this.intersect && null === s;
            if (this.intersect = s,
            n && this.setBetweenIntersectClass(Boolean(this.intersect)),
            null === this.intersect)
                return n && this.playTime(),
                void this.distancePanel.setLineGraphicDotOffset(null);
            const o = 1 === this.app.getManager("time").getTimeRate();
            n && !o && this.pauseTime();
            const {normalSpacePoint: a, pixelSpacePoint: r} = this._vectors;
            i.getNormalSpacePositionFromCameraSpacePosition(a, this.intersect.linePoint),
            i.getViewport().getPixelSpacePositionFromNormalSpacePosition(r, a);
            const {x: l=0, y: c=0} = this._betweenPosEntity?.getPixelSpacePosition(i) || {}
              , h = r.x - l
              , d = r.y - c;
            this.setBetweenOffsetVars(h, d);
            const u = this.getInterpolationU(this.intersect.u);
            this.distancePanel.setLineGraphicDotOffset(u)
        }
        getInterpolationU(t) {
            const {limitedU: e, minSurfaceU: i, maxSurfaceU: s} = this.getLimitedU(t)
              , n = (e - i) / (s - i);
            return this._bpParentIsSource ? n : 1 - n
        }
        getOffsetU(t) {
            const e = this._bpParentIsSource ? t : 1 - t
              , {limitedU: i, minSurfaceU: s, maxSurfaceU: n} = this.getLimitedU(e);
            return .5 !== t ? i : s + (n - s) * t
        }
        on3dLineClick(t, e) {
            if (this.app.canHover || (this.intersect = this.calcIntersect()),
            null === this.intersect && void 0 === e)
                return;
            const i = this._uValueCurrent
              , {limitedU: s} = this.getLimitedU(e ?? this.intersect.u)
              , {x: n, y: o} = this._currBetweenOffset;
            if (this.valuesWithPrecisionAreEqual(i, s))
                return;
            const a = void 0 !== e && Math.abs(i - e) > .8;
            this.setHoldU(null),
            this.setIsTransitioning(!0),
            this.setBetweenPosHidden(!0);
            const r = this.camToBetweenPos({
                targetU: s,
                duration: 1
            });
            this.setBpAnimation({
                initialU: i,
                targetU: s,
                duration: 1,
                onUpdate: (t, e) => {
                    const i = Math.max(1 - t, 0)
                      , s = n * i
                      , r = o * i;
                    if (this.setBetweenOffsetVars(s, r),
                    a) {
                        const t = Math.pow(2 * Math.abs(e - .5), 12)
                          , i = parseFloat(t.toFixed(2));
                        this._distanceLine?.setOpacity(i)
                    }
                }
                ,
                onEnd: async () => {
                    await r,
                    s > .5 && this.toggleBetweenParent(s),
                    this.setIsTransitioning(!1),
                    this.setBetweenPosHidden(!1),
                    this.setBetweenIntersectClass(!1),
                    this.playTime()
                }
            })
        }
        onNewULimit() {
            const t = this._uValueCurrent ?? 0
              , {limitedU: e} = this.getLimitedU(t);
            if (t === e)
                return;
            this.setIsTransitioning(!0);
            this.setBpAnimation({
                initialU: t,
                targetU: e,
                duration: .3,
                onEnd: async () => {
                    e > .5 && this.toggleBetweenParent(e),
                    0 !== t && 1 !== t || this.setHoldU(t),
                    this.setIsTransitioning(!1)
                }
            })
        }
        async camToBetweenPos({targetU: t, duration: e=1.5, force: i=!1}={}) {
            const {entity: s, measurePoint: o} = this.sourceDistanceEntity || {}
              , {entity: a, measurePoint: r} = this.targetDistanceEntities[0] || {}
              , {sourceTargetDiff: l} = this.distanceInfo;
            if (null === l)
                return;
            const c = this._bpParentIsSource ? s : a
              , h = this._bpParentIsSource ? a : s
              , d = this._bpParentIsSource ? o : r
              , u = this._bpParentIsSource ? r : o
              , p = null !== this._uValueHold ? this.getOffsetU(this._uValueHold) : null
              , m = this._bpParentIsSource ? 0 : 1
              , _ = p ?? this._uValueCurrent ?? m
              , {limitedU: g, minRadiusU: y, maxRadiusU: f} = this.getLimitedU(_)
              , b = t ?? g
              , T = this.app.getManager("camera")
              , v = 4 * this.centerDistance
              , S = 20 * (b > .5 ? u.radius : d.radius)
              , E = S + (v - S) * (-2 * Math.abs(b - .5) + 1)
              , C = T.cameraEntity.getPosition().magnitude()
              , x = Math.abs(C - E)
              , w = S
              , I = Math.abs(b - _);
            if (!i && !(x > w || I > .1))
                return;
            const M = -168 * b - 6
              , A = new n.Vector3
              , N = new n.Vector3
              , L = new n.Vector3
              , k = new n.Vector3
              , V = new n.Vector3;
            V.copy(l),
            V.neg(V),
            V.normalize(V),
            V.mult(V, E),
            c.getOrientation().getAxis(A, 2),
            h.getOrientation().getAxis(N, 2),
            L.lerp(A, N, b),
            k.cross(V, L),
            k.normalize(k);
            const R = window.innerHeight > 640 ? k : L
              , P = new n.Quaternion;
            P.setFromAxisAngle(R, n.MathUtils.degToRad(M)),
            V.rotate(P, V);
            const O = new n.Vector3;
            this._bpParentIsSource ? O.neg(l) : O.copy(l),
            O.normalize(O);
            const F = this.app.cameraScripts._easeInOutExpoTransition;
            let U = 1;
            b < y || b > f ? U = 0 : b < .1 ? U = (b - y) / (.1 - y) : b > .9 && (U = (b - .9) / (f - .9)),
            U = Math.max(U, 0);
            const D = 2.5 + 17.5 * U;
            let z = (d.radius + (u.radius - d.radius) * b) * D;
            const j = Math.max(d.radius, u.radius)
              , B = Math.min(d.radius, u.radius)
              , H = .1 * this.measuredDistance;
            this.centerDistance < 20 * j ? z = 2.5 * B : 1 === U && z < H && (z = H);
            const $ = Math.max(j, 50 * Math.abs(this.centerDistance))
              , G = new n.Interval(z,$);
            await (T.goToBetweenPos?.(this._betweenPosEntity, {
                destination: V,
                destinationUp: O,
                transitionFunction: F,
                duration: e,
                zoomInterval: G
            }))
        }
        setBpAnimation({initialU: t, targetU: e, onUpdate: i, onEnd: s, duration: n=1.5}) {
            this._bpAnimation = {
                duration: 1e3 * n,
                startTime: Date.now(),
                initialU: t,
                targetU: e,
                onUpdate: i,
                onEnd: s
            }
        }
        _updateBpAnimation() {
            const {duration: t, startTime: e, initialU: i, targetU: s, onUpdate: n, onEnd: o} = this._bpAnimation
              , a = Date.now() - e;
            let r = a > t ? 1 : a / t;
            const l = r;
            if (1 !== r) {
                const t = 4;
                r = ((r *= 2) <= 1 ? Math.pow(r, t) : 2 - Math.pow(2 - r, t)) / 2
            }
            "function" == typeof n && n(r, l);
            const c = i + (s - i) * r;
            this.updateBetweenPoint(c, !1),
            1 === r && ("function" == typeof o && o(),
            this._bpAnimation = null)
        }
        pauseTime() {
            const t = this.app.getComponent("timeControls")
              , e = this.app.getManager("time")
              , i = 0 === e.getTimeRate();
            this.setAllowPlay(!i),
            i || (t._canUpdate ? t.playPauseRate(null, !0) : e.pause())
        }
        playTime() {
            const t = this.app.getManager("time")
              , e = 0 !== t.getTimeRate();
            if (!this._allowPlay || e)
                return;
            const i = this.app.getComponent("timeControls");
            i._canUpdate ? i.playPauseRate(null, !1) : t.play()
        }
        swapSourceAndTarget() {
            const {id: t} = this.sourceDistanceEntity
              , {id: e} = this.targetDistanceEntities[0]
              , i = `${e}/distance`
              , s = {
                to: t
            };
            this.app.getManager("router")?.navigate(s, i, {
                keepTime: !0
            })
        }
        setBetweenOffsetVars(t, e) {
            const {x: i, y: s} = this._currBetweenOffset;
            if (t === i && e === s)
                return;
            this._currBetweenOffset = {
                x: t,
                y: e
            };
            const o = this._betweenPosEntity?.getComponent(n.DivComponent)?.getDiv();
            o.style.setProperty("--icon-offset-x", `${t}px`),
            o.style.setProperty("--icon-offset-y", `${e}px`)
        }
        getAccurateRadius(t, e=!1) {
            const i = n.Vector3.pool.get()
              , s = n.Vector3.pool.get();
            e ? i.neg(this.distanceInfo.sourceTargetDiff) : i.copy(this.distanceInfo.sourceTargetDiff),
            i.rotateInverse(t.getOrientation(), i);
            let o = !1;
            for (let e = t.getNumComponents() - 1; e >= 0; e--) {
                const n = t.getComponentAt(e);
                if (void 0 !== n.getGroundPosition) {
                    n.getGroundPosition(i, s, i),
                    o = !0;
                    break
                }
            }
            const a = o ? i.magnitude() : null;
            return n.Vector3.pool.release(i),
            n.Vector3.pool.release(s),
            a
        }
        measureDistance(t=!1, e) {
            const {entity: i, measurePoint: s} = this.sourceDistanceEntity || {}
              , {entity: n, measurePoint: o} = this.targetDistanceEntities[0] || {};
            if (!i || !n)
                return null;
            if (this.setDistanceInfo(e),
            !this.distanceIsValid(this.centerDistance))
                return null;
            const a = s.radius > .01 && s.radius / this.centerDistance > .001
              , r = o.radius > .01 && o.radius / this.centerDistance > .001
              , l = this.setMPAdjustable(this.sourceDistanceEntity, a)
              , c = this.setMPAdjustable(this.targetDistanceEntities[0], r)
              , {sourceMpPosChanged: h, targetMpPosChanged: u} = this.calcMPPositions();
            let p = !1;
            if (t || l || h) {
                const {position: t} = this.sourceDistanceEntity.measurePoint;
                this.distancePanel.setSourceMpState(a && t),
                p = !0,
                this._distanceLine?.setSourceMeasurePoint(a && t)
            }
            if (t || c || u) {
                const {position: t} = this.targetDistanceEntities[0].measurePoint;
                this.distancePanel.setTargetMpState(r && t),
                p = !0,
                this._distanceLine?.setTargetMeasurePoint(r && t)
            }
            const m = s.adjustable && s.position === d
              , _ = o.adjustable && o.position === d;
            if (m) {
                const t = this.getAccurateRadius(i);
                t && (this.sourceDistanceEntity.measurePoint.radius = t),
                this.distanceInfo.measuredValue -= s.radius
            }
            if (_) {
                const t = this.getAccurateRadius(n, !0);
                t && (this.targetDistanceEntities[0].measurePoint.radius = t),
                this.distanceInfo.measuredValue -= o.radius
            }
            if (p && this.onNewULimit(),
            this._distanceLine?.setDistanceProps({
                distance: this.centerDistance,
                sourceRadius: s.radius,
                targetRadius: o.radius
            }),
            !this.distanceIsValid(this.measuredDistance))
                return null;
            const g = this.measuredDistance < 0;
            this._isBelowZero !== g && (this.setBetweenPosHidden(g),
            this._distanceLine.setVisible(!g),
            this._isBelowZero = g);
            const y = this.measuredDistance.toPrecision(4);
            return this._getDistanceParams(y)
        }
        _getDistanceParams(t) {
            const e = this._currentUnitSystem === m
              , i = 9460730472580.8
              , s = 1e9
              , n = 1e6
              , {kmToMi: o, miToFt: a, kmToM: r} = l;
            let c = e ? t * o : t;
            c = Math.max(0, c);
            let h = c
              , d = ""
              , u = ""
              , p = e ? "mi" : "km";
            t >= i ? (h = t / i,
            p = "light years") : c >= s ? (h = c / s,
            u = "billion") : c >= n ? (h = c / n,
            u = "million") : c >= 1e3 ? (h = c / 1e3,
            u = "thousand") : c < 1 && (d = "~ ",
            h = e ? c * a : c * r,
            p = e ? "ft" : "m");
            const _ = h.toPrecision(4).split(".");
            return {
                prefix: d,
                value: h,
                scale: u,
                unit: p,
                dps: _.length > 1 && _[1].length > 1 ? 2 : 1
            }
        }
        measureRelativeVelocity(t) {
            const {entity: e} = this.sourceDistanceEntity || {}
              , {entity: i} = this.targetDistanceEntities[0] || {};
            if (!e || !i)
                return null;
            const s = n.Vector3.pool.get();
            e.getVelocityRelativeToEntity(s, n.Vector3.Zero, i, t);
            const o = this._getDistanceParams(3600 * s.magnitude());
            return o.unit += "/hr",
            n.Vector3.pool.release(s),
            o
        }
        _createDistanceEntity(t) {
            const e = this.app.getManager("content").getEntityInfo(t)
              , i = this.app.scene.getEntity(t);
            if (null === e || !i)
                throw Error(`DistanceView._createDistanceEntity: Cannot find entity ${t}.`);
            const s = {
                adjustable: !1,
                position: u,
                radius: i.getExtentsRadius()
            };
            return {
                id: t,
                entity: i,
                info: e,
                measurePoint: s
            }
        }
        _createBetweenEntity() {
            const t = this.app.getManager("label")
              , e = "distance_betweenPos"
              , i = o.Entity.createFromOptions(e, {
                parents: [],
                label: "~",
                labelFadeEntity: !1
            }, this.app.scene);
            i.setPosition(n.Vector3.Zero),
            i.setOrientation(n.Quaternion.Identity);
            i.setOcclusionRadius(.001),
            i.setExtentsRadius(.001),
            t.addLabel(i),
            t.setLabelProps({
                getLabelClass: () => "no-select distance-between-pos"
            }, [e]),
            t.setLabelClickable(e, !1);
            const s = i.getComponent(n.DivComponent);
            return s?.setFadeWhenCloseToCamera(!1),
            s.setFadeWhenCloseToEntity("sun"),
            this.setLabelWeight(e, !1, "201"),
            i
        }
        setBetweenEntityParent(t) {
            this._betweenPosEntity.setParent(t),
            this._bpParentIsSource = t === this.sourceDistanceEntity?.entity
        }
        toggleBetweenParent(t) {
            const {entity: e} = this.sourceDistanceEntity || {}
              , {entity: i} = this.targetDistanceEntities[0] || {}
              , s = this._bpParentIsSource ? i : e;
            this.setBetweenEntityParent(s),
            this.setDistanceInfo(),
            this.updateBetweenPoint(1 - t)
        }
        setHoldU(t) {
            this._uValueHold = t
        }
        updateBetweenPoint(t, e=!0) {
            const {sourceTargetDiff: i} = this.distanceInfo;
            if (!this.hasTarget || null === i)
                return;
            const s = null !== this._uValueHold ? this.getOffsetU(this._uValueHold) : null
              , n = this._bpParentIsSource ? 0 : 1;
            let o = t ?? s ?? this._uValueCurrent ?? n;
            const {limitedU: a} = this.getLimitedU(o);
            e && (o = a),
            this.setBpControllerMults(o);
            const r = this.getInterpolationU(o);
            this.distancePanel.setLineGraphicDotPos(r),
            this._uValueCurrent !== o && (this._uValueCurrent = o)
        }
        setBpControllerMults(t) {
            const {id: e} = this.sourceDistanceEntity || {}
              , {id: i} = this.targetDistanceEntities[0] || {}
              , s = 1 - t
              , n = this._bpParentIsSource ? s : t
              , o = this._bpParentIsSource ? t : s
              , a = this._bpController._entities.get(e)
              , r = this._bpController._entities.get(i);
            a && r && (a.mult = n,
            r.mult = o)
        }
        resetUValue() {
            this._uValueCurrent = null
        }
        resetAreRelated() {
            this._areRelated = null
        }
        resetDistanceInfo() {
            this.distanceInfo = {
                centerValue: null,
                measuredValue: null,
                sourceTargetDiff: null
            }
        }
        setBetweenPosHidden(t) {
            const e = this._betweenPosEntity?.getComponent(n.DivComponent).getDiv();
            e.classList.toggle("hide", t)
        }
        toggleCurrentUnitSystem() {
            const t = this._currentUnitSystem === p ? m : p;
            this._currentUnitSystem = t
        }
        setMPPosition(t, e=u) {
            const {measurePoint: i} = t || {}
              , s = i?.position !== e;
            return s && (i.position = e),
            s
        }
        setMPAdjustable(t, e) {
            const {measurePoint: i} = t || {}
              , s = i?.adjustable !== e;
            return s && (i.adjustable = e),
            s
        }
        toggleSourceMeasurePoint() {
            const {adjustable: t, position: e} = this.sourceDistanceEntity?.measurePoint || {};
            if (!t)
                return;
            const i = e === h ? d : h;
            this.setMPPosition(this.sourceDistanceEntity, i),
            this.updateMeasurement(null, !0)
        }
        toggleTargetMeasurePoint() {
            const {adjustable: t, position: e} = this.targetDistanceEntities[0]?.measurePoint || {};
            if (!t)
                return;
            const i = e === h ? d : h;
            this.setMPPosition(this.targetDistanceEntities[0], i),
            this.updateMeasurement(null, !0)
        }
        setSourceDistanceEntity(t) {
            this.resetSourceDistanceEntity(),
            this._sourceDistanceEntity = this._createDistanceEntity(t);
            const {entity: e, id: i} = this.sourceDistanceEntity || {};
            this._distanceLine = e && e.addComponent(s.DistanceLineComponent, "distance_line"),
            this.setBetweenEntityParent(e),
            this.distancePanel.setSourceText(this.sourceDisplayName),
            this.distancePanel.targetSearch?.setExcludeResults([i]),
            this.toggleSourceIconClass("distance-source", !0),
            this.setLabelWeight(i),
            e && this.setOcclusionRadius(e),
            this._bpController.addEntity(i, 1, 0),
            null === this._uValueHold && this.setHoldU(0)
        }
        setTargetDistanceEntities(t) {
            this.resetTargetDistanceEntities(),
            t.forEach((t => this.addTargetDistanceEntity(t)));
            const e = Boolean(this.targetDistanceEntities.length);
            if (e) {
                const {id: t, entity: i} = this.targetDistanceEntities[0] || {}
                  , {entity: s} = this.sourceDistanceEntity || {};
                this.setHasTarget(e),
                this.hideSpacecraftLayer(),
                this.setBetweenEntityParent(s),
                this.distancePanel.setTargetText(this.targetDisplayNames[0]),
                this.distancePanel.sourceSearch?.setExcludeResults([t]),
                this.distancePanel.setResult({
                    text: ""
                }),
                this.toggleTargetIconClass("distance-target", !0),
                this.setLabelWeight(t),
                i && this.setOcclusionRadius(i),
                this._distanceLine.setTargetEntity(i),
                this._bpController.addEntity(t, 0, 0),
                null === this._uValueHold && this.setHoldU(0)
            } else
                this.resetUValue()
        }
        async setTempErrorResult(t) {
            return this.distancePanel.setResult({
                text: t
            }),
            new Promise((t => {
                this.errorResultTimeout = setTimeout(( () => {
                    this.distancePanel.setResult(),
                    t()
                }
                ), 3e3)
            }
            ))
        }
        setLabelWeight(t, e=!1, i) {
            if (!t)
                return;
            if (null === this.app.scene.getEntity(t))
                return;
            const s = i ?? "200"
              , n = this.app.getManager("label")
              , o = n.getDefaultWeight(t);
            0 === o && (n._weights[t] = {}),
            e ? this._prevValues.weights[t] && n.setWeight(t, this._prevValues.weights[t]) : (n.setWeight(t, s),
            this._prevValues.weights[t] = o)
        }
        setOcclusionRadius(t, e=!1) {
            const i = t.getName()
              , s = t.getOcclusionRadius();
            e ? this._prevValues.occRadii[i] && t.setOcclusionRadius(this._prevValues.occRadii[i]) : (t.setOcclusionRadius(0),
            this._prevValues.occRadii[i] = s)
        }
        setBetweenIntersectClass(t) {
            this._betweenPosEntity?.getComponent(n.DivComponent)?.getDiv()?.classList?.toggle("intersect", t)
        }
        toggleSourceIconClass(t, e) {
            const {entity: i} = this.sourceDistanceEntity || {};
            if (!i)
                return;
            const s = i?.getComponent(n.DivComponent);
            s.setFadeWhenCloseToEntity(e ? "camera" : "");
            const o = s?.getDiv()?.firstChild;
            o && o.classList.toggle(t, e)
        }
        toggleTargetIconClass(t, e) {
            const {entity: i} = this.targetDistanceEntities[0] || {};
            if (!i)
                return;
            const s = i?.getComponent(n.DivComponent);
            s.setFadeWhenCloseToEntity(e ? "camera" : "");
            const o = s?.getDiv()?.firstChild;
            o && o.classList.toggle(t, e)
        }
        calcMPPositions() {
            if (!this.hasTarget)
                return;
            const {id: t, entity: e, measurePoint: i} = this.sourceDistanceEntity || {}
              , {id: s, entity: n, measurePoint: o} = this.targetDistanceEntities[0] || {}
              , a = e?.getParent()?.getName() === s || n?.getParent()?.getName() === t
              , r = this._areRelated !== a
              , l = i.radius / this.measuredDistance < .01 || o.radius / this.measuredDistance < .01
              , c = this._areClose !== l
              , h = {
                sourceMpPosChanged: !1,
                targetMpPosChanged: !1
            };
            if (r || c) {
                const t = i.adjustable && (a || l)
                  , e = o.adjustable && (a || l)
                  , s = t ? d : u
                  , n = e ? d : u;
                h.sourceMpPosChanged = this.setMPPosition(this.sourceDistanceEntity, s),
                h.targetMpPosChanged = this.setMPPosition(this.targetDistanceEntities[0], n),
                this._areRelated = a,
                this._areClose = l
            }
            return h
        }
        resetSourceDistanceEntity() {
            const {entity: t, id: e} = this.sourceDistanceEntity || {};
            t && t.removeComponent("distance_line"),
            this.resetAreRelated(),
            1 === this._uValueHold && this.setHoldU(null),
            this._bpController.removeEntity(e),
            this.toggleSourceIconClass("distance-source", !1),
            this.setLabelWeight(e, !0),
            t && this.setOcclusionRadius(t, !0),
            this._sourceDistanceEntity = null,
            this.distancePanel.setSourceText(""),
            this.distancePanel.setSourceMpState(""),
            this.distancePanel.targetSearch?.setExcludeResults([]),
            this.resetDistanceInfo()
        }
        addTargetDistanceEntity(t) {
            this.targetDistanceEntities.find(( ({id: e}) => e === t)) && console.error(`DistanceManager.addTargetDistanceEntity: The entity, '${t}', is already a target.`);
            const e = this._createDistanceEntity(t);
            this._targetDistanceEntities.push(e)
        }
        resetTargetDistanceEntities() {
            const {entity: t, id: e} = this._targetDistanceEntities[0] || {};
            this.resetAreRelated(),
            1 === this._uValueHold && this.setHoldU(null),
            this._bpController.removeEntity(e),
            this.toggleTargetIconClass("distance-target", !1),
            this.setLabelWeight(e, !0),
            t && this.setOcclusionRadius(t, !0),
            this._targetDistanceEntities = [],
            this.setHasTarget(!1),
            this.distancePanel.setTargetText(""),
            this.distancePanel.setTargetMpState(""),
            this.distancePanel.setResult(),
            this.distancePanel.setSourceMpState(""),
            this.distancePanel.sourceSearch?.setExcludeResults([]),
            this._distanceLine?.setTargetEntity(null),
            this.resetDistanceInfo(),
            this.showSpacecraftLayer()
        }
        valuesWithPrecisionAreEqual(t, e, i=5) {
            return null != t && null != e && (null == i ? t === e : t.toPrecision(i) === e.toPrecision(i))
        }
        resetAllDistanceEntities() {
            this.resetSourceDistanceEntity(),
            this.resetTargetDistanceEntities()
        }
        setHasTarget(t) {
            this.hasTarget = t,
            this.distancePanel.setCanMinimize(this.hasTarget),
            this.distancePanel.setSwapButtonVisible(this.hasTarget)
        }
        setAllowRaycasting(t) {
            this._allowRaycasting = t
        }
        setAllowPlay(t) {
            this._allowPlay = t
        }
        setIsTransitioning(t) {
            this._isTransitioning = t
        }
        setIsWaitingForEntities(t) {
            this._isWaitingForEntities = t
        }
        getEntitiesToLoad() {
            const t = [];
            return this.sourceDistanceEntity?.id && t.push(this.sourceDistanceEntity.id),
            this.targetDistanceEntities.length && t.push(...this.targetDistanceEntities.map(( ({id: t}) => t))),
            t
        }
        setDistanceInfo(t) {
            const {entity: e} = this.sourceDistanceEntity || {}
              , {entity: i} = this.targetDistanceEntities[0] || {}
              , {sourceTargetDiff: s} = this._vectors
              , o = this._bpParentIsSource ? e : i;
            (this._bpParentIsSource ? i : e).getPositionRelativeToEntity(s, n.Vector3.Zero, o, t);
            const a = s.magnitude();
            this.distanceIsValid(a) && this.distanceInfo.value !== a && (this.distanceInfo.measuredValue = a,
            this.distanceInfo.centerValue = a,
            this.distanceInfo.sourceTargetDiff = s)
        }
        isCloseEnough() {
            const {measurePoint: t} = this.sourceDistanceEntity
              , {measurePoint: e} = this.targetDistanceEntities[0];
            if (this.distanceIsValid(this.measuredDistance)) {
                const i = Math.max(t.radius, e.radius) / this.measuredDistance
                  , s = this.app.getManager("camera").cameraEntity.getPosition().magnitude() / this.centerDistance;
                return s < 5 && (s < .5 || i > 1)
            }
            return !0
        }
        updateMeasurement(t, e=!1) {
            const i = t && parseInt(.001 * t.valueOf())
              , s = t && i === this._currentSecond;
            if (!e && (!this.hasTarget || this._isWaitingForEntities || s && !this.isCloseEnough()))
                return !1;
            t && (this._currentSecond = i);
            const {prefix: n, value: o=null, scale: a, unit: r, dps: l} = this.measureDistance(e) || {}
              , {prefix: c, value: h=null, scale: d, unit: u, dps: p} = this.measureRelativeVelocity() || {};
            if (null === o)
                return !1;
            const m = this._formatText(n, o, a, r, l)
              , _ = this._formatText(c, h, d, u.split("/")[0], p)
              , {resultText: g, resultUnit: y, relVelocityText: f, relVelocityUnit: b} = this.distancePanel._state;
            return m === g && r === y && _ === f && u === b || this.distancePanel.setResult({
                text: m,
                unit: r,
                isDistance: !0,
                relText: _,
                relUnit: u,
                isRelVelocity: !0
            }),
            !0
        }
        _formatText(t, e, i, s, n) {
            return `${t}${r(e, "m" === s || "ft" === s ? 0 : n, "m" === s || "ft" === s ? 0 : n)} ${i}`
        }
        calcIntersect() {
            if (!this._allowRaycasting)
                return null;
            const {entity: t} = this.sourceDistanceEntity || {}
              , {entity: e} = this.targetDistanceEntities[0] || {}
              , {sourceTargetDiff: i} = this.distanceInfo;
            if (!t || !e || i.isNaN())
                return null;
            const s = this.app.pioneer.getInput()
              , n = s.getActiveViewport()
              , o = s.getCursorPosition()
              , a = n.getCamera()
              , r = this._bpParentIsSource ? t : e
              , l = this._bpParentIsSource ? e : t
              , {rayDirection: c, parentEntityPosition: h, otherEntityPosition: d, planeNormal: u, intersectionPoint: p, intersectToSource: m, closestPointOnLine: _} = this._vectors;
            n.getNormalSpacePositionFromPixelSpacePosition(c, o),
            a.getCameraSpacePositionFromNormalSpacePosition(c, c),
            c.normalize(c),
            h.copy(r.getCameraSpacePosition(a)),
            d.copy(l.getCameraSpacePosition(a));
            const g = h.magnitude()
              , y = d.magnitude()
              , f = i.magnitude();
            let b = n.getNormalSpaceRadiusFromPixelSpaceRadius(80)
              , T = b;
            b = a.getRadiusFromNormalSpaceRadius(b, g),
            T = a.getRadiusFromNormalSpaceRadius(T, y),
            u.cross(i, c),
            u.cross(u, i),
            u.normalize(u);
            const v = h.dot(u) / u.dot(c);
            if (v < 0)
                return null;
            p.copy(c),
            p.mult(p, v),
            m.sub(p, h);
            const S = m.dot(i) / Math.pow(f, 2);
            if (S > 1 || S < 0)
                return null;
            _.lerp(h, d, S);
            const E = p.distance(_)
              , C = b + S * (T - b);
            if (E < -C || E > C)
                return null;
            const x = this.getLimitedU(S).limitedU;
            return _.lerp(h, d, x),
            {
                u: S,
                linePoint: _
            }
        }
        getLimitedU(t) {
            const {measurePoint: e} = this.sourceDistanceEntity || {}
              , {measurePoint: i} = this.targetDistanceEntities[0] || {}
              , s = {
                limitedU: 0,
                minSurfaceU: 0,
                maxSurfaceU: 1
            };
            if (null == e || null == i)
                return s;
            const n = Math.min(e.radius / this.centerDistance, 1)
              , o = Math.min(i.radius / this.centerDistance, 1)
              , a = e.position === d ? n : 0
              , r = i.position === d ? o : 0
              , l = this._bpParentIsSource ? a : r
              , c = 1 - (this._bpParentIsSource ? r : a)
              , h = this._bpParentIsSource ? n : o
              , u = 1 - (this._bpParentIsSource ? o : n);
            return s.limitedU = Math.min(c, Math.max(l, t)),
            s.minSurfaceU = l,
            s.maxSurfaceU = c,
            s.minRadiusU = h,
            s.maxRadiusU = u,
            s
        }
        _grabVectors() {
            const {pool: t} = n.Vector3
              , {pool: e} = n.Vector3;
            this._vectors = {
                rayDirection: t.get(),
                parentEntityPosition: t.get(),
                otherEntityPosition: t.get(),
                planeNormal: t.get(),
                intersectionPoint: t.get(),
                intersectToSource: t.get(),
                closestPointOnLine: t.get(),
                sourceTargetDiff: t.get(),
                normalSpacePoint: t.get(),
                pixelSpacePoint: e.get()
            }
        }
        _releaseVectors() {
            for (const t of Object.values(this._vectors))
                n.Vector3.pool.release(t)
        }
        update(t) {
            const e = this.app.pioneer.getInput()
              , i = !e.getDraggedOffset().isZero()
              , s = Math.abs(e.getZoomedOffset()) > 0
              , n = null !== this._bpAnimation || this._isTransitioning
              , o = this._isWaitingForEntities
              , a = !o && !n && !(i || s)
              , r = !o && !n
              , l = null !== this._bpAnimation
              , c = this.distancePanel.allowBpOffset
              , h = null === this.intersect || i || s;
            this.setAllowRaycasting(a),
            h && this.setBetweenOffsetVars(0, 0),
            r && this.updateBetweenPoint(),
            l && this._updateBpAnimation(),
            c && this.distancePanel.setBpCSSOffsets(),
            this._updateTooltip(),
            !o && this.updateMeasurement(t)
        }
        distanceIsValid(t) {
            return "number" == typeof t && !isNaN(t) && null != t && t !== 1 / 0
        }
        get centerDistance() {
            return this.distanceInfo.centerValue
        }
        get measuredDistance() {
            return this.distanceInfo.measuredValue
        }
        get sourceDisplayName() {
            const {info: t} = this.sourceDistanceEntity || {};
            return t?.displayName || t?.iauName
        }
        get targetDisplayNames() {
            return this.targetDistanceEntities.map(( ({info: t}) => t.displayName || t.iauName))
        }
        get targetDistanceEntities() {
            return this._targetDistanceEntities
        }
        get sourceDistanceEntity() {
            return this._sourceDistanceEntity
        }
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e),
    i.d(e, {
        STORY_LIST: function() {
            return l
        },
        STORIES: function() {
            return c
        }
    });
    var s = i(1048)
      , n = i(1049)
      , o = i(1050)
      , a = i(1051)
      , r = i(1052)
      , l = i(744);
    const c = {
        annular_solar_eclipse: s.default,
        total_solar_eclipse: n.default,
        enceladus_discovery: o.default,
        voyager_grand_tour: a.default,
        psp_perihelion: r.default
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e);
    var s = i(5)
      , n = i(542);
    const o = {
        layers: []
    };
    let a, r, l, c, h, d, u, p, m, _, g, y, f, b, T = !1, v = !0;
    const S = [];
    function E() {
        let t = y.getComponent(n.ShadowConeComponent, "shadowConeUmbra")
          , e = y.getComponent(n.ShadowConeComponent, "shadowConePenumbra");
        t && e || (t = y.addComponent(n.ShadowConeComponent, "shadowConeUmbra"),
        e = y.addComponent(n.ShadowConeComponent, "shadowConePenumbra")),
        t.setSourceEntity("sun"),
        t.setTargetEntity("earth"),
        t.setColor(new s.Color(.437,.18,.593,.25)),
        e.setSourceEntity("sun"),
        e.setTargetEntity("earth"),
        e.setShadowType("penumbra"),
        e.setColor(new s.Color(.218,.093,.3,.3))
    }
    function C() {
        for (const t of S)
            t.style.display = "none"
    }
    function x() {
        if (v)
            for (const t of S)
                t.style.display = "block"
    }
    e.default = {
        type: "nonsequential",
        entities: ["moon"],
        onEnter: async t => {
            const e = t.getManager("layer")
              , i = t.getComponent("layerPanel");
            t.getManager("time").resetLimits(),
            ["asteroids", "comets", "dwarfPlanets", "minorMoons", "spacecraft", "planets", "majorMoons"].forEach((t => {
                e.getLayer(t).visible && (o.layers.push(t),
                i.toggleLayer(t))
            }
            )),
            t.pioneer.getScene("main").getEntity("earth").isEnabled(!0)
        }
        ,
        onLeave: t => {
            const {layers: e} = o
              , i = t.getComponent("layerPanel");
            t.getManager("time").resetLimits();
            for (let t = 0; t < e.length; t++)
                i.toggleLayer(e[t]);
            o.layers = []
        }
        ,
        slides: [{
            id: "slide_1",
            type: "panel",
            content: [{
                type: "description",
                title: "Annular Solar Eclipse",
                description: "On October 14, 2023, an annular solar eclipse crossed North, Central, and South America creating a path of annularity.",
                more: 'An annular solar eclipse occurs when the Moon passes between the Sun and Earth while at its farthest point from Earth. Because the Moon is farther away from Earth, it does not completely block the Sun. This creates a "ring of fire" effect in the sky for those standing in the path of annularity. During an annular eclipse, it is never safe to look directly at the Sun without specialized eye protection designed for solar viewing.'
            }, {
                type: "buttons",
                blockTitle: "Select your view",
                buttonContent: [{
                    id: "earth",
                    label: "Earth",
                    iconSrc: "assets/images/cards/eclipse_view_earth_icon.png",
                    onClick: () => {
                        x(),
                        T = !1,
                        app.cameraScripts.alignObjects("earth", "sun", {
                            distance: 28e3,
                            horizontalOffset: 150
                        })
                    }
                }, {
                    id: "behind-moon",
                    label: "Behind Moon",
                    iconSrc: "assets/images/cards/eclipse_view_behind_moon_icon.png",
                    onClick: async () => {
                        C(),
                        T = !0,
                        app.cameraScripts.alignObjects("moon", "earth", {
                            distance: 1e4,
                            horizontalOffset: -15,
                            verticalOffset: 10
                        })
                    }
                }, {
                    id: "earth-moon",
                    label: "Earth-Moon",
                    iconSrc: "assets/images/cards/eclipse_view_earth_moon_icon.png",
                    onClick: () => {
                        x(),
                        T = !1,
                        app.cameraScripts.alignObjects("earth", "moon", {
                            distance: 12e5,
                            horizontalOffset: -90,
                            verticalOffset: 10
                        })
                    }
                }, {
                    id: "sun-earth-moon",
                    label: "Sun-Earth-Moon",
                    iconSrc: "assets/images/cards/eclipse_view_sun_earth_moon_icon.png",
                    onClick: () => {
                        x(),
                        T = !1,
                        app.cameraScripts.alignObjects("earth", "sun", {
                            distance: 1e6,
                            horizontalOffset: -5,
                            verticalOffset: 10
                        })
                    }
                }],
                clickable: !0
            }, {
                type: "checkboxes",
                checkboxBlockTitle: "More Options",
                checkboxContent: [{
                    label: "Enable Shadow Cones",
                    onChange: t => {
                        t.target.checked ? E() : (y.removeComponent(y.getComponent(n.ShadowConeComponent, "shadowConeUmbra")),
                        y.removeComponent(y.getComponent(n.ShadowConeComponent, "shadowConePenumbra")))
                    }
                }, {
                    label: "Enable Contour Map",
                    onChange: t => {
                        t.target.checked ? (v = !0,
                        f.setTexture("decal", "assets/images/stories/annular_solar_eclipse/eclipse_$SIZE_$FACE.png", [1024]),
                        T || x()) : (v = !1,
                        f.setTexture("decal", "", [1024]),
                        C())
                    }
                }]
            }],
            time: "2023-10-14T14:50:00Z",
            timeLimits: {
                min: "2023-10-14T14:50:00Z",
                max: "2023-10-14T23:00:00Z"
            },
            onLeave: t => {
                y.removeComponent(y.getComponent(n.ShadowConeComponent, "shadowConeUmbra")),
                y.removeComponent(y.getComponent(n.ShadowConeComponent, "shadowConePenumbra")),
                C(),
                f.setTexture("decal", a, r),
                f.setTexture("color", l, c),
                f.setTexture("night", h, d),
                f.setTexture("specular", u, p),
                g.getComponent(s.AtmosphereComponent).setDensity(m),
                t.scene.setAmbientLightColor(_),
                t.scene.removeEntity("top_left_35"),
                t.scene.removeEntity("top_left_60"),
                t.scene.removeEntity("top_left_85"),
                t.scene.removeEntity("bottom_left_85"),
                t.scene.removeEntity("bottom_left_60"),
                t.scene.removeEntity("bottom_left_35"),
                t.scene.removeEntity("top_right_35"),
                t.scene.removeEntity("top_right_60"),
                t.scene.removeEntity("top_right_85"),
                t.scene.removeEntity("bottom_right_85"),
                t.scene.removeEntity("bottom_right_60"),
                t.scene.removeEntity("bottom_right_35"),
                S.length = 0
            }
            ,
            camera: [async t => {
                if (await t.cameraScripts.goToSystem("inner_solar_system"),
                g = t.scene.getEntity("earth"),
                y = t.scene.getEntity("moon"),
                f = g.getComponent(s.SpheroidLODComponent),
                b = g.getComponent(s.SpheroidComponent),
                g.getComponent(n.WMTSComponent)) {
                    const t = g.getComponent(n.WMTSComponent);
                    g.removeComponent(t),
                    f.setEnabled(!0)
                }
                if (a = f.getTextureUrl("decal"),
                r = f.getTextureSizes("decal"),
                l = f.getTextureUrl("color"),
                c = f.getTextureSizes("color"),
                h = f.getTextureUrl("night"),
                d = f.getTextureSizes("night"),
                u = f.getTextureUrl("specular"),
                p = f.getTextureSizes("specular"),
                m = g.getComponent(s.AtmosphereComponent).getDensity(),
                _ = new s.Color,
                _.copy(t.scene.getAmbientLightColor()),
                E(),
                0 === S.length) {
                    S.push(n.Placemarks.addPlacemark("top_left_35", "35%", g, 68.4, -140, 0, !1).getComponent(s.DivComponent).getDiv()),
                    S.push(n.Placemarks.addPlacemark("top_left_60", "60%", g, 59.3, -141.9, 0, !1).getComponent(s.DivComponent).getDiv()),
                    S.push(n.Placemarks.addPlacemark("top_left_85", "85%", g, 51.5, -143.5, 0, !1).getComponent(s.DivComponent).getDiv()),
                    S.push(n.Placemarks.addPlacemark("bottom_left_85", "85%", g, 46.7, -144, 0, !1).getComponent(s.DivComponent).getDiv()),
                    S.push(n.Placemarks.addPlacemark("bottom_left_60", "60%", g, 39.4, -145.3, 0, !1).getComponent(s.DivComponent).getDiv()),
                    S.push(n.Placemarks.addPlacemark("bottom_left_35", "35%", g, 32, -146.7, 0, !1).getComponent(s.DivComponent).getDiv()),
                    S.push(n.Placemarks.addPlacemark("top_right_35", "35%", g, 13.4, -33.7, 0, !1).getComponent(s.DivComponent).getDiv()),
                    S.push(n.Placemarks.addPlacemark("top_right_60", "60%", g, 4.3, -33.2, 0, !1).getComponent(s.DivComponent).getDiv()),
                    S.push(n.Placemarks.addPlacemark("top_right_85", "85%", g, -3.6, -32.6, 0, !1).getComponent(s.DivComponent).getDiv()),
                    S.push(n.Placemarks.addPlacemark("bottom_right_85", "85%", g, -8.2, -32.3, 0, !1).getComponent(s.DivComponent).getDiv()),
                    S.push(n.Placemarks.addPlacemark("bottom_right_60", "60%", g, -15.7, -32, 0, !1).getComponent(s.DivComponent).getDiv()),
                    S.push(n.Placemarks.addPlacemark("bottom_right_35", "35%", g, -23.2, -31.4, 0, !1).getComponent(s.DivComponent).getDiv());
                    for (const t of S)
                        t.style.fontSize = ".75em"
                } else
                    x();
                f.setTexture("decal", "assets/images/stories/annular_solar_eclipse/eclipse_$SIZE_$FACE.png", [1024]),
                f.setTexture("color", "assets/images/stories/annular_solar_eclipse/earth_color_$FACE.png", [1024]),
                f.setTexture("night", "", ""),
                f.setTexture("specular", "", [1024]),
                g.getComponent(s.AtmosphereComponent).setDensity(1e-4),
                t.scene.setAmbientLightColor(new s.Color(.125,.125,.125)),
                await t.cameraScripts.alignObjects("earth", "sun", {
                    distance: 28e3,
                    horizontalOffset: 150
                }),
                t.pioneer.getScene("main").waitTillEntitiesInPlace(["earth", "moon"], t.pioneer.getTime(), 10).then(( () => (t.getManager("time").setTimeRate(300),
                !0))).catch((t => {
                    console.warn(t)
                }
                ))
            }
            ]
        }]
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e);
    var s = i(5)
      , n = i(542);
    const o = {
        layers: []
    }
      , a = "2024-04-08T15:40:00Z";
    let r, l, c, h, d, u, p, m, _, g, y, f;
    const b = {
        Mazatlan: {
            text: "Mazatlan",
            latLng: [23.24923710314604, -106.40993819539558]
        },
        Durango: {
            text: "Durango",
            latLng: [24.02441384699334, -104.66984097026072]
        },
        "San Antonio": {
            text: "San Antonio",
            latLng: [29.420047396623932, -98.57519484659794]
        },
        Austin: {
            text: "Austin",
            latLng: [30.263780185402428, -97.75987715008797]
        },
        Dallas: {
            text: "Dallas",
            latLng: [32.77380380404552, -96.79954491353796]
        },
        "Little Rock": {
            text: "Little Rock",
            latLng: [34.74290714935434, -92.29046361128361]
        },
        Indianapolis: {
            text: "Indianapolis",
            latLng: [39.76489045302965, -86.17327537195442]
        },
        Buffalo: {
            text: "Buffalo",
            latLng: [42.88564478789335, -78.88023833127143]
        },
        Montreal: {
            text: "Montreal",
            latLng: [45.50519157056544, -73.56425672504801]
        }
    }
      , T = {
        top_left_50: {
            text: "50%",
            latLng: [6.4, -162]
        },
        top_left_75: {
            text: "75%",
            latLng: [-.4, -159.7]
        },
        top_left_95: {
            text: "95%",
            latLng: [-5.3, -157.8]
        },
        left_100: {
            text: "100%",
            latLng: [-7.5, -157.4]
        },
        bottom_left_95: {
            text: "95%",
            latLng: [-9.5, -157]
        },
        bottom_left_75: {
            text: "75%",
            latLng: [-14.6, -155.4]
        },
        bottom_left_50: {
            text: "50%",
            latLng: [-20.5, -153.9]
        },
        top_right_50: {
            text: "50%",
            latLng: [62.2, -13.2]
        },
        top_right_75: {
            text: "75%",
            latLng: [55.1, -17.9]
        },
        top_right_95: {
            text: "95%",
            latLng: [50, -20.3]
        },
        right_100: {
            text: "100%",
            latLng: [47.7, -20.9]
        },
        bottom_right_95: {
            text: "95%",
            latLng: [45.7, -21.9]
        },
        bottom_right_75: {
            text: "75%",
            latLng: [40.8, -23.6]
        },
        bottom_right_50: {
            text: "50%",
            latLng: [34.7, -24.9]
        }
    };
    e.default = {
        type: "nonsequential",
        entities: ["earth", "moon"],
        onEnter: async t => {
            const e = t.getManager("layer")
              , i = t.getComponent("layerPanel");
            t.getManager("time").resetLimits();
            const a = t.scene.getEntity("earth");
            if (["asteroids", "comets", "dwarfPlanets", "minorMoons", "spacecraft", "planets"].forEach((t => {
                e.getLayer(t).visible && (o.layers.push(t),
                i.toggleLayer(t))
            }
            )),
            y = a.getComponent(s.SpheroidLODComponent),
            f = a.getComponent(s.SpheroidComponent),
            a.getComponent(n.WMTSComponent)) {
                const t = a.getComponent(n.WMTSComponent);
                a.removeComponent(t),
                y.setEnabled(!0)
            }
            r = y.getTextureUrl("decal"),
            l = y.getTextureSizes("decal"),
            c = y.getTextureUrl("color"),
            h = y.getTextureSizes("color"),
            d = y.getTextureUrl("night"),
            u = y.getTextureSizes("night"),
            p = y.getTextureUrl("specular"),
            m = y.getTextureSizes("specular"),
            _ = a.getComponent(s.AtmosphereComponent).getDensity(),
            g = new s.Color,
            g.copy(t.scene.getAmbientLightColor()),
            y.setTexture("night", "", ""),
            y.setTexture("specular", "", [1024]),
            y.setTexture("decal", "assets/images/2024_eclipse_contour/eclipse_contour_$SIZE_$FACE.png", [1024]),
            y.setTexture("color", "assets/images/stories/annular_solar_eclipse/earth_color_$FACE.png", [1024]),
            a.getComponent(s.AtmosphereComponent).setDensity(1e-4),
            t.scene.setAmbientLightColor(new s.Color(.125,.125,.125)),
            S(t, "contour_map_group", T, !1),
            S(t, "city_placemarks_group", b, !0),
            v(t)
        }
        ,
        onLeave: t => {
            const {layers: e} = o
              , i = t.getComponent("layerPanel");
            t.getManager("time").resetLimits();
            for (let t = 0; t < e.length; t++)
                i.toggleLayer(e[t]);
            o.layers = [];
            const a = t.scene.getEntity("moon");
            a.removeComponent(a.getComponent(n.ShadowConeComponent, "shadowConeUmbra")),
            a.removeComponent(a.getComponent(n.ShadowConeComponent, "shadowConePenumbra")),
            E(t, "contour_map_group", !1),
            C(t),
            y.setTexture("decal", r, l),
            y.setTexture("color", c, h),
            y.setTexture("night", d, u),
            y.setTexture("specular", p, m),
            t.scene.getEntity("earth").getComponent(s.AtmosphereComponent).setDensity(_),
            t.scene.setAmbientLightColor(g),
            t.scene.removeEntity("contour_map_group"),
            t.scene.removeEntity("city_placemarks_group")
        }
        ,
        slides: [{
            id: "slide_1",
            type: "panel",
            content: [{
                type: "description",
                title: "Total Solar Eclipse",
                description: "On April 8, 2024, a total solar eclipse crossed North and Central America and created a path of totality.",
                more: "During a total solar eclipse, the Moon completely blocks the Sun while it passes between the Sun and Earth. The sky darkens as if it were dawn or dusk and those standing in the path of totality may see the Sun's outer atmosphere (the corona) if weather permits."
            }, {
                type: "buttons",
                blockTitle: "Select your view",
                buttonContent: [{
                    id: "earth",
                    label: "Earth",
                    iconSrc: "assets/images/cards/eclipse_view_earth_icon.png",
                    onClick: async t => {
                        E(t, "contour_map_group"),
                        E(t, "city_placemarks_group"),
                        C(t),
                        v(t);
                        y.setTexture("decal", "assets/images/2024_eclipse_contour/eclipse_contour_$SIZE_$FACE.png", [1024]),
                        t.getComponent("story").getStoryBlock("checkboxes").setChecked("shadow_cones", !0),
                        await t.cameraScripts.alignObjects("earth", "sun", {
                            distance: 28e3,
                            horizontalOffset: 155,
                            verticalOffset: 30
                        })
                    }
                }, {
                    id: "behind-moon",
                    label: "Behind Moon",
                    iconSrc: "assets/images/cards/eclipse_view_behind_moon_icon.png",
                    onClick: async t => {
                        E(t, "contour_map_group", !1),
                        E(t, "city_placemarks_group", !1),
                        C(t),
                        await t.cameraScripts.alignObjects("moon", "earth", {
                            distance: 1e4,
                            horizontalOffset: -15,
                            verticalOffset: 10
                        })
                    }
                }, {
                    id: "earth-moon",
                    label: "Earth-Moon",
                    iconSrc: "assets/images/cards/eclipse_view_earth_moon_icon.png",
                    onClick: async t => {
                        const e = t.scene.getEntity("earth");
                        if (E(t, "contour_map_group", !1),
                        E(t, "city_placemarks_group", !1),
                        await t.cameraScripts.alignObjects("earth", "moon", {
                            distance: 12e5,
                            horizontalOffset: -90,
                            verticalOffset: 10
                        }),
                        !t.scene.getEntity("earthEcliptic")) {
                            const i = t.scene.addEntity("earthEcliptic");
                            i.setParent(e),
                            i.setPosition(s.Vector3.Zero);
                            const o = new s.Quaternion;
                            e.getController(s.DynamoController).getOrbitOrientation(o, t.pioneer.getTime()),
                            i.setOrientation(o);
                            const a = i.addComponent(n.AnnulusComponent, "annulus");
                            a.setInnerRadius(0),
                            a.setOuterRadius(42e4),
                            a.setIgnoreDistance(!1),
                            a.setMinDistance(2e5),
                            a.setMaxDistance(1e7),
                            a.setColor(new s.Color(110,110,110,.1))
                        }
                    }
                }, {
                    id: "sun-earth-moon",
                    label: "Sun-Earth-Moon",
                    iconSrc: "assets/images/cards/eclipse_view_sun_earth_moon_icon.png",
                    onClick: t => {
                        E(t, "contour_map_group", !1),
                        E(t, "city_placemarks_group", !1),
                        C(t),
                        t.cameraScripts.alignObjects("earth", "sun", {
                            distance: 1e6,
                            horizontalOffset: -5,
                            verticalOffset: 10
                        })
                    }
                }],
                clickable: !0
            }, {
                type: "checkboxes",
                checkboxBlockTitle: "More Options",
                checkboxContent: [{
                    id: "city_placemarks",
                    label: "Display Cities",
                    onChange: (t, e) => {
                        E(e, "city_placemarks_group", t.target.checked)
                    }
                }, {
                    id: "shadow_cones",
                    label: "Enable Shadow Cones",
                    onChange: (t, e) => {
                        if (t.target.checked)
                            v(e);
                        else {
                            const t = e.scene.getEntity("moon");
                            t.getComponent(n.ShadowConeComponent, "shadowConeUmbra").setEnabled(!1),
                            t.getComponent(n.ShadowConeComponent, "shadowConePenumbra").setEnabled(!1)
                        }
                    }
                }, {
                    id: "contour_map",
                    label: "Enable Contour Map",
                    onChange: (t, e) => {
                        const i = t.target.checked ? "assets/images/2024_eclipse_contour/eclipse_contour_$SIZE_$FACE.png" : "";
                        y.setTexture("decal", i, [1024]),
                        E(e, "contour_map_group", t.target.checked)
                    }
                }]
            }],
            time: a,
            timeLimits: {
                min: a,
                max: "2024-04-08T20:50:00Z"
            },
            camera: [async (t, e) => {
                await t.cameraScripts.goToSystem("inner_solar_system"),
                e() || (await t.scene.waitTillEntitiesInPlace(["sun", "earth"]),
                await t.cameraScripts.alignObjects("earth", "sun", {
                    distance: 28e3,
                    horizontalOffset: 155,
                    verticalOffset: 30
                }),
                e() || (await t.scene.waitTillEntitiesInPlace(["moon"]),
                v(t),
                t.getManager("time").setTimeRate(300)))
            }
            ]
        }]
    };
    const v = t => {
        const e = t.scene.getEntity("moon");
        let i = e.getComponent(n.ShadowConeComponent, "shadowConeUmbra")
          , o = e.getComponent(n.ShadowConeComponent, "shadowConePenumbra");
        i && o ? (i.setEnabled(!0),
        o.setEnabled(!0)) : (i = e.addComponent(n.ShadowConeComponent, "shadowConeUmbra"),
        o = e.addComponent(n.ShadowConeComponent, "shadowConePenumbra"),
        i.setSourceEntity("sun"),
        i.setTargetEntity("earth"),
        i.setColor(new s.Color(.437,.18,.593,.25)),
        o.setSourceEntity("sun"),
        o.setTargetEntity("earth"),
        o.setShadowType("penumbra"),
        o.setColor(new s.Color(.218,.093,.3,.3)))
    }
      , S = (t, e, i, o=!1) => {
        const a = t.scene.getEntity("earth")
          , r = t.scene.getEntity(e) || t.scene.addEntity(e);
        r.setParent(a),
        r.setCanOcclude(!1),
        r.setOcclusionRadius(a.getOcclusionRadius());
        const l = r.addController(s.FixedController);
        l.setPosition(s.Vector3.Zero),
        l.setOrientation(s.Quaternion.Identity),
        r.addController(s.RotateByEntityOrientationController);
        for (const e in i) {
            const l = i[e]
              , c = 10
              , h = t.scene.getEntity(e) || n.Placemarks.addPlacemark(e, l.text, a, l.latLng[0], l.latLng[1], c);
            h.setEnabled(!0),
            h.setParent(r);
            const d = h.getComponent(s.DivComponent).getDiv();
            if (d.id = e,
            d.classList.add("placemark"),
            h.getComponent(s.DivComponent).setAlignment(new s.Vector2(-.25,.6)),
            d.classList.remove("pioneer-label-div"),
            o) {
                const i = t.scene.getEntity(`${e}_placemark_icon`) || n.Placemarks.addPlacemark(`${e}_placemark_icon`, "", a, l.latLng[0], l.latLng[1], 0);
                i.setEnabled(!0),
                i.setParent(r);
                const o = i.getComponent(s.DivComponent).getDiv();
                o.classList.add("placemark"),
                o.classList.remove("pioneer-label-div"),
                o.innerHTML = '<div class="pin"><img class="no-drag" style="width: 10px" src="assets/images/map_marker.svg"></div><div class="content"></div>'
            }
        }
        r.setEnabled(!0)
    }
      , E = (t, e, i=!0) => {
        t.scene.getEntity(e)?.setEnabled(i);
        const s = e.split("_group")[0];
        if (s) {
            const {checkboxContent: e} = t.getComponent("story").getStoryBlock("checkboxes").options.config.info;
            Object.values(e)?.forEach((e => {
                t.getComponent("story").getStoryBlock("checkboxes")?.setChecked(s, i)
            }
            ))
        }
    }
      , C = t => {
        t.scene.getEntity("earthEcliptic") && t.scene.removeEntity("earthEcliptic")
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e);
    var s = i(5);
    const n = {
        layers: []
    };
    e.default = {
        type: "nonsequential",
        entities: ["sc_cassini", "enceladus"],
        onEnter: async t => {
            const e = t.getManager("layer")
              , i = t.getComponent("layerPanel");
            ["asteroids", "comets", "dwarfPlanets", "minorMoons", "spacecraft"].forEach((t => {
                e.getLayer(t).visible && (n.layers.push(t),
                i.toggleLayer(t))
            }
            )),
            ["planets", "majorMoons"].forEach((t => {
                e.getLayer(t).visible || (n.layers.push(t),
                i.toggleLayer(t))
            }
            )),
            n.maxTextureSize = t.pioneer.getConfig().getValue("maxTextureSize"),
            t.pioneer.getConfig().setValue("maxTextureSize", 2048)
        }
        ,
        onLeave: t => {
            const {layers: e} = n
              , i = t.getComponent("layerPanel");
            for (let t = 0; t < e.length; t++)
                i.toggleLayer(e[t]);
            t.pioneer.getConfig().setValue("maxTextureSize", n.maxTextureSize),
            n.layers = [],
            delete n.trail,
            delete n.maxTextureSize
        }
        ,
        slides: [{
            id: "slide_1",
            type: "overlay",
            classList: ["opaque", "black"],
            content: [{
                type: "title",
                title: "Discovery at Enceladus"
            }]
        }, {
            id: "slide_2",
            type: "panel",
            content: [{
                type: "description",
                title: "There is Something Happening on Enceladus",
                subtitle: "February 2005",
                description: "The Cassini mission spent 13 years orbiting Saturn and its moons, arriving at Saturn in 2004. But no one was expecting what was found on the moon named Enceladus."
            }],
            time: "2005-02-14T05:22:35Z",
            camera: [async t => {
                const e = "enceladus"
                  , i = t.getManager("scene");
                await i.isReady(e);
                const n = t.pioneer.getScene("main").getEntity(e).getComponent(s.SpheroidLODComponent);
                i.addLoading(e, "spheroidLOD"),
                await n.getTexturesLoadedPromise(),
                i.removeLoading(e, "spheroidLOD"),
                await t.cameraScripts.goToCelestialObject(e, {
                    duration: 3
                })
            }
            ]
        }, {
            id: "slide_3",
            type: "panel",
            content: [{
                type: "description",
                title: "Detection",
                subtitle: "Feb 16th, 2005",
                description: "The magnetometer aboard NASA's robotic Cassini spacecraft discovers something -- perhaps an atmosphere -- is pushing against Saturn's magnetic field around Enceladus, a small, icy moon of Saturn barely 300 miles (500 kilometers) in diameter. There is evidence that gases may be originating from the moon's surface or interior. Cassini's cosmic dust analyzer records thousands of hits from tiny particles of dust or ice, possibly coming from a cloud around the moon or from the adjacent E ring, a broad ring of dust-sized ice particles in which Enceladus orbits. The science team makes plans to return to Enceladus for a closer look."
            }],
            time: "2005-02-17T03:15:30Z",
            rate: 12,
            camera: [async t => {
                await t.cameraScripts.alignObjects("sc_cassini", "enceladus", {
                    transitionDuration: 3,
                    alignDuration: 3,
                    distance: .04,
                    horizontalOffset: 10
                })
            }
            ],
            onEnter: t => {}
            ,
            onLeave: t => {}
        }, {
            id: "slide_4",
            type: "panel",
            content: [{
                type: "description",
                title: "Water Vapor at the South Pole",
                subtitle: "July 2005",
                description: "During this pivotal flyby, the Cassini cameras obtain new, detailed images of the south polar region of Enceladus.To their amazement, Cassini scientists detect a huge cloud of water vapor over the area -- and relatively warm fractures in the crust that are supplying the cloud of water vapor and ice particles that extend into space. Cassini data also confirms that this activity is the major source of material in the E ring. Cassini has already made a major discovery, and something that no telescope could have seen."
            }, {
                type: "image",
                src: "assets/images/enceladus_terrain.jpg",
                title: "Enceladus Terrain",
                alt: "Enceladus Terrain",
                clickable: !0
            }, {
                type: "image",
                src: "assets/images/enceladus_temperature.jpg",
                title: "Enceladus Temperature",
                alt: "Enceladus Temperature",
                clickable: !0
            }],
            time: "2005-07-14T19:51:20Z",
            rate: 5,
            camera: [async t => {
                await t.cameraScripts.alignObjects("sc_cassini", "enceladus", {
                    transitionDuration: 1,
                    alignDuration: 2,
                    distance: .04,
                    horizontalOffset: 12
                })
            }
            ]
        }, {
            id: "slide_5",
            type: "panel",
            content: [{
                type: "description",
                title: "A Major Announcement",
                subtitle: "March 2006",
                description: "Cassini scientists announced they have found evidence of liquid water reservoirs feeding the Enceladus plume, possibly in the form of geysers. After examining high-resolution Cassini images and other data showing icy jets ejecting large quantities of particles at high speed, scientists rule out the idea that the particles are produced by or blown off the moon's surface by vapor created when warm water ice converts to a gas. Instead, they find evidence that the jets might be erupting from near-surface pockets of liquid water."
            }, {
                type: "image",
                src: "assets/images/enceladus_icy_jets.jpg",
                title: "Enceladus Icy Jets",
                alt: "Enceladus Icy Jets",
                clickable: !0
            }],
            time: "2022-01-25T22:15:00Z",
            camera: [async t => {
                await t.getManager("scene").isReady("enceladus"),
                await t.cameraScripts.goToCelestialObject("enceladus")
            }
            ]
        }, {
            id: "slide_6",
            type: "panel",
            content: [{
                type: "description",
                title: "Cassini and the Jets",
                description: "During a very close flyby on March 12th, 2008, Cassini's instruments sample the plume directly, and detect a surprising brew of volatile gases, water vapor, carbon dioxide and carbon monoxide, as well as organic materials, some 20 times denser than expected. The brew is described as being 'like carbonated water with an essence of natural gas.' New heat maps of the surface show higher temperatures than previously known in the south polar region, with higher-than-expected temperatures running the length of the giant fissures near the south pole."
            }, {
                type: "replay"
            }],
            time: "2008-03-12T19:06:15Z",
            onEnter: t => {
                t.getComponent("settings").toggleLightOptions("flood"),
                t.scene.getEntity("sc_cassini").getComponent(s.TrailComponent).setEnabled(!1)
            }
            ,
            onLeave: t => {
                t.getComponent("settings").toggleLightOptions("shadow"),
                t.scene.getEntity("sc_cassini").getComponent(s.TrailComponent).setEnabled(!0)
            }
            ,
            camera: [async t => {
                await t.cameraScripts.alignObjects("sc_cassini", "enceladus", {
                    duration: 4,
                    distance: .4,
                    horizontalOffset: 10
                })
            }
            ]
        }, {
            id: "slide_7",
            type: "panel",
            content: [{
                type: "description",
                title: "What We Learned Along the Way",
                description: "Over the next nine years, Cassini completes 23 flybys of Enceladus, unlocking new clues with each event. In subsequent flybys, Cassini found that the ice fractures called â€œtiger stripesâ€ are about 300 meters (980 feet) deep, with V-shaped inner walls. Cassini also found that the particles in the plume were water ice with a surprising amount of salt in addition to methane, ammonia and carbon dioxide. Gravitational measurements indicated that the jets are supplied by a global subsurface ocean, probably regional to the south pole. Tiny silica grains, also found in the plume, suggest that the ocean of Enceladus likely contains hydrothermal vents - one of the places scientists suspect life could have begun on Earth."
            }, {
                type: "image",
                src: "assets/images/enceladus_cutaway.jpg",
                title: "Enceladus cutaway",
                alt: "Enceladus cutaway",
                clickable: !0
            }, {
                type: "image",
                src: "assets/images/enceladus_cutaway_description.jpg",
                title: "Enceladus cutaway with description",
                alt: "Enceladus cutaway with description",
                clickable: !0
            }, {
                type: "image",
                src: "assets/images/enceladus_geyser_cutaway.jpg",
                title: "Enceladus cutaway with geysers",
                alt: "Enceladus cutaway with geysers",
                clickable: !0
            }],
            time: "2008-10-09T19:06:46Z",
            camera: [async t => {
                await t.getManager("scene").isReady("sc_cassini"),
                await t.cameraScripts.goToSpacecraft("sc_cassini")
            }
            ]
        }, {
            id: "slide_8",
            type: "panel",
            content: [{
                type: "description",
                title: "Shoot the Plumes",
                description: "On October 28th, 2015, the Cassini mission managers decided to boldly send the spacecraft directly through the plumes. This entailed a very small amount of risk of damage to Cassini, but since it was nearing the end of the mission, it was a chance they were willing to take. This flyby, informally called the â€œCassini car washâ€ was a complete success.\nThanks to the hard work of scientists and engineers, we discovered something that was completely unknown to us about this incredible moon of Saturn. This knowledge was not possible without actually visiting the site; no Earth-based telescopes could discover the geysers of water ice that emanate from the south pole. Over a decade of visiting, we learned that this moon harbors a sub-surface ocean of water, complete with organic material and an energy source which remains to be determined with certainty. This means something deeply significant; there could be life in that ocean, under the frozen crust, similar to what we have on Earth at the bottom of the Atlantic ocean, where there are hydrothermal vents."
            }],
            time: "2015-10-28T15:22:30Z",
            camera: [async t => {
                await t.cameraScripts.viewFromSide("sc_cassini", {
                    duration: 2,
                    distance: 1e3,
                    planeId: "enceladus",
                    upVector: "-z-axis"
                })
            }
            ],
            onEnter: t => {
                t.getComponent("settings").toggleLightOptions("flood");
                const e = t.scene.getEntity("sc_cassini").getComponent(s.TrailComponent);
                n.trail = {
                    sc_cassini: e.getStartTime()
                },
                e.setRelativeToEntity("enceladus"),
                e.setStartTime(1e3)
            }
            ,
            onLeave: t => {
                t.getComponent("settings").toggleLightOptions("shadow");
                const e = t.scene.getEntity("sc_cassini").getComponent(s.TrailComponent);
                e.setRelativeToEntity(""),
                e.setStartTime(n.trail.sc_cassini),
                n.trail = {}
            }
        }]
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e);
    var s = i(5)
      , n = i(542);
    const o = {
        layers: []
    };
    e.default = {
        type: "nonsequential",
        entities: ["sc_voyager_1", "sc_voyager_2"],
        onEnter: async t => {
            const e = t.getManager("layer")
              , i = t.getComponent("layerPanel");
            ["asteroids", "comets", "dwarfPlanets", "minorMoons", "spacecraft"].forEach((t => {
                e.getLayer(t).visible && (o.layers.push(t),
                i.toggleLayer(t))
            }
            )),
            ["planets", "majorMoons"].forEach((t => {
                e.getLayer(t).visible || (o.layers.push(t),
                i.toggleLayer(t))
            }
            ))
        }
        ,
        onLeave: t => {
            o.zoomFitController && t.scene.getEntity("camera").getController(n.ZoomFitController) && (t.scene.getEntity("camera").removeController(o.zoomFitController),
            delete o.zoomFitController);
            const {layers: e} = o
              , i = t.getComponent("layerPanel");
            for (let t = 0; t < e.length; t++)
                i.toggleLayer(e[t]);
            o.layers = []
        }
        ,
        slides: [{
            id: "slide_1",
            type: "overlay",
            classList: ["opaque", "black"],
            content: [{
                type: "title",
                title: "Voyager's Grand Tour",
                subtitle: "1977 - Today"
            }],
            time: "1977-09-05T12:56:00Z",
            rate: 0,
            camera: [async t => {
                await t.cameraScripts.goToSystem("outer_solar_system")
            }
            ]
        }, {
            id: "slide_2",
            type: "panel",
            content: [{
                type: "description",
                description: "The twin spacecraft Voyager 1 and Voyager 2 were launched by NASA in separate months in the summer of 1977. The Voyager mission was designed to take advantage of a rare geometric arrangement of the outer planets in the late 1970s and the 1980s which allowed for a four-planet tour for a minimum of propellant and trip time. This layout of Jupiter, Saturn, Uranus and Neptune, which occurs about every 175 years, allows a spacecraft on a particular flight path to swing from one planet to the next without the need for large onboard propulsion systems."
            }, {
                type: "replay"
            }],
            time: "1977-09-05T12:56:00Z",
            rate: 25228800,
            onEnter: async t => {
                if (t.getManager("label").addExceptions(["sc_voyager_1", "sc_voyager_2"]),
                !o.trail) {
                    const e = t.scene.getEntity("sc_voyager_1").getComponent(s.TrailComponent)
                      , i = t.scene.getEntity("sc_voyager_2").getComponent(s.TrailComponent);
                    o.trail = {
                        sc_voyager_1: e.getStartTime(),
                        sc_voyager_2: i.getStartTime()
                    },
                    e.setStartTime(1e8 * e.getStartTime()),
                    i.setStartTime(1e8 * i.getStartTime())
                }
                if (!o.timeCheck) {
                    const e = t.getManager("time");
                    o.timeCheck = setInterval(( () => {
                        e.getTime().valueOf() >= e.getNow().valueOf() && (clearInterval(o.timeCheck),
                        e.resetTimeRate(),
                        e.setToNow(),
                        delete o.timeCheck)
                    }
                    ), 500)
                }
                await t.getManager("scene").isListReady(["sun", "earth", "sc_voyager_1", "sc_voyager_2"])
            }
            ,
            onLeave: t => {
                t.getManager("label").removeExceptions(["sc_voyager_1", "sc_voyager_2"]),
                t.scene.getEntity("sc_voyager_1").getComponent(s.TrailComponent).setStartTime(o.trail.sc_voyager_1),
                t.scene.getEntity("sc_voyager_2").getComponent(s.TrailComponent).setStartTime(o.trail.sc_voyager_2),
                delete o.trail,
                o.timeCheck && (clearInterval(o.timeCheck),
                delete o.timeCheck)
            }
            ,
            camera: [async t => {
                const e = t.getManager("time");
                e.pause(),
                await t.cameraScripts.showLocation("sun", "earth", "earth", "planeNormal", {
                    distance: 6e8,
                    duration: 2,
                    startFromTarget: !1,
                    rotateByScreenRatio: !1
                }),
                await t.scene.getLoadedPromise();
                const i = t.scene.getEntity("camera");
                o.zoomFitController = i.addController(n.ZoomFitController, "", i.getController(s.AlignController)),
                o.zoomFitController.addEntity("sun"),
                o.zoomFitController.addEntity("sc_voyager_1"),
                o.zoomFitController.addEntity("sc_voyager_2"),
                o.zoomFitController.setEdgeSize(.04),
                o.zoomFitController.setTightFit(!0),
                o.zoomFitController.setZoomOutOnly(!1),
                await t.scene.getLoadedPromise(),
                e.play()
            }
            ]
        }, {
            id: "slide_3",
            type: "panel",
            content: [{
                type: "description",
                description: "Voyager 1 was the first to reach Jupiter, in March of 1979, followed by Voyager 2 in August. Discovery of active volcanism on the satellite Io was easily the greatest unexpected discovery at Jupiter. It was the first time active volcanoes had been seen on another body in the solar system. The Voyagers also discovered that the Great Red Spot was revealed as a complex storm moving in a counterclockwise direction, and a movie was made of it as Voyager 1 was inbound."
            }, {
                type: "image",
                src: "assets/images/PIA02855_blue_movie.gif",
                title: 'Voyager 1 "Blue Movie"',
                alt: 'Voyager 1 "Blue Movie"',
                clickable: !0
            }, {
                type: "image",
                src: "assets/images/PIA01971_volcanic_explosion_on_io.jpg",
                title: "Volcanic Explosion on Io",
                alt: "Volcanic Explosion on Io",
                clickable: !0
            }, {
                type: "image",
                src: "assets/images/PIA00010_io_with_loki_plume_on_bright_limb.jpg",
                title: "Io with Loki Plume on Bright Limb",
                alt: "Io with Loki Plume on Bright Limb",
                clickable: !0
            }, {
                type: "image",
                src: "assets/images/PIA00014_jupiter_great_red_spot.jpg",
                title: "Jupiter's Great Red Spot",
                alt: "Jupiter's Great Red Spot",
                clickable: !0
            }, {
                type: "image",
                src: "assets/images/PIA02857_io_rotation_movie.gif",
                title: "Io Rotation Movie",
                alt: "Io Rotation Movie",
                clickable: !0
            }, {
                type: "image",
                src: "assets/images/PIA01384_jupiter_great_red_spot.jpg",
                title: "Jupiter's Great Red Spot",
                alt: "Jupiter's Great Red Spot",
                clickable: !0
            }],
            time: "1979-03-04T15:56:00-08:00",
            rate: 600,
            entities: ["jupiter", "io"],
            camera: [async t => {
                await t.cameraScripts.alignObjects("sc_voyager_1", "jupiter", {
                    duration: 4,
                    distance: .04,
                    horizontalOffset: 10
                })
            }
            ]
        }, {
            id: "slide_4",
            type: "panel",
            content: [{
                type: "description",
                description: 'The Voyager spacecraft both used Jupiter\'s gravity as a free speed boost, or a "slingshot" to reach Saturn. At Saturn, the Voyagers discovered many new details about Saturn\'s rings, as well as new data about Saturn\'s large moon Titan, which has an atmosphere. After the Saturn encounter, Voyager 1 headed "up" from Saturn, out of the plane of the ecliptic, whereas Voyager 2 continued on towards Uranus and Neptune.'
            }, {
                type: "image",
                src: "assets/images/PIA02269_saturn_ring_system.jpg",
                title: "Saturn's Ring System",
                alt: "Saturn's Ring System",
                clickable: !0
            }, {
                type: "image",
                src: "assets/images/PIA02238_titan_thick_haze_layer.jpg",
                title: "Titan's Thick Haze Layer",
                alt: "Titan's Thick Haze Layer",
                clickable: !0
            }],
            time: "1980-11-11T15:00:00-08:00",
            rate: 3600,
            entities: ["saturn", "titan"],
            camera: [async t => {
                await t.cameraScripts.alignObjects("sc_voyager_1", "saturn", {
                    duration: 4,
                    distance: .04,
                    horizontalOffset: 10,
                    verticalOffset: -5
                })
            }
            ]
        }, {
            id: "slide_5",
            type: "panel",
            content: [{
                type: "description",
                description: "With Voyager 1's primary science phase over, Voyager 2 made the long journey out to Uranus, arriving in January of 1986. The planet had never been visited before, and the encounter did not disappoint: Voyager 2 found eleven new moons and two new rings around the planet. This was the first-ever visit to Uranus."
            }, {
                type: "image",
                src: "assets/images/PIA18182_uranus_as_seen_by_nasa_voyager_2.jpg",
                title: "Uranus as seen by NASA's Voyager 2",
                alt: "Uranus as seen by NASA's Voyager 2",
                clickable: !0
            }, {
                type: "image",
                src: "assets/images/PIA00036_titania_high-resolution_color_composite.jpg",
                title: "Titania High-Resolution Color Composite",
                alt: "Titania High-Resolution Color Composite",
                clickable: !0
            }, {
                type: "image",
                src: "assets/images/PIA00141_miranda_geologic_history_(variety_of_terrain).jpg",
                title: "Miranda's Geologic History (Variety of Terrain)",
                alt: "Miranda's Geologic History (Variety of Terrain)",
                clickable: !0
            }, {
                type: "image",
                src: "assets/images/PIA01977_uranus_rings.jpg",
                title: "Uranus Rings",
                alt: "Uranus Rings",
                clickable: !0
            }],
            time: "1986-01-23T04:00:00-08:00",
            rate: 3600,
            entities: ["uranus"],
            camera: [async t => {
                await t.cameraScripts.alignObjects("sc_voyager_2", "uranus", {
                    duration: 4,
                    distance: .08,
                    horizontalOffset: 15
                })
            }
            ]
        }, {
            id: "slide_6",
            type: "panel",
            content: [{
                type: "description",
                description: "Voyager 2 makes its closest approach to Neptune, making it the first spacecraft to observe Neptune up close and the first to visit four planets beyond Earth. Highlights from the encounter include the discovery of six new moons, the first images of Neptune's rings, and the discovery of a huge, counter-clockwise rotating storm in Neptune's southern hemisphere, named \"The Great Dark Spot\"."
            }, {
                type: "image",
                src: "assets/images/PIA02245_neptune_blue-green_atmosphere.jpg",
                title: "Neptune's Blue-green Atmosphere",
                alt: "Neptune's Blue-green Atmosphere",
                clickable: !0
            }, {
                type: "image",
                src: "assets/images/PIA00058_neptune_clouds_showing_vertical_relief.jpg",
                title: "Neptune Clouds Showing Vertical Relief",
                alt: "Neptune Clouds Showing Vertical Relief",
                clickable: !0
            }, {
                type: "image",
                src: "assets/images/PIA00317_global_color_mosaic_of_triton.jpg",
                title: "Global Color Mosaic of Triton",
                alt: "Global Color Mosaic of Triton",
                clickable: !0
            }],
            time: "1989-08-24T16:30:00Z",
            rate: 3e3,
            entities: ["neptune", "triton"],
            camera: [async t => {
                await t.cameraScripts.alignObjects("sc_voyager_2", "neptune", {
                    duration: 4,
                    distance: .07,
                    verticalOffset: 10
                })
            }
            ],
            onEnter: t => {
                t.getComponent("settings").toggleLightOptions("flood")
            }
            ,
            onLeave: t => {
                t.getComponent("settings").toggleLightOptions("shadow")
            }
        }, {
            id: "slide_7",
            type: "panel",
            content: [{
                type: "description",
                description: 'After visiting Neptune, Voyager 2 turned "down" or south of the ecliptic plane, while Voyager 1 turned "up" or north of the plane. Each spacecraft headed out in a different direction, and they will never stop. In August of 2012, it was determined that Voyager 1 had reached the edge of the sun\'s influence(the heliopause), which is the boundary where the solar wind is balanced by the interstellar wind. Voyager 2 reached the heliopause in 2018.'
            }, {
                type: "image",
                src: "assets/images/heliosphere.jpg",
                title: "Heliosphere",
                alt: "Heliosphere",
                clickable: !0
            }],
            time: "2012-08-25T00:00:00-08:00",
            onEnter: t => {
                t.scene.getEntity("sun").getComponent(s.ModelComponent)?.setEnabled(!0)
            }
            ,
            onLeave: t => {
                t.scene.getEntity("sun").getComponent(s.ModelComponent)?.setEnabled(!1)
            }
            ,
            camera: [async t => {
                await t.getManager("camera").goToEntity("sc_voyager_1", {
                    duration: 3,
                    destination: new s.Vector3(82226007739.1375,-56908057519.63546,597193963.1270928),
                    destinationUp: s.Vector3.ZAxis
                })
            }
            ]
        }, {
            id: "slide_8",
            type: "panel",
            content: [{
                type: "description",
                description: "The Voyager spacecraft are still sending back data to this day, and will wander the Milky Way forever. Each spacecraft carries a message, prepared by a team headed by Carl Sagan, in the form of a 12 inch (30-centimeter) diameter gold-plated copper disc for potential extraterrestrials who might find the spacecraft. Like the plaques on Pioneers 10 and 11, the record has symbols to show the location of Earth relative to several pulsars. The records also contain instructions to play them using a cartridge and a needle, much like a vinyl record player. The audio on the disc includes greetings in 55 languages, 35 sounds from life on Earth (such as whale songs, laughter, etc.), 90 minutes of generally Western music including everything from Mozart and Bach to Chuck Berry and Blind Willie Johnson. It also includes 115 images of life on Earth and recorded greetings."
            }, {
                type: "image",
                src: "assets/images/voyager_golden_record_cover.jpg",
                title: "Voyager's Golden Record Cover",
                alt: "Voyager's Golden Record Cover",
                clickable: !0
            }, {
                type: "image",
                src: "assets/images/voyager_golden_record.jpg",
                title: "Voyager's Golden Record",
                alt: "Voyager's Golden Record",
                clickable: !0
            }],
            onEnter: async t => {
                const e = t.getManager("scene");
                await e.isReady("sc_voyager_1"),
                n.Entity.createFromOptions("voyager_disc", {
                    occlusionRadius: 1e-4,
                    extentsRadius: 1e-4,
                    parents: [[Number.NEGATIVE_INFINITY, "sc_voyager_1"]],
                    controllers: [{
                        type: "fixed",
                        position: new s.Vector3(95e-5,0,0),
                        orientation: s.Quaternion.Identity
                    }, {
                        type: "rotateByEntityOrientation"
                    }]
                }, t.scene),
                await e.isReady("voyager_disc"),
                await t.pioneer.waitUntilNextFrame()
            }
            ,
            onLeave: async t => {
                t.scene.getEntity("camera").setParent(t.scene.getEntity("sc_voyager_1")),
                t.scene.removeEntity("voyager_disc")
            }
            ,
            camera: [async t => {
                await t.cameraScripts.goToInstrument("voyager_disc", {
                    distance: .005,
                    upVector: "-z-axis",
                    forwardVector: "x-axis"
                })
            }
            ]
        }]
    }
}
, function(t, e, i) {
    "use strict";
    i.r(e);
    const s = "2024-12-24T12:56:00Z";
    e.default = {
        type: "nonsequential",
        entities: ["sc_parker_solar_probe"],
        onEnter: async t => {
            t.getManager("layer").toggleLayer("spacecraft", {}, !1)
        }
        ,
        slides: [{
            id: "slide_1",
            type: "overlay",
            classList: ["opaque", "black"],
            content: [{
                type: "title",
                title: "Parker Solar Probe's Closest Pass by the Sun "
            }],
            rate: 0,
            camera: [async t => {
                await t.cameraScripts.goToSpacecraft("sc_parker_solar_probe")
            }
            ]
        }, {
            id: "slide_2",
            type: "panel",
            content: [{
                type: "description",
                description: "NASAâ€™s Parker Solar Probe is a mission to â€œtouchâ€ the Sun. Moving at up to 430,000 miles per hour (692,017 km per hour), the spacecraft endures temperatures up to 1,800 degrees Fahrenheit (982 degrees Celsius) as it flies through the tenuous outer atmosphere of the Sun called the corona to help scientists better understand our closest star. On Dec. 24, 2024, Parker Solar Probe will make history with a record-breaking closest approach to the Sun."
            }, {
                type: "image",
                src: "assets/images/psp_sun.png",
                title: "Conceptual image of Parker Solar Probe about to enter the solar corona. Credit: NASA SVS",
                alt: "Conceptual image of Parker Solar Probe about to enter the solar corona. Credit: NASA SVS",
                clickable: !0
            }],
            time: s,
            rate: 1814400,
            entities: ["sc_parker_solar_probe", "sun"],
            camera: [async t => {
                await t.cameraScripts.viewFromSide("sun", {
                    distance: 4e8,
                    verticalOffset: -50,
                    upVector: "z-axis"
                })
            }
            ]
        }, {
            id: "slide_3",
            type: "panel",
            content: [{
                type: "description",
                description: "Since its launch in 2018, Parker Solar Probe has circled gradually closer to the Sun, using flybys of Venus to gravitationally move it into a tighter orbit. These flybys have also enabled new discoveries about Venus. One instrument aboard the spacecraft captured visible and near-infrared light from Venus, giving scientists a new way to see through the planetâ€™s thick clouds to the Venusian surface below, which had only been done with radar and infrared imagery before. The last planned Venus flyby occurred on Nov. 6, 2024, and set the spacecraft up for its closest approach to the Sun. "
            }, {
                type: "replay"
            }, {
                type: "image",
                src: "assets/images/psp_venus_flyby.webp",
                title: "Venus as seen by Parker Solar Probe. Credit: NASA",
                alt: "Venus as seen by Parker Solar Probe. Credit: NASA",
                clickable: !0
            }],
            time: "2024-10-15T00:10:00",
            rate: 432e3,
            entities: ["sc_parker_solar_probe", "venus"],
            camera: [async t => {
                await t.cameraScripts.goToCenter(["sun", "venus"], "sun", 782223069.182, {
                    distance: 35e7
                })
            }
            ]
        }, {
            id: "slide_4",
            type: "panel",
            content: [{
                type: "description",
                description: "Parker Solar Probeâ€™s first pass by the Sun on its latest orbit will occur on Dec. 24, 2024, and will bring the spacecraft a record-breaking 3.8 million miles (6.1 million km) above the surface of the Sun. This distance puts the spacecraft well within the corona, enabling Parker Solar Probe to conduct unrivaled scientific measurements with the potential to change our understanding of our closest star. When the spacecraft first passed into the solar atmosphere in 2021, it made unexpected findings about the boundary of the corona and imaged structures called coronal streamers, which previously had only been seen from afar. "
            }, {
                type: "replay"
            }, {
                type: "image",
                src: "assets/images/psp_coronal_streamers.png",
                title: "Coronal streamers up close. Credit: NASA SVS",
                alt: "Coronal streamers up close. Credit: NASA SVS",
                clickable: !0
            }],
            time: s,
            rate: 600,
            entities: ["sc_parker_solar_probe", "sun"],
            camera: [async t => {
                await t.cameraScripts.alignObjects("sc_parker_solar_probe", "sun", {
                    distance: .04
                })
            }
            ]
        }, {
            id: "slide_5",
            type: "panel",
            content: [{
                type: "description",
                description: "During its closest approach, Parker Solar Probe will be out of contact with Earth due to constraints on signal transmission so close to the Sun. It wonâ€™t be until Dec. 27, 2024, that the spacecraft is able to send a beacon signal back to Earth, giving operators at the Johns Hopkins Applied Physics Laboratory â€“ where the probe was designed and built â€“ a hint of its condition after its closest pass of the Sun. When the spacecraft reaches a position in its orbit with a clear view of Earth at the end of January 2025, it will begin to send back the science data it took on its closest flyby of the Sun. "
            }, {
                type: "replay"
            }, {
                type: "image",
                src: "assets/images/psp_corona.png",
                title: "Conceptual image of Parker Solar Probe passing through the corona. Credit: NASA SVS",
                alt: "Conceptual image of Parker Solar Probe passing through the corona. Credit: NASA SVS",
                clickable: !0
            }],
            time: "2024-12-27T12:16:25.007",
            rate: 10800,
            entities: ["sc_parker_solar_probe", "sun"],
            camera: [async t => {
                await t.cameraScripts.alignObjects("sc_parker_solar_probe", "sun", {
                    distance: .04
                })
            }
            ]
        }],
        onLeave: async t => {
            t.getManager("layer").toggleLayer("spacecraft", {}, !0)
        }
    }
}
, function(t) {
    t.exports = '<header class="header">\n\t<Breadcrumb></Breadcrumb>\n\t<nav class="top-right-nav">\n\t\t<Search id="searchDesktop"></Search>\n\t\t<Menu></Menu>\n\t</nav>\n</header>\n<ShareModal></ShareModal>\n<FeaturedStoriesPanel></FeaturedStoriesPanel>\n<ContentPanel></ContentPanel>\n<DistancePanel></DistancePanel>\n<Story></Story>\n<CollapsibleMenu></CollapsibleMenu>\n<ClockShortcut></ClockShortcut>\n<div id="float-mid-bottom" class="float-mid-bottom">\n\t<div id="extended-controls" class="extended-controls">\n\t\t<MobileExpandButton></MobileExpandButton>\n\t\t<Clock id="storyClock"></Clock>\n\t</div>\n</div>\n<div id="float-right-bottom" class="float-right-bottom">\n\t<LayerPanel></LayerPanel>\n\t<Settings></Settings>\n</div>\n<Comparison></Comparison>\n<Telescope></Telescope>\n<KioskMode></KioskMode>\n<Toast></Toast>'
}
], function(t) {
    t.O(0, [3], (function() {
        return e = 0,
        t(t.s = e);
        var e
    }
    ));
    t.O()
}
]);
